<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Unreal Engine 4 SDK构建相关笔记]]></title>
    <url>%2F2020%2F12%2F24%2FUnreal4%E7%AC%94%E8%AE%B0%2FUnreal-Engine-4-SDK%E6%9E%84%E5%BB%BA%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[SDK构建相关阅读[toc] 在Unreal项目开发的过程中，可能会用到第三方开发的库来集成一些第三方的功能，例如语音通话、播放视频等功能。虚幻引擎本身也引用了很多第三方的库,例如物理库PhysX、Steam平台相关的库SteamWorks、GoogleVR等等。这些库可以在引擎的Engine\Source\ThirdParty目录下找到。Unreal官方推荐将第三方库集成到插件目录中，这样可以将游戏代码与第三方代码进行隔离。 使用插件引入第三方库在Unreal的编辑器中，可以新建一个ThirdParty插件来引入SDK：在项目中点击编辑-插件-新插件-第三方库就可以创建一个使用已包含第三方库的插件。 1. 貌似只有C++项目中才可以创建第三方库插件，蓝图项目中貌似只能建立空白插件 新插件的目录结构如下： 其中SDKTest是插件本身逻辑的目录，ThirdParty是第三方库的目录，对于不同平台，所使用的SDK文件格式也有不同，这一点我们在后面再详细展开讲。 .uplugin文件是插件描述文件，虚幻引擎通过搜索这个格式的文件来查找插件，这个文件提供插件相关的基本信息。 XXX.Build.cs文件是模块描述文件，虚幻引擎使用UnrealBuildTool编译这个文件，并构造来确定整个编译环境。 Mac,x64文件夹内是不同平台下引入的库文件，x64平台下一般为.lib和.dll文件，Mac平台下一般为dylib，IOS平台下一般为.a文件、.dylib文件和.framework文件，Android平台下一般为.aar和.jar文件。这些文件在模块描述文件中进行引入，在实例项目中如图所示： 一个例子：以GCloud的相关SDK接入为例（GCloud相关文档）: (由于没有SDK的下载权限所以只能用官网的图来意思意思) 下载之后将文件夹拷贝到插件的Public目录下，并参考AAInfo4Copy.txt，在xxx.Build.cs文件中引入相应的插件。 在官方文档中引入插件的方法是： PrivateDependencyModuleNames.AddRange(new string[] { "GCloudCore" }); PrivateDependencyModuleNames.AddRange(new string[] { "GCloud" }); PrivateDependencyModuleNames.AddRange(new string[] { "TApm" }); PrivateDependencyModuleNames.AddRange(new string[] { "GVoice" }); PrivateDependencyModuleNames.AddRange(new string[] { "GEM_OneSDK" }); 这部分的代码原理可以参考Engine\Source\Programs\UnrealBuildTool\Configuration\ModuleRules.cs文件中的相关定义 // 通过将插件中的Public文件夹下的相对路径添加进这个List中来暴露给其他模块 public List PublicIncludePaths = new List(); // 同理，如果不想暴露给其他模块，则将相对路径添加到这个List中 public List PrivateIncludePaths = new List(); // 公共依赖模块名称列表（不需要路径）（自动进行私有/公共包含）。这些模块是我们的公共源文件所需要的。 public List PublicDependencyModuleNames = new List(); // 私有依赖模块名称列表。 这些模块是我们的私有代码所依赖的模块，但在公共的include文件中没有任何模块可以依赖。 public List PrivateDependencyModuleNames = new List(); // 附加库列表（包括拓展名在内的.lib文件名），通常用于第三方模块 public List PublicAdditionalLibraries = new List(); //...除此之外还有很多列表，可以在上述路径中文件内查看源码和注释 // ReceiptProperty在\Engine\Source\Programs\UnrealBuildTool\System\TargetReceipt.cs中定义 // 任意属性名/值，来自构建脚本的元数据可以传递给下游任务。（这是一对键值对），在文件中存储着UPL格式写的XML文件，其中可以进行一些设置，并且可以插入代码到AndroidManifest.xml和GameActivity.java中，关于这两个文件的作用在后面会解释 public List AdditionalPropertiesForReceipt = new List(); 总而言之，在xxx.Build.cs文件中，将对应的第三方库路径和设置文件的路径加入到了全局的List中，在之后的编译过程中，UBT会根据这个文件将对应的第三方库文件编译构建到指定的位置。 虚幻插件语言（Unreal Plugin Language, UPL） 虚幻插件语言 (UPL)是一种基于XML的简单语言，用于操作XML和返回字符串。它包含一个分段，在计算任何其他分段之前，每个架构计算一次这个分段。状态被维护并推进到下个分段进行评估，因此分段的执行顺序很重要。虽然UPL是一个用于修改和查询XML的通用系统，但它专门用于允许插件影响其所属包的全局配置。例如，它允许插件修改Android APK AndroidManfiest.xml文件或IOS IPA plist文件。UBT还将查询插件的UPL xml文件，查找文件中要包含的字符串（对于包来说必须是常见的字符串），例如Android上的一些.java文件。 首先贴一个相关的文档在这里：https://docs.unrealengine.com/zh-CN/SharingAndReleasing/Mobile/UnrealPluginLanguage/index.html 在第三方库的引入过程中，可能会涉及到一些平台相关的功能，比如说权限获取等，这部分的设置文件，不同平台下有不同的规定，以Android和ios为例，在安卓平台下，使用应用清单概览文件对组件和权限进行控制，即AndroidManifest.xml文件；而在IOS下，使用Property List文件来存储用户设置。 对于Android平台，可能需要对AndroidManifest.xml文件进行一些修改，这时候就需要使用UPL来对该文件进行改动。 一个例子以GCloudSDK中的MSDK为例： 这里的一些参数本质上是Android的一些参数，如果详细了解请阅读：Android开发者指南，(有一说一Google这个文档写的是真滴好，什么是国际大厂啊) 以其中几个为例： android:name : 实现 Activity 的类的名称，是 Activity 的子类。此属性值应为完全限定类名称（例如，“com.example.project.ExtracurricularActivity”）。不过，为简便起见，如果名称的第一个字符是句点（例如，“.ExtracurricularActivity”），则名称将追加至 &lt;manifest&gt; 元素中指定的软件包名称。 android:screenOrientation : Activity 在设备上的显示方向。如果 Activity 是在多窗口模式下运行，则系统会忽略该属性。 对GameActivity.java的拓展： 什么是GameActivity.java： 在网上搜索了一下，大多数都是讲述这个文件是如何通过UPL插入修改的，没有描述这个文件本身是什么作用的。这个文件可以在\Engine\Build\Android\Java\src\com\epicgames\ue4\GameActivity.java下找到，在开头的注释中可以看到： Extending NativeActivity so that this Java class is instantiated from the beginning of the program. This will allow the user to instantiate other Java libraries from here, that the user can then use the functions from C++ 扩展NativeActivity，使这个Java类从程序开始就被实例化。 这将允许用户从这里实例化其他Java库，然后用户可以使用C++中的函数。 NOTE — This class is not necessary for the UnrealEngine C++ code to startup, as this is handled through the base NativeActivity class. This class’s functionality is to provide a way to instantiate other Java libraries at the startup of the program and store references to them in this class. 注意 — 这个类对于UnrealEngine C++代码的启动是不必要的，因为这是由基础NativeActivity类处理的。这个类的功能是提供一种方法，在程序启动时实例化其他Java库，并在这个类中存储对它们的引用。 那么，在Android的文档中找到了关于NativeActivity类的描述，而GameActivity类继承自这个类。在文档内对NativeActivity的描述如下： Convenience for implementing an activity that will be implemented purely in native code. That is, a game (or game-like thing). There is no need to derive from this class; you can simply declare it in your manifest, and use the NDK APIs from there. 方便实现一个将纯用本地代码实现的活动。也就是说，一个游戏（或类似游戏的东西）。不需要从这个类派生出来；你可以简单地在你的manifest中声明它，然后从那里使用NDK API。 继续向上追溯，看看Acitvity类意在负责什么事： An activity is a single, focused thing that the user can do. Almost all activities interact with the user, so the Activity class takes care of creating a window for you in which you can place your UI with setContentView(View). While activities are often presented to the user as full-screen windows, they can also be used in other ways: as floating windows (via a theme with R.attr.windowIsFloating set), Multi-Window mode or embedded into other windows. There are two methods almost all subclasses of Activity will implement: 一个Activity是用户可以做的独立的事情。几乎所有的Activity都可以与用户产生交互，因此Activity类负责为你创建一个窗口，你可以通过setContentView(View)来放置你的UI。虽然Activity通常以全屏窗口的方式呈现给用户，但是它们同样可以以其他的方式进行展示：例如浮动窗口（通过一个主题设置R.attr.windowIsFloating实现），多窗口模式或者嵌入到其他窗口中。几乎所有的Activity的子类都会实现两个方法: onCreate(Bundle) onPause() 看到这两个函数命名就大概能知道这个Activity类是贯穿一个应用的生命周期的，那么NaviteActivity类以及GameActivity类中的内容就是用来在应用生命周期的不同阶段执行不同逻辑的。 如何拓展： 在UPL的源代码中可以看到全部的API，在SDK文档中应该会说明SDK的使用步骤，例如GCloud的文档中： 这部分的初始化代码就可以使用UPL插入到GameActivity.java中： GCloud::InitializeInfo initInfo; initInfo.GameId = GCLOUD_GAME_ID; initInfo.GameKey = GCLOUD_GAME_KEY; IGCloud::GetInstance().Initialize(initInfo); 当然具体的实现要参考不同SDK文档中提供的实现。 IOS平台设置相关： info.plist文件 这个文件的作用就是提供应用在运行期间的一些设置，是一个XML格式组织起来的文件。 在虚幻引擎中的设置： 在 Project Settings - iOS - Extra Plist Data - Aditional Plist Data - 中添加相关的配置信息中添加相关的渠道信息。 一些详细的解读可以参考查利鹏大佬的这篇博文：UE4 开发笔记：Mac/iOS 篇 参考插件 虚幻插件语言(Unreal Plugin Language) : https://docs.unrealengine.com/en-US/SharingAndReleasing/Mobile/UnrealPluginLanguage/index.html 虚幻插件语言参考：https://qiita.com/shiena/items/fe0e4cc1de4ddbaa60f0 UE4:UPL与JNI调用的最佳实践：https://imzlp.me/posts/27289/ 模块 模块的官方文档 : https://docs.unrealengine.com/en-US/ProductionPipelines/BuildTools/UnrealBuildTool/ModuleFiles/index.html 详解UE4静态库与动态库的导入与使用：https://www.cnblogs.com/sevenyuan/p/7161516.html 平台相关Android 应用清单 (AndroidManifest) : https://developer.android.com/guide/topics/manifest/manifest-intro?hl=zh-cn AndroidManifest.xml详解 : https://www.jianshu.com/p/3b5b89d4e154 权限 (Permission) : https://developer.android.com/guide/topics/permissions/overview?hl=zh-cn 应用二进制接口 (Android ABI, Application Binary Interface) : https://developer.android.com/ndk/guides/abis Android 关于arm64-v8a、armeabi-v7a、armeabi、x86下的so文件兼容问题：https://zhuanlan.zhihu.com/p/23102158 aar与jar : https://developer.android.com/studio/projects/android-library?hl=zh-cn IOS .bundle资源文件 : https://www.jianshu.com/p/55038871e7de framework库文件 : https://blog.csdn.net/lvxiangan/article/details/43115131 info.plist：https://my.oschina.net/hmj/blog/104196]]></content>
      <categories>
        <category>开发相关</category>
      </categories>
      <tags>
        <tag>Unreal,SDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Minigame以及其他有的没的]]></title>
    <url>%2F2020%2F09%2F17%2F%E9%9A%8F%E7%AC%94%2FMinigame%E4%BB%A5%E5%8F%8A%E5%85%B6%E4%BB%96%E6%9C%89%E7%9A%84%E6%B2%A1%E7%9A%84%2F</url>
    <content type="text"><![CDATA[从上海归来：这一段时间在搞Minigame，有点感触。从上海和顺佬还有翔仔回来的路上还是挺挫败的，一方面是有点中二的想法，感觉自己GameJam的好运气到此为止了；另一方面是觉得自己的技术力实在是不太行，有点对不起我的队友们；还有一方面是觉得是不是有的时候过于主观了，就像顺佬自述「我的优点是听人讲话」，感觉自己有时候对于别人的想法还是有点不太重视？ 从上海那次回来之后，挫败感也没有持续太久，当时在回酒店还是哪里的大巴上和隆德聊着说还是应该多看看GameJam的优秀作品找点启发。可除了整理了一个Ludum Dare历届主题之外，也没有额外的做什么事，只是在某次Minigame开会上临时抱佛脚的看了几个Demo。 当然这远远不够，等我再入职之后，和蒙哥聊起来什么「localmotion」说的我一愣一愣的，感觉对于游戏开发还是了解的太少太少了。 哀叹至此，实际上对现状也不会产生什么影响，还是说回本次Minigame。 Minigame和表达这次的MiniGame定的主题就是一个「文学」向的拼字游戏，为什么要给文学加引号呢，是因为本质上玩法并不怎么文学，只是拼字组成某种东西罢了。我们对于字的理解不会比其他人更多。 说来有点好笑，一开始我们的两个想法都是所谓的「公益」游戏，但实际上，我觉得游戏其实还是好玩比较重要。这点也是前不久才转变观点的，还和顺佬聊过。此前以为个人表达很重要，我可以不care任何受众，只表达我想表达的：当然这全然可以，只不过以部分人的水平来看，这么搞只会做出一团只有自己可以理解的shit，此外在表达自我和让它变得有趣or让更多的人可以理解之间并不冲突，其间的难处在于这需要一定的技术和审美。这里的技术不单单是指编码的技术，而是综合起来让自己的表达更高级的技术。 这很难。 当然这是现阶段看来一条值得追求的方向，即在提升自己技术力的同时，多多试着感受、记录、表达和修正（或者说优化）。 该做什么 最直观的应该是完成之前说的多看看GameJam视频，积累积累灵感，类似骑砍盾牌分析 by SecluSong)这类积累可以多做一做，哦，按我司的话来说应该是多沉淀一些。 再上一层的可能是多试着去实现一些东西，保持一个手热的状态，对于自己的知识库应该不断更新巩固，而不是一劳永逸，很多东西可能放一段时间之后就忘掉了。 再上一层的其实是一些生活上的一些东西，比如如何提高效率，如何利用下班时间提升自己（当然这属于知乎经典句式了），这些都还有待探索和学习，感觉可以先从调整作息开始，既然晚上的时间不多，其实可以早点睡觉，早上起来做一些事情。 最后的最后想了一些方法，但是说出来像是flag一样的东西，所以还是等验证过，有些结果之后再总结一下。]]></content>
      <categories>
        <category>文字</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“2020年第33周周报”]]></title>
    <url>%2F2020%2F08%2F19%2F%E4%B8%AA%E4%BA%BA%E6%8A%A5%E5%91%8A%2F202033%2F</url>
    <content type="text"><![CDATA[这是2020年的第33周报告。 上周计划完成情况 导师给Review了一下代码，改了之后提交了。 测试了一下性能，没什么问题。 本周做了什么 接了一个新需求，目前就是在看新需求涉及到的相关代码。 在看现有系统有没有可以重构的地方。 购物： 《世界经典鸡尾酒大全（珍藏版）》，可以说受到《赛博朋克酒保行动 VA-11 Hall-A: Cyberpunk Bartender Action》的强烈影响，对调酒有点感兴趣，二手书，130r。 摩飞的多功能锅，打算学学做饭，750r。 投资： 定投50r。 把1000左右放进余额宝了。 锻炼：无，体重维持在150上下，有点怪，现在进入了平衡，虽然感觉每天上下班汽车运动量也很大，但是从数字上看还是不太行。 下周打算做点什么 弹电吉他，我的电吉他到了，买了4年了还没有好好练过。 看看Unity的知识，写一点小轮子。 锻炼，看EVA。]]></content>
      <categories>
        <category>reports</category>
      </categories>
      <tags>
        <tag>report</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“2020年第32周周报”]]></title>
    <url>%2F2020%2F08%2F09%2F%E4%B8%AA%E4%BA%BA%E6%8A%A5%E5%91%8A%2F202032%2F</url>
    <content type="text"><![CDATA[这是2020年的第32周报告。 上周计划完成情况 邮箱基本上重构完成了，wiki读的还是太少，周五的时候把代码提了，等新包出来测试一下。 本周做了什么 前两天去事业群的培训了，大概就是通知一些事情。 开始读《大象无形：虚幻引擎程序设计浅析》，周末打游戏的时候脑海里总回想着“客户端是对服务端的拙劣模仿”这句话，可能是打游戏的时候总卡顿的缘故。还是要多看文档。 购物，简要清单如下： 铁三角CLR100，99r，放在公司用来听电脑的音频。 投资：买了50块的基金，每周一 定投50r。 锻炼：无，体重维持着150上下。 公益：给水灾捐了20r，助学捐了20r 下周打算做点什么 我必健身环。 看看Unity的知识，阅读项目代码，接需求。 等补发的自行车零件到了就可以骑自行车上班了。]]></content>
      <categories>
        <category>reports</category>
      </categories>
      <tags>
        <tag>report</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“2020年第31周周报”]]></title>
    <url>%2F2020%2F08%2F05%2F%E4%B8%AA%E4%BA%BA%E6%8A%A5%E5%91%8A%2F202031%2F</url>
    <content type="text"><![CDATA[这是2020年的第31周报告。 上周计划完成情况 邮箱重构要比想象中难很多，导师说的原来是两周不是两天。 本周做了什么入职快一个月了，上周去封闭培训了，所以两周报告和在一起，简单讲讲做了什么： 封闭培训，认识了一些还不错的人，但我并不怀念它。 阅读项目源码并重构某系统：大概实际耗时应该在5天，其中某些流程卡了我很久，还有一个恶性Bug需要明天去公司解决，如果顺利的话这周就能解决（希望这周就能解决，听说下周要接现行分支上的需求了）。 购物，简要清单如下： 充电宝：99r，华为 瑜伽垫：49r，用于健身环大冒险 剃须刀：小米 自行车：600r，凤凰，通勤用 上述消费大概在1000以内 锻炼：两周实际上没有怎么锻炼，封培期间一直在忙各种事，开始上班之后才能走走路，重新回到每天1w+的节奏，体重从7月25日的152.7斤降到了149.2斤，距离目标体重还有29.2斤。 本周开销较少，都是一些一次性消费重复使用的物品。 书影音：基本没有。 只言片语：这部分是从封培期间得到的一点体悟： 用利益驱动别人构成合作。（其实是换位思考的一种，想想对方想要什么。） 沟通时把别人当傻逼似的事无巨细有助于帮助你把潜在的傻逼教成正常人，从而规避掉坑。 人太分奴，或者得失心太重有时候会搞得吃相太难看。 待人礼貌是基本原则。 下周打算做点什么 把邮箱系统重构完，梳理整个系统结构。 学习性能分析部分。 读书，学习Lua和Unity。 找个周末去看场电影，《乔乔的奇妙冒险》、《妙先生》都在想看之列。]]></content>
      <categories>
        <category>reports</category>
      </categories>
      <tags>
        <tag>report</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“2020年第29周周报”]]></title>
    <url>%2F2020%2F07%2F18%2F%E4%B8%AA%E4%BA%BA%E6%8A%A5%E5%91%8A%2F202029%2F</url>
    <content type="text"><![CDATA[这是2020年的第29周报告。 本周做了什么这周是入职之后的经历过的第一个完整的一周，简单讲讲做了些什么。 阅读项目源码：项目发展到现在已经很庞大了，如果想要入手需要对整个项目有一个明确的认识，这一周就择性的阅读了项目的源码。 购物，简要清单如下： 吹风机：小米 台灯：小米 桌子：宜家 椅子：宜家 邮差包：TIMBUK2 锻炼：除了每天的1w+步以外，周三还玩了10分钟的健身环大冒险，体重情况则从157斤减少到了154斤，距离目标还有30斤。 本月开销较大，粗略计算达到了惊人的15600块，其中有12000属于房租，暂无收入。 想了下不是暂无收入，四个月前买了10块钱的基金，前两天卖了，扣除手续费之后大概卖了10块零八毛。 书影音： 在读《Lua设计与实现》和《Lua程序设计》 看过了《千年女优》，很喜欢，运镜太流畅了。 游戏打了打《和平精英》，算是做作业了。 只言片语： ​ 「我们一切都是从体验出发，我们要去了解后台那边是怎么写的，如果仅仅是少了几个函数，导致体验变差了，他们不给我们改，这说不过去的。」——我们组长和其他前辈沟通时说的话，有点动人。 ​ 「企业会怕你混日子，不怕你有企图。」——请教张老师后，张老师给出的点拨，挺有道理的，欲望写在脸上，如果是正当的欲望，没什么不好，我这人其实有欲望，但是因为胆怯或者懦弱总不愿意表达出来，感觉有的时候有点吃亏。 下周打算做点什么 工作：把邮箱系统改写好，听导师说好像两三天就能写好（？）。 体重：再减三斤！ 书影音： 把在读的两本书尽量读一些。 电影的话可能会再看一部今敏的片子。 消费：自行车？还有一些衣物。 自我盘点： 工作时应该更专心，必要时应该去除一些干扰。 记得写日志和周报，起码让你的上级了解你在做什么，这没什么坏处，就够了。]]></content>
      <categories>
        <category>reports</category>
      </categories>
      <tags>
        <tag>report</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“2020年第21周周报”]]></title>
    <url>%2F2020%2F05%2F26%2F%E4%B8%AA%E4%BA%BA%E6%8A%A5%E5%91%8A%2F202021%2F</url>
    <content type="text"><![CDATA[这是2020年的第21周报告（0518～0524）。 上周计划完成情况 摸鱼。 本周做了什么输出 答辩：18号毕业答辩结束，反正是平平淡淡就结束了，竟然还有点怅然若失，不知道是不是没有进行过一段校园恋情的缘故，还是对未来的迷茫，也或者两者都有。 答辩结束之后提交各种表格，文档。 摄影一则：寒风中接着大街上插座给手机充电的男子。生活不易啊。 消费 机票退款了，退了一半。 下周打算做点什么 看看蒙哥推荐的那个那本小说：《doom启示录》 尝试着写一个软渲染的Demo。 学C++。]]></content>
      <categories>
        <category>reports</category>
      </categories>
      <tags>
        <tag>report</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“2020年第20周周报”]]></title>
    <url>%2F2020%2F05%2F26%2F%E4%B8%AA%E4%BA%BA%E6%8A%A5%E5%91%8A%2F202020%2F</url>
    <content type="text"><![CDATA[这是2020年的第20周报告（0511～0517）。 上周计划完成情况 毕业论文：把论文的重复率降了下来。 本周做了什么输出 论文：把论文的内容修改了一下。 制作了一个毕业设计答辩的PPT和对应的讲稿。 消费 返校机票：¥880 无主之地3：¥35.48，Epic就是我大哥。 发现账本app只记到11日，没有坚持记账的习惯并不好。 输入 看了Epic关于Unreal Engine 5的演示视频，有点恍惚，我还能跟得上吗？ 虚幻引擎5！！！4K画质PS5实机演示！ 下周打算做点什么 摸鱼]]></content>
      <categories>
        <category>reports</category>
      </categories>
      <tags>
        <tag>report</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“2020年第19周周报”]]></title>
    <url>%2F2020%2F05%2F12%2F%E4%B8%AA%E4%BA%BA%E6%8A%A5%E5%91%8A%2F202019%2F</url>
    <content type="text"><![CDATA[这是2020年的第19周报告（0504～0510）。 上周计划完成情况 毕业设计：改初稿。 8号老师才给我反馈意见，在这之前基本上是放飞自我，这之后开始苦哈哈的改稿。 本周做了什么输出 摄影： 姑且命名为「马其顿防线」 改论文稿。 消费 美的台灯：¥59，之前搬家，东西都搬走了，在家这边又买了一个台灯，和寝室用的一样，能亮就行。 和朋友聚餐：¥88，社交花费。 输入 《羞羞的铁拳》：作为一个喜剧片来说还可以。 《bilibili献给新一代的演讲《后浪》》：一种目前无法企及的生活状态宣传片。 《动物新世代 BNA ビー・エヌ・エー》：老生常谈的设定和出色的画面表现，以及合适的BGM切入时机。 下周打算做点什么 论文改稿，降重，答辩。 学习C++。 学习Unreal。 坚持跑步。]]></content>
      <categories>
        <category>reports</category>
      </categories>
      <tags>
        <tag>report</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“2020年第18周周报”]]></title>
    <url>%2F2020%2F05%2F07%2F%E4%B8%AA%E4%BA%BA%E6%8A%A5%E5%91%8A%2F202018%2F</url>
    <content type="text"><![CDATA[这是2020年的第18周报告（0427～0503）。 上周计划完成情况 毕业设计：继续写论文。 基本完成了，稍作修改就可以发给老师看看了。 本周做了什么输出 毕业设计：把论文写的差不多了。由于毕业设计的存在，这一周基本上都是起床、摸鱼、吃饭、写论文、和方佬快乐联盟，看直播、睡觉度过的。 消费 FPX的锤石冠军皮肤：¥115.43，冲动消费一则。 Moo音乐会员月票：¥15，非必要消费一则。 敲钟牛皮肤：¥21.82，冲动消费两则。 输入 看了一眼让·鲍德里亚的《消费社会》，感觉太高深了，没看下去。 《新喜剧之王》：一场尴尬的闹剧和并不高明的讽刺。 下周打算做点什么 毕业设计：改初稿。]]></content>
      <categories>
        <category>reports</category>
      </categories>
      <tags>
        <tag>report</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“2020年第17周周报”]]></title>
    <url>%2F2020%2F04%2F28%2F%E4%B8%AA%E4%BA%BA%E6%8A%A5%E5%91%8A%2F202017%2F</url>
    <content type="text"><![CDATA[这是2020年的第17周报告（0420～0426）。 上周计划完成情况 毕设：把测试用例写完，虽然感觉大概率是我自己写，而不是从CTS这个项目里移植过来。然后把日志整理出来，再写一份论文初稿。 基本完成，但是日志还没有写完……太难编了。 出门走走：买了相机之后利用率不高，希望下周开始能出门透透气，顺便拍点东西。 调整作息：就像这篇周报写完的此刻，已经是00:52分了，希望之后能12点前睡觉，早上早点起床。 没有完成，下周继续努力。 本周做了什么输出： 毕业设计：改写了一部分CTS项目里的测试用例到GP101的测试框架下，然后每天写了写论文。 每天基本上都是在写毕业设计和论文，没什么其他好说的。 消费： 《仙剑奇侠传4》：¥25，Steam上买的，买一个算是补票，致敬一下当年感动到我的经典游戏。 《游戏开发：世嘉新人培训教材》：¥138.60，当当网购买，打算读读看。 《程序员修炼之道：通向务实的最高境界》：¥75.65，当当网购买，既然游戏业内的dalao都推荐了，就买来看看，当然这种思路不太理性。 《算法竞赛入门到进阶》：¥52.62，当当网购买，本质上说这本书是为了凑满减的，另一个动机来说这本书当作刷leetcode的一个教材来看，纯粹属于个人爱好了，类似于数独那种脑力游戏罢了，没有指望发挥什么现实作用。 输入： 了解了一下「入关学」的概念：https://zhuanlan.zhihu.com/p/120432699 看了看英雄联盟里锤石的玩法，虽然已经玩了好几年的锤石了，但是想看看还能不能更上一层楼。 下周打算做点什么 毕业设计：继续写论文。]]></content>
      <categories>
        <category>reports</category>
      </categories>
      <tags>
        <tag>report</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“2020年第16周周报”]]></title>
    <url>%2F2020%2F04%2F20%2F%E4%B8%AA%E4%BA%BA%E6%8A%A5%E5%91%8A%2F202016%2F</url>
    <content type="text"><![CDATA[这是2020年的第16周报告。 上周计划完成情况上周实际上没有什么计划，说起来这是第一次正式记录周报，就写这些好了。 本周做了什么本周实际上也没有完成什么特别值得拿来说说的事情。 消费： 路由器：京东上买的TP-LINK WDR7660千兆路由器，189.90元。 动机：买这个的缘由是觉得内蒙广电这里的机顶盒&amp;路由器太垃圾了（误），所以想换一个相对好一点点的路由器，上知乎看了一圈，买了这个。家里的宽带实际上只有100M，想着饱和式配置，就直接上了一个千兆的路由器，如果以后升级宽带就能派上用场了，就算不能，那其实这100M的宽带也能跑满。 体验：目前还可以，算是从东非走出来了，终于从手动在浏览器里输入192.168.1.1变成了在手机&amp;电脑双端都能进行控制，美中不足的是这个路由器貌似可玩性小一点，不能自己设置加速器的相关配置，不过一分钱一分货，也没什么奢望了。 输出： 博客相关：探索了一下关于hexo模版以及生成命令的知识 比如这篇博客，生成的命令就是hexo new report -p /个人报告/202016 “2020年第16周周报”，这行命令会从我写好的report模版出发，在-post文件夹下的「个人报告」文件夹中生成一篇报告，这样做的好处是省去了一些手动复制的过程，比较省事，同时看起来比较整洁。 社交媒体：没有什么值得一说的更新。 输入： 《我是于欢水》：看了这部电视剧，感觉还可以，一开始在朋友的豆瓣动态里看过，后来因为有关女权的争论所以打算看看。不到一下午的时间，用2倍速看完了这部剧。一些内容不能细品，另外一些内容又详细的出人意料，我不喜欢国产电视剧的一个原因在于感觉房间里的布景太亮了，过于惨白，以至于有一种隔阂感。日剧里的房间给我的印象都是暖黄色的光，比较柔和。此外还有一点就是有的时候主人公居住的环境往往超过他的消费水平，让我感觉非常突兀。说回这部剧，如果你把他当作一个重逻辑的电视剧去推敲可能会大失所望；但如果你就把他当作茶余饭后打发时间的剧，那还是能看看的。 《OpenGL ES 3.0 编程指南》：非常粗浅的翻阅了开头，记录了一下ES2.0与ES3.0的差别，作为毕业设计测试API的选取标准。 看了一下有关斐讯的新闻，为了骗钱真是什么手段都有啊，防不胜防。 事件： 笔记本电脑电池彻底不行了，只有33%的容量了，而且现在也完全充不进去电了，打算忙完毕设之后就保存数据，再之后要么换个新电脑，要么换个新电池了。 忘了买大头菜了，血亏。 下周打算做点什么 毕设：把测试用例写完，虽然感觉大概率是我自己写，而不是从CTS这个项目里移植过来。然后把日志整理出来，再写一份论文初稿。 出门走走：买了相机之后利用率不高，希望下周开始能出门透透气，顺便拍点东西。 调整作息：就像这篇周报写完的此刻，已经是00:52分了，希望之后能12点前睡觉，早上早点起床。]]></content>
      <categories>
        <category>reports</category>
      </categories>
      <tags>
        <tag>report</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ludum Dare 历届主题]]></title>
    <url>%2F2019%2F12%2F18%2F%E9%9A%8F%E7%AC%94%2FLudum-Dare-%E5%8E%86%E5%B1%8A%E4%B8%BB%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Ludum Dare 历届主题 No. Month Theme (bonus) 0† April 2002 Indirect interaction（间接干扰） 1 July 2002 Guardian（保卫者） 2 November 2002 Construction/destruction (sheep)（建立/毁灭（绵羊）） 3 April 2003 Preparation – Set it up, let it go（准备—设置好，放手） 4 April 2004 Infection（感染） 5 October 2004 Random（随机） 6 April 2005 Light and darkness（光与暗） 7 December 2005 Growth（生长） 8 April 2006 Swarms（密集） 8.5† January 2007 Moon/anti-text（月/反文本（不知道这个在中文中表达什么）） 9 April 2007 Build the level you play（构建你玩的关卡） 10 December 2007 Chain reaction（连锁反应） 10.5 February 2008 Weird/unexpected/surprise（奇怪/意想不到/惊奇） 11 April 2008 Minimalist（极简主义者） 12 August 2008 The tower（塔） 13 December 2008 Roads（路） 14 April 2009 Advancing wall of doom（前进的末日之墙） 15 August 2009 Caverns（洞穴） 16 December 2009 Exploration（探索） 17 April 2010 Islands（群岛，岛屿） 18 August 2010 Enemies as weapons（敌人作为武器，作为武器的敌人） 19 December 2010 Discovery（发现） 20 April 2011 It’s dangerous to go alone! Take this!（一个人去是很危险的!拿着这个！） 21 August 2011 Escape（逃脱） 22 December 2011 Alone (kitten challenge)（单独（小猫挑战）） 23 April 2012 Tiny world（小世界） 24 August 2012 Evolution（演变） 25 December 2012 You are the villain (goat)（你是恶棍 （山羊）） 26 April 2013 Minimalism (potato)（简约主义（马铃薯）） 27 August 2013 10 seconds（十秒） 28 December 2013 You only get one（你只得到一个） 29 April 2014 Beneath the surface（表面下） 30 August 2014 Connected Worlds（被连接的世界） 31 December 2014 Entire Game on One Screen（整个游戏在一个屏幕上） 32 April 2015 An Unconventional Weapon（非常规武器） 33 August 2015 You are the Monster（你是怪兽） 34 December 2015 Growing/two button controls（增长/两个按钮控件） 35 April 2016 Shapeshift（变形） 36 August 2016 Ancient Technology（古代科技） 37 December 2016 One Room（一个房间） 38 April 2017 A Small World（一个小世界） 39 July 2017 Running out of Power（电源耗尽） 40 December 2017 The more you have, the worse it is（你拥有的越多, 就越糟糕） 41 April 2018 Combine two incompatible genres（结合两种不相容的体裁） 42 August 2018 Running out of space（空间耗尽） 43 December 2018 Sacrifices must be made（必须作出牺牲） 44 April 2019 Your life is currency（你的生命（生活）是一种货币） 45 October 2019 Start with nothing（从无到有） 46 April 2020 Keep it Alive（保持或者）]]></content>
      <tags>
        <tag>灵感</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[翻译]Integrating Lua]]></title>
    <url>%2F2019%2F09%2F24%2F%E7%BF%BB%E8%AF%91%2F%E7%BF%BB%E8%AF%91-Integrating-Lua%2F</url>
    <content type="text"><![CDATA[一篇名为Integrating Lua的Wiki页面翻译。 原文链接：https://wiki.unrealengine.com/Integrating_Lua Integrating LuaOverview欢迎来到我的第三个Wiki页面，这个页面是关于那个很棒的游戏引擎的——虚幻引擎！这篇文章包含了人们最近问我数次的那个问题，我认为这将对游戏逻辑编程和一个高水平的mod-abilty（模块化能力？）：整合Lua很有用。 RequirementsStarting off : code in our projectAquiring:现在，我们需要向项目中引入Lua，以便于其与我们的项目一起编译并包含在最终游戏中。但是首先，我们需要获取到Lua的二进制文件。有些项目会为您提供预编译的二进制文件，或者您也可以自行编译！因为编译的过程耗费时间，而且这个过程是必要的，所以我们将使用预编译的版本。LuaBinaries是一个很棒的项目，它始终是最新的，并且具有适用于每个平台的二进制文件（在本文中，我们将只涉及Windows）。选择最新版本，然后选择Windows库，接着选择静态（Static），因为我们会将Lua嵌入到游戏的可执行文件中，然后根据需要搜索软件包。在我们下载过这些包后，我们应该在它们的结构中找到如下文件： Include/(essential includes for working with Lua) luaxlib.h lua.h lua.hpp luaconf.h lualib.h luaXX.lib（XX代表Lua的当前版本，例如Lua 5.3.3就为lu a53.lib） 现在，我们拥有了二进制文件和包含文件，我们可以开始我们的集成工作了！ Copying the files在虚幻引擎中链接Lua很容易。首先，我们需要在项目目录中创建一个新文件夹，将Lua内容放入其中。我个人更喜欢在项目的主目录（.uproject所在的位置）中创建一个新文件夹，并将其命名为“ThirdParty”。然后在这个文件夹中，我创建了一个名为“Lua”的文件夹，并将其分为“includes”和“libraries”。结构如下： Project Home/ ThirdParty/ Lua/ includes/（我们只需要复制一次，因为它们与体系结构没有区别，最后请注意“s”） libraries/ luaXX.x64.lib（这是您在Win64包中下载的库文件，重命名来做区分） luaXX.x32.lib（这是您在Win32包中下载的库文件，重命名来做区分） Linking在Visual Studio中，打开YourProjectName.Build.cs，这个文件位于 Source/YourProjectName/ 文件夹中。默认情况下，此文件仅链接默认引擎模块。要对此链接Lua，我们需要向其中添加一些代码。由于展示每一个细节实在是太多了，所以我只向你展示我对Build.cs文件的改动： using System.IO; using UnrealBuildTool; public class ProjectName : ModuleRules { private string ThirdPartyPath { get { return Path.GetFullPath(Path.Combine(ModuleDirectory, "../../ThirdParty/")); } } public ProjectName(TargetInfo Target) { PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject", "Engine", "InputCore" }); PrivateDependencyModuleNames.AddRange(new string[] { }); // 如果使用Slate UI，则取消注释 // PrivateDependencyModuleNames.AddRange(new string[] { "Slate", "SlateCore" }); // 如果使用在线功能，则取消注释 // PrivateDependencyModuleNames.Add("OnlineSubsystem"); // 要包含 OnlineSubsystemSteam, 请将其添加到uproject文件的plugins部分中，并将Enabled属性设置为true LoadLua(TargetRules); // 此函数加载Lua } private bool LoadLua(ReadOnlyTargetRules TargetRules) { bool isLibSupported = false; // 检查是否使用的是Windows if ((Target.Platform == UnrealTargetPlatform.Win64) || (Target.Platform == UnrealTargetPlatform.Win32)) { isLibSupported = true; string PlatformString = (Target.Platform == UnrealTargetPlatform.Win64) ? "x64" : "x86"; // 此字符串是“x64”或“x86”，因此我们可以将其附加到lib文件名 string LibrariesPath = Path.Combine(ThirdPartyPath, "Lua", "libraries"); PublicAdditionalLibraries.Add(Path.Combine(LibrariesPath, "lua53." + PlatformString + ".lib")); PublicIncludePaths.Add(Path.Combine(ThirdPartyPath, "Lua", "includes")); } Definitions.Add(string.Format("WITH_LUA_BINDING={0}", isLibSupported ? 1 : 0)); return isLibSupported; } } “LoadLua”方法检查我们是否在Windows上，如果是，则根据编译的体系结构创建一个包含“x64”或“x86”的字符串，因此我们可以轻松的找到lib文件。然后，我们创建库路径，该路径就是（在这个例子中为“ThirdParty/”）/Lua/libraries。从那里，我们将平台字符串附加到文件名的前缀和后缀，因此最后应该是lua53.xxx.lib。此路径已添加到PublicAdditionalLibraries中，这会强制编译器使用我们放在其中的lib文件。我们还将includes目录添加到PublicIncludePaths，以便编译器找到我们的includes。最后也很重要的一点是，我们向已编译的游戏中添加了一个定义：WITH_LUA_BINDING = x，其中x为0（不支持Lua）或1（支持Lua）。 First steps现在，我们已经将Lua二进制文件集成到我们的游戏中，让我们通过在Visual Studio中右键单击该项目并选择“Build”来进行尝试。它应该会成功！下一步：编写一个蓝图节点，该节点从我们输入的字符串中执行Lua代码。打开您创建的蓝图函数库的头文件（.h）。空文件如下所示： #pragma once #include "Kismet/BlueprintFunctionLibrary.h" #include "LuaBlueprints.generated.h" /** * */ UCLASS() class YOURPROJECT_API ULuaBlueprints : public UBlueprintFunctionLibrary { GENERATED_BODY() }; 首先，在顶部添加Lua包含项，以便编译器知道声明函数的位置。为此，请在其他包含项的头部添加#include &quot;lua.hpp&quot;。接下来，我们向其中添加一个新的UFUNCTION，将其解析为带有以下声明的蓝图节点： public: UFUNCTION(BlueprintCallable, Category = "Lua") static void RunLua(const FString& code); 这将创建一个可调用的蓝图节点，该节点带有一个字符串（FString），我们可以在其中输入将要运行的Lua代码。请注意，这是静态的，因为我们没有要在上下文中调用此对象的对象，换言之，我们想在没有任何目标的情况下从任何地方调用它。让我们进入LuaBlueprints.cpp文件，该文件应该为空（include文件除外）。我们为RunLua函数添加定义： void ULuaBlueprints::RunLua(const FString& code) { lua_State* L = luaL_newstate(); luaL_openlibs(L); int result = luaL_dostring(L, TCHAR_TO_ANSI(*code)); if (result != 0) { UE_LOG(LogTemp, Error, TEXT("Lua Script error: %s"), ANSI_TO_TCHAR(lua_tostring(L, -1))); } } 这很容易。它使用Lua C API创建一个新的Lua状态，将其分配给名为L的变量。然后，打开标准的lua库（例如math），然后通过执行luaL_dostring()运行代码。这将Lua状态L作为一个参数，并将要运行的代码作为另一个参数。该函数返回一个整数，如果一切正常，则返回0。如果不为0，则显然出了问题。在这种情况下，我使用UE_LOG将其打印到日志中。注意，我们通过lua_tostring(L,-1)得到Lua错误消息。]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>Lua</tag>
        <tag>Unreal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下配置OpenGL环境]]></title>
    <url>%2F2019%2F09%2F11%2FOpenGL%E7%AC%94%E8%AE%B0%2FMac%E4%B8%8B%E9%85%8D%E7%BD%AEOpenGL%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[Mac下配置OpenGL环境。 Mac下配置OpenGL 安装homebrew ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 安装GLEW与GLFW brew install glew brew install glfw3 CLion法（推荐） 在CLion:A cross-platform IDE for C and C++下载CLion 配置GLAD： 打开在线服务（点击这个链接），API选择3.3及以上，Profile选择Core，勾选Options中的Generate a loader，点击GENERATE，会生成一个压缩包，下载。 将子目录中的/include/glad与/include/KHR复制到/usr/Local/include文件夹下。（如果/usr文件夹隐藏，可用快捷键command+shift+G输入访问） 新建一个项目，配置对应的Cmake文件： cmake_minimum_required(VERSION 3.12) project(OpenGL) set(CMAKE_CXX_STANDARD 14) set(GLEW_H /usr/local/Cellar/glew/2.1.0/include/GL) set(GLFW_H /usr/local/Cellar/glfw/3.2.1/include/GLFW) set(GLAD_H /usr/local/include/glad) set(KH_H /usr/local/include/KHR) include_directories(${GLEW_H} ${GLFW_H} ${GLAD_H} ${KH_H}) # 添加目标链接 set(GLEW_LINK /usr/local/Cellar/glew/2.1.0/lib/libGLEW.2.1.dylib) set(GLFW_LINK /usr/local/Cellar/glfw/3.2.1/lib/libglfw.3.dylib) link_libraries(${OPENGL} ${GLEW_LINK} ${GLFW_LINK}) # 执行编译命令 # 这个glad.c在第2步中说过要拉到项目中，注意路径 set(SOURCE_FILES "src/glad.c" "main.cpp") add_executable(OpenGL ${SOURCE_FILES}) # mac下这步很重要 if (APPLE) target_link_libraries(OpenGL "-framework OpenGL") target_link_libraries(OpenGL "-framework GLUT") endif() 注意这样配置之后需要更改/usr/local/include/glad文件夹下的glad.h中的#include &lt;KHR/khrplatform.h&gt;更改为#include &lt;khrplatform.h&gt;，具体步骤： 在CLion中打开glad.c文件，command+点按#include &lt;glad.h&gt;会跳到glad.h 然后在glad.h中command+f找到#include &lt;KHR/khrplatform.h&gt;，将它改为#include &lt;khrplatform.h&gt; 运行测试代码（把下列代码复制到main.cpp中）： ```cpp include include include using namespace std; void key_callback(GLFWwindow* window, int key, int scancode, int action, int mode){ //如果按下ESC，把windowShouldClose设置为True，外面的循环会关闭应用 if(key==GLFW_KEY_ESCAPE &amp;&amp; action == GLFW_PRESS) glfwSetWindowShouldClose(window, GL_TRUE); std::cout&lt;&lt;”ESC”&lt;&lt;mode;} int main(void){ //初始化GLFW库 if(!glfwInit()) return -1; //创建窗口以及上下文 GLFWwindow* window = glfwCreateWindow(640, 480, “hello world”, NULL, NULL); if(!window) { //创建失败会返回NULL glfwTerminate(); } //建立当前窗口的上下文 glfwMakeContextCurrent(window); glfwSetKeyCallback(window, key_callback); //注册回调函数 //循环，直到用户关闭窗口 while(!glfwWindowShouldClose(window)) { /*******轮询事件*******/ glfwPollEvents(); /*******渲染*******/ //选择清空的颜色RGBA glClearColor(0.2, 0.3, 0.3, 1); glClear(GL_COLOR_BUFFER_BIT); //开始画一个三角形 glBegin(GL_TRIANGLES); glColor3f(1, 0, 0); //Red glVertex3f(0, 1, 1); glColor3f(0, 1, 0); //Green glVertex3f(-1, -1, 0); glColor3f(0, 0, 1); //Blue glVertex3f(1, -1, 0); //结束一个画图步骤 glEnd(); glBegin(GL_POLYGON); //再画个梯形，需要注意笔顺 glColor3f(0.5, 0.5, 0.5); //Grey glVertex2d(0.5, 0.5); glVertex2d(1, 1); glVertex2d(1, 0); glVertex2d(0.5, 0); glEnd(); /******交换缓冲区，更新window上的内容******/ glfwSwapBuffers(window); } glfwTerminate(); return 0; } ``` 如果出现如下窗口说明配置成功： XCode法 在App Store中搜索XCode并安装。 新建Xcode的Command Line C++项目，在build settings中设置Header Search Path与Library Search Path，在其中添加对应的glew与glfw的头文件(include)与库文件(lib)路径。 在build Phases中添加库文件 ​ （在对应的文件夹中将两个/.dylib的文件直接拖拽进来） 配置GLAD： 打开在线服务（点击这个链接），API选择3.3及以上，Profile选择Core，勾选Options中的Generate a loader，点击GENERATE，会生成一个压缩包，下载。 将子目录中的/include/glad与/include/KHR复制到/usr/Local/include文件夹下。（如果/usr文件夹隐藏，可用快捷键command+shift+G输入访问） 将/src中的glad.c复制到Xcode工程文件夹下。 在build settings中添加路径/usr/local/include 此时如果不出意外的话，你的第一个测试程序已经可以运行了，点击测试代码，复制到自己的.cpp文件中执行，会出现一个黑色窗口。(或者直接复制下面的代码) ```cpp #include &lt;glad/glad.h&gt; #include &lt;GLFW/glfw3.h&gt; #include &lt;iostream&gt; void framebuffer_size_callback(GLFWwindow* window, int width, int height); void processInput(GLFWwindow *window); // settings const unsigned int SCR_WIDTH = 800; const unsigned int SCR_HEIGHT = 600; int main() { // glfw: initialize and configure // ------------------------------ glfwInit(); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); #ifdef __APPLE__ glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); // uncomment this statement to fix compilation on OS X #endif // glfw window creation // -------------------- GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, &quot;LearnOpenGL&quot;, NULL, NULL); if (window == NULL) { std::cout &lt;&lt; &quot;Failed to create GLFW window&quot; &lt;&lt; std::endl; glfwTerminate(); return -1; } glfwMakeContextCurrent(window); glfwSetFramebufferSizeCallback(window, framebuffer_size_callback); // glad: load all OpenGL function pointers // --------------------------------------- if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) { std::cout &lt;&lt; &quot;Failed to initialize GLAD&quot; &lt;&lt; std::endl; return -1; } // render loop // ----------- while (!glfwWindowShouldClose(window)) { // input // ----- processInput(window); // glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.) // ------------------------------------------------------------------------------- glfwSwapBuffers(window); glfwPollEvents(); } // glfw: terminate, clearing all previously allocated GLFW resources. // ------------------------------------------------------------------ glfwTerminate(); return 0; } // process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly // --------------------------------------------------------------------------------------------------------- void processInput(GLFWwindow *window) { if(glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) glfwSetWindowShouldClose(window, true); } // glfw: whenever the window size changed (by OS or user resize) this callback function executes // --------------------------------------------------------------------------------------------- void framebuffer_size_callback(GLFWwindow* window, int width, int height) { // make sure the viewport matches the new window dimensions; note that width and // height will be significantly larger than specified on retina displays. glViewport(0, 0, width, height); } ``` 如果运行出现如下窗口，说明配置成功： 参考： https://www.cnblogs.com/shayue/p/Mac-CLion-xiaOpenGL-huan-jing-pei-zhi.html]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua源码阅读：虚拟机概述]]></title>
    <url>%2F2019%2F08%2F21%2FLua%2FLua%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%9A%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[Lua 虚拟机的执行过程。 Lua 执行过程概述：解释型脚本语言与编译型语言的区别如下： 由于每个脚本语言都有自己的一套字节码，与具体的硬件平台无关，所以不用修改脚本代码，就能运行在各个平台上。硬件、软件平台的差异都由语言自身的虚拟机解决。 由于脚本语言的字节码需要虚拟机执行，而不像机器代码能够直接执行，所以运行速度比编译型语言差不少。 虚拟机需要完成以下工作： 将源代码编译成虚拟机可以识别执行的字节码。 为函数调用准备调用栈。 内部维持一个 IP（Instruction Pointer，指令指针）来保存下一个将执行的指令地址。在 Lua 代码中，IP 对应的是 PC 指针。 模拟一个 CPU 的运行：循环拿出由 IP 指向的字节码，根据字节码格式进行解码，然后执行字节码。 虚拟机的实现方式：虚拟机有两种不同的实现方式：基于栈的虚拟机和基于寄存器的虚拟机。Lua 是基于寄存器虚拟机的语言。 区别： 在基于栈的虚拟机中，字节码的操作数是从栈顶上弹出（pop），在执行完操作后再压入栈顶的，这样的缺点是会多出几条指令来准备数据，优点是指令中不需要关心操作数的地址，在执行操作之前就已经将操作数准备在栈顶上了。 在基于寄存器的指令中，操作数是放在“CPU 的寄存器”中，因此，同样的操作不再需要 PUSH、POP 指令，取而代之的是在字节码中带上具体操作数所在的寄存器地址。对比需要栈的寄存器，这里的指令数会减少，但缺点是此时程序需要关注操作数所在的位置。 实现一个脚本语言的解释器： 设计一套字节码，分析源代码文件生成字节码。 在虚拟机中执行字节码。 如何在整个执行过程中保存整个执行环境。 执行Lua文件调用的是luaL_dofile 函数： #define luaL_dofile(L, fn) \ (luaL_loadfile(L, fn) || lua_pcall(L, 0, LUA_MULTRET, 0)) 其中 luaL_loadfile 函数用于进行词法和语法分析，lua_pcall 用于将第一步中分析的结果（字节码）放在虚拟机中执行。 luaL_loadfile 函数，通过lua_load，luaD_protectedparser，最终调用 f_parser 函数： // ldo.c static void f_parser (lua_State *L, void *ud) { LClosure *cl; struct SParser *p = cast(struct SParser *, ud); int c = zgetc(p->z); /* read first character */ if (c == LUA_SIGNATURE[0]) { checkmode(L, p->mode, "binary"); cl = luaU_undump(L, p->z, &p->buff, p->name); } else { checkmode(L, p->mode, "text"); cl = luaY_parser(L, p->z, &p->buff, &p->dyd, p->name, c); } lua_assert(cl->nupvalues == cl->p->sizeupvalues); luaF_initupvals(L, cl); } 完成词法分析之后，返回了 Proto 类型的指针tf，然后将其绑定在新创建的 Closure 指针上，初始化 Upvalue，最后压入栈中。 词法分析之后产生的字节码等相关数据都在这个 Proto 类型的结构体中，而这个数据又作为 Closure 保存了下来。 lua_pcall 内部调用了lua_pcallk函数： // lapi.c LUA_API int lua_pcallk (lua_State *L, int nargs, int nresults, int errfunc, lua_KContext ctx, lua_KFunction k) { struct CallS c; int status; ptrdiff_t func; lua_lock(L); api_check(k == NULL || !isLua(L->ci), "cannot use continuations inside hooks"); api_checknelems(L, nargs+1); api_check(L->status == LUA_OK, "cannot do calls on non-normal thread"); checkresults(L, nargs, nresults); if (errfunc == 0) func = 0; else { StkId o = index2addr(L, errfunc); api_checkstackindex(errfunc, o); func = savestack(L, o); } c.func = L->top - (nargs+1); /* function to be called */ if (k == NULL || L->nny > 0) { /* no continuation or no yieldable? */ c.nresults = nresults; /* do a 'conventional' protected call */ status = luaD_pcall(L, f_call, &c, savestack(L, c.func), func); } else { /* prepare continuation (call is already protected by 'resume') */ CallInfo *ci = L->ci; ci->u.c.k = k; /* save continuation */ ci->u.c.ctx = ctx; /* save context */ /* save information for error recovery */ ci->extra = savestack(L, c.func); ci->u.c.old_errfunc = L->errfunc; L->errfunc = func; setoah(ci->callstatus, L->allowhook); /* save value of 'allowhook' */ ci->callstatus |= CIST_YPCALL; /* function can do error recovery */ luaD_call(L, c.func, nresults, 1); /* do the call */ ci->callstatus &= ~CIST_YPCALL; L->errfunc = ci->u.c.old_errfunc; status = LUA_OK; /* if it is here, there were no errors */ } adjustresults(L, nresults); lua_unlock(L); return status; } 可以看到，首先获取需要调用的函数指针： c.func = L->top - (nargs+1); /* function to be called */ 这里的 nargs 是由函数参数传入的，在 lual_dofile 中调用 lua_pcall 时，这里传入的参数是 0。换句话说，这里得到的函数对象指针就是前面 f_parser 函数中最后两句代码放入 Lua 栈的 Closure 指针。 继续向下执行，在调用函数 luaD_pcall 时，最终会执行到 luaD_call 函数，其中有： if (!luaD_precall(L, func, nResults)) /* is a Lua function? */ luaV_execute(L); /* call it */ 首先调用 luaD_precall 函数进行执行前的准备工作： /* ** returns true if function has been executed (C function) ...部分有省略 */ int luaD_precall (lua_State *L, StkId func, int nresults) { lua_CFunction f; CallInfo *ci; int n; /* number of arguments (Lua) or returns (C) */ ptrdiff_t funcr = savestack(L, func); switch (ttype(func)) { ... case LUA_TLCL: { /* Lua function: prepare its call */ StkId base; Proto *p = clLvalue(func)->p; ... ci = next_ci(L); /* now 'enter' new function */ ci->nresults = nresults; ci->func = func; ci->u.l.base = base; ci->top = base + p->maxstacksize; lua_assert(ci->top stack_last); ci->u.l.savedpc = p->code; /* starting point */ ci->callstatus = CIST_LUA; L->top = ci->top; luaC_checkGC(L); /* stack grow uses memory */ if (L->hookmask & LUA_MASKCALL) callhook(L, ci); return 0; } ... } } 从 lua_State 的 CallInfo 数组中得到一个新的 CallInfo 结构体，设置它的func、base、top 指针 从前面分析阶段生成的 Closure 指针中，取出保存下来的 Proto 结构体。这个结构体中保存的是分析过程完结之后生成的字节码等信息。 将这里创建的 CallInfo 指针的 top、base 指针赋给 lua_State 结构体的 top、base 指针。将 Proto 结构体的 code 成员赋值给 lua_State 指针的 savedpc 字段，code 成员保留的就是字节码。 将多余的函数参数赋值为 nil，比如一个函数定义中需要的是两个参数，实际传入的只有一个，那么多出来的那个参数会被赋值为 nil。 执行完 luaD_precall 函数之后，接着会进入 luaV_execute 函数，这里是虚拟机执行代码的主函数： // lvm.c void luaV_execute (lua_State *L) { CallInfo *ci = L->ci; LClosure *cl; TValue *k; StkId base; newframe: /* reentry point when frame changes (call/return) */ lua_assert(ci == L->ci); cl = clLvalue(ci->func); k = cl->p->k; base = ci->u.l.base; /* main loop of interpreter */ for (;;) { Instruction i = *(ci->u.l.savedpc++); StkId ra; if ((L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT)) && (--L->hookcount == 0 || L->hookmask & LUA_MASKLINE)) { Protect(luaG_traceexec(L)); } /* WARNING: several calls may realloc the stack and invalidate 'ra' */ ra = RA(i); /* 后面是各种字节码的处理流程 */ } 这里的 ci-&gt;u.l.savedpc存放的是虚拟机 OpCode 代码，这部分从 L-&gt;savepc 初始化而来，而 L-&gt;savepc 在 luaD_precall 中赋值。可以看到，luaV_execute 函数最主要的作用就是一个大循环，将当前传入的指令依次执行。 执行完毕后，会调用 luaD_poscall 函数恢复到上一次函数调用的环境。 int luaD_poscall (lua_State *L, StkId firstResult) { StkId res; int wanted, i; CallInfo *ci = L->ci; if (L->hookmask & (LUA_MASKRET | LUA_MASKLINE)) { if (L->hookmask & LUA_MASKRET) { ptrdiff_t fr = savestack(L, firstResult); /* hook may change stack */ luaD_hook(L, LUA_HOOKRET, -1); firstResult = restorestack(L, fr); } L->oldpc = ci->previous->u.l.savedpc; /* 'oldpc' for caller function */ } res = ci->func; /* res == final position of 1st result */ wanted = ci->nresults; L->ci = ci = ci->previous; /* back to caller */ /* move results to correct place */ for (i = wanted; i != 0 && firstResult < L->top; i--) setobjs2s(L, res++, firstResult++); while (i-- > 0) setnilvalue(res++); L->top = res; return (wanted - LUA_MULTRET); /* 0 iff wanted == LUA_MULTRET */ } 虚拟机执行流程： 在f_parser函数中，对代码文件的分析返回了Proto指针。这个指针会保存在Closure指针中，留待后续继续使用。 在luaD_precall函数中，将lua_state的savedpc指针指向第一步中Proto结构体的code指针，同时准备好函数调用时的栈信息。 在luaV_execute函数中，pc指针指向第二步的savedpc指针（Lua5.3中似乎直接使用的savedpc指针），紧跟着就是一个大的循环体，依次取出其中的OpCode执行。 执行完毕后，调用luaD_poscall函数恢复到上一个函数的环境。 虚拟机指令执行的两大入口如下： 词法、语法分析阶段的luaY_parser，Lua一次遍历脚本文件完成了词法分析和语法分析，生成的OpCode存放在Proto结构体的code数组中。 luaV_execute：虚拟机执行指令阶段的入口函数，取出第一步生成的Proto结构体中的指令执行。 Proto结构体中的数据： 函数的常量数组 编译生成的字节码信息 函数的局部变量信息 保存upvalue名字的数组 /* ** Function Prototypes */ typedef struct Proto { CommonHeader; lu_byte numparams; /* number of fixed parameters */ lu_byte is_vararg; lu_byte maxstacksize; /* maximum stack used by this function */ int sizeupvalues; /* size of 'upvalues' */ int sizek; /* size of 'k' */ int sizecode; int sizelineinfo; int sizep; /* size of 'p' */ int sizelocvars; int linedefined; int lastlinedefined; TValue *k; /* constants used by the function */ Instruction *code; struct Proto **p; /* functions defined inside the function */ int *lineinfo; /* map from opcodes to source lines (debug information) */ LocVar *locvars; /* information about local variables (debug information) */ Upvaldesc *upvalues; /* upvalue information */ struct LClosure *cache; /* last created closure with this prototype */ TString *source; /* used for debug information */ GCObject *gclist; } Proto; 该程序最终会调用 luaV_execute() 函数执行，开始会初始化 global_State、lua_State 两个结构体，用来保存上下文的相关信息。 main() |-luaL_newstate() # 创建global_State+lua_State，并初始化 |-lua_pcall() # 实际会调用pmain()函数 | # 根据不同的参数调用不同的函数 |-runargs() # 执行命令行通过-e指定的命令 |-doREPL() # 执行交互模式，也即read-eval-print loop |-handle_script() # 执行lua脚本 |-luaL_loadfile() # 加载lua文件，后面详细介绍 | |-lua_load() | |-docall() # 调用执行 |-lua_pcall() |-luaD_pcall() # 实际会调用f_call()函数 在调用函数执行过程中，最终会调用 luaV_execute() 函数。其中，主要处理字节码的是 for(;;){} 循环，也即进入到解释器的主循环，处理很简单，取得当前指令，pc 递增，初始化 ra，然后根据指令的操作码进行选择；然后接下来是一大串的 switch … case … 处理。 接下来对其中有主要的几类指令进行说明。 关于define部分符号用法详见：https://www.jianshu.com/p/e9f00097904a，先转一个，有时间了再写。 另一个参考：https://gcc.gnu.org/onlinedocs/cpp/Macros.html#Macros]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua与C交互相关]]></title>
    <url>%2F2019%2F08%2F16%2FLua%2FLua%E4%B8%8EC%E4%BA%A4%E4%BA%92%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[C语言API总览。 C语言和Lua语言的两种交互形式： C语言拥有控制权，而Lua语言被用作库，这种交互形式中的C代码被称为应用代码。 Lua语言拥有控制权，而C语言被用作库，此时的C代码被称为库代码。 应用代码和库代码都适用相同的API和Lua语言通信，这些API称为C API。 一个简单的独立解释器：#include #include #include "lua.h" #include "lauxlib.h" #include "lualib.h" int main(void) { char buff[256]; int error; lua_State *L = luaL_newstate(); /* 打开Lua */ luaL_openlibs(L); /* 打开标准库 */ while(fgets(buuff,sizeof(buff),stdin) != NULL) { error = luaL_loadstring(L,buff) || lua_pcall(L,0,0,0); if(error) { fprintf(stderr,"%s\n",lua_tostring(L,-1)); lua_pop(L,1); /* 从栈中弹出错误信息 */ } } lua_close(L); return 0; } 头文件lua.h声明了Lua提供的基础函数，其中包括创建新Lua环境的函数、调用Lua函数的函数、读写环境中的全局变量的函数，以及注册供Lua语言调用的新函数的函数，等等。其中声明的所有内容都有一个前缀lua_。 头文件lauxlib.h声明了辅助库所提供的函数，其中所有的声明均以luaL_开头。 头文件lualib.h中声明了用于打开这些库的函数。 栈：Lua和C之间通信的主要组件是虚拟栈，几乎所有的API的调用都是在操作这个栈中的值，Lua和C之间所有的数据交换都是通过这个栈完成的，此外，还可以利用栈保存中间结果。 为了解决动态类型和静态类型体系之间不匹配，以及自动内存管理和手动内存管理之间不匹配：Lua API中没有定义任何类似于lua_Value的类型，而是使用栈在Lua和C之间交换数据。栈中的每个元素都能保存Lua中任意类型的值。当我们想要从Lua中获取一个值时，只需调用Lua，Lua就会将指定的值压入栈中。当想要将一个值传给Lua时，首先要将这个值压入栈，然后调用Lua将其从栈中弹出即可。这需要每个C语言类型都有一个函数将其压入栈，还需要每个类型都有一个弹出的函数，但是避免了过多的组合，另外由于这个栈是Lua状态的一部分，因此垃圾收集器知道C语言正在使用哪些值。 压入元素：针对每一种能用C语言直接表示的Lua数据类型，C API中都有一个对应的压栈函数。 对栈空间的检查可以使用int lua_checkstack(lua_State *L,int sz);这里，sz是我们所需的额外栈位置的数量，如果可能，函数 lua_checkstack 会增加栈的大小，以容纳所需的额外空间；否则该函数返回0。 查询元素：第一个被压入栈的元素索引为1，第二个被压入的元素索引为2，依此类推。也可以使用负数索引来访问栈中的元素，栈顶的元素为-1，-2表示在它之前被压入栈中的元素。 与Lua栈相关的函数游一系列，在此不做赘述。 使用C API进行错误处理：处理应用程序中的错误：Lua语言通常通过长跳转来提示错误，但是如果没有相应的setjmp，解释器就无法进行长跳转。此时，API中的任何错误都会导致Lua调用紧急函数。当这个函数返回后，应用就会退出。 要正确的处理应用代码中的错误，就必须通过Lua语言调用我们自己的代码，即在setjmp的上下文中运行代码。 我们可以把C代码封装到一个函数F中，然后使用lua_pcall调用这个函数F，通过这种方式，我们的C代码会在保护模式下运行。即便发生内存分配失败，函数lua_pcall也会返回一个对应的错误码，使解释器能够保持一致的状态： static int foo(lua_State *L) { //code to run in protected mode return 0; } int secure_foo(lua_State *L) { lua_pushcfunction(L,foo); return (lua_pcall(L,0,0,0) == 0) } 无论发生什么，调用secure_foo时都会返回一个布尔值，来表示foo执行是否成功。 处理库代码中的错误：当C语言库中的函数检测到错误时，只需简单的调用lua_error即可。 内存分配：Lua语言核心对内存分配不进行任何假设，只会通过一个分配函数来分配和释放内存，当用户创建lua状态时必须提供该函数。 luaL_newstate是一个用默认分配函数来创建Lua状态的辅助函数。该默认分配函数使用了来自C语言标准函数库的标准函数malloc-realloc-free，对于大多数应用程序来说已经够了，但是，要完全控制Lua的内存分配也很容易，使用原始的lua_newstate来创建我们自己的Lua状态即可： lua_State *lua_newstate(lua_Alloc f,void *ud) 该函数有两个参数：一个是分配函数，另一个是用户数据。用这种方式创建的Lua状态会通过调用f完成所有的内存分配和释放，甚至结构lua_State也是由f分配的。 分配函数f必须满足lua_Alloc的类型声明： typedef void *(*lua_Alloc)(void *ud, // 为lua_newstate所提供的用户数据 void *ptr, // 正要被分配或者释放的块的地址 size_t osize, // 原始块的大小 size_t nsize); // 请求的块大小 如果ptr不是NULL，则lua会保证其之前被分配的大小就是osize。 当nsize为0时，分配函数必须释放ptr指向的块并返回NULL，对应于所要求的大小为零的块。当ptr时NULL时，该函数必须分配并返回一个指定大小的块；如果无法分配指定的块，则必须返回NULL。 pcall：在调用函数lua_pcall时，第二个参数表示传递的参数数量，第三个参数是期望的结果数量，第四个参数代表错误处理函数。就像Lua语言的赋值一样，函数lua_pcall会根据所要求的数量来调整返回值的个数，即压入nil或丢弃多余的结果。在压入结果前，lua_pcall会把函数和其参数从栈中移除。当一个函数返回多个结果时，那么第一个结果最后被压入。 在Lua中调用C语言：当Lua调用C函数时，我们必须注册该函数，即必须以一种恰当的方式为Lua提供该C函数的地址。Lua调用C函数时，也使用了一个与C语言调用Lua函数时相同类型的栈，C函数从栈中获取参数，并将结果压入栈中。 这个栈不是一个全局结构；每个函数都有其私有的局部栈。当Lua调用一个C函数时，第一个参数总是位于这个局部栈中索引为1的位置。即使一个C函数调用了Lua代码，而且Lua代码又再次调用了同一个的C函数，这些调用每一个都只会看到本次调用自己的私有栈，其中索引为1的位置上就是第一个参数。 所有在Lua中注册的函数都必须使用一个相同的原型，该原型就是定义在lua.h中的lua_CFunction： typedef int (*lua_CFunction)(lua_State *L) 在Lua中，调用这个函数前，还必须通过lua_pushcfunction注册该函数。函数lua_pushcfunction会获取一个指向C函数的指针，然后在Lua中创建一个“function”类型，代表待注册的函数。一旦完成注册，C函数就可以像其他Lua函数一样行事了。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua源码阅读：基本数据类型Table]]></title>
    <url>%2F2019%2F08%2F12%2FLua%2FLua%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8BTable%2F</url>
    <content type="text"><![CDATA[Lua中Table数据结构的定义、初始化、查找等。 Table数据结构的定义：typedef union TKey { struct { TValuefields; int next; /* for chaining (offset for next node) */ } nk; TValue tvk; } TKey; typedef struct Node { TValue i_val; TKey i_key; } Node; typedef struct Table { CommonHeader; lu_byte flags; /* 1 MAXHBITS) luaG_runerror(L, "table overflow"); size = twoto(lsize); t->node = luaM_newvector(L, size, Node); for (i = 0; i < (int)size; i++) { Node *n = gnode(t, i); gnext(n) = 0; setnilvalue(wgkey(n)); setnilvalue(gval(n)); } } t->lsizenode = cast_byte(lsize); t->lastfree = gnode(t, size); /* all positions are free */ } #define dummynode (&dummynode_) #define isdummy(n) ((n) == dummynode) static const Node dummynode_ = { {NILCONSTANT}, /* value */ {{NILCONSTANT, 0}} /* key */ }; flag设置为全1表示没有元方法，node指向的不是NULL而是dummynode，dummynode是一个全局共享的对象（key和value均为nil），这样做可以减少NULL的判断：例如，刚初始化完table，需要查找一个key为“test”的对象，因为lsizenode为0，所以经过运算确定的位置肯定为node[0]，然后读取node[0].i_key和“test”的TKey进行比较，判断是否相同，node[0]是dummynode，所以比较结果肯定不相同，所以返回nil；如果node[0]为NULL，访问node[0]的时候必须先判断node[0]是否为NULL，否则直接访问会越界，dummynode的设计省去了NULL的判断。 Table的查找：因为table有两部分，数组和hash表，所以查找也分为两部分来进行： 在数组中查找，如果传入的key是integer类型，而且其值-1小于sizearray的话，在数组中查找。 其他情况在hash表中查找：计算出该key的散列值，根据此散列值访问Node数组得到散列桶所在的位置，遍历该散列桶下的所有链表元素，直到找到该key为止。 在Lua中除了nil，其他类型均可以作为表的key，那么table的key是如何与其array数组与hash表的下标对应的呢？ 对于array数组，如果是上述的第一种情况，则直接将key-1即得到了下标，对于hash表则需要将key转换成uint类型，然后通过计算得到下标。 通过运算将各类型转换为uint 类型的值，如将LUA_TNUMFLT 类型二进制数值转成以uint 型类 型表示，将LUA_TTABLE 的gc 指针转换为uint 类型， LUA_TSHRSTR 类型直接取其hash值，因为短字符串在构造时会计算其hash值，LUA_TLNGSTR 类型则需要通过hash函数计算其hash值。在 完成了对key 的hash运算以后，需要根据key 的hash值计算该key对应hash表中的哪个下标，计算的公式是: index = hash_value & ((2^lsizenode) - 1) 其中2^lsizenode - 1 为一个二进制低位全为1 的值，和hash_value 相与可以保证hash_value超过2^lsizenode - 1 的部分为0，则得到的值一定在[0，(2^lsizenode) - 1] 区间内，此时key和hash 表的下标就对应了起来，并且不会越界。 /* ** main search function */ const TValue *luaH_get (Table *t, const TValue *key) { switch (ttype(key)) { case LUA_TSHRSTR: return luaH_getstr(t, tsvalue(key)); case LUA_TNUMINT: return luaH_getint(t, ivalue(key)); case LUA_TNIL: return luaO_nilobject; case LUA_TNUMFLT: { lua_Integer k; if (numisinteger(fltvalue(key), &k)) /* index is int? */ return luaH_getint(t, k); /* use specialized version */ /* else go through */ } default: { Node *n = mainposition(t, key); for (;;) { /* check whether 'key' is somewhere in the chain */ if (luaV_rawequalobj(gkey(n), key)) return gval(n); /* that's it */ else { int nx = gnext(n); if (nx == 0) break; n += nx; } }; return luaO_nilobject; } } } /* ** search function for integers */ const TValue *luaH_getint (Table *t, lua_Integer key) { /* (1 array[key - 1]; else { Node *n = hashint(t, key); for (;;) { /* check whether 'key' is somewhere in the chain */ if (ttisinteger(gkey(n)) && ivalue(gkey(n)) == key) return gval(n); /* that's it */ else { int nx = gnext(n); if (nx == 0) break; n += nx; } }; return luaO_nilobject; } } Table的更新：table 更新也分两种情况: 通过上述查找的 value 如果不是 luaO_nilobject ，直接将 value 更改即可，即table的修改和删除(将值置为nil) 查找返回的是 luaO_nilobject ，即 key 在 table 中不存在时( table 的插入操作)需要先找一个空的槽，然后完成插入操作，如果找不到空槽则需要扩容。 散列表部分的数据组织是，首先计算数据的key所在的桶数组位置，这个位置称为mainposition。相同mainposition的数据以链表形式组织： 这部分的API包括luaH_set、luaH_setnum、luaH_setstr 这三个函数，它们的实际行为并不在其函数内部对 key 所对应的数据进行添加或者修改，而是返回根据该 key 查找到的 TValue 指针，由外部的使用者来进行实际的替换操作。 当找不到对应的 key 时，这几个 API 最终都会调用内部的 newkey 函数分配一个新的 key 来返回。 具体的更新操作如下： 如果查找一个空槽： 在lua Table中有一个lastfree指针，在更新时通过该指针寻找一个空槽，lastfree 指针在最开始的时候指向NULL ，当空间不够rehash 时，lastfree 指针指向 node 数组中最后不可用的空间，如node 数组size为4 其指向的就是4 的位置(从0开始)。当需要找一个空槽时，lastfree指针向左移，判断当前位置有没有被占用，即key 是否为nil ，如果被占用则继续左移，直到找到一个空槽，或者地址大于node 的地址，即移动到了node 的前一个，表示没有找到。这种方式可以保证lastfree的右边和当前指向的位置均不可用或者被占用，可以减少在查找空槽时对非nil元素的遍历。 冲突时谁移动： 记冲突位置为index ，找到的空槽位置为freeindex ，发生冲突位置的key 为oldkey ， 新的key 为newkey 。发生冲突时计算oldkey 的下标，如果值为index ，则将newkey 建立 到freeindex 位置处，如果oldkey 计算后不是index ，而是因为冲突被移动到index 位置的，则移动oldkey 的node到新的槽。 Tkey的Next如何设置： lua 中的Tkey 中添加了一个next 成员，通过next 可以查找冲突位置的所有元素。比如两个元素冲突了，冲突位置为index (下标，后面的freeindex 也是下标)，这两个元素分别 为node1 、node2 ，假设将node1 移动到了另一个位置freeindex ，那么node2 则在index位置，node2 的next 为freeindex 减去index ，当需要查找node1 时，通过hash 运算找到是node2 ，比较发现不是要找的元素，此时可以通过index + next 找到freeindex 的位置，继续比较判断发现是node1 则返回结果。这种方式可以减少查找时对非冲突元素的遍 历，加快查找效率，不过也有弊端就是每个节点占用的空间会增减四个字节。 Table的扩容：rehash操作是hash 表不可避免的，当空间不够时就需要进行扩容，而扩容后每个元素的下标就需要重新计算。对于一般的开放地址法会有一个负载因子 ，当负载因子大于某个值的时候就需要扩容，这个是为了考虑效率问题，当负载因子越来越大的时候，元素之间冲突的可能性会越来越大，导致插入和查找的时间复杂度会增大所以需要扩容降低负载因子。lua 的table没有负载因子，而是当node 的所有空间都用完的时候才会扩容(被置为nil 也算，lastfree指针不会向右移动，而判断满的条件就是lastfree 已经到了第一个元素的位置)。 /* ** nums[i] = number of keys 'k' where 2^(i - 1) < k array[i]); return 1; } } for (i -= t->sizearray; cast_int(i) < sizenode(t); i++) { /* hash part */ if (!ttisnil(gval(gnode(t, i)))) { /* a non-nil value? */ setobj2s(L, key, gkey(gnode(t, i))); setobj2s(L, key+1, gval(gnode(t, i))); return 1; } } return 0; /* no more elements */ } /* 在数组部分查找数据： 查找成功，则返回该 key 的下一个数据 否则在散列桶部分查找数据： 查找成功，则返回该 key 的下一个数据 */ 一开始进入 findindex 函数，返回一个整数索引，如果这个索引在表的 sizearray 之内，则说明落入到数组部分，否则就落入到散列桶部分。 Table 取长度操作：对Lua 中的表进行取长度的操作时，如果没有提供该表的原方法 _len，那么该操作只针对该表的序列部分进行——序列指的是该表的一个子集{1…n}，n是一个正整数，其中每个键对应的数据都不为 nil。 /* ** Try to find a boundary in table 't'. A 'boundary' is an integer index ** such that t[i] is non-nil and t[i+1] is nil (and 0 if t[1] is nil). */ int luaH_getn (Table *t) { unsigned int j = t->sizearray; if (j > 0 && ttisnil(&t->array[j - 1])) { /* there is a boundary in the array part: (binary) search for it */ unsigned int i = 0; while (j - i > 1) { unsigned int m = (i+j)/2; if (ttisnil(&t->array[m - 1])) j = m; else i = m; } return i; } /* else must find a boundary in hash part */ else if (isdummy(t->node)) /* hash part is empty? */ return j; /* that is easy... */ else return unbound_search(t, j); } Table的元表：注意事项： 尽量不要在一个表中混用数组和散列桶部分，即一个表最好只存放一类数据。Lua 的实现上确实提供了两者统一表示的遍历，但这并不意味着使用者就应该混用这两种方式。 尽量不要在表中存放 nil 值，这会让取长度操作的行为不稳定。 尽量避免重新散列操作，因为这个操作的代价极大，通过预分配、只使用数组部分等策略规避这个 Lua 解释器背后的动作，能提升不少效率。 参考： 《lua 设计与实现》codedump 著]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua源码阅读：基本数据类型String]]></title>
    <url>%2F2019%2F08%2F08%2FLua%2FLua%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8BString%2F</url>
    <content type="text"><![CDATA[Lua中对于String的实现。 Lua使用TString结构体代表一个字符串对象。 /* ** Header for string value; string bytes follow the end of this structure ** (aligned according to 'UTString'; see next). */ typedef struct TString { CommonHeader; lu_byte extra; /* reserved words for short strings; "has hash" for longs */ unsigned int hash; size_t len; /* number of characters in string */ struct TString *hnext; /* linked list for hash table */ } TString; /* ** Ensures that address after this type is always fully aligned. */ typedef union UTString { L_Umaxalign dummy; /* ensures maximum alignment for strings 用于最大字节对齐 */ TString tsv; } UTString; hash用来记录字符串对应的哈希值，len用来记录字符串的长度。 在Lua中，分为长字符串和短字符串，长度大于40的是长字符串，小于40的是短字符串，这部分在luaconf.h中定义： /* @@ LUAI_MAXSHORTLEN is the maximum length for short strings, that is, ** strings that are internalized. (Cannot be smaller than reserved words ** or tags for metamethods, as these strings must be internalized; ** #("function") = 8, #("__newindex") = 10.) */ #define LUAI_MAXSHORTLEN 40 对于短字符串，在实际使用中一般用来作为索引或需要进行字符串比较，存放在global_State-&gt;strt中，这个字符串表（strt）是一个stringtable类型的全局唯一的哈希表，当需要创建一个短字符串对象时，会首先在这个表中查找已有对象。所有的短字符串都是全局唯一的，不会存在两个相同的短字符串对象，如果短字符串对象的extra&gt;0，表示这是一个系统保留的字符串；长字符串一般用来存放文本数据，很少需要比较或者索引，所以长字符串被挂接到allgc链表上当作普通的对象来处理。 /* ** new string (with explicit length) 生成新字符串的函数 */ TString *luaS_newlstr (lua_State *L, const char *str, size_t l) { if (l (MAX_SIZE - sizeof(TString))/sizeof(char)) luaM_toobig(L); return createstrobj(L, str, l, LUA_TLNGSTR, G(L)->seed); } } /* 在global_State中存储的哈希表结构体 */ typedef struct stringtable { TString **hash; int nuse; /* number of elements 已装元素的个数 */ int size; /* 实际hash桶的大小 */ } stringtable; 对于短字符串，在创建的时候，首先计算str的哈希值。计算时会得到一个随机种子，这个种子就是global_State-&gt;seed，然后通过LUAI_HASHLIMIT控制步长，每一个步长范围内取字符串中的一个字符，和上次hash的结果相加，得到新的hash结果，计算出hash后，开始找是否存在这个字符串，方法是遍历global_State-&gt;strt-&gt;hash，短字符串表申请内存的大小和实际使用大小由后两个字段表示。 /* ** checks whether short string exists and reuses it or creates a new one ** 检查短字符串的存在性，根据结果重用已存在的字符串或创建一个新的字符串 */ static TString *internshrstr (lua_State *L, const char *str, size_t l) { TString *ts; global_State *g = G(L); unsigned int h = luaS_hash(str, l, g->seed); TString **list = &g->strt.hash[lmod(h, g->strt.size)]; for (ts = *list; ts != NULL; ts = ts->hnext) { if (l == ts->len && (memcmp(str, getstr(ts), l * sizeof(char)) == 0)) { /* found! */ if (isdead(g, ts)) /* dead (but not collected yet)? */ changewhite(ts); /* resurrect it */ return ts; } } if (g->strt.nuse >= g->strt.size && g->strt.size strt.size * 2); list = &g->strt.hash[lmod(h, g->strt.size)]; /* recompute with new size */ } ts = createstrobj(L, str, l, LUA_TSHRSTR, h); ts->hnext = *list; *list = ts; g->strt.nuse++; return ts; } /* 对字符串按步长hash的函数 */ unsigned int luaS_hash (const char *str, size_t l, unsigned int seed) { unsigned int h = seed ^ cast(unsigned int, l); size_t l1; size_t step = (l >> LUAI_HASHLIMIT) + 1; for (l1 = l; l1 >= step; l1 -= step) h = h ^ ((h2) + cast_byte(str[l1 - 1])); return h; }]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua中的垃圾回收机制]]></title>
    <url>%2F2019%2F08%2F07%2FLua%2FLua%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Lua中的垃圾回收机制：弱引用表，析构器和函数collectgarbage 垃圾收集：Lua语言使用自动内存管理，程序可以创建对象（表，闭包等），但却没有函数来删除对象。Lua语言通过垃圾收集自动的删除成为垃圾的对象。 弱引用表，析构器和函数collectgarbage是在Lua语言中用来辅助垃圾收集器的主要机制。弱引用表允许收集Lua语言中还可以被程序访问的对象；析构器允许收集不在垃圾收集器直接控制下的外部对象；函数collectgarbage则允许我们控制垃圾收集器的步长。 弱引用表：垃圾收集器不能猜测我们认为哪些是垃圾，程序不会再用到的、存储在全局变量中的对象，对于Lua语言来说不是垃圾，需要我们的代码将这些对象所在的位置赋为nil，以便这些位置不会锁定可释放的对象。 简单的清除引用并不够，有些情况下，还需要程序和垃圾收集器之间的协作——当我们要保存某种类型的活跃对象的列表时，只需要将新对象插入数组即可；但是，一旦一个对象成为了数组的一部分，即使没有其他任何地方在引用它，但数组依然在引用它，无法被回收。 弱引用表就是这样一种用来告知Lua语言一个引用不应阻止对一个对象回收的的机制。 所谓弱引用是一种不在垃圾收集器考虑范围内的对象引用。如果对一个对象的所有引用都是弱引用，那么垃圾收集器将会回收这个对象并删除这些弱引用。Lua通过弱引用表来实现弱引用，弱引用表就是元素均为弱引用的表，这意味着如果一个对象只被一个弱引用表持有，那么Lua语言最终会回收这个对象。 表由键值对组成，其两者都可以容纳任意类型的对象。在正常情况下，垃圾收集器不会回收一个在可访问表中作为键和值的对象。也就是说，键和值都是强引用，他们会阻止对其所指向对象的回收。在一个弱引用表中，键和值都可以是弱引用的。这就意味着有三种类型的弱引用表：具有弱引用键的表、具有弱引用值的表及同时具有弱引用键和值的表。不论是哪种类型的弱引用表，只要有一个键或值被回收了，那么对应的整个键值对都会被从表中删除。 一个表是否为弱引用表是由其元表中的__mode字段所决定的。当这个字段存在时，其值应为一个字符串：如果这个字符串是”k”，则说明这个表的键（key）是弱引用的，如果这个字符串是”v”，那么这个表的值是弱引用的；如果这个字符串是“kv”，那么这个表的键和值都是弱引用的。 只有对象可以从弱引用表中被移除，而像数字和布尔这样的“值”是不可回收的。 析构器：析构器是一个与对象关联的函数，当该对象即将被回收时该函数会被调用。 Lua语言通过元方法__gc实现析构器： o = {x = "hi"} setmetatable(o,{__gc = function(o) print(o.x) end}) o = nil collectgarbage() --> hi 通过给对象设置一个具有非空__gc元方法的元表，就可以将一个对象标记为需要进行析构处理，如果不标记对象，那么对象就不会被析构。 当垃圾收集器在同一个周期中析构多个对象时，它会按照对象被标记为需要析构处理的顺序逆序调用这些对象的析构器。 析构器的另一个特点是复苏：当一个析构器被调用时，它的参数是正在被析构的对象。因此，这个对象会至少在析构期间重新变成活跃的，这叫做“临时复苏”；在析构器执行期间，我们无法阻止析构器把该对象存储在全局变量中，使得该对象在析构器返回后仍然可访问，这称为“永久复苏”。 由于复苏的存在，Lua语言会在两个阶段中回收具有析构器的对象。当垃圾收集器首次发现某个具有析构器的对象不可达的时候，垃圾收集器就把这个对象复苏，并将其放入等待被析构的队列中。一旦析构器开始执行，Lua语言就将该对象标记为已被析构，当下一次垃圾收集器又发现这个对象不可达时，它就将这个对象删除。 如果想保证我们程序中的所有垃圾都被真正的释放了的话，那么必须调用collectgarbage两次，第二次调用才会删除第一次调用中被析构的对象。 由于Lua语言在被析构对象上设置的标记，每一个对象的析构器都会精确的运行一次，如果一个对象直到程序运行结束还没有被回收，那么Lua语言就会在整个Lua虚拟机关闭后调用它的析构器。 另一个有趣的技巧会允许程序在每次完成垃圾回收后调用指定的函数。由于析构器只运行一次，所以这种技巧是让每个析构器创建一个用来运行下一个析构器的新对象。 具有析构器的对象和弱引用表之间的交互也有些微妙：在每个垃圾收集周期内，垃圾收集器会在调用析构器前清理弱引用表的值，在调用析构器之后再清理键。这种行为的原理在于我们经常使用带有弱引用键来保存对象的属性，因此，析构器可能需要访问那些属性。不过，我们也会使用具有弱引用值的表来重用活跃的对象，在这种情况下，正在被析构的对象就不再有用了。 垃圾收集器：一直到Lua5.0，Lua语言使用的都是一个简单的标记-清除式垃圾收集器，这种收集器又被称为全局暂停式的收集器，意味着Lua语言会时不时地停止主程序的运行来执行一次完整的垃圾收集周期。每一个垃圾收集周期由四个阶段组成：标记、清理、清除和析构。 标记阶段：把根结点集合（由Lua语言可以直接访问的对象组成）标记为活跃。在Lua语言中，这个集合只包括C注册表。保存在一个活跃对象中的对象是程序可达的，因此也会被标记为活跃（弱引用表中的内容除外），当所有可达对象都被标记为活跃后，标记阶段完成。 清理阶段：首先，Lua语言遍历所有被标记为需要进行析构、但又没有被标记为活跃状态的对象。这些没有被标记为活跃状态的对象会被标记为活跃（复苏），并被放在一个单独的列表中，这个列表会在析构阶段用到。然后，Lua语言遍历弱引用表并从中移除键或值未被标记的元素。 清除阶段：遍历所有对象（Lua 语言把所有创建的对象放在一个链表中），如果一个对象没有被标记为活跃，Lua语言就将其回收。否则，Lua语言清理标记，然后准备进行下一个清理周期。 析构阶段：Lua语言调用清理阶段被分离出的对象的析构器。 Lua5.1使用了增量式垃圾收集器。这种垃圾收集器像老版的垃圾收集器一样执行相同的步骤，但是不需要在垃圾收集期间停止主程序的运行：它与解释器一起交替运行，每当解释器分配了一定数量的内存时，垃圾收集器也执行一小步。 Lua5.2引入了紧急垃圾收集，当内存分配失败时，Lua语言会强制进行一次完整的垃圾收集，然后再次尝试分配。这些紧急情况可以发生在Lua语言进行内存分配的任意时刻，包括Lua语言处于不一致的代码执行状态时，因此，这些收集动作不能运行析构器。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua源码阅读：C API]]></title>
    <url>%2F2019%2F08%2F06%2FLua%2FLua%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%9AC%20API%2F</url>
    <content type="text"><![CDATA[Lua中关于C API的内容。 Iapi.cindex2addr：static TValue *index2addr (lua_State *L, int idx) { CallInfo *ci = L->ci; if (idx > 0) { TValue *o = ci->func + idx; api_check(idx top - (ci->func + 1), "unacceptable index"); if (o >= L->top) return NONVALIDVALUE; else return o; } else if (!ispseudo(idx)) { /* negative index */ api_check(idx != 0 && -idx top - (ci->func + 1), "invalid index"); return L->top + idx; } else if (idx == LUA_REGISTRYINDEX) return &G(L)->l_registry; else { /* upvalues */ idx = LUA_REGISTRYINDEX - idx; api_check(idx func)) /* light C function? */ return NONVALIDVALUE; /* it has no upvalues */ else { CClosure *func = clCvalue(ci->func); return (idx nupvalues) ? &func->upvalue[idx-1] : NONVALIDVALUE; } } } 这个index2addr函数的作用就是通过给定的 index 参数取出对应的TValue类型的对象指针。 情况 执行 当 index &gt; 0 时 在当前function的栈空间找对应的TValue 当 LUA_REGISTRYINDEX &lt; index &lt;= 0 时 在当前function的栈空间逆向找对应的TValue 当LUA_REGISTRYINDEX == index 时 返回registry（注册表） 否则当 LUA_REGISTRYINDEX &gt; index 时 查找upvalues]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua源码阅读：标准库]]></title>
    <url>%2F2019%2F08%2F06%2FLua%2FLua%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%9A%E6%A0%87%E5%87%86%E5%BA%93%2F</url>
    <content type="text"><![CDATA[Lua标准库中定义的一些函数及其实现方式。 lmathlib.c从一个简单的math.Abs()函数开始： static int math_abs (lua_State *L) { if (lua_isinteger(L, 1)) { lua_Integer n = lua_tointeger(L, 1); if (n < 0) n = (lua_Integer)(0u - n); lua_pushinteger(L, n); } else lua_pushnumber(L, l_mathop(fabs)(luaL_checknumber(L, 1))); return 1; } 首先，先检查传入的值是否是int类型，这里调用了lapi.c中的lua_isinteger函数，检查传入值的TValue原始类型标签是否是LUA_TNUMINT，这部分的检查在lObject.h中定义的函数完成，同时数据类型LUA_TNUMINT也在lObject.h中定义： /* Variant tags for numbers */ #define LUA_TNUMFLT (LUA_TNUMBER | (0 < 4)) /* float numbers */ #define LUA_TNUMINT (LUA_TNUMBER | (1 < 4)) /* integer numbers */ // lObject.h]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua源码阅读：目录及模块结构]]></title>
    <url>%2F2019%2F08%2F05%2FLua%2FLua%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%9A%E7%9B%AE%E5%BD%95%E5%8F%8A%E6%A8%A1%E5%9D%97%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[Lua源码阅读的第一期，主要内容：系列内容计划以及目录。 Lua源码阅读：本篇转载于LuaSource 目录 第一篇：目录及模块结构 第二篇：基本数据类型 第三篇：实用函数 第四篇：标准库 第五篇：C API lua.cint main (int argc, char **argv) { int status, result; lua_State *L = luaL_newstate(); /* create state */ if (L == NULL) { l_message(argv[0], "cannot create state: not enough memory"); return EXIT_FAILURE; } lua_pushcfunction(L, &pmain); /* to call 'pmain' in protected mode */ lua_pushinteger(L, argc); /* 1st argument */ lua_pushlightuserdata(L, argv); /* 2nd argument */ status = lua_pcall(L, 2, 1, 0); /* do the call */ result = lua_toboolean(L, -1); /* get result */ report(L, status); lua_close(L); return (result && status == LUA_OK) ? EXIT_SUCCESS : EXIT_FAILURE; } 模块结构Lua代码的模块概要介绍如下： 以下模块实现了一些实用函数： ldebug.c - 调试接口，包含功能有：访问调试钩子（lua_sethook、lua_gethook、lua_gethookcount）；访问运行时栈（lua_getstack、lua_getlocal、lua_setlocal）；检测字节码（luaG_checkopenop、luaG_checkcode）；抛出错误（luaG_typeerror、luaG_concaterror、luaG_aritherror、luaG_ordererror、luaG_errormsg、luaG_runerror） lzio.c - 通用的输入流接口 lmem.c - 内存管理接口。实现了luaM_realloc / luaM_growaux_ 两个函数，其中封装了内存分配函数 lgc.c - 增量的垃圾回收器 以下模块实现了基本的数据类型： lstate.c - 全局状态。包括打开、关闭Lua状态机（lua_newstate / lua_close）和线程（luaE_newthread / luaE_freethread）。 lobject.c - 一些操作Lua Object的通用函数。包括一些数据类型到字符串的互转函数，原生类型的相等性测试（luaO_rawequalObj），和以2为底的对数函数（luaO_log2） lstring.c - 字符串哈希表（管理了所有被Lua用到的字符串） lfunc.c - 一些用于操作函数原型(Proto）和闭包（Closure）的辅助函数 ltable.c - Lua的table实现 以下模块做语法解析和代码生成： lcode.c - 代码生成器，被lparser.c用到 llex.c - 词法分析器，被lparser.c用到 lparser.c - Lua语法解析器 lundump.c - 加载预编译的Lua代码块。实现了luaU_undump函数，此函数加载预编译的代码块。还提供了另外一个函数lua_header（被luaU_undump内部使用），用于加载代码块中的函数头信息。 ldump.c - 保存预编译的Lua代码块。实现了luaU_dump函数，些函数导出Lua函数为二进制形式的字符串 以下模块处理Lua字节码的执行： lopcodes.c - 定义Lua虚拟机的操作码。定义了所有操作码的名字和操作模式等信息（通过列表luaP_opnames、luaP_opmodes定义的） lvm.c - Lua虚拟机（luaV_execute），可执行Lua字节码。另外还暴露了一些被lapi.c用到的函数，比如：luaV_concat ldo.c - 函数调用栈。处理函数调用（luaD_call、luaD_pcall），栈空间增长，协程等 ltm.c - 元方法。实现从对象访问元方法的一些函数 以下模块实现标准库： lbaselib.c - 基础函数 lstrlib.c - 字符串函数 ltablib.c - 表函数 lmathlib.c - 数学函数 loslib.c - 系统函数 liolib.c - 输入输出、文件读写 loadlib.c - 包、模块 ldblib.c - 调试函数 以下模块定义了C API： lapi.c - Lua API。实现了大部分Lua C API（lua_* 系列函数） lauxlib.c - 定义了luaL_*系列函数 linit.c - 实现luaL_openlibs，这个函数中加载了所有的标准库函数 以下模块实现Lua和Luac两个程序： lua.c - Lua的独立解释器 print.c - 定义了“PrintFunction”函数，它可以打印出一个函数的字节码（可在Luac中使用 -l 选项） luac.c - Lua编译器（可保存字节码到文件中，也可在控制台列出字节码） 命名约定一个函数的前缀表明了它来自哪个模块 luaA_ - lapi.c luaB_ - lbaselib.c luaC_ - lgc.c luaD_ - ldo.c luaE_ - lstate.c luaF_ - lfunc.c luaG_ - ldebug.c luaH_ - ltable.c luaI_ - lauxlib.c luaK_ - lcode.c luaL_ - llauxlib.c/h linit.c luaM_ - lmem.c luaO_ - lobject.c luaP_ - lopcodes.c luaS_ - lstring.c luaT_ - ltm.c luaU_ - lundump.c luaV_ - lvm.c luaX_ - llex.c luaY_ - lparser.c luaZ_ - lzio.c lua_ - lapi.c/h + luaconfig.h, ldebug.c luai_ - luaconf.h luaopen_ - luaconf.h + libraries (lbaselib.c, ldblib.c, liolib.c, lmathlib.c, loadlib.c, loslib.c, lstrlib.c, ltablib.c) 参考： Lua源码阅读笔记 Lua有关的论文和The Lua Architecture从各个方面论述了Lua的实现 Lua VM指令在文档A No-Frills Introduction to Lua 5.1 VM Instructions中 Yueliang项目（用Lua实现Lua VM），其中的大量的源码注释，可以帮助理解相关的C代码 LuaAnnotate - C代码注释，注释单独存放在外部文件中，用某些文本工具可以将注释嵌入显示在代码中 stevedonovan.github.com/lua-5.1.4 包含LuaAnnotate注释的源码 可在http://www.lua.org/source/网站上浏览Lua源码]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[����ʼ�]]></title>
    <url>%2F2019%2F07%2F29%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%2FRayTracing-In-Weekend-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[����RayTracing In A Weekendһ���ʵ��ϸ�ڡ� Chapter1��Output an Image����һ��ppm�����������ص���XnView�� ��һ����������Ĵ��벢�������������õ�PPM��ʽ���ļ��Ļ�����Ҫ�ڴ��������д��txt�ļ��Ĵ��룺 #include "pch.h" #include #include using namespace std; int main() { int nx = 200; int ny = 100; ofstream outfile(".\\result\\FirstPicture.txt", ios_base::out); outfile < "P3\n" < nx < " " < ny < "\n255\n"; for (int j = ny - 1; j >= 0; j--) { for (int i = 0; i < nx; i++) { float r = float(i) / float(nx); float g = float(j) / float(ny); float b = 0.2; int ir = int(255.99*r); int ig = int(255.99*g); int ib = int(255.99*b); outfile < ir < " " < ig < " " < ib < "\n"; std::cout < ir < " " < ig < " " < ib < "\n"; } } return 0; }]]></content>
      <categories>
        <category>�����ͼ��ѧ</category>
      </categories>
      <tags>
        <tag>�����ͼ��ѧ</tag>
        <tag>����׷��</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua迭代器和范型for]]></title>
    <url>%2F2019%2F07%2F05%2FLua%2FLua%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E8%8C%83%E5%9E%8Bfor%2F</url>
    <content type="text"><![CDATA[关于Lua中的迭代器：ipairs与pairs。 迭代器和泛型for：迭代器和闭包：所有的迭代器都需要在连续的调用之间保存一些状态，这样才能知道当前迭代所处的位置及如何从当前位置步进到下一位置。对于我们自己的迭代器而言，闭包为保存状态提供了一种良好的机制。一个闭包就是一个可以访问其自身的环境中一个或多个局部变量的函数。这些变量将连续调用过程中的值并将其保存在闭包中，从而使得闭包能够记住迭代所处的位置。当然，要创建一个新的闭包，我们还需要创建非局部变量。因此，一个闭包结构通常涉及两个函数：闭包本身和一个用于创建该闭包及其封装变量的工厂。 泛型for：泛型for在循环过程中在其内部保存了迭代函数，泛型for保存了三个值：一个迭代函数、一个不可变状态和一个控制变量。 语法如下： for var-list in exp-list do body end 其中，var-list是由一个或多个变量名组成的列表，以逗号分隔；exp-list是一个或多个表达式组成的列表，同样以逗号分隔。通常，表达式列表只有一个元素，即一句对迭代器工厂的调用。 for k,v in pairs(t) do print(k,v) end 我们把变量列表的第一个变量称为控制变量，其值在循环过程中永远不会为nil，因为当其值为nil时循环就结束了。 for做的第一件事情是对in后面的表达式求值。这些表达式应该返回三个值供for保存：迭代函数、不可变状态和控制变量的初始值。类似于多重赋值，只有最后一个白哦大事能够产生不止一个值；表达式列表的结果只会保留三个，多余的值会被丢弃，不足三个则以nil补齐。 在上述的初始化步骤完成后，for使用不可变状态和控制变量为参数来调用迭代函数，从for代码结构的立足点来看，不可变状态根本没有意义，for只是把从初始化步骤得到的状态值传递给所有迭代函数，然后，for将迭代函数的返回值赋给变量列表中声明的变量。如果第一个返回值为nil，那么循环终止；否则，for执行它的循环体并再次调用迭代函数，再不断的重复这个过程。 两种语法等价： for var_1,...,var_n in explist do block end 等价于： do local _f,_s,_var = explist while true do local var_1,...,var_n = _f(_s,_var) _var = var_1 if _var == nil then break end block end end 假设迭代函数是f，不可变状态为s，控制变量的初始值为a0，那么在循环中控制变量的值依次为a1=f(s,a0),a2=f(s,a1)，直到ai为nil。如果for还有其他变量，那么这些变量只是简单的在每次调用f后得到额外的返回值。 无状态迭代器：无状态迭代器就是一种自身不保存任何状态的迭代器，因此，可以在多个循环中使用同一个无状态迭代器，从而避免创建新闭包的开销。 for循环会以不可变状态和控制变量为参数调用迭代函数，一个无状态迭代器之需要这两个值来为迭代生成下一个元素： a = {"One","Two","Three"} for i,v in ipairs(a) do print(i,v) end ipairs和迭代器都非常简单： local function iter(t,i) i = i + 1 local v = t[i] if v then return i,v end end function ipairs(t) return iter,t,0 end 当调用for循环中的ipairs(t)时，ipairs(t)会返回三个值，即迭代函数iter，不可变状态表t和控制变量的初始值0。 然后Lua语言调用iter(t,0)，得到1，t[1]（除非t[1]已经变成了nil）。在第二次迭代中，Lua语言调用iter(t,1)，得到2，t[2]，依次类推，直至得到第一个为nil的元素。 函数pairs和函数ipairs类似，也用于遍历一个表中的所有元素，不同的是，函数pairs的迭代函数是Lua语言中的一个基本函数next： function pairs(t) return next,t,nil end 在调用next(t,k)时，k是表t的一个键，该函数会以随机次序返回表中的下一个键以及k对应的值，调用next(t,nil)时，返回表中的第一个键值对。当所有的元素遍历完时，函数next返回nil。 区别： pairs：用于迭代table，可以遍历表中所有的key，可以返回nil ipairs: 迭代数组，不能返回 nil,如果遇到 nil 则退出]]></content>
      <categories>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua模块与包]]></title>
    <url>%2F2019%2F07%2F04%2FLua%2FLua%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85%2F</url>
    <content type="text"><![CDATA[Lua中的模块和包。 一个模块就是一些代码，这些代码可以通过函数require加载，然后创建和返回一个表。这个表就像是某种命名空间，其中定义的内容是模块中导出的东西，比如函数和常量。 函数require：函数require尝试对模块的定义做最小的假设。对于该函数来说，一个模块可以是定义了一些变量的（比如函数或者包含函数的表）的代码。 require的加载机制首先，函数require在表package.loaded中检查模块是否已被加载，如果模块已经被加载，函数require就返回相应的值，因此，一旦一个模块被加载过，后续的对于同一模块的所有require调用都将返回同一个值，而不会再运行任何代码。 如果模块尚未加载，那么函数require则搜索具有指定模块名的Lua文件（搜索路径由变量package.path指定）。如果函数require找到了相应的文件，那么就用函数loadfile将其进行加载，结果是一个我们称之为加载器的函数。 如果函数require找不到指定模块名的Lua文件，那么它就搜索相应名称的C标准库。如果找到了一个C标准库，则使用底层函数package.loadlib进行加载，这个底层函数会查找名为luaopen_modname的函数。在这种情况下，加载函数就是loadlib的执行结果，也就是一个被表示为Lua函数的C语言函数。 为了最终加载模块，函数require带着两个参数调用加载函数：模块名和加载函数所在的文件的名称。如果加载函数有返回值，那么函数require会返回这个值，然后将其保存在表package.loaded中，以便于将来在加载统一模块时返回相同的值。如果加载函数没有返回值且表中的package.loaded[@rep{modname}]为空，函数require就假设模块的返回值为true。如果没有这种补偿，那么后续调用函数require时将会重复加载模块。 编写模块的基本方法在Lua语言中创建一个表，并将所有需要导出的函数放入其中，最后返回这个表。 另一种编写模块的方法是把所有的函数定义为局部变量，然后在最后构造返回的表。 字模块和包Lua支持具有层次结构的模块名，通过点来分隔名称中的层次，例如一个名为mod.sub的模块是模块mod的一个子模块。一个包（package）是一棵由模块组成的完整的树，它是Lua语言用于发行程序的单位。]]></content>
      <categories>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Unity] 不同设备屏幕适配问题]]></title>
    <url>%2F2019%2F04%2F24%2FUnity%E7%AC%94%E8%AE%B0%2FUnity-%E4%B8%8D%E5%90%8C%E8%AE%BE%E5%A4%87%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[面试问到了，不同设备屏幕适配问题。]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Unity] 在Unity中纹理图该是什么格式？]]></title>
    <url>%2F2019%2F04%2F17%2FUnity%E7%AC%94%E8%AE%B0%2FUnity-%E5%9C%A8Unity%E4%B8%AD%E7%BA%B9%E7%90%86%E5%9B%BE%E8%AF%A5%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%BC%E5%BC%8F%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[一个在Windows下的png格式图，在Unity中存储为什么格式？ Unity下的资源导入问题：Unity会把我们放进去的外部资源转换成一种Unity内部格式的资源，这个过程就是资源导入。 比如说在Windows下显示为png格式的图片，在Unity内部会根据平台的不同而设置成不同的压缩格式。 可以使用AssetPostProcessor来对导入的资源进行规定化。 AssetPostProcessor是一个编辑器类，用来管理资源导入，当资源导入之前和之后都会发送通知，可以根据不同的资源类型，在导入之前和之后做不同的处理，来修改Unity内部资源格式。 由于这是一个编辑器类，在UnityEditor命名空间下，所以在使用C#脚本时，需要在脚本前加上using UnityEditor引用，且放在工程目录下的Asset/Editor文件夹下。一般我们通过修改这个类中OnPreprocessxxx和OnPostprocessxxx函数来修改资源数据和设置。这两者的区别可以简单理解为：前者用来Inspector视图可见的选项，后者为不可见的。 下面的脚本可以自动设置不同文件夹下贴图的压缩格式以及大小： using UnityEditor; using UnityEngine; public class Script_12_02 : AssetPostprocessor { void OnPreprocessTexture() { TextureImporter textureImporter = (TextureImporter)assetImporter; if(textureImporter.assetPath.Contains("UI")) { textureImporter.textureType = TextureImporterType.Sprite; textureImporter.mipmapEnabled = false; // 设置UI贴图在三个平台下的压缩格式以及大小 textureImporter.SetPlatformTextureSettings("Standalone",2048,TextureImporterFormat.RGBA32); textureImporter.SetPlatformTextureSettings("iPhone",2048,TextureImporterFormat.RGBA32,100,true); textureImporter.SetPlatformTextureSettings("Android",2048,TextureImporterFormat.RGBA32,true); } else if(textureImporter.assetPath.Contains("Texture")) { textureImporter.textureType = TextureImporterType.Default; textureImporter.mipmapEnabled = true; // 设置模型贴图在三个平台下的压缩格式以及大小 textureImporter.SetPlatformTextureSettings("Standalone",2048,TextureImporterFormat.DXT5); textureImporter.SetPlatformTextureSettings("iPhone",2048,TextureImporterFormat.ASTC_RGBA_4x4,100,true); textureImporter.SetPlatformTextureSettings("Android",2048,TextureImporterFormat.ETC_RGB4,true); } } } 拓展阅读：为什么要进行纹理压缩：http://www.newhappy.com.cn/?p=907 那么纹理有哪些压缩格式呢？桌面平台： RGB Compressed DXT1 压缩的RGB纹理。这是最常见的漫反射纹理格式。4位/像素（32 KB 256x256） RGBA Compressed DXT5 压缩的RGBA纹理。这是漫反射和高光控制纹理的主要格式。1 字节/像素（64 KB 256x256） RGB 16 bit 65万颜色不带alpha。压缩的DXT格式使用较少的内存，通常会更好看。（128 KB 256x256） RGB 24 bit 真彩色不带alpha。（192 KB 256x256） Alpha 8 bit 高质量alpha通道，不带颜色。（64 KB 256x256） RGBA 16 bit 低质量真彩色。有16级红，绿，蓝和alpha。压缩的DXT5格式使用较少的内存，通常会更好看。（128 KB 256x256） RGBA 32 bit 高质量真彩色带alpha（256 KB 256x256），这个文件很大。大多数情况下 DXT5提供足够的质量，文件大小要小得多。这个主要用于法线贴图，DXT压缩往往带有一个可见的质量损失。 Android： RGB Compressed DXT1 压缩的RGB纹理。支持Nvidia Tegra。4位/像素（32 KB 256x256） RGBA Compressed DXT5 压缩的RGBA纹理。支持Nvidia Tegra。6位/像素（64 KB 256x256） RGB Compressed ETC 4 bits 压缩的RGB纹理。这是Android工程默认的纹理格式。 ETC1是OpenGL ES 2.0标准的一部分，并且支持所有的OpenGL ES 2.0 GPU，但它不支持Alpha。4位/像素（32 KB 256x256） RGB Compressed PVRTC 2 bits 压缩的RGB纹理。 支持Imagination PowerVR GPU。2位/像素（16 KB 256x256） RGBA Compressed PVRTC 2 bits 压缩的RGBA纹理。支持Imagination PowerVR GPU。2位/像素（16 KB 256x256） RGB Compressed PVRTC 4 bits 压缩的RGB纹理。 支持Imagination PowerVR GPU。4位/像素（32 KB 256x256） RGBA Compressed PVRTC 4 bits 压缩的RGBA纹理。 支持Imagination PowerVR GPU。4位/像素（32 KB 256x256） RGB Compressed ATC 4 bits 压缩的RGB纹理。 支持Qualcomm Snapdragon。4位/像素（32 KB 256x256） RGBA Compressed ATC 8 bits 压缩的RGB纹理。 支持Qualcomm Snapdragon。6位/像素（64 KB 256x256） RGB 16 bit 65万颜色不带alpha。比压缩的格式使用更多的内存，但更适用于UI或不带渐变的明快的纹理。128 KB 256x256 RGB 24 bit 真彩色不带alpha。（192 KB 256x256） Alpha 8 bit 高质量alpha通道，不带颜色。（64 KB 256x256） RGBA 16 bit 低质量真彩色。默认压缩的纹理带有alpha通道（128 KB 256x256） RGBA 32 bit 真彩色带alpha - 这是高质量压缩的纹理带有alpha通道。（256 KB 256x256） IOS： RGB Compressed PVRTC 4 bits PVRTC 4位，压缩的RGB纹理。这是最常见的漫反射纹理格式。4位/像素（32 KB 256x256） RGBA Compressed PVRTC 4 bits 压缩的RGBA纹理。这是漫反射和高光控制纹理的主要格式。4 位/像素（32 KB 256x256） RGB Compressed PVRTC 2 bits压缩的RGB纹理。 低质量格式，适用于漫反射纹理。2 位/像素（16 KB 256x256） RGBA Compressed PVRTC 2 bits 压缩的RGBA纹理。 低质量格式，适用于漫反射纹理和高光控制纹理。2 位/像素（16 KB 256x256） RGB Compressed DXT1 压缩的RGB纹理。 在iOS不支持此格式，但为桌面项目保持向后兼容性。 RGBA Compressed DXT5 压缩的RGBA纹理。在iOS不支持此格式，但为桌面项目保持向后兼容性。 RGB 16 bit 65万颜色不带alpha。比PVRTC格式使用更多的内存，但更适用于UI或不带渐变的明快的纹理。128 KB 256x256 RGB 24 bit 真彩色不带alpha。（192 KB 256x256） Alpha 8 bit 高质量alpha通道，不带颜色。（64 KB 256x256） RGBA 16 bit 低质量真彩色。具有16级的红、绿、蓝和alpha。比PVRTC格式使用更多的内存，但如果需要精确的alpha通道，会更方便。（128 KB 256x256） RGBA 32 bit 真彩色带alpha - 这是最高质量。256KB 256x256，这个是很消耗性能的。大多数情况下，PVRTC格式提供足够的质量，但有更小的文件大小。 (图片来自：喵小逗@UWA问答社区) 几种主要的压缩格式介绍：高清晰无压缩 - RGBA32RGBA32等同于原图了，优点是清晰、与原图一致，缺点是内存占用十分大；对于一些美术要求最好清晰度的图片，是首选。 要注意一些png图片，在硬盘中占用几KB，怎么在Unity中显示却变大？因为Unity显示的是Texture大小，是实际运行时占用内存的大小，而png却是一种压缩显示格式；可以这样理解，png类似于zip格式，是一个压缩文件，只不过在运行时会自动解压解析罢了。 中清晰中压缩 - RGBA16 + DitheringUnity RGBA16，不抖动处理的渐变图片惨不忍睹 既然叫RGBA16，自然就是RGBA32的阉割版。对于一些采用渐变的图片，从RGBA32转换成RGBA16，能明显的看出颜色的层叠变化。 采用Floyd Steinberg抖动处理后，除非放大，否则肉眼基本看不出区别 RGBA16的优点，内存占用是RGBA32的1/2；搭配上Dithering抖动，在原尺寸下看清晰度一模一样； 缺点，Unity原生不支持Dithering抖动，需要自己做工具对图片做处理；对于需要放大、拉伸的图片，Dithering抖动的支持不好，会有非常明显的颗粒感。 RGB16而RGB16，是主要针对一些，不带透明通道，同时长宽又不是2的次方的图片；对于这些图片，使用RGB16可以降低一半的内存，但是效果会略逊于RGB32。 当然了，RGB16其实也是可以搭配抖动，也能提升显示效果；但同样的Dithering抖动对拉伸放大是不友好的。 低清晰高压缩 - ETC1+Alpha/PVRTC4很多初学者都会疑惑，为什么游戏开发中经常看到一些图片，需要设置成2的次方？因为像ETC1、PVRTC4等这类在内存中无需解压、直接被GPU支持的格式，占用内存极低，而且性能效率也是最好的。 但是，相对RGBA32，还是能肉眼看出质量有所下降的。 ETC1 ETC1+Alpha一般应用在Android版的UI图集中，ETC1不带透明通道，所以需要外挂一张同样是ETC1格式的Alpha通道图。方法是，在原RGBA32的原图中，提取RGB生成第一张ETC1，再提取A通道，填充另一张ETC1的R通道；游戏运行时，Shader将两张ETC1图片进行混合。 PVRTC4 PVRTC4在Unity中是直接支持的，不过要注意的细节是，它必须是二次方正方形；也就是说，长宽在二次方的同时，还必须要相等。 在项目中，尽可能是使用ETC1和PVRTV4等GPU直接支持的图片格式，不仅内存占用低、性能也更好；当出现质量不及格时，再逐步的提升压缩格式，来满足需要。 参考： Unity运用导入器规范资源格式和设置 Unity3D 图片纹理格式(作者：JumboWu) 干货：Unity游戏开发图片纹理压缩方案]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Unity] 生命周期相关]]></title>
    <url>%2F2019%2F04%2F17%2FUnity%E7%AC%94%E8%AE%B0%2FUnity-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[生命周期相关。 脚本的生命周期：Unity脚本有一套完整的生命周期，脚本需要挂在任意游戏对象上，并且同一个游戏对象可以挂不同的脚本，各脚本执行自己的生命周期，它们可以互相组合并且互不干预。生命周期中的所有方法都是Unity系统自己回调的，不需要手动调用，主要有编辑脚本、初始化、物理碰撞事件、更新回调、渲染和销毁等。学习脚本的生命周期之前，我们不得不引用文档中非常经典的一张图，它完整的描述了脚本的生命周期： 第一个场景加载：这些函数将在场景开始加载时调用。(场景中的每个物体仅调用一次) Awake：这个方法总是在在任何开始方法之前调用(可以理解成最先调用吧？)，并且在一个prefab刚被实例化后就调用。(如果一个游戏物体在开始时是不活跃的(inactive)则将不会调用awake函数，直到其变为活跃。) OnEnable：(仅在物体为活跃(active)状态调用)：这个函数仅在一个物体变为有效(enabled)后调用。这通常发生在一个MonoBehavior实例创建时，例如在一个场景加载时或者一个持有脚本组件的游戏物体被实例化时。 OnLevelWasLoaded：这个函数用来通知游戏逻辑一个新的场景已经被加载完。 注意：对于加到场景中的物体来说，Awake和OnEnable方法将在所有脚本的任何类似于Start、Update等方法被调用之前调用。自然的，这些方法也不能在游戏进行中强制调用。 编辑器： Reset：Reset被调用于第一次将脚本绑定到物体上时初始化脚本属性，或者在Reset指令被触发时调用。 在帧之间： OnApplicationPause:：这个方法在检测到暂停的帧的末尾调用，在正常帧更新间有效？之后将会发出一个额外的帧。调用OnApplicationPause以允许游戏显示指示暂停状态的图形。 更新顺序：当你追踪游戏逻辑和交互、动画、相机位置等，你可以使用几个不同的事件。常见的模式是在Update函数中执行大多数任务，但也可以使用其他功能。 FixedUpdate：FixedUpdate函数通常要比Update函数调用的更为频繁，会按照设置的时间固定频率来循环更新。如果帧速率低，则可以每帧调用多次，如果帧速率高，则可以不在帧之间调用。所有物理计算和更新在FixedUpdate之后立即发生。在FixedUpdate中应用移动计算时，不需要乘以Time.deltaTime。这是因为FixedUpdate在可靠的定时器上调用，与帧速率无关。 Update：Update每帧调用一次。它是帧更新的主要功能。 LateUpdate：LateUpdate每帧调用一次，但在Update执行结束之后。在LateUpdate开始时，在Update中执行的任何计算都应该已经完成。LateUpdate的一个常见用途是实现跟随的第三人称相机。如果你将角色移动放在Update中执行，那么你可以将所有的相机移动和旋转计算放在LateUpdate中执行。这将确保角色在摄像机跟踪其位置之前完全移动。 总体来说，Update()和LateUpdate()属于立即更新，更新之间的频率是不固定的，比如某一帧有一个耗时操作的时候，就会影响到下一帧更新的时间，所以对更新频率要求比较稳定的物理系统就不太适合在这里处理更新。 FixedUpdate()虽然是固定更新，但是其实也是相对固定的，比如某一帧耗了好几秒，它依然会卡住。不过正常的程序要优化耗时操作，小范围的帧率波动是正常的，可以让它更新的时间间隔稍微长一点，这样它的更新是比较平滑的。在实际的开发中，例如以秒为单位的倒计时，并不需要每一帧去判断时间，所以用FixedUpdate()就再合适不过了。 动画更新循环：这些方法和Profiler Markers在Unity评估(？)动画系统时会调用。 (暂略) 有用的profile markers：(暂略) 渲染： OnPreCull：在相机剔除场景之前调用。剔除确定相机可以看到哪些对象。在剔除之前调用OnPreCull。 OnBecameVisible/OnBecameInvisible：当对象变得对任何相机可见/不可见时调用。 OnWillRenderObject：如果对象可见，则为每个摄像机调用一次。 OnPreRender：在相机开始渲染场景之前调用一次。 OnRenderObject：在完成所有常规场景渲染后调用。您可以使用GL类或Graphics.DrawMeshNow来绘制自定义几何体。 OnPostRender：在相机完成渲染场景后调用。 OnRenderImage：在场景渲染完成后调用以允许对图像进行后处理，请参阅后处理效果。 OnGUI：响应GUI事件，每帧调用多次。首先处理Layout和Repaint事件，然后为每个输入事件处理Layout和keyboard / mouse事件。 OnDrawGizmos：用于在场景视图中绘制Gizmo以进行可视化。 协程：正常的协程在Update函数返回后更新。协程是一个可以暂停执行(yield)直到给定的YieldInstruction完成的函数。以下是协程的不同用处： yield：在下一帧调用所有Update函数后，协程将继续。 yield WaitForSeconds：在为帧调用了所有的Update函数后，协程在指定的延迟时间后继续。 yield WaitForFixedUpdate：在所有脚本中的的所有FixedUpdate执行后继续协程。 yield WWW：在一个WWW类的下载完成之后执行协程。 yield StartCoroutine：链接协程，并将等待MyFunc协程首先完成。 当物体被销毁时： OnDestroy：在对象存在的最后一帧的所有帧更新之后调用这个函数。(该对象可能在相应Object.Destory或者场景闭合时被销毁)。 当退出时：在场景中的所有活动对象上调用这些函数： OnApplicationQuit：在退出应用程序之前，将在所有游戏对象上调用此函数。在编辑器中，当用户停止播放模式时调用它。 OnDisable：当行为被禁用或处于非活动状态时，将调用此函数。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Unity] Unity中的内存泄漏]]></title>
    <url>%2F2019%2F04%2F11%2FUnity%E7%AC%94%E8%AE%B0%2FUnity-Unity%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%2F</url>
    <content type="text"><![CDATA[Unity中的内存泄漏。 参考： 内存是手游的硬伤——Unity游戏Mono内存管理及泄漏 深入浅出再谈Unity内存泄漏]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[游戏AI] 状态机]]></title>
    <url>%2F2019%2F04%2F01%2F%E6%B8%B8%E6%88%8FAI%2F%E6%B8%B8%E6%88%8FAI-%E7%8A%B6%E6%80%81%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[状态机的利与弊。 参考： 漫谈游戏中的人工智能 《游戏人工智能编程案例精粹》 状态机状态机是什么：为什么选择状态机：状态机的演进：最简单的状态机：首先很容易抽象出IUnit： public interface IUnit { void ChangeState(UnitStateEnum state); void Patrol(); IUnit GetNearestTarget(); void LockTarget(IUnit unit); float GetFleeBloodRate(); bool CanMove(); bool HpRateLessThan(float rate); void Flee(); void Speak(); } 要注意的是，原作者的实现方式是定义一个单位接口，每个智能体要实现这个单位接口中定义的方法。(这样写会使每个单位类中有着一套自己所有行为的方法。我之前的实现方式是状态机来控制单位进行相应的行为，这样可以使每个状态仅有这个状态下自身的方法，但是耦合性较高。原作者这种接口是不是可以改写成虚方法的形式，在基类中实现基本行为，具体单位子类中再override出特定的行为？) 一个最简单的状态机定义： public interface IState where TState : IConvertible { TState Enum {get;} TUnit Self {get;} void OnEnter(); void Drive(); void OnExit(); } 这样写有着一个明显的性能问题：状态机本质是描述状态迁移的，并不需要保存实体的上下文，如果实体的上下文都保存在State中(上文中的TUnit类型的Self)，那么这个状态机的每个状态迁移逻辑需要每个状态都保存一个实体的实例，这样浪费内存，应该将决策逻辑与实体的上下文分离。 决策逻辑和上下文分离：剥离后： public interface IState where TState : IConvertible { TState Enum {get;} void OnEnter(TUnit self); void Drive(TUnit self); void OnExit(TUnit self); } 可以使用单例模式保持静态的状态内容实例只有一个，此时状态之间的迁移逻辑变成了静态，动态的是状态迁移过程中的上下文。 分层有限状态机：如果想要让状态机框架描述层级结构的概念，需要对其进行拓展： 例如一个怪物需要在巡逻一段时间后进行休息，在休息一段时间后再次进行巡逻，而巡逻与休息状态均保持着对于战斗的检查。这时如果按照之前的框架(我之前就是最初级的那种)，就需要手动进行装配，在每个状态中都写入一个关于是否进入战斗状态的检查。可以看出战斗状态的优先级较高，并且相对来说算是一种”全局检查”，可以将其抽离出来作为上层状态。 父状态需要关注子状态的运行结果，所以状态的Drive接口需要一个运行结果的返回值。 子状态一定是由父状态驱动的。 考虑这样一个组合状态情景：巡逻时，需要依次得先走到一个点，然后怠工一会儿，再走到下一个点，然后再怠工一会儿，循环往复。这样就需要父状态（巡逻状态）注记当前激活的子状态，并且根据子状态执行结果的不同来修改激活的子状态集合。这样不仅是Unit自身有上下文，连组合状态也有了自己的上下文。 状态定义： public interface IState where TState : IConvertible { // ... TResult Drive(); // ... } 组合状态的定义： public abstract class UnitCompositeStateBase : UnitStateBase { protected readonly LinkedList subStates = new LinkedList(); // ... protected Result ProcessSubStates() { if (subStates.Count == 0) { return Result.Success; } var front = subStates.First; var res = front.Value.Drive(); if (res != Result.Continue) { subStates.RemoveFirst(); } return Result.Continue; } // ... } 巡逻状态： public class PatrolState : UnitCompositeStateBase { // ... public override void OnEnter() { base.OnEnter(); AddSubState(new MoveToState(Self)); } public override Result Drive() { if (subStates.Count == 0) { return Result.Success; } var unit = Self.GetNearestTarget(); if (unit != null) { Self.LockTarget(unit); return Result.Success; } var front = subStates.First; var ret = front.Value.Drive(); if (ret != Result.Continue) { if (front.Value.Enum == CleverUnitStateEnum.MoveTo) { AddSubState(new IdleState(Self)); } else { AddSubState(new MoveToState(Self)); } } return Result.Continue; } } 分层有限状态机的上下文分离： 我们对之前重构出来的层次状态机框架再进行一次Context分离优化。 要优化的点有这样几个： 首先是继续之前的，unit不应该作为一个state自己的内部status。 组合状态的实例内部不应该包括自身执行的status。目前的组合状态，可以动态增删子状态，也就是根据status决定了结构的状态，理应分离静态与动态。巡逻状态组合了两个子状态——A和B，逻辑中是一个完成了就添加另一个，这样一想的话，其实巡逻状态应该重新描述——先进行A，再进行B，循环往复。 由于有了父状态的概念，其实状态接口的设计也可以再迭代，理论上只需要一个drive即可。因为状态内部的上下文要全部分离出来，所以也没必要对外提供OnEnter、OnExit，提供这两个接口的意义只是做一层内部信息的隐藏，但是现在内部的status没了，也就没必要隐藏了。 具体分析一下需要拆出的status： 一部分是entity本身的status，这里可以简单的认为是unit。 另一部分是state本身的status。 对于组合状态，这个status描述的是我当前执行到哪个substate。 对于原子状态，这个status描述的种类可能有所区别。 例如MoveTo/Flee，OnEnter的时候，修改了unit的status，然后Drive的时候去check。 例如Idle，OnEnter时改了自己的status，然后Drive的时候去check。 经过总结，我们可以发现，每个状态的status本质上都可以通过一个变量来描述。一个State作为一个最小粒度的单元，具有这样的Concept： 输入一个Context，输出一个Result。 Context暂时只需要包括这个Unit，和之前所说的status。同时，考虑这样一个问题： 父状态A，子状态B。 子状态B向上返回Continue的同时，status记录下来为b。 父状态ADrive子状态的结果为Continue，自身也需要向上抛出Continue，同时自己也有status为a。 这样，再还原现场时，就需要即给A一个a，还需要让A有能力从Context中拿到需要给B的b。因此上下文的结构理应是递归定义的，是一个层级结构。 Context如下定义： public class Continuation { public Continuation SubContinuation { get; set; } public int NextStep { get; set; } public object Param { get; set; } } public class Context { public Continuation Continuation { get; set; } public T Self { get; set; } } 修改State的接口定义为： public interface IState { TResult Drive(Context ctx); } 已经相当简洁了。 这样，我们对之前的巡逻状态也做下修改，达到一个ContextFree的效果。利用Context中的Continuation来确定当前结点应该从什么状态继续： public class PatrolState : IState { private readonly List subStates; public PatrolState() { subStates = new List() { new MoveToState(), new IdleState(), }; } public Result Drive(Context ctx) { var unit = ctx.Self.GetNearestTarget(); if (unit != null) { ctx.Self.LockTarget(unit); return Result.Success; } var nextStep = 0; if (ctx.Continuation != null) { // Continuation var thisContinuation = ctx.Continuation; ctx.Continuation = thisContinuation.SubContinuation; var ret = subStates[nextStep].Drive(ctx); if (ret == Result.Continue) { thisContinuation.SubContinuation = ctx.Continuation; ctx.Continuation = thisContinuation; return Result.Continue; } else if (ret == Result.Failure) { ctx.Continuation = null; return Result.Failure; } ctx.Continuation = null; nextStep = thisContinuation.NextStep + 1; } for (; nextStep < subStates.Count; nextStep++) { var ret = subStates[nextStep].Drive(ctx); if (ret == Result.Continue) { ctx.Continuation = new Continuation() { SubContinuation = ctx.Continuation, NextStep = nextStep, }; return Result.Continue; } else if (ret == Result.Failure) { ctx.Continuation = null; return Result.Failure; } } ctx.Continuation = null; return Result.Success; } } subStates是readonly的，在组合状态构造的一开始就确定了值。这样结构本身就是静态的，而上下文是动态的。不同的entity instance共用同一个树的instance。 ​ (最后这个理解起来比较吃力了)]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>游戏AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[游戏引擎架构] 第十章：渲染引擎]]></title>
    <url>%2F2019%2F03%2F26%2F%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%2F%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84-%E7%AC%AC%E5%8D%81%E7%AB%A0-%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[「占位」 渲染引擎采用深度缓冲的三角形光栅化基础三维场景渲染的本质涉及以下基本步骤： 描述一个虚拟场景。这些场景一般是以某数学形式表示的三维表面。 定位及定向一个虚拟摄像机，为场景取景。 设置光源。 描述场景中物体表面的视觉特性。 对于每个位于影像矩形内的像素，渲染引擎会找出经过该像素而聚焦于虚拟摄像机焦点的光线，并计算其颜色和强度。此过程为求解渲染方程，也叫做着色方程。 场景描述：高端渲染软件所用的表示法三角形网格游戏开发者会使用三角形网格来为表面建模。三角形是表面的分段线性逼近。 为什么选取三角形？ 三角形是最简单的多边形 三角形必然是平坦的 三角形经过多种转换之后仍然维持是三角形，对于仿射转换与透视转换也成立 几乎所有的商用图形加速软件都是为三角形光栅化而设计的。 镶嵌： 镶嵌是指把表面分割为一组离散多边形的过程。 构造三角形网格 缠绕顺序 三角形由三个顶点的位置矢量定义，此三个矢量设为p1，p2，p3。每条棱的相邻顶点的位置矢量相减，就能求得三条棱的矢量。 任何两棱的叉积，归一化后就能定义为三角形的单位面法线N，若要知道面法线的方向，需要定义哪一面才是三角形的正面，哪一面是背面，这个可以简单用缠绕顺序(winding order)定义，缠绕顺序用来定义表面方向有两种方式，分别是顺时针方向和逆时针方向。 模型空间世界空间及网格实例化描述表面的视觉性质光和颜色的概论顶点属性顶点格式属性插值纹理材质光照基础局部及全局光照模型Phong氏光照模型光源模型虚拟摄像机观察空间投影观察体积及平截头体投影及齐次裁剪空间屏幕空间及长宽比帧缓冲三角形光栅化及片段遮挡及深度缓冲渲染管道高级光照及全局光照视觉效果和覆盖层]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>游戏引擎</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Unity] 托管堆与垃圾回收]]></title>
    <url>%2F2019%2F03%2F25%2FUnity%E7%AC%94%E8%AE%B0%2FUnity-%E6%89%98%E7%AE%A1%E5%A0%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%2F</url>
    <content type="text"><![CDATA[有关Unity中的托管堆与垃圾回收。 托管堆与垃圾回收托管堆：“托管堆”是一段内存，由项目脚本运行时（Mono或IL2CPP）的内存管理器自动管理。托管代码中创建的所有对象必须在托管堆上分配（注意：严格地说，必须在托管堆上分配所有非空引用类型对象和所有盒装值类型对象）。 在上图中，白框表示分配给托管堆的内存量，其中的彩色框表示存储在托管堆内存空间中的数据值。当需要其他值时，将从托管堆中分配更多空间。 垃圾收集器定期运行（注意：确切的时间与平台有关）。这会扫描堆上的所有对象，标记删除任何不再引用的对象。然后删除未引用的对象，释放内存。 至关重要的是，Unity的垃圾收集 - 使用Boehm GC算法 - 是非代数和非压缩的。“非世代”意味着GC在执行收集传递时必须扫描整个堆，因此其性能因堆扩展而降低。“非压缩”意味着内存中的对象不会被重新定位以便关闭对象之间的间隙。 上图显示了内存碎片的示例。释放对象时，将释放其内存。但是，释放的空间也不会成为“空闲内存”一家独大池的一部分。释放对象两侧的对象可能仍在使用中。因此，释放的空间是存储器的其他部分之间的“间隙”（该间隙由图中的红色圆圈表示）。因此，新释放的空间仅可用于存储与释放的对象相同或更小的数据。 分配对象时，请记住该对象必须始终占用内存中的连续空间块。 这导致了内存碎片的核心问题：虽然堆中可用的总空间量可能很大，但是该空间中的一些或全部可能在分配的对象之间存在小的“间隙”。在这种情况下，即使可能有足够的总空间来容纳某个分配，托管堆也找不到足够大的连续内存块来适应分配。 但是，如果分配了大对象并且没有足够的连续可用空间来容纳对象，则如上所述，Unity内存管理器执行两个操作。 首先，如果还没有这样做，垃圾收集器就会运行。这会尝试释放足够的空间来完成分配请求。 如果在GC运行后，仍然没有足够的连续空间来满足请求的内存量，则堆必须扩展。堆扩展的具体数量取决于平台; 但是，大多数Unity平台的大小都是托管堆的两倍。 堆的关键问题托管堆扩展的核心问题有两个： Unity在扩展时不会经常释放分配给托管堆的内存页; 它乐观地保留了扩展堆，即使它的大部分是空的。这是为了防止在进一步发生大量分配时需要重新扩展堆。 在大多数平台上，Unity最终将托管堆空部分使用的页面释放回操作系统。发生这种情况的间隔不能保证，不应该依赖。 托管堆使用的地址空间永远不会返回给操作系统。 对于32位程序，如果托管堆多次扩展和收缩，则可能导致地址空间耗尽。如果程序的可用内存地址空间已用尽，操作系统将终止该程序。 对于64位程序，地址空间足够大，对于运行时间不超过人类平均寿命的程序来说，这种情况极不可能发生。 了解自动内存管理：创建对象，字符串或数组时，存储它所需的内存是从称为堆的中央池分配的。当项目不再使用时，它曾经占用的内存可以被回收并用于其他内容。在过去，通常由程序员通过适当的函数调用显式地分配和释放这些堆内存块。如今，Unity的Mono引擎等运行时系统会自动为您管理内存。自动内存管理比显式分配/释放需要更少的编码工作，并且大大降低了内存泄漏的可能性（分配内存但从未随后释放的情况）。 分配和垃圾收集内存管理器跟踪它知道未使用的堆中的区域。当请求新的存储器块时（例如，当实例化对象时），管理器选择一个未使用的区域，从该区域分配块，然后从已知的未使用空间中移除分配的存储器。后续请求以相同的方式处理，直到没有足够大的空闲区域来分配所需的块大小。此时极不可能从堆中分配的所有内存仍在使用中。只有存在可以找到它的引用变量时，才能访问堆上的引用项。如果对内存块的所有引用都消失了（即，引用变量已被重新分配，或者它们是现在超出范围的局部变量），则可以安全地重新分配它占用的内存。 为了确定哪些堆块不再使用，内存管理器搜索所有当前活动的引用变量，并将它们称为“实时”的块标记。在搜索结束时，内存管理器认为实时块之间的任何空格都是空的，并且可以用于后续分配。由于显而易见的原因，定位和释放未使用的内存的过程称为垃圾收集（或简称GC）。 优化垃圾收集是自动的，对于程序员不可见，但在采集过程中实际需要的背后显著CPU时间的场景。如果使用正确，自动内存管理通常会等于或超过手动分配以获得整体性能。但是，程序员必须避免错误，这些错误会比必要时更频繁地触发收集器并在执行时引入暂停。 Unity中的垃圾回收：堆分配期间会发生什么？堆分配比堆栈分配复杂得多。这是因为堆可用于存储长期和短期数据，以及许多不同类型和大小的数据。分配和解除分配并不总是以可预测的顺序发生，并且可能需要非常不同大小的存储器块。 创建堆变量时，将执行以下步骤： 首先，Unity必须检查堆中是否有足够的可用内存。如果堆中有足够的可用内存，则分配变量的内存。 如果堆中没有足够的可用内存，Unity会尝试释放垃圾收集器，以释放未使用的堆内存。这可能是一个缓慢的操作。如果堆中现在有足够的可用内存，则会分配变量的内存。 如果垃圾回收后堆中没有足够的可用内存，Unity会增加堆中的内存量。这可能是一个缓慢的操作。然后分配变量的内存。 堆分配可能很慢，特别是如果垃圾收集器必须运行并且必须扩展堆。 垃圾收集期间会发生什么？当堆变量超出范围时，用于存储它的内存不会立即释放。只有在垃圾收集器运行时才会释放未使用的堆内存。 每次垃圾收集器运行时，都会发生以下步骤： 垃圾收集器检查堆上的每个对象。 垃圾收集器搜索所有当前对象引用以确定堆上的对象是否仍在范围内。 任何不再在范围内的对象都被标记为删除。 将删除标记的对象，并将分配给它们的内存返回到堆中。 垃圾收集可能是一项昂贵的操作。堆上的对象越多，它必须做的工作越多，代码中的对象引用越多，它必须做的工作就越多。 垃圾收集什么时候发生？有三件事可能导致垃圾收集器运行： 无论何时请求堆分配都无法使用堆中的可用内存来执行垃圾收集器。 垃圾收集器会不时自动运行（尽管频率因平台而异）。 垃圾收集器可以强制手动运行。 垃圾收集可能是一个频繁的操作。每当无法从可用堆内存中实现堆分配时，就会触发垃圾收集器，这意味着频繁的堆分配和解除分配会导致频繁的垃圾回收。 参考： Understanding the managed heap（理解托管堆） Understanding Automatic Memory Management(理解自动内存管理) Optimizing garbage collection in Unity games(在Unity游戏中优化垃圾回收) Boehm garbage collector]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Unity] 动画系统]]></title>
    <url>%2F2019%2F03%2F25%2FUnity%E7%AC%94%E8%AE%B0%2FUnity-%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[Unity中的动画控制系统。 动画系统Unity的动画系统支持引擎内编辑动画，也支持外部导入FBX动画。由于引擎内置的的动画编辑器没有骨骼动画的概念，所以只能编辑每一帧模型的Transform、整体的旋转、缩放和平移。 模型：Unity显示模型必须给游戏对象提供Mesh Filter和Mesh Renderer组件，前者表示模型需要用的Mesh文件，后者通过材质的贴图和Shader最终将这个模型渲染出来。 Mesh Filter：Mesh Render：Prefab：动画编辑器：动画编辑器的原理就是通过时间线来修改组件的信息，比如修改Transform位置信息，修改Renderer组件或者修改颜色信息，控制模型显示隐藏；此外，还可以在时间线上添加动画事件，编辑后的动画需要配合Animator组件使用。 导入类动画：人形重定向动画：人形重定向动画就是多个身形不同的人物模型也可以共用一份骨骼动画，此技术应用在游戏中会大量减少内存和包体大小。重定向动画的原理就是将不同身形的骨骼信息套入相同的动画中来运算。 通用动画：老版动画：导入类动画事件：动画控制器：动画控制器的原理就是状态机：]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity Shader中的测试]]></title>
    <url>%2F2019%2F03%2F18%2FUnity%E7%AC%94%E8%AE%B0%2FUnity-Shader%E4%B8%AD%E7%9A%84%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[Unity Shader中的测试：Alpha测试、模版测试、深度测试。 Alpha测试：Alpha Test和Alpha Blending是两种处理透明的方法。 Alpha Test：Alpha Test采用一种很霸道极端的机制，只要一个像素的alpha不满足条件，那么它就会被fragment shader舍弃。被舍弃的fragments不会对后面的各种Tests产生影响；否则，就会按正常方式写入到缓存中，并进行正常的深度检验等等，也就是说，Alpha Test是不需要关闭ZWrite的。Alpha Test产生的效果也很极端，要么完全透明，即看不到，要么完全不透明。 Alpha Blending：而Alpha Blending则是一种中庸的方式，它使用当前fragment的alpha作为混合因子，来混合之前写入到缓存中颜色值。但Alpha Blending麻烦的一点就是它需要关闭ZWrite，并且要十分小心物体的渲染顺序。如果不关闭ZWrite，那么在进行深度检测的时候，它背后的物体本来是可以透过它被我们看到的，但由于深度检测时大于它的深度就被剔除了，从而我们就看不到它后面的物体了。因此，我们需要保证物体的渲染顺序是从后往前，并且关闭该半透明对象的ZWrite。 注意：Alpha Blending只是关闭ZWrite，人家可没有关闭ZTest哦！这意味着，在输出一个Alpha Blending的fragment时，它还是会判断和当前Color Buffer中的fragment的深度关系，如果它比当前的fragment深度更远，那么它就不会再做后续的混合操作；否则，它就会和当前的fragment进行混合，但是不会把自己的深度信息写入Depth Buffer中。这是非常重要的，这一点决定了，即便一个不透明物体出现在一个透明物体的前面，不透明物体仍可以正常的遮挡住透明物体！也就是说，对于Alpha Blending来说，Depth Buffer是只读的。 尽可能使用Alpha Blending，而不要使用Alpha Test。 模板测试：模板测试stencil test是3d渲染管线中介于透明测试alpha test和深度测试depth test之间的测试，目的是根据条件来比较设置的参考值referenceValue和模板缓冲区stencil buff中对应的值stencilBuffValue的大小，如果条件满足就让片段fragment（候选的像素）进入下一测试，即深度测试，条件不满足就过滤掉片段，不把对应材质的片段输出到屏幕。 深度测试： 什么是深度？ 深度其实就是该像素点在3d世界中距离摄象机的距离，深度值Zbuffer（Z值）越大，则离摄像机越远。 什么是深度缓存？ 深度缓存中存储着每个像素点（绘制在屏幕上的）的深度值，如果启用了深度缓冲区，在绘制每个像素之前，OpenGL会把它的深度值和已经存储在这个像素的深度值进行比较。新像素深度值小于原先像素深度值，则新像素值会取代原先的；反之，新像素值被遮挡，其颜色值和深度将被丢弃，最终屏幕显示的就是深度缓存中深度对应的像素点的颜色！(深度主要起的是比较的作用) 什么是深度测试？ 在深度测试中，默认情况是将要绘制的新像素的z值与深度缓冲区中对应位置的z值进行比较，如果比深度缓存中的值小，那么用新像素的颜色值更新深度缓存中对应像素的颜色值。 为什么需要深度？ 在不使用深度测试的时候，如果我们先绘制一个距离较近的物体，再绘制距离较远的物体，则距离远的物体因为后绘制，会把距离近的物体覆盖掉，这样的效果并不是我们所希望的。而有了深度缓冲以后，绘制物体的顺序就不那么重要了，都能按照远近（Z值）正常显示，这很关键。(越后绘制的东西，距离相机就越近) ZWrite：ZWrite可以取的值为：On/Off，默认值为On，代表是否要将像素的深度写入深度缓存中。 ZTest：ZTest可以取的值为：Greater/GEqual/Less/LEqual/Equal/NotEqual/Always/Never/Off，默认值为LEqual，代表如何将像素的颜色写入深度缓存中，例如当取默认值的情况下，如果将要绘制的新像素的z值小于等于深度缓存中的值，则将用新像素的颜色值更新深度缓存中对应像素的颜色值。需要注意的是，当ZTest取值为Off时，表示的是关闭深度测试，等价于取值为Always，而不是Never！Always指的是直接将当前像素颜色(不是深度)写进颜色缓冲区中；而Never指的是不要将当前像素颜色写进颜色缓冲区中，相当于消失。 Early-Z技术：传统的渲染管线中，ZTest其实是在Blending阶段，这时候进行深度测试，所有对象的像素着色器都会计算一遍，没有什么性能提升，仅仅是为了得出正确的遮挡结果，会造成大量的无用计算，因为每个像素点上肯定重叠了很多计算。因此现代GPU中运用了Early-Z的技术，在Vertex阶段和Fragment阶段之间（光栅化之后，fragment之前）进行一次深度测试，如果深度测试失败，就不必进行fragment阶段的计算了，因此在性能上会有很大的提升。但是最终的ZTest仍然需要进行，以保证最终的遮挡关系结果正确。前面的一次主要是Z-Cull为了裁剪以达到优化的目的，后一次主要是Z-Check。 Early-Z的实现，主要是通过一个Z-pre-pass实现，简单来说，对于所有不透明的物体（透明的没有用，本身不会写深度），首先用一个超级简单的shader进行渲染，这个shader不写颜色缓冲区，只写深度缓冲区，第二个pass关闭深度写入，开启深度测试，用正常的shader进行渲染。其实这种技术，我们也可以借鉴，在渲染透明物体时，因为关闭了深度写入，有时候会有其他不透明的部分遮挡住透明的部分，而我们其实不希望他们被遮挡，仅仅希望被遮挡的物体半透，这时我们就可以用两个pass来渲染，第一个pass使用Color Mask屏蔽颜色写入，仅写入深度，第二个pass正常渲染半透，关闭深度写入。 Unity渲染顺序：如果我们先绘制后面的物体，再绘制前面的物体，就会造成over draw；而通过Early-Z技术，我们就可以先绘制较近的物体，再绘制较远的物体（仅限不透明物体），这样，通过先渲染前面的物体，让前面的物体先占坑，就可以让后面的物体深度测试失败，进而减少重复的fragment计算，达到优化的目的。Unity中默认应该就是按照最近距离的面进行绘制的。 参考： 【Unity Shaders】Alpha Test和Alpha Blending Unity Shader中的渲染队列、ZWrite和ZTest Unity Shader-渲染队列，ZTest，ZWrite，Early-Z]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity Shader 使用噪声]]></title>
    <url>%2F2019%2F03%2F10%2FUnity%E7%AC%94%E8%AE%B0%2FUnity-Shader-%E4%BD%BF%E7%94%A8%E5%99%AA%E5%A3%B0%2F</url>
    <content type="text"><![CDATA[消融效果、水波效果、全局雾效。 消融效果的实现：通过噪声纹理采样与设置好的消融属性相减，将算得结果小于0的像素剔除。对于剩下的像素进行正常的光照计算，然后在设定好的宽度范围内对两种溶解颜色进行插值，再将混合得到的颜色与环境光和漫反射光照混合输出。 后面还需要加一个用于处理阴影的Pass，否则已经消融的部分会投射影子。 定义属性： 定义消融需要的Pass：为了得到正确的光照，我们设置了Pass的LightMode和multi_compile_fwdbase的编译指令。 我们使用Cull off来关闭Shader的面片剔除，来使得其正面和背面都会被渲染。 定义顶点着色器： 通过片元着色器实现模拟消融效果： 首先对噪声纹理进行采样，并将结果和用于控制消融程度的属性相减，传递给clip函数，将结果小于0的像素剔除。 对于剩下的像素，进行正常的光照计算。我们根据漫反射纹理获得反射率albedo，并由此计算环境光照与漫反射光照。 计算烧焦颜色：在宽度为_LineWidth的范围内模拟一个烧焦的颜色变化，使用smoothstep来计算混合系数（当t为1时，表明该像素位于消融的边界处；当t为0时，表明该像素为正常的模型颜色），插值用来模拟一个烧焦效果：使用t来混合两种火焰颜色。同样使用step函数来保证剔除。 自定义投射阴影的Pass： 同样使用clip函数来剔除片元，然后使用内置宏SHADOW_CASTER_FRAGMENT()来完成阴影投射，将结果输出到深度图和阴影映射纹理中。 水波效果：全局雾效：生成噪声：噪声是怎么生成的：https://blog.csdn.net/candycat1992/article/details/50346469 基于晶格的方法（Lattice based） 基于点的方法（Point based） Perlin噪声： Perlin噪声还是比较简单的，Perlin噪声的实现需要三个步骤： 定义一个晶格结构，每个晶格的顶点有一个“伪随机”的梯度向量（其实就是个向量啦）。对于二维的Perlin噪声来说，晶格结构就是一个平面网格，三维的就是一个立方体网格。 输入一个点（二维的话就是二维坐标，三维就是三维坐标，n维的就是n个坐标），我们找到和它相邻的那些晶格顶点（二维下有4个，三维下有8个，n维下有2n2n个），计算该点到各个晶格顶点的距离向量，再分别与顶点上的梯度向量做点乘，得到2n2n个点乘结果。 使用缓和曲线（ease curves）来计算它们的权重和。在原始的Perlin噪声实现中，缓和曲线是s(t)=3t2−2t3s(t)=3t2−2t3。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity Shader 高级纹理]]></title>
    <url>%2F2019%2F03%2F06%2FUnity%E7%AC%94%E8%AE%B0%2FUnity-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86%2F</url>
    <content type="text"><![CDATA[立方体纹理实现环境映射，渲染纹理以及程序纹理。 立方体纹理：定义：立方体纹理是环境映射的一种实现方式。环境映射可以模拟物体周围的环境，使用了环境映射的物体可以看起来像是镀了金属一样反射出周围的环境。 采样方式正方体纹理一共包含了6张图像，这些图像对应了一个立方体的6个面。立方体的每个面表示沿着世界空间下的轴向观察所得来的图像。对立方体纹理采样需要我们提供一个三维的纹理坐标，这个三维纹理坐标表示了我们在世界空间下的一个3D方向。这个方向矢量从立方体的中心出发，当它向外部延伸时就会和立方体的6个纹理之一发生相交，而采样得到的结果就是由该交点计算而来的。 优点与缺点： 优点：实现简单快速，得到的效果比较好。 缺点： 当场景中引入了新的物体、光源，或者物体发生移动时，我们就需要重新生成立方体纹理。 立方体纹理只能反射环境，不能反射使用了该立方体纹理的物体本身。它不能模拟多次反射的结果，故应尽量对凸面体而不是凹面体使用立方体纹理。 天空盒子（Skybox）：天空盒子是在所有不透明物体之后渲染的，而其背后使用的网格是一个立方体或一个细分后的球体。 创建用于环境映射的立方体纹理： 直接由一些特殊布局的纹理创建：需要一张具有特殊布局的纹理，然后将其Texture Type设置成Cubemap即可。 手动创建一个Cubemap资源：创建一个Cubemap，将六张纹理拖拽到它的面板中。 由脚本生成：使用Camera.RenderToCubemap函数实现——从任意位置观察到的场景图像存储到6张图像中，从而创建出该位置上对应的正方体纹理。 反射效果： 通过入射光线的方向和表面法线方向来计算反射方向，再利用反射方向对立方体纹理采样。 首先，声明需要用到的属性： 在顶点着色器中计算该顶点处的反射方向，根据CG的reflect函数来实现： 物体反射到摄像机中的光线方向，可以由光路可逆的原则来反向求得。可以计算视角方向关于顶点法线的反射方向来求得入射光线的方向。 (TRANSFER_SHADOW参见以前的博客：（此处应有链接）) 在片元着色器中，利用反射方向来对立方体纹理采样： 对立方体纹理的采样需要使用CG的texCUBE函数，用于采样的参数仅仅是作为方向变量传递给texCUBE函数的，没有必要进行归一化。 然后使用_ReflectAmount来混合漫反射颜色和反射颜色，并和环境光照相加后返回。 可以在片元着色器中计算反射方向，这样效果更好，但是差别不大；处于性能考虑，我们选择在顶点着色器中计算反射方向。 效果： 折射效果： 当光线从一种介质斜射入另一种介质时，传播方向一般会发生改变。当给定入射角时，可以使用斯涅尔定律来计算反射角。 ​ $n_1sinθ_1 = n_2sinθ_2$ 其中，n1和n2分别是两个介质的折射率。 一般对一个透明物体，准确的模拟需要计算两次折射——一次入射与一次出射。但是这样模拟很复杂，所以初学在此仅模拟一次折射。 声明属性： 使用CG的refract函数来计算折射方向。 第一个参数是入射光线的方向，必须是归一化后的矢量；第二个参数是表面法线，法线方向同样需要是归一化的；第三个参数是入射光线所在介质的折射率与折射光线所在介质的折射率之间的比值。返回计算而得的折射方向，它的模则等于入射光线的模。 在片元着色器中使用折射方向对立方体纹理进行采样： 最后使用_RefractAmount来混合漫反射和折射颜色，并和环境光照相加后返回。 效果： 菲涅尔反射： 当光线照射到物体表面上时，一部分发生反射，一部分进入物体内部，发生折射或散射。被反射的光和入射光之间存在一定的比率关系，这个比例关系可以通过菲涅尔等式进行计算。 菲涅尔等式： Schlick菲涅尔近似等式： ​ $F_{Schlick}(v,n) = F_0 + (1 - F_0)(1 - v·n)^5$ ​ $F_0$是反射系数，用于控制菲涅尔反射的强度，v是视角方向，n是表面法线。 Empricial菲涅尔近似等式： ​ $F_{Empricial}(v,n) = max(0, min(1,bias + scale * (1 - v·n)^{power})$ Bias、scale和power是控制项。 定义属性：_FresnelScale属性用于调整菲涅尔反射 在顶点着色器中计算世界空间下的法线方向、视角方向和反射方向： 在片元着色器中计算菲涅尔反射，并使用结果值混合漫反射光照和反射光照： 效果： 当_FresnelScale为1时： 为0.5时： 为0时： 渲染纹理：镜子效果的实现：玻璃效果的实现：我们可以使用GrabPass来完成获取屏幕图像的目的。在Shader中定义了一个GrabPass后，Unity会把当前屏幕的图像绘制在一张纹理中，以便在后续的Pass中访问。与简单的透明混合不同，使用GrabPass可以让我们对物体后面的图像进行更复杂的处理，例如使用法线来模拟折射效果，而不是简单的与原屏幕颜色进行混合。 使用GrabPass时，要小心物体的渲染队列设置，往往需要把物体的渲染队列设置成透明队列（“Queue ” = “Transparent”），来保证当渲染该物体的时候，所有的不透明物体已经被绘制在屏幕上，获得正确的屏幕图像。 整体思路： 首先使用一张法线纹理来修改模型的法线信息，然后使用反射方法，通过一个Cubemap来模拟玻璃的反射，而在模拟折射时，使用了GrabPass获取玻璃后面的屏幕图像，并使用切线空间下的法线对屏幕纹理坐标偏移后，再对屏幕图像进行采样来模拟近似的折射效果。 声明属性： 定义相应的渲染队列 定义变量： 定义顶点着色器阶段： 先进行必要的顶点坐标变换。 调用内置的ComputeGrabScreenPos函数来得到对应被抓取的屏幕图像的采样坐标。 计算_MainTex和_BumpMap的采样坐标，并存储在一个float4类型变量中。 接着计算顶点对应的从切线空间到世界空间的变换矩阵，并把该矩阵的每一行分别存储在三个TtoWx的xyz分量中。这样做是为了在片元着色器中把法线方向从切线空间转换到世界空间下，以便对CubeMap进行采样。 计算得到的分量被按列组成一个变换矩阵，w轴被用来存储世界空间下的顶点坐标。 定义片元着色器： 通过世界坐标得到该片元对应的视角方向。 对法线纹理进行采样，得到切线空间下的法线方向。 使用切线空间下的法线方向进行偏移（因为该空间下的法线可以反映顶点局部空间下的法线方向） 随后对scrPos透视除法得到真正的屏幕坐标，再使用该坐标对抓取的屏幕图像_RefractionTex进行采样，得到模拟的折射颜色。 下一步把法线方向从切线空间变换到了世界空间下，并据此得到视角方向相对于法线方向的反射方向。 使用反射方向对Cubemap进行采样，并把结果和主纹理颜色相乘后得到反射颜色。 最后使用_RefractAmount属性对反射和折射颜色进行混合，作为最终的输出颜色。 效果： 为什么要在Pass中使用一个字符串指明被抓取的屏幕图像存储名称？ 直接使用GrabPass{}性能消耗较大，因为这样对于每个使用它的物体，Unity会为它单独进行一次昂贵的屏幕抓取工作。不过这样可以使不同的物体得到不同的屏幕图像。 指明字符串后，可以在后续的Pass中通过名称来访问屏幕图像。这样效果更高效，但是所有物体都会使用同一张屏幕图像。 程序纹理：可以使用程序纹理来创建程序材质。 波点纹理实例：]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[翻译] StateMachine]]></title>
    <url>%2F2018%2F12%2F17%2F%E7%BF%BB%E8%AF%91%2F%E7%BF%BB%E8%AF%91-StateMachine%2F</url>
    <content type="text"><![CDATA[[TOC] 游戏中的状态机，分层状态机以及伪代码实现。 Chapter 5 Decision Making5.3 STATE MACHINES：状态机Often, characters in a game will act in one of a limited set of ways. They will carry on doing the same thing until some event or influence makes them change. A covenant warrior in Halo [Bungie Software, 2001], for example, will stand at its post until it notices the player, then it will switch into attack mode, taking cover and firing. 通常来说，游戏中的角色所进行的行为将会从有限的行为集合中选取。它们将会保持这个状态，直到一些事件或者影响使得它们改变。以 光环：战斗进化 为例，敌人将会一直驻守直到它们注意到玩家，此时将会转换到攻击状态，寻求掩体以及开火。 We can support this kind of behavior using decision trees, and we’ve gone some way to doing that using random decisions. In most cases, however, it is easier to use a technique designed for this purpose: state machines. 我们可以通过决策树来实现这种行为，并且我们已经采用某种方式使用随机决策来做到这一点。然而，在大多数情况下，对于这个目标，我们可以采用更为容易的技术设计：状态机。 State machines are the technique most often used for this kind of decision making and, along with scripting (see Section 5.9), make up the vast majority of decision making systems used in current games. 状态机是一种经常用于这类决策的技术，它与脚本一起使用（参见第5.9节），构成当前游戏中使用的绝大多数（vast majority）决策系统。 State machines take account of both the world around them (like decision trees) and their internal makeup (their state). 状态机既与它周围的世界相关（类似于决策树）又与其内部组成相关（它们自身的状态）。 A Basic State Machine ：一个基本状态机In a state machine each character occupies one state. Normally, actions or behaviors are associated with each state. So as long as the character remains in that state, it will continue carrying out the same action. 在状态机中，每个角色占据一个状态。通常，动作或行为与每个状态相关联。因此，只要角色保持在该状态，它将继续执行相同的动作。 States are connected together by transitions. Each transition leads from one state to another, the target state, and each has a set of associated conditions. If the game determines that the conditions of a transition are met, then the character changes state to the transition’s target state. When a transition’s conditions are met, it is said to trigger, and when the transition is followed to a new state, it has fired. 每个状态通过状态转换联系在一起。每个转换从一个状态引导到另一个状态，即目标状态，并且每个转换具有一组相关条件。如果游戏确定满足转换的条件，则角色将状态改变为要转换的目标状态。当满足转换条件时，它会被触发，当转换到新状态时，它就会被触发。 Figure 5.13 shows a simple state machine with three states: On Guard, Fight, and Run Away. Notice that each state has its own set of transitions. 图5.13显示了一个具有三种状态的简单状态机：On Guard，Fight和Run Away。请注意，每个状态都有自己的一组转换。 The state machine diagrams in this chapter are based on the UML state chart di- agram format, a standard notation used throughout software engineering. States are shown as curved corner boxes. Transitions are arrowed lines, labelled by the condition that triggers them. Conditions are contained in square brackets. 本章中的状态机图表基于UML状态图表格式，这是整个软件工程中使用的标准符号。状态显示为弯角框。过渡是箭头线，由触发它们的条件标记。条件包含在方括号中。 The solid circle in Figure 5.13 has only one transition without a trigger condition. The transition points to the initial state that will be entered when the state machine is first run. 图5.13中的实心圆只有一个没有触发条件的转换。转换指向首次运行状态机时将进入的初始状态。 You won’t need an in-depth understanding of UML to understand this chapter. If you want to find out more about UML, I’d recommend Pilone [2005]. 您不需要深入了解UML来理解本章。如果你想了解更多关于UML的信息，我推荐Pilone [2005]。 In a decision tree the same set of decisions is always used, and any action can be reached through the tree. In a state machine only transitions from the current state are considered, so not every action can be reached. 在决策树中，始终使用相同的决策集，并且可以通过树到达任何操作。在状态机中，仅考虑从当前状态的转换，因此不是每个动作都可以到达。 Finite State Machines ：有限状态机In game AI any state machine with this kind of structure is usually called a finite state machine (FSM). This and the following sections will cover a range of increasingly powerful state machine implementations, all of which are often referred to as FSMs. 在游戏AI中，具有这种结构的任何状态机通常称为有限状态机（FSM）。本节和以下部分将介绍一系列日益强大的状态机实现，所有这些实现通常都称为FSM。 This causes confusion with non-games programmers, for whom the term FSM is more commonly used for a particular type of simple state machine. An FSM in computer science normally refers to an algorithm used for parsing text. Compilers use an FSM to tokenize the input code into symbols that can be interpreted by the compiler. 这导致与非游戏程序员的混淆，对于他们来说，术语FSM更常用于特定类型的简单状态机。计算机科学中的FSM通常是指用于解析文本的算法。编译器使用FSM将输入代码标记为可由编译器解释的符号。 The Game FSM ：游戏中的有限状态机The basic state machine structure is very general and admits any number of imple- mentations. I have seen tens of different ways to implement a game FSM, and it is rare to find any two developers using exactly the same technique. That makes it difficult to put forward a single algorithm as being the “state machine” algorithm. 基本状态机结构非常通用，允许任意数量的实现。我已经看到了几种不同的方法来实现游戏FSM，并且很少发现任何两个开发人员使用完全相同的技术。这使得将单个算法提出为“状态机”算法变得困难。 Later in this section, I’ll look at a range of different implementation styles for the FSM, but the main algorithm I work through is just one. I chose it for its flexibility and the cleanness of its implementation. 在本节的后面部分，我将介绍FSM的一系列不同的实现样式，但我使用的主要算法只有一个。我之所以选择它是因为它的灵活性和实现的优雅性。 5.3.1 THE PROBLEM ：问题We would like a general system that supports arbitrary state machines with any kind of transition condition. The state machine will conform to the structure given above and will occupy only one state at a time. 我们想要一个支持具有任何转换条件的任意状态机的通用系统。这个状态机将符合上面给出的结构，并且一次只占用一个状态。 5.3.2 THE ALGORITHM ：算法We will use a generic state interface which can be implemented to include any spe- cific code. The state machine keeps track of the set of possible states and records the current state it is in. Alongside each state, a series of transitions are maintained. Each transition is again a generic interface that can be implemented with the appropriate conditions. It simply reports to the state machine whether it is triggered or not. 我们将使用通用状态接口，可以实现包含任何特定代码。 状态机跟踪可能状态的集合并记录它所处的当前状态。在每个状态下，保持一系列转换。 每次转换都是一个通用接口，可以使用适当的条件实现。 它只是向状态机报告它是否被触发。 At each iteration (normally each frame), the state machine’s update function is called. This checks to see if any transition from the current state is triggered. The first transition that is triggered is scheduled to fire. The method then compiles a list of actions to perform from the currently active state. If a transition has been triggered, then the transition is fired. 在每次迭代（通常是每个帧），调用状态机的更新函数。 这将检查是否触发了当前状态的任何转换。 触发的第一个转换将会被执行。 然后，该方法维护一个要从当前活动状态执行的动作列表(actions)。 如果已触发某个转换，则会执行这个转换。 This separation of the triggering and firing of transitions allows the transitions to also have their own actions. Often, transitioning from one state to another also involves carrying out some action. In this case a fired transition can add the action it needs to those returned by the state. 这种转换的触发和触发的分离允许转换也具有它们自己的动作。 通常，从一个状态转换到另一个状态也涉及执行某些行动。 //在这种情况下，触发转换可以将所需的操作添加到状态返回的操作。 5.3.3 PSEUDO-CODE ：伪代码实现The state machine holds a list of states, with an indication of which one is the current state. It has an update function for triggering and firing transitions and a function that returns a set of actions to carry out. 状态机保存状态列表，指示哪一个是当前状态。 //它具有用于执行和触发转换的更新功能以及返回要执行的一组操作的功能。 class machine { // 维护一个状态机的状态列表 list states; // 初始状态 State initialState； // 当前状态 currentState = initialState; // 检查并执行转换，同时返回一个动作列表 Update() { // 假定没有转换被触发 triggeredTransition = None; // 遍历所有状态并保存第一个被触发的状态 for transition in currentState.getTransitions() { if transition.isTriggered(): triggeredTransition = transition; break; } // 检查是否有状态被触发？ if triggeredTransition { targetState = triggeredTransition.getTargetState(); // 在行为列表之中增加旧状态的退出操作、状态转移的操作以及新状态的入口操作 actions = currentState.getExitAction() actions += triggeredTransition.getAction() actions += targetState.getEntryAction() // 完成状态转移并返回行为列表 currentState = targetState return actions } // 否则直接返回当前状态的行为列表 else return currentState.getAction() } } 5.3.4 DATA STRUCTURES AND INTERFACES ：数据结构与接口The state machine relies on having states and transitions with a particular interface.The state interface has the following form: 状态机依赖于具有特定接口的状态和转换。状态接口具有以下形式： class State { def getAction(); def getEntryAction(); def getExitAction(); def getTransitions(); } Each of the getAction methods should return a list of actions to carry out. As we will see below, the getEntryAction is only called when the state is entered from a transition, and the getExitAction is only called when the state is exited. The rest of the time that the state is active, getAction is called. The getTransitions method should return a list of transitions that are outgoing from this state. The transition interface has the following form: 每个getAction方法都应返回要执行的操作列表。 正如我们将在下面看到的，只有在从转换进入状态时才调用getEntryAction，并且仅在退出状态时调用getExitAction。 其余时间状态为活动状态，调用getAction。 getTransitions方法应返回从此状态传出的转换列表。 转换接口具有以下形式： class Transition { def isTriggered(); def getTargetState(); def getAction(); } The isTriggered method returns true if the transition can fire; the getTarget-State method reports which state to transition to; and the getAction method returns a list of actions to carry out when the transition fires. 如果转换可以触发，则isTriggered方法返回true; getTarget-State方法报告要转换到的状态; 并且getAction方法返回转换触发时要执行的操作列表。 Transition Implementation ：实现转换Only one implementation of the state class should be required: it can simply hold the three lists of actions and the list of transitions as data members, returning them in the corresponding get methods. 只需要一个状态类的实现：它可以简单地将三个动作列表和转换列表保存为数据成员，并在相应的get方法中返回它们。 In the same way, we can store the target state and a list of actions in the transition class and have its methods return the stored values. The isTriggered method is more difficult to generalize. Each transition will have its own set of conditions, and much of the power in this method is allowing the transition to implement any kind of tests it likes. 以同样的方式，我们可以在转换类中存储目标状态和操作列表，并使其方法返回存储的值。 isTriggered方法更难以概括。 每个转换都有自己的一组条件，这种方法的大部分功能是允许转换实现它喜欢的任何类型的条件测试。 Because state machines are often defined in a data file and read into the game at run time, it is a common requirement to have a set of generic transitions. The state machine can then be set up from the data file by using the appropriate transitions for each state. 由于状态机通常在数据文件中定义并在运行时读入游戏，因此通常需要具有一组通用转换。 然后，可以通过使用每个状态的适当转换从数据文件中设置状态机。 In the previous section on decision trees, we saw generic testing decisions that operated on basic data types. The same principle can be used with state machine transitions: we have generic transitions that trigger when data they are looking at is in a given range. 在上一节关于决策树的部分中，我们看到了对基本数据类型进行操作的通用测试决策。 相同的原理可以与状态机转换一起使用：我们具有通用转换，当它们正在查看的数据处于给定范围内时触发。 Unlike decision trees, state machines don’t provide a simple way of combining these tests together to make more complex queries. If we need to transition based on the condition that the enemy is far away AND health is low, then we need some way of combining triggers together. 与决策树不同，状态机不提供将这些测试组合在一起以进行更复杂查询的简单方法。// 如果我们需要根据敌人在远处且健康状况低的条件进行过渡，那么我们需要一些将触发器组合在一起的方法。 In keeping with our polymorphic design for the state machine, we can accom- plish this with the addition of another interface: the condition interface. We can use a general transition class of the following form: 为了与状态机的多态设计保持一致，我们可以通过添加另一个接口来实现这一点：条件接口。 我们可以使用以下形式的一般转换类： class Transition {// 条件接口类 actions def getAction(): return actions targetState def getTargetState(): return targetState condition def isTriggered(): return condition.test() } The isTriggered function now delegates the testing to its condition member.Conditions have the following simple format: isTriggered函数现在将测试委托给其条件成员。条件具有以下简单格式： class Condition { def test(); } We can then make a set of sub-classes of condition for particular tests, just like we did for decision trees: 然后，我们可以为特定测试创建一组条件子类，就像我们为决策树所做的那样： class FloatCondition (Condition) {// 数值条件 minValue; maxValue; testValue; // 我们想关注的游戏数据 def test() { return minValue 0: # Its destined for a higher level // 这表示一个更高的层级 # Exit our current state // 退出当前状态 result.actions += currentState.getExitAction() currentState = None # Decrease the number of levels to go // 当相对于目标层级为降低时 result.level -= 1 else: # It needs to be passed down // 它需要向下迁移 targetState = result.transition.getTargetState() targetMachine = targetState.parent result.actions += result.transition.getAction() result.actions += targetMachine.updateDown(targetState, -result.level) # Clear the transition, so nobody else does it // 清除转换，因此没有其他(?)执行它 result.transition = None # If we didn’t get a transition // 如果我们没有（从结果中）取得转换 else: # We can simply do our normal action // 我们可以简单的执行我们的基本行为 result.action += getAction() # Return the accumulated result // 返回积累的结果 return result # Recurses up the parent hierarchy, transitioning into # each state in turn for the given number of levels // 递归父层次结构，依次转换到指定层级号的每个状态 def updateDown(state, level): # If we’re not at top level, continue recursing // 如果不在顶层，继续递归 if level > 0: # Pass ourself as the transition state to our parent // 将自己作为转换状态传递给父状态 actions = parent.updateDown(this, level-1) # Otherwise we have no actions to add to // 否则我们将没有要添加的行为 else: actions = [] # If we have a current state, exit it // 如果当前状态存在，退出 if currentState: actions += currentState.getExitAction() # Move to the new state, and return all the actions // 转移到新的状态，并且返回所有行为 currentState = state actions += state.getEntryAction() return actions The state class is substantially the same as before, but adds an implementation for getStates: 状态类的实现与之前的实现大体相同，但是增加了一个有关getStates的实现： class State (HSMBase): def getStates(): # If we’re just a state, then the stack is just us // 如果是一个状态，那么要返回的状态栈仅有这个状态自身 return [this] # As before... def getAction() def getEntryAction() def getExitAction() def getTransitions() Similarly, the Transition class is the same, but adds a method to retrieve the level of the transition. 无独有偶，Transition类的实现也一样，但是添加了一个方法来返回的转换所在的层级。 class Transition: # Returns the different in levels of the hierarchy from # the source to the target of the transition. // 返回 def getLevel() # As before... def isTriggered() def getTargetState() def getAction() Finally, the SubMachineState class merges the functionality of a state and a state machine. 最后，SubMachineState类整合了一个状态的功能与一个状态机。 class SubMachineState (State, HierarchicalStateMachine): # Route get action to the state // 转换 def getAction(): return State::getAction() # Route update to the state machine // 转换 def update(): return HierarchicalStateMachine::update() # We get states by adding ourself to our active children // 通过将自身加入活跃子节点集中获取当前状态 def getStates(): if currentState: return [this] + currentState.getStates() else: return [this] Implementation Notes：实现说明I’ve used multiple inheritance to implement SubMachineState. For languages (or programmers) that don’t support multiple inheritance, there are two options. The Sub- MachineState could encapsulate HierarchicalStateMachine, or the Hierarchical- StateMachine can be converted so that it is a sub-class of State. The downside with the latter approach is that the top-level state machine will always return its active action from the update function, and getStates will always have it as the head of the list. 我已经使用多重继承来实现SubMachineState类。对于不支持多重继承的语言（或程序员），有两种选择。 Sub-MachineState可以封装HierarchicalStateMachine，或者Hierarchical-StateMachine可以被转换，使其成为State的子类。后一种方法的缺点是顶级状态机将始终从更新函数返回其活动操作，并且getStates将始终将其作为列表的头部。 I’ve elected to use a polymorphic structure for the state machine again. It is possible to implement the same algorithm without any polymorphic method calls. Given that it is complex enough already, however, I’ll leave that as an exercise. My experience deploying a hierarchical state machine involved an implementation using poly- morphic method calls (provided on the CD). In-game profiling on both PC and PS2 showed that the method call overhead was not a bottleneck in the algorithm. In a system with hundreds or thousands of states, it may well be, as cache efficiency issues come into play.Some implementations of hierarchical state machines are significantly simpler than this by making it a requirement that transitions can only occur between states at the same level. With this requirement, all the recursion code can be eliminated. If you don’t need cross hierarchy transitions, then the simpler version will be easier to implement. It is unlikely to be any faster, however. Because the recursion isn’t used when the transition is at the same level, the code above will run about as fast if all the transitions have a zero level. 我已经选择再次使用状态机的多态结构。没有任何多态方法调用就可以实现相同的算法。鉴于它已经足够复杂了，我将把它留作练习。我部署分层状态机的经验涉及使用多态方法调用的实现（在CD上提供）。 PC和PS2上的游戏内分析表明，方法调用开销不是算法中的瓶颈。在具有数百或数千个状态的系统中，很可能会出现缓存效率问题。分层状态机的一些实现比这更简单，因为要求转换只能在同一级别的状态之间发生。根据此要求，可以消除所有递归代码。如果您不需要跨层次转换，则更简单的版本将更容易实现。然而，它不太可能更快。因为当转换处于相同级别时不使用递归，所以如果所有转换具有零级别，则上述代码将以相同的速度运行。 Performance ：开销The algorithm is O(n) in memory, where n is the number of layers in the hierarchy. It requires temporary storage for actions when it recurses down and up the hierarchy. 该算法在内存中是O（n），其中n是层次结构中的层数。它需要临时存储操作，以便在向下和向下递增层次结构时执行操作。 Similarly, it is O(nt) in time, where t is the number of transitions per state. To find the correct transition to fire, it potentially needs to search each transition at each level of the hierarchy and O(nt) process. The recursion, both for a transition level 0 is O(n), so it does not affect the O(nt) for the whole algorithm. 类似地，它是时间上的O（nt），其中t是每个状态的转换数。要找到正确的触发转换，可能需要在层次结构的每个级别和O（nt）进程中搜索每个转换。对于转换级别 0的递归都是O（n），因此它不会影响整个算法的O（nt）。 5.3.10 COMBINING DECISION TREES AND STATE MACHINES ：决策树与状态机的结合The implementation of transitions bears more than a passing resemblance to the implementation of decision trees. This is no coincidence, but we can take it even further. Decision trees are an efficient way of matching a series of conditions, and this has application in state machines for matching transitions. We can combine the two approaches by replacing transitions from a state with a decision tree. The leaves of the tree, rather than being actions as before, are transitions to new states. 转换的实现不仅仅与决策树的实现有相似之处。这不是巧合，但我们可以更进一步。决策树是匹配一系列条件的有效方式，而且具有这种行为在用于匹配转换的状态机中有效。 我们可以通过用状态替换状态转换的方式来组合这两种方法决策树。树的叶子，而不是像以前那样的动作，是向新状态的过渡。 A simple state machine might look like Figure 5.20. 一个简单的状态机可能如图5.20所示。 The diamond symbol is also part of the UML state chart diagram format, repre- senting a decision. In UML there is no differentiation between decisions and transi- tions, and the decisions themselves are usually not labelled. In this book I’ve labelled the decisions with the test that they perform, which is clearer for our needs. 菱形符号也是UML状态图表格式的一部分，代表了一个决定。在UML中，决策和转换之间没有区别，决策本身通常没有标记。 在本书中，我用他们执行的测试标记了决策，这更符合我们的需求。 When in the “Alert” state, a sentry has only one possible transition: via the de- cision tree. It quickly ascertains whether the sentry can see the player. If the sentry is not able to see the player, then the transition ends and no new state is reached. If the sentry is able to see the player, then the decision tree makes a choice based on the distance of the player. Depending on the result of this choice, two different states may be reached: “Raise Alarm” or “Defend.” The latter can only be reached if a further test (distance to the player) passes. 当处于“警报”状态时，哨兵只有一个可能的过渡：通过决策树。它可以快速确定哨兵是否可以看到玩家。如果哨兵无法看到该玩家，则转换结束并且不会达到新的状态。如果哨兵能够看到玩家，则决策树根据玩家的距离做出选择。根据此选择的结果，可能会达到两种不同的状态：“提升警报”或“防御”。只有在进一步测试（与玩家的距离）通过后才能达到后者。 To implement the same state machine without the decision nodes, the state ma- chine in Figure 5.21 would be required. Note that now we have two very complex con- ditions and both have to evaluate the same information (distance to the player and distance to the alarm point). If the condition involved a time-consuming algorithm (such as the line of sight test in our example), then the decision tree implementationwould be significantly faster. 要在没有决策节点的情况下实现相同的状态机，将需要图5.21中的状态机。请注意，现在我们有两个非常复杂的条件，两者都必须评估相同的信息（到播放器的距离和到报警点的距离）。如果条件涉及耗时的算法（例如我们示例中的视线测试），那么决策树实现将明显更快。 Pseudo-Code ：伪代码We can incorporate a decision tree into the state machine framework we’ve developed so far. 我们可以将决策树合并到我们迄今为止开发的状态机框架中。 The decision tree, as before, consists of DecisionTreeNodes. These may be decisions (using the same Decision class as before) or TargetStates (which replace the Action class in the basic decision tree). TargetStates hold the state to transition to and can contain actions. As before, if a branch of the decision tree should lead to no result, then we can have some null value at the leaf of the tree. 与以前一样，决策树由DecisionTreeNodes组成。这些可能是决策（使用与之前相同的Decision类）或TargetStates（它们替换基本决策树中的Action类）。 TargetStates保持状态转换并可以包含操作。和以前一样，如果决策树的一个分支应该导致没有结果，那么我们可以在树的叶子上有一些空值。 The decision making algorithm needs to change. Rather than testing for Actions to return, it now tests for TargetState instances: 决策算法需要改变。它不是测试要返回的Actions，而是测试TargetState实例： We can then build an implementation of the Transition interface which supports these decision trees. It has the following algorithm: 然后我们可以构建支持的Transition接口的实现这些决策树。它有以下算法： Implementation：实现As before, this implementation relies heavily on polymorphic methods in an object- oriented framework. The corresponding performance overhead may be unacceptable in some cases where lots of transitions or decisions are being considered.和以前一样，这种实现在很大程度上依赖于面向对象框架中的多态方法。在考虑大量转换或决策的某些情况下，相应的性能开销可能是不可接受的。]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>Artificial Intelligence for Games</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unity shader 渲染管线]]></title>
    <url>%2F2018%2F10%2F22%2FUnity%E7%AC%94%E8%AE%B0%2Funity-shader-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[GPU图形渲染管线流程流程概述应用程序阶段应用程序阶段，使用高级编程语言(C、C++、JAVA 等)进行开发，主要和CPU、内存打交道，诸如碰撞检测、场景图建立、空间八叉树更新、视锥裁剪等经典算法都在此阶段执行。在该阶段的末端，几何体数据(顶点坐标、法向量、纹理坐标、纹理等)通过数据总线传送到图形硬件。 工作： 准备场景数据：如摄像机的位置、视锥体、场景中包含的模型、光源等 粗粒度剔除：把不可见的物体剔除 设置好每个模型的渲染状态：包括材质、使用的纹理、使用的Shader等 输出： 渲染图元：渲染所需的几何信息 几何阶段几何阶段，主要负责顶点坐标变换、光照、裁剪、投影以及屏幕映射，该阶段基于GPU进行运算，在该阶段的末端得到了经过变换和投影之后的顶点坐标、颜色、以及纹理坐标。光照计算属于几何阶段，因为光照计算涉及视点、光源和物体的世界坐标，所以通常放在世界坐标系中进行计算。 工作： 决定需要绘制的图元是什么 怎样绘制 在哪里绘制 输出： 屏幕空间的二维顶点坐标 每个顶点的深度值、着色等相关信息 光栅阶段 光栅阶段，基于几何阶段的输出数据，为像素(Pixel)正确配色，以便绘制完整图像，该阶段进行的都是单个像素的操作，每个像素的信息存储在颜色缓冲器(color buffer 或者 frame buffer)中。 雾化以及涉及物体透明度的计算属于光栅化阶段，因为上述两种计算都需要深度值信息(Z 值)，而深度值是在几何阶段中计算，并传递到光栅阶段的。 工作：根据上个阶段传递的数据来产生屏幕上的像素，并渲染出最终的图像。 输出：逐像素处理过的渲染图元。 从几何阶段到光栅化阶段： 几何阶段：变换三维顶点坐标和光照计算 将模型空间坐标（object space coordinate）通过四阶矩阵变换矩阵（world matrix）转换为世界空间坐标（ world space coordinate ）。 进行光照计算。 将模型空间下的顶点法向量转换为世界空间下的，所用的转换矩阵为world matrix的转置矩阵的逆矩阵。 将物体顶点坐标从世界空间（world space）转换到观察空间下（eye space）。 将顶点坐标从观察空间下转换到裁剪空间下（project and clip space）。 投影：用透视变换矩阵把顶点从视锥体（viewing frustum）中变换到裁剪空间的规范立方体（CVV）中。 图元装配（Primitive Assembly）：将顶点根据原始的连接关系还原出网格结构。 裁剪：在CVV中将位于视体外的场景数据去除。 将得到的完全位于视体中的场景数据映射到屏幕坐标系上。 光栅化阶段：决定哪些像素被集合图元覆盖。光栅化是将几何数据经过一系列变换后最终转换为像素，从而呈现在显示设备上的过程，光栅化的本质是坐标变换，几何离散化。 三角形设置：计算光栅化一个三角网格所需的信息 三角形遍历：检查每个像素是否被一个三角网格所覆盖，被覆盖则生成一个片元（对顶点信息插值）。 读取模型的顶点，3个3个的读，因为要画三角形。 将3个顶点两两连成线，形成三角形。 计算屏幕像素点在三角形内还是三角形外。在三角形内部的，就上色（颜色是之前算出来的），在三角形外部的，就不上色。http://www.cnblogs.com/graphics/archive/2010/08/05/1793393.html（可以通过叉积来实现，连接PA，将PA和AB做叉积，再将CA和AB做叉积，如果两个叉积的结果方向一致，那么两个点在同一测。判断两个向量的是否同向可以用点积实现，如果点积大于0，则两向量夹角是锐角，否则是钝角。） Pixel Operation 纹理操作（Texture operation）：根据像素的纹理坐标，查询对应的纹理值。 消除遮挡面：深度测试，模版测试等。 混色（Blending）：根据目前已经画好的颜色，与正在计算的颜色的透明度(Alpha)，混合为两种颜色，作为新的颜色输出。 滤波（Filtering）：将正在算的颜色通过某种滤波后输出。 HLSL、GLSL与Cg：常见的着色语言： DirectX的HLSL：微软控制着色器编译，编译结果在不同硬件上相同，但平台有限。 OpenGL的GLSL：跨平台性良好，编译结果取决于硬件供应商。 NVIDIA的Cg：真正的跨平台。 DrawCall：CPU调用图像编程接口，命令GPU进行渲染的操作。 Shader： GPU流水线上一些可高度编程的阶段，由着色器编译出来的最终代码会在GPU上运行 有一些特定类型的着色器 依靠着色器来控制流水线中的渲染细节。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[六月七日随笔]]></title>
    <url>%2F2018%2F06%2F07%2F%E9%9A%8F%E7%AC%94%2F%E5%85%AD%E6%9C%88%E4%B8%83%E6%97%A5%E9%9A%8F%E7%AC%94%2F</url>
    <content type="text"><![CDATA[无聊夜晚的碎碎念罢了。 近来还好。 不知道是什么原因，现在拿起笔或者打开word，面对着一片空白，总不知道该敲下点什么。但是偏偏又觉得应该写点什么，作为一种记录被遗忘，在机缘巧合之下向某个尘封已久的服务器发出一个请求，再把这点文字翻出来，以一种陌生人的眼光重新审视当时的自己。 事实上，以上所描述的情况很可能不会发生，于我自己而言，以往写过的那些烂东西（包括这一篇），我只能让它静静地躺在我的日志列表里，并不指望以后翻出来再得到什么愉悦的享受。 之所以有记录的想法，与对他人的效仿不无关系。去年工程实训的时候偶然接触到学长的游戏——《没有人知道的大冒险》，后来在种子班宣讲的时候才得知，原来这款游戏是学长所做。我对这个游戏本身所表达的内容很有感触，便由此对学长其人也生出了些许好奇。互联网是有记忆的，我还是找到了学长的博客，虽然它已经好久没有更新，但是我还是从他当时的文字中依稀看到他当时的状态。我想，文字的魅力在于，它无法向你描述所有，但是你却可以从文字本身生发出基于你人生经验的幻想世界。它或许只是一个截面、一个场景、甚至是一种氛围，但是却可以给你无比真实的代入感。 但是记录仅仅是记录本身，它代表着我当下思想的一部分——用文字所能表述的那部分。 很久没有读过书，我是指文学类的书籍。笼统的把原因归结为每天太忙其实是不成立的，每天固然有很多事情要去做，但是闲下来的时间，还是投入到了无限的收割快速愉悦事业中去了。刷刷微博、看看视频、翻翻好友的动态（所幸目前还没有接触短视频），我的大脑就告诉我：“哦，我感受到多巴胺了！”。纵使我知道这世界也没那么需要我，也没有什么动态是非我知道不可的，我还是这样做了。低级并快乐。 伴随而来的就是，快乐的阈值提高了，而表达自己的水平降低了。可表达的事情越来越少，能感触到的事情也越来越少。我从心底里觉得这不是什么好事，当一部分情绪很久不再出现在你的备选项中，其实是一件非常无聊的事情。就如同炒菜少了那么几位调料，寡淡而无趣。 很清楚的意识到这一点的时候，大概是在成都站的gamejam结束，当主持人宣布第二组入围的时候，我以为我会很开心，但是并没有发生。对事物的好奇、对成就的满足和那种单纯的想要做某件事情的欲望——这些好像都在离我而去。 当然，这或许可以解释为所谓的“佛系”或者“人间不值得”或者随便一句什么用烂了的腔调，但是我想我不该是这样，我想象中的自己是一个有血有肉的、愚蠢的、有着清楚欲望的年轻人，而不是一个默认着某些事情发生、而盲从于某些“看起来好”的人。 我知道这团火终归会熄，但至少不应该是现在。 无知且狂妄总要好过纠结且麻木，起码前者看起来还活着。 先记到这。]]></content>
      <categories>
        <category>文字</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity Shader 基础]]></title>
    <url>%2F2018%2F05%2F11%2FUnity%E7%AC%94%E8%AE%B0%2FUnity-Shader-%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Unity Shader的一些基础知识 Chapter3 Unity Shader 基础概述在Unity需要材质（Material）与Unity Shader配合使用来达到满意的效果。 Unity Shader定义了渲染需要的各种代码（顶点着色器与片元着色器等），属性（使用哪些纹理）和指令（渲染和标签设置），我们通过材质调节这些属性，再赋给相应的模型。 材质：配合GameObject的Mesh或者Particle Systems组件来工作。 Unity Shader： Standard Surface Shader:使用了一个包含了标准光照模型的表面着色器模板 Unlit Shader: 一个不包含光照但是包含雾效的基本顶点/片元着色器 Image Effect Shader: 为实现屏幕后处理提供基本模板 Compute Shader: 借助GPU的并行性来进行一些与渲染流水线无关的计算 ShaderLab一款专门为Unity Shader服务的语言。 Properties 属性 语句格式：Name(&quot;display name&quot;,PropertyType)=DefaultValue 支持的属性类型： |属性类型|定义语法| |:————:|:————:| |Int|number| |Float|number| |Range(min,max)|number| |Color|(number,number,number,number)| |Vector|(number,number,number,number)| |2D|”defaulttexture”{}| |Cube|”defaulttexture”{}| |3D|”defaulttexture”{}| Unity允许重载默认的材质编辑面板以提供更多的自定义数据类型。 关键词“Custom Shader GUI”Properties语义块的作用仅仅是为了让这些属性可以出现在材质面板里。 SubShader:表面着色器 语句格式 SubShader{ //可选的，标签 [Tags] //可选的，状态 [RenderSetup] //一次完整的渲染流程，如果pass的数目过多，会造成渲染性能的下降。 Pass{ } ... } RenderSetup 状态：关于渲染状态的设置指令| 状态名称 | 设置指令 |解释||:————:|:————:|:——:|| Cull |Cull Back/Front/Off| 剔除模式：剔除背面/正面/关闭剔除||ZTest|ZTest Less Greater/LEqual/GEqual/Equal/NotEqual/Always|设置深度剔除时使用的函数||ZWrite|ZWrite On/Off|关闭/开启深度写入||Blend|Blend SrcFactor DstFactor|开启并设置混合模式| Tags 标签：希望怎样以及何时渲染这个对象Tags{&quot;TagName1&quot;=&quot;Value1&quot; &quot;TagName2&quot;=&quot;Value2&quot;}| 标签类型 | 说明 ||————|————|| Queue | 控制渲染顺序，指定该物体属于哪一个渲染队列 ||RenderType|对着色器进行分类，可以用于着色器替换功能||DisableBatching|指明是否对该SubShader使用批处理||ForceNoShadowCasting|控制使用该SubShader的物体是否会投射阴影||IgnoreProjector|控制使用该SubShader的物体是否受projector（投影仪？）的影响||CanUseSpriteAtlas|当该SubShader是用于sprite时，将该标签设为“false”||PreviewType|指明材质面板将如何预览该材质。默认材质下，材质将显示为一个球形，我们可以通过将该标签的值设为“Plane”“SkyBox”来改变预览类型|上述标签可以在SubShader中声明，而不可以在Pass块中声明，Pass块有专属于自己的标签。 Pass语义块： Pass{ [Name] [Tag] [RenderSetup] // Other code } Name “MyPassName”：定义该Pass的名称，可以使用UsePass命令来直接使用其他unity shader中的Pass，例如：UsePass &quot;MyShader/MYPASSNAME&quot;，由于Unity 内部会将所有Pass 名称转换为大写字母的表示，所以在使用UsePass的时候必须使用大写形式的名字。 RenderSetup：我们可以对Pass设置渲染状态，除上述状态设置以外，我们还可以使用固定管线的着色器。 Tag：|标签类型|说明|例子||—-|——|—-||LightMode|定义该Pass在Unity渲染流水线中的角色|Tags{“LightMode”=”ForwardBase”}||RequireOptions|用于制定当满足某些条件的时候才渲染该Pass，它的值是一个由空格分割的字符串，目前支持的选项：SoftVegetation|Tags{“RequireOptions”=”SoftVegetation”}| 特殊的Pass： UsePass：使用该指令复用其他UnityShader中的Pass。 GrabPass：负责抓取屏幕并将结果存储在一张纹理之中，以用于后续的Pass 处理。 FallBack如果上面所有的SubShader在这块显卡上都不能运行，那么就用这个最低级的Shader。 FallBack "name" // 或者 FallBack Off 通过一个字符串通知引擎最低级的Shader是哪个，也可以关闭Fallback功能——如果上述的SubShader无法使用，那就不要管它了。 其他语义 拓展编辑界面：CustomEditor 对命令进行分组：CateGory UnityShader的形式ShaderLab语句块： Shader "Myshader"{ Properties{ // 所需的各种属性 } SubShader{ // 真正意义上的SubShdaer代码会出现在这里 // 表面着色器(Surface Shader) // 顶点/片元着色器(Vertex/Fragment Shader) // 固定函数着色器(Fixed Function Shader) } SubShader{ // 与上一个Shader类似 } } 表面着色器当给Unity提供一个表面着色器的时候，它在背后依旧将其转换为对应的顶点/片元着色器。意义在于Unity为我们处理了很多光照细节，使得我们无需再操心这些事情。 Shader "Custom/Simple Surface Shader"{ SubShader{ Tags{ "RenderType" = "Opaque" } CGPROGRAM #pragma surface surf Lambert struct Input { float4 color:COLOR; }; void surf (Input IN,inout SurfaceOutput o) { o.Albedo = 1; } ENDCG } Fallback "Diffuse" } 表面着色器被定义在SubShader语义块中的CGPROGRAM与ENDCG之间。之间的代码使用Cg/HLSL语言编写，它嵌套在ShaderLab语言中。 顶点/片元着色器顶点/片元着色器的代码需要定义在CGPROGRAM与ENDCG之间，而着色器是写在Pass语义块内，而非SubShader内，这样做来定义每个Pass需要的Shader代码，灵活性更高，同时控制渲染的实现细节。 Shader "Custom/Simple VertexFragment Shader"{ SubShader{ Pass{ CGPROGRAM #pragma vertex vert #pragma fragment frag float4 vert(float4 v:POSITION):SV_POSITION{ return mul(UNITY_MATRIX_MVP,v); } fixed4 frag():SV_Target{ return fixed4(1.0,0.0,0.0,1.0); } ENDCG } } } 固定函数着色器上面两种UnityShader形式都使用了可编程管线，而对于一些旧的设备不支持可编程管线着色器，此时需要使用固定函数着色器来完成渲染，这些着色器往往只可以完成一些非常简单的效果。 Shader "Tutorial/Basic"{ Properties{ _Color("Main Color",color)=(1.0,5.0,5.1) } SubShader{ Pass{ Material{ Diffuse[_Color] } Lighting On } } } 乐乐女神的一些建议： 除非有明确的需求必须要使用固定函数着色器，否则请使用可编程管线的着色器。 如果想和各种光源打交道，你可能更喜欢表面着色器，但需要小心它在移动平台的性能表现。 如果需要使用的光照数目非常少，使用顶点/片元着色器是一个更好的选择。 如果有很多自定义的渲染效果，请选择顶点/片元着色器。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Unity】 Cursor学习]]></title>
    <url>%2F2018%2F04%2F11%2FUnity%E7%AC%94%E8%AE%B0%2FUnity-Cursor%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[关于CursorLockMode 光标锁定模式的一个随手记。 CursorLockMode.None 光标行为未修改，第一人称视角下鼠标可以突破窗口。 CursorLockMode.Locked 光标锁定到游戏窗口的中心，与全屏与否无关，同时隐藏光标（这一点在3D相机下成立，在2D相机下貌似不成立，还需要用visible来控制隐藏），无论如何移动光标光标都无法出现，按‘esc’切换到None模式。 CursorLockMode.Confined 光标限制在游戏窗口内，光标不会隐藏，在窗口模式下无法突破窗口，限制在窗口区域内。 Cursor.visible 光标可见性，和人感觉用来实现鼠标隐藏的效果并不好，或许和Confined联合可以有Locked的效果？那为什么不用Locked呢…… 示例代码：https://docs.unity3d.com/ScriptReference/Cursor-lockState.html资料来源：http://wiki.ceeger.com/script/unityengine/enumerations/cursorlockmode/cursorlockmode]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>unity学习</tag>
      </tags>
  </entry>
</search>
