<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Minigame以及其他有的没的</title>
      <link href="/2020/09/17/%E9%9A%8F%E7%AC%94/Minigame%E4%BB%A5%E5%8F%8A%E5%85%B6%E4%BB%96%E6%9C%89%E7%9A%84%E6%B2%A1%E7%9A%84/"/>
      <url>/2020/09/17/%E9%9A%8F%E7%AC%94/Minigame%E4%BB%A5%E5%8F%8A%E5%85%B6%E4%BB%96%E6%9C%89%E7%9A%84%E6%B2%A1%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h4 id="从上海归来："><a href="#从上海归来：" class="headerlink" title="从上海归来："></a>从上海归来：</h4><p>这一段时间在搞Minigame，有点感触。从上海和顺佬还有翔仔回来的路上还是挺挫败的，一方面是有点中二的想法，感觉自己GameJam的好运气到此为止了；另一方面是觉得自己的技术力实在是不太行，有点对不起我的队友们；还有一方面是觉得是不是有的时候过于主观了，就像顺佬自述「我的优点是听人讲话」，感觉自己有时候对于别人的想法还是有点不太重视？</p><p>从上海那次回来之后，挫败感也没有持续太久，当时在回酒店还是哪里的大巴上和隆德聊着说还是应该多看看GameJam的优秀作品找点启发。可除了整理了一个<a href="http://mosswang.com/2019/12/18/%E9%9A%8F%E7%AC%94/Ludum-Dare-%E5%8E%86%E5%B1%8A%E4%B8%BB%E9%A2%98/" target="_blank" rel="noopener">Ludum Dare历届主题</a>之外，也没有额外的做什么事，只是在某次Minigame开会上临时抱佛脚的看了几个Demo。</p><p>当然这远远不够，等我再入职之后，和蒙哥聊起来什么「localmotion」说的我一愣一愣的，感觉对于游戏开发还是了解的太少太少了。</p><p>哀叹至此，实际上对现状也不会产生什么影响，还是说回本次Minigame。</p><h4 id="Minigame和表达"><a href="#Minigame和表达" class="headerlink" title="Minigame和表达"></a>Minigame和表达</h4><p>这次的MiniGame定的主题就是一个「文学」向的拼字游戏，为什么要给文学加引号呢，是因为本质上玩法并不怎么文学，只是拼字组成某种东西罢了。我们对于字的理解不会比其他人更多。</p><p>说来有点好笑，一开始我们的两个想法都是所谓的「公益」游戏，但实际上，我觉得游戏其实还是好玩比较重要。这点也是前不久才转变观点的，还和顺佬聊过。此前以为个人表达很重要，我可以不care任何受众，只表达我想表达的：当然这全然可以，只不过以部分人的水平来看，这么搞只会做出一团只有自己可以理解的shit，此外在表达自我和让它变得有趣or让更多的人可以理解之间并不冲突，其间的难处在于这需要一定的技术和审美。这里的技术不单单是指编码的技术，而是综合起来让自己的表达更高级的技术。</p><p>这很难。</p><p>当然这是现阶段看来一条值得追求的方向，即在提升自己技术力的同时，多多试着<strong>感受、记录、表达和修正</strong>（或者说优化）。</p><h4 id="该做什么"><a href="#该做什么" class="headerlink" title="该做什么"></a>该做什么</h4><ul><li>最直观的应该是完成之前说的<strong>多看看GameJam视频</strong>，积累积累灵感，类似<a href="[https://skmtjun.github.io/2018/04/10/%E9%AA%91%E7%A0%8D%E7%9B%BE%E7%89%8C%E5%88%86%E6%9E%90/](https://skmtjun.github.io/2018/04/10/骑砍盾牌分析/">骑砍盾牌分析 by SecluSong</a>)这类积累可以多做一做，哦，按我司的话来说应该是多沉淀一些。</li><li>再上一层的可能是<strong>多试着去实现一些东西</strong>，保持一个手热的状态，对于自己的知识库应该不断更新巩固，而不是一劳永逸，很多东西可能放一段时间之后就忘掉了。</li><li>再上一层的其实是一些生活上的一些东西，比如如何提高效率，如何利用下班时间提升自己（当然这属于知乎经典句式了），这些都还有待探索和学习，感觉可以先从调整作息开始，既然晚上的时间不多，其实可以早点睡觉，早上起来做一些事情。</li></ul><h4 id="最后的最后"><a href="#最后的最后" class="headerlink" title="最后的最后"></a>最后的最后</h4><p>想了一些方法，但是说出来像是flag一样的东西，所以还是等验证过，有些结果之后再总结一下。</p>]]></content>
      
      
      <categories>
          
          <category> 文字 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“2020年第33周周报”</title>
      <link href="/2020/08/19/%E4%B8%AA%E4%BA%BA%E6%8A%A5%E5%91%8A/202033/"/>
      <url>/2020/08/19/%E4%B8%AA%E4%BA%BA%E6%8A%A5%E5%91%8A/202033/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>这是2020年的第33周报告。</p><h3 id="上周计划完成情况"><a href="#上周计划完成情况" class="headerlink" title="上周计划完成情况"></a>上周计划完成情况</h3><ul><li>导师给Review了一下代码，改了之后提交了。</li><li>测试了一下性能，没什么问题。</li></ul><h3 id="本周做了什么"><a href="#本周做了什么" class="headerlink" title="本周做了什么"></a>本周做了什么</h3><ul><li>接了一个新需求，目前就是在看新需求涉及到的相关代码。</li><li>在看现有系统有没有可以重构的地方。</li><li>购物：<ul><li><a href="https://book.douban.com/subject/30676070/" target="_blank" rel="noopener">《世界经典鸡尾酒大全（珍藏版）》</a>，可以说受到<a href="https://www.douban.com/game/26847236/" target="_blank" rel="noopener">《赛博朋克酒保行动 VA-11 Hall-A: Cyberpunk Bartender Action》</a>的强烈影响，对调酒有点感兴趣，二手书，130r。</li><li>摩飞的多功能锅，打算学学做饭，750r。</li></ul></li><li>投资：<ul><li>定投50r。</li><li>把1000左右放进余额宝了。</li></ul></li><li>锻炼：无，体重维持在150上下，有点怪，现在进入了平衡，虽然感觉每天上下班汽车运动量也很大，但是从数字上看还是不太行。</li></ul><h3 id="下周打算做点什么"><a href="#下周打算做点什么" class="headerlink" title="下周打算做点什么"></a>下周打算做点什么</h3><ul><li>弹电吉他，我的电吉他到了，买了4年了还没有好好练过。</li><li>看看Unity的知识，写一点小轮子。</li><li>锻炼，看EVA。</li></ul>]]></content>
      
      
      <categories>
          
          <category> reports </category>
          
      </categories>
      
      
        <tags>
            
            <tag> report </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“2020年第32周周报”</title>
      <link href="/2020/08/09/%E4%B8%AA%E4%BA%BA%E6%8A%A5%E5%91%8A/202032/"/>
      <url>/2020/08/09/%E4%B8%AA%E4%BA%BA%E6%8A%A5%E5%91%8A/202032/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>这是2020年的第32周报告。</p><h3 id="上周计划完成情况"><a href="#上周计划完成情况" class="headerlink" title="上周计划完成情况"></a>上周计划完成情况</h3><ul><li>邮箱基本上重构完成了，wiki读的还是太少，周五的时候把代码提了，等新包出来测试一下。</li></ul><h3 id="本周做了什么"><a href="#本周做了什么" class="headerlink" title="本周做了什么"></a>本周做了什么</h3><ul><li>前两天去事业群的培训了，大概就是通知一些事情。</li><li>开始读《<a href="https://book.douban.com/subject/27033749/" target="_blank" rel="noopener">大象无形：虚幻引擎程序设计浅析</a>》，周末打游戏的时候脑海里总回想着“客户端是对服务端的拙劣模仿”这句话，可能是打游戏的时候总卡顿的缘故。还是要多看文档。</li><li>购物，简要清单如下：<ul><li>铁三角CLR100，99r，放在公司用来听电脑的音频。</li></ul></li><li>投资：买了50块的基金，每周一 定投50r。</li><li>锻炼：无，体重维持着150上下。</li><li>公益：给水灾捐了20r，助学捐了20r</li></ul><h3 id="下周打算做点什么"><a href="#下周打算做点什么" class="headerlink" title="下周打算做点什么"></a>下周打算做点什么</h3><ul><li>我必健身环。</li><li>看看Unity的知识，阅读项目代码，接需求。</li><li>等补发的自行车零件到了就可以骑自行车上班了。</li></ul>]]></content>
      
      
      <categories>
          
          <category> reports </category>
          
      </categories>
      
      
        <tags>
            
            <tag> report </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“2020年第31周周报”</title>
      <link href="/2020/08/05/%E4%B8%AA%E4%BA%BA%E6%8A%A5%E5%91%8A/202031/"/>
      <url>/2020/08/05/%E4%B8%AA%E4%BA%BA%E6%8A%A5%E5%91%8A/202031/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>这是2020年的第31周报告。</p><h3 id="上周计划完成情况"><a href="#上周计划完成情况" class="headerlink" title="上周计划完成情况"></a>上周计划完成情况</h3><ul><li>邮箱重构要比想象中难很多，导师说的原来是两周不是两天。</li></ul><h3 id="本周做了什么"><a href="#本周做了什么" class="headerlink" title="本周做了什么"></a>本周做了什么</h3><p>入职快一个月了，上周去封闭培训了，所以两周报告和在一起，简单讲讲做了什么：</p><ul><li><p>封闭培训，认识了一些还不错的人，但我并不怀念它。</p></li><li><p>阅读项目源码并重构某系统：大概实际耗时应该在5天，其中某些流程卡了我很久，还有一个恶性Bug需要明天去公司解决，如果顺利的话这周就能解决（希望这周就能解决，听说下周要接现行分支上的需求了）。</p></li><li>购物，简要清单如下：<ul><li>充电宝：99r，华为</li><li>瑜伽垫：49r，用于健身环大冒险</li><li>剃须刀：小米</li><li>自行车：600r，凤凰，通勤用</li><li>上述消费大概在1000以内</li></ul></li><li>锻炼：两周实际上没有怎么锻炼，封培期间一直在忙各种事，开始上班之后才能走走路，重新回到每天1w+的节奏，体重从7月25日的152.7斤降到了149.2斤，距离目标体重还有29.2斤。</li><li>本周开销较少，都是一些一次性消费重复使用的物品。</li><li>书影音：基本没有。</li></ul><h4 id="只言片语："><a href="#只言片语：" class="headerlink" title="只言片语："></a>只言片语：</h4><p>这部分是从封培期间得到的一点体悟：</p><blockquote><p>用<strong>利益</strong>驱动别人构成合作。（其实是换位思考的一种，想想对方想要什么。）</p><p>沟通时把别人当傻逼似的事无巨细有助于帮助你把潜在的傻逼教成正常人，从而规避掉坑。</p><p>人太分奴，或者得失心太重有时候会搞得吃相太难看。 </p><p>待人礼貌是基本原则。</p></blockquote><h3 id="下周打算做点什么"><a href="#下周打算做点什么" class="headerlink" title="下周打算做点什么"></a>下周打算做点什么</h3><ul><li>把邮箱系统重构完，梳理整个系统结构。</li><li>学习性能分析部分。</li><li>读书，学习Lua和Unity。</li><li>找个周末去看场电影，《乔乔的奇妙冒险》、《妙先生》都在想看之列。</li></ul>]]></content>
      
      
      <categories>
          
          <category> reports </category>
          
      </categories>
      
      
        <tags>
            
            <tag> report </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“2020年第29周周报”</title>
      <link href="/2020/07/18/%E4%B8%AA%E4%BA%BA%E6%8A%A5%E5%91%8A/202029/"/>
      <url>/2020/07/18/%E4%B8%AA%E4%BA%BA%E6%8A%A5%E5%91%8A/202029/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>这是2020年的第29周报告。</p><h3 id="本周做了什么"><a href="#本周做了什么" class="headerlink" title="本周做了什么"></a>本周做了什么</h3><p>这周是入职之后的经历过的第一个完整的一周，简单讲讲做了些什么。</p><ul><li>阅读项目源码：项目发展到现在已经很庞大了，如果想要入手需要对整个项目有一个明确的认识，这一周就择性的阅读了项目的源码。</li><li>购物，简要清单如下：<ul><li>吹风机：小米</li><li>台灯：小米</li><li>桌子：宜家</li><li>椅子：宜家</li><li>邮差包：TIMBUK2</li></ul></li><li>锻炼：除了每天的1w+步以外，周三还玩了10分钟的健身环大冒险，体重情况则从157斤减少到了154斤，距离目标还有30斤。</li><li>本月开销较大，粗略计算达到了惊人的15600块，其中有12000属于房租，暂无收入。<ul><li>想了下不是暂无收入，四个月前买了10块钱的基金，前两天卖了，扣除手续费之后大概卖了10块零八毛。</li></ul></li><li>书影音：<ul><li>在读《<a href="https://book.douban.com/subject/27108476/" target="_blank" rel="noopener">Lua设计与实现</a>》和《<a href="https://book.douban.com/subject/30262035/" target="_blank" rel="noopener">Lua程序设计</a>》</li><li>看过了《<a href="https://movie.douban.com/subject/1307394/" target="_blank" rel="noopener">千年女优</a>》，很喜欢，运镜太流畅了。</li><li>游戏打了打《<a href="https://www.douban.com/game/33438620/" target="_blank" rel="noopener">和平精英</a>》，算是做作业了。</li></ul></li></ul><h4 id="只言片语："><a href="#只言片语：" class="headerlink" title="只言片语："></a>只言片语：</h4><blockquote><p>​        「我们一切都是从体验出发，我们要去了解后台那边是怎么写的，如果仅仅是少了几个函数，导致体验变差了，他们不给我们改，这说不过去的。」——我们组长和其他前辈沟通时说的话，有点动人。</p></blockquote><blockquote><p>​        「企业会怕你混日子，不怕你有企图。」——请教张老师后，张老师给出的点拨，挺有道理的，欲望写在脸上，如果是正当的欲望，没什么不好，我这人其实有欲望，但是因为胆怯或者懦弱总不愿意表达出来，感觉有的时候有点吃亏。</p></blockquote><h3 id="下周打算做点什么"><a href="#下周打算做点什么" class="headerlink" title="下周打算做点什么"></a>下周打算做点什么</h3><ul><li>工作：把邮箱系统改写好，听导师说好像两三天就能写好（？）。</li><li>体重：再减三斤！</li><li>书影音：<ul><li>把在读的两本书尽量读一些。</li><li>电影的话可能会再看一部今敏的片子。</li></ul></li><li>消费：自行车？还有一些衣物。</li><li>自我盘点：<ul><li>工作时应该更专心，必要时应该去除一些干扰。</li><li>记得写日志和周报，起码让你的上级了解你在做什么，这没什么坏处，就够了。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> reports </category>
          
      </categories>
      
      
        <tags>
            
            <tag> report </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“2020年第21周周报”</title>
      <link href="/2020/05/26/%E4%B8%AA%E4%BA%BA%E6%8A%A5%E5%91%8A/202021/"/>
      <url>/2020/05/26/%E4%B8%AA%E4%BA%BA%E6%8A%A5%E5%91%8A/202021/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>这是2020年的第21周报告（0518～0524）。</p><h3 id="上周计划完成情况"><a href="#上周计划完成情况" class="headerlink" title="上周计划完成情况"></a>上周计划完成情况</h3><blockquote><p>摸鱼。</p></blockquote><h3 id="本周做了什么"><a href="#本周做了什么" class="headerlink" title="本周做了什么"></a>本周做了什么</h3><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><ul><li><p>答辩：18号毕业答辩结束，反正是平平淡淡就结束了，竟然还有点怅然若失，不知道是不是没有进行过一段校园恋情的缘故，还是对未来的迷茫，也或者两者都有。</p></li><li><p>答辩结束之后提交各种表格，文档。</p></li><li><p>摄影一则：寒风中接着大街上插座给手机充电的男子。生活不易啊。</p><p><img src="http://hust_mo.gitee.io/blogpicturerepo/IMG_37032.jpg" alt></p></li></ul><h4 id="消费"><a href="#消费" class="headerlink" title="消费"></a>消费</h4><ul><li>机票退款了，退了一半。</li></ul><h3 id="下周打算做点什么"><a href="#下周打算做点什么" class="headerlink" title="下周打算做点什么"></a>下周打算做点什么</h3><ul><li>看看蒙哥推荐的那个那本小说：《doom启示录》</li><li>尝试着写一个软渲染的Demo。</li><li>学C++。</li></ul>]]></content>
      
      
      <categories>
          
          <category> reports </category>
          
      </categories>
      
      
        <tags>
            
            <tag> report </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“2020年第20周周报”</title>
      <link href="/2020/05/26/%E4%B8%AA%E4%BA%BA%E6%8A%A5%E5%91%8A/202020/"/>
      <url>/2020/05/26/%E4%B8%AA%E4%BA%BA%E6%8A%A5%E5%91%8A/202020/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>这是2020年的第20周报告（0511～0517）。</p><h3 id="上周计划完成情况"><a href="#上周计划完成情况" class="headerlink" title="上周计划完成情况"></a>上周计划完成情况</h3><blockquote><p>毕业论文：把论文的重复率降了下来。</p></blockquote><h3 id="本周做了什么"><a href="#本周做了什么" class="headerlink" title="本周做了什么"></a>本周做了什么</h3><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><ul><li>论文：把论文的内容修改了一下。</li><li>制作了一个毕业设计答辩的PPT和对应的讲稿。</li></ul><h4 id="消费"><a href="#消费" class="headerlink" title="消费"></a>消费</h4><ul><li>返校机票：¥880</li><li>无主之地3：¥35.48，Epic就是我大哥。</li><li>发现账本app只记到11日，没有坚持记账的习惯并不好。</li></ul><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><ul><li><p>看了Epic关于Unreal Engine 5的演示视频，有点恍惚，我还能跟得上吗？</p><p><a href="https://www.bilibili.com/video/BV1BK411W75W?from=search&amp;seid=5691921854571944731" target="_blank" rel="noopener">虚幻引擎5！！！4K画质PS5实机演示！</a></p></li></ul><h3 id="下周打算做点什么"><a href="#下周打算做点什么" class="headerlink" title="下周打算做点什么"></a>下周打算做点什么</h3><ul><li>摸鱼</li></ul>]]></content>
      
      
      <categories>
          
          <category> reports </category>
          
      </categories>
      
      
        <tags>
            
            <tag> report </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“2020年第19周周报”</title>
      <link href="/2020/05/12/%E4%B8%AA%E4%BA%BA%E6%8A%A5%E5%91%8A/202019/"/>
      <url>/2020/05/12/%E4%B8%AA%E4%BA%BA%E6%8A%A5%E5%91%8A/202019/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>这是2020年的第19周报告（0504～0510）。</p><h3 id="上周计划完成情况"><a href="#上周计划完成情况" class="headerlink" title="上周计划完成情况"></a>上周计划完成情况</h3><blockquote><p>毕业设计：改初稿。</p></blockquote><p>8号老师才给我反馈意见，在这之前基本上是放飞自我，这之后开始苦哈哈的改稿。</p><h3 id="本周做了什么"><a href="#本周做了什么" class="headerlink" title="本周做了什么"></a>本周做了什么</h3><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><ul><li><p>摄影：</p><p><img src="http://hust_mo.gitee.io/blogpicturerepo/R0000495.jpg" alt></p><p>姑且命名为「马其顿防线」</p></li><li><p>改论文稿。</p></li></ul><h4 id="消费"><a href="#消费" class="headerlink" title="消费"></a>消费</h4><ul><li>美的台灯：¥59，之前搬家，东西都搬走了，在家这边又买了一个台灯，和寝室用的一样，能亮就行。</li><li>和朋友聚餐：¥88，社交花费。</li></ul><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><ul><li>《<a href="https://movie.douban.com/subject/27038183/" target="_blank" rel="noopener">羞羞的铁拳</a>》：作为一个喜剧片来说还可以。</li><li>《<a href="https://www.bilibili.com/video/BV1FV411d7u7?from=search&amp;seid=13630638212949182388" target="_blank" rel="noopener">bilibili献给新一代的演讲《后浪》</a>》：一种目前无法企及的生活状态宣传片。</li><li>《<a href="https://movie.douban.com/subject/34458962/" target="_blank" rel="noopener">动物新世代 BNA ビー・エヌ・エー</a>》：老生常谈的设定和出色的画面表现，以及合适的BGM切入时机。</li></ul><h3 id="下周打算做点什么"><a href="#下周打算做点什么" class="headerlink" title="下周打算做点什么"></a>下周打算做点什么</h3><ul><li>论文改稿，降重，答辩。</li><li>学习C++。</li><li>学习Unreal。</li><li>坚持跑步。</li></ul>]]></content>
      
      
      <categories>
          
          <category> reports </category>
          
      </categories>
      
      
        <tags>
            
            <tag> report </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“2020年第18周周报”</title>
      <link href="/2020/05/07/%E4%B8%AA%E4%BA%BA%E6%8A%A5%E5%91%8A/202018/"/>
      <url>/2020/05/07/%E4%B8%AA%E4%BA%BA%E6%8A%A5%E5%91%8A/202018/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>这是2020年的第18周报告（0427～0503）。</p><h3 id="上周计划完成情况"><a href="#上周计划完成情况" class="headerlink" title="上周计划完成情况"></a>上周计划完成情况</h3><blockquote><p>毕业设计：继续写论文。</p></blockquote><p>基本完成了，稍作修改就可以发给老师看看了。</p><h3 id="本周做了什么"><a href="#本周做了什么" class="headerlink" title="本周做了什么"></a>本周做了什么</h3><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><ul><li>毕业设计：把论文写的差不多了。由于毕业设计的存在，这一周基本上都是起床、摸鱼、吃饭、写论文、和方佬快乐联盟，看直播、睡觉度过的。</li></ul><h4 id="消费"><a href="#消费" class="headerlink" title="消费"></a>消费</h4><ul><li><p>FPX的锤石冠军皮肤：¥115.43，冲动消费一则。</p></li><li><p>Moo音乐会员月票：¥15，非必要消费一则。</p></li><li><p>敲钟牛皮肤：¥21.82，冲动消费两则。</p></li></ul><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><ul><li>看了<strong>一眼</strong>让·鲍德里亚的《<a href="https://book.douban.com/subject/25900948/" target="_blank" rel="noopener">消费社会</a>》，感觉太高深了，没看下去。</li><li>《<a href="https://movie.douban.com/subject/4840388/" target="_blank" rel="noopener">新喜剧之王</a>》：一场尴尬的闹剧和并不高明的讽刺。</li></ul><h3 id="下周打算做点什么"><a href="#下周打算做点什么" class="headerlink" title="下周打算做点什么"></a>下周打算做点什么</h3><ul><li>毕业设计：改初稿。</li></ul>]]></content>
      
      
      <categories>
          
          <category> reports </category>
          
      </categories>
      
      
        <tags>
            
            <tag> report </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“2020年第17周周报”</title>
      <link href="/2020/04/28/%E4%B8%AA%E4%BA%BA%E6%8A%A5%E5%91%8A/202017/"/>
      <url>/2020/04/28/%E4%B8%AA%E4%BA%BA%E6%8A%A5%E5%91%8A/202017/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>这是2020年的第17周报告（0420～0426）。</p><h3 id="上周计划完成情况"><a href="#上周计划完成情况" class="headerlink" title="上周计划完成情况"></a>上周计划完成情况</h3><blockquote><p>毕设：把测试用例写完，虽然感觉大概率是我自己写，而不是从CTS这个项目里移植过来。然后把日志整理出来，再写一份论文初稿。</p></blockquote><p>基本完成，但是日志还没有写完……太难编了。</p><blockquote><p>出门走走：买了相机之后利用率不高，希望下周开始能出门透透气，顺便拍点东西。</p><p>调整作息：就像这篇周报写完的此刻，已经是00:52分了，希望之后能12点前睡觉，早上早点起床。</p></blockquote><p>没有完成，下周继续努力。</p><h3 id="本周做了什么"><a href="#本周做了什么" class="headerlink" title="本周做了什么"></a>本周做了什么</h3><h4 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h4><ul><li>毕业设计：改写了一部分CTS项目里的测试用例到GP101的测试框架下，然后每天写了写论文。</li><li>每天基本上都是在写毕业设计和论文，没什么其他好说的。</li></ul><h4 id="消费："><a href="#消费：" class="headerlink" title="消费："></a>消费：</h4><ul><li>《<a href="https://www.douban.com/game/10734171/" target="_blank" rel="noopener">仙剑奇侠传4</a>》：¥25，Steam上买的，买一个算是补票，致敬一下当年感动到我的经典游戏。</li><li>《<a href="https://book.douban.com/subject/34996720/" target="_blank" rel="noopener">游戏开发：世嘉新人培训教材</a>》：¥138.60，当当网购买，打算读读看。</li><li>《<a href="https://book.douban.com/subject/35006892/" target="_blank" rel="noopener">程序员修炼之道：通向务实的最高境界</a>》：¥75.65，当当网购买，既然游戏业内的dalao都推荐了，就买来看看，当然这种思路不太理性。</li><li>《<a href="https://book.douban.com/subject/34465629/" target="_blank" rel="noopener">算法竞赛入门到进阶</a>》：¥52.62，当当网购买，本质上说这本书是为了凑满减的，另一个动机来说这本书当作刷leetcode的一个教材来看，纯粹属于个人爱好了，类似于数独那种脑力游戏罢了，没有指望发挥什么现实作用。</li></ul><h4 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h4><ul><li>了解了一下「入关学」的概念：<a href="https://zhuanlan.zhihu.com/p/120432699" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/120432699</a></li><li>看了看英雄联盟里锤石的玩法，虽然已经玩了好几年的锤石了，但是想看看还能不能更上一层楼。</li></ul><h3 id="下周打算做点什么"><a href="#下周打算做点什么" class="headerlink" title="下周打算做点什么"></a>下周打算做点什么</h3><ul><li>毕业设计：继续写论文。</li></ul>]]></content>
      
      
      <categories>
          
          <category> reports </category>
          
      </categories>
      
      
        <tags>
            
            <tag> report </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“2020年第16周周报”</title>
      <link href="/2020/04/20/%E4%B8%AA%E4%BA%BA%E6%8A%A5%E5%91%8A/202016/"/>
      <url>/2020/04/20/%E4%B8%AA%E4%BA%BA%E6%8A%A5%E5%91%8A/202016/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>这是2020年的第16周报告。</p><h3 id="上周计划完成情况"><a href="#上周计划完成情况" class="headerlink" title="上周计划完成情况"></a>上周计划完成情况</h3><p>上周实际上没有什么计划，说起来这是第一次正式记录周报，就写这些好了。</p><h3 id="本周做了什么"><a href="#本周做了什么" class="headerlink" title="本周做了什么"></a>本周做了什么</h3><p>本周实际上也没有完成什么特别值得拿来说说的事情。</p><h4 id="消费："><a href="#消费：" class="headerlink" title="消费："></a>消费：</h4><ul><li>路由器：京东上买的TP-LINK WDR7660千兆路由器，189.90元。<ul><li>动机：买这个的缘由是觉得内蒙广电这里的机顶盒&amp;路由器太垃圾了（误），所以想换一个相对好一点点的路由器，上知乎看了一圈，买了这个。家里的宽带实际上只有100M，想着饱和式配置，就直接上了一个千兆的路由器，如果以后升级宽带就能派上用场了，就算不能，那其实这100M的宽带也能跑满。</li><li>体验：目前还可以，算是从东非走出来了，终于从手动在浏览器里输入192.168.1.1变成了在手机&amp;电脑双端都能进行控制，美中不足的是这个路由器貌似可玩性小一点，不能自己设置加速器的相关配置，不过一分钱一分货，也没什么奢望了。</li></ul></li></ul><h4 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h4><ul><li><p>博客相关：探索了一下关于hexo模版以及生成命令的知识</p><p>比如这篇博客，生成的命令就是<code>hexo new report -p /个人报告/202016 “2020年第16周周报”</code>，这行命令会从我写好的report模版出发，在-post文件夹下的「个人报告」文件夹中生成一篇报告，这样做的好处是省去了一些手动复制的过程，比较省事，同时看起来比较整洁。</p></li><li><p>社交媒体：没有什么值得一说的更新。</p></li></ul><h4 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h4><ul><li>《我是于欢水》：看了这部电视剧，感觉还可以，一开始在朋友的豆瓣动态里看过，后来因为有关女权的争论所以打算看看。不到一下午的时间，用2倍速看完了这部剧。一些内容不能细品，另外一些内容又详细的出人意料，我不喜欢国产电视剧的一个原因在于感觉房间里的布景太亮了，过于惨白，以至于有一种隔阂感。日剧里的房间给我的印象都是暖黄色的光，比较柔和。此外还有一点就是有的时候主人公居住的环境往往超过他的消费水平，让我感觉非常突兀。说回这部剧，如果你把他当作一个重逻辑的电视剧去推敲可能会大失所望；但如果你就把他当作茶余饭后打发时间的剧，那还是能看看的。</li><li>《OpenGL ES 3.0 编程指南》：非常粗浅的翻阅了开头，记录了一下ES2.0与ES3.0的差别，作为毕业设计测试API的选取标准。</li><li>看了一下有关斐讯的新闻，为了骗钱真是什么手段都有啊，防不胜防。</li></ul><h4 id="事件："><a href="#事件：" class="headerlink" title="事件："></a>事件：</h4><ul><li>笔记本电脑电池彻底不行了，只有33%的容量了，而且现在也完全充不进去电了，打算忙完毕设之后就保存数据，再之后要么换个新电脑，要么换个新电池了。</li><li>忘了买大头菜了，血亏。</li></ul><h3 id="下周打算做点什么"><a href="#下周打算做点什么" class="headerlink" title="下周打算做点什么"></a>下周打算做点什么</h3><ul><li>毕设：把测试用例写完，虽然感觉大概率是我自己写，而不是从CTS这个项目里移植过来。然后把日志整理出来，再写一份论文初稿。</li><li>出门走走：买了相机之后利用率不高，希望下周开始能出门透透气，顺便拍点东西。</li><li>调整作息：就像这篇周报写完的此刻，已经是00:52分了，希望之后能12点前睡觉，早上早点起床。</li></ul>]]></content>
      
      
      <categories>
          
          <category> reports </category>
          
      </categories>
      
      
        <tags>
            
            <tag> report </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ludum Dare 历届主题</title>
      <link href="/2019/12/18/%E9%9A%8F%E7%AC%94/Ludum-Dare-%E5%8E%86%E5%B1%8A%E4%B8%BB%E9%A2%98/"/>
      <url>/2019/12/18/%E9%9A%8F%E7%AC%94/Ludum-Dare-%E5%8E%86%E5%B1%8A%E4%B8%BB%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>Ludum Dare 历届主题</p><a id="more"></a><table><thead><tr><th style="text-align:center">No.</th><th style="text-align:center">Month</th><th style="text-align:center">Theme (bonus)</th></tr></thead><tbody><tr><td style="text-align:center">0†</td><td style="text-align:center">April 2002</td><td style="text-align:center">Indirect interaction（间接干扰）</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">July 2002</td><td style="text-align:center">Guardian（保卫者）</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">November 2002</td><td style="text-align:center">Construction/destruction (sheep)（建立/毁灭（绵羊））</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">April 2003</td><td style="text-align:center">Preparation – Set it up, let it go（准备—设置好，放手）</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">April 2004</td><td style="text-align:center">Infection（感染）</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">October 2004</td><td style="text-align:center">Random（随机）</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">April 2005</td><td style="text-align:center">Light and darkness（光与暗）</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">December 2005</td><td style="text-align:center">Growth（生长）</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">April 2006</td><td style="text-align:center">Swarms（密集）</td></tr><tr><td style="text-align:center">8.5†</td><td style="text-align:center">January 2007</td><td style="text-align:center">Moon/anti-text（月/反文本（不知道这个在中文中表达什么））</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">April 2007</td><td style="text-align:center">Build the level you play（构建你玩的关卡）</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">December 2007</td><td style="text-align:center">Chain reaction（连锁反应）</td></tr><tr><td style="text-align:center">10.5</td><td style="text-align:center">February 2008</td><td style="text-align:center">Weird/unexpected/surprise（奇怪/意想不到/惊奇）</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">April 2008</td><td style="text-align:center">Minimalist（极简主义者）</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">August 2008</td><td style="text-align:center">The tower（塔）</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">December 2008</td><td style="text-align:center">Roads（路）</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">April 2009</td><td style="text-align:center">Advancing wall of doom（前进的末日之墙）</td></tr><tr><td style="text-align:center">15</td><td style="text-align:center">August 2009</td><td style="text-align:center">Caverns（洞穴）</td></tr><tr><td style="text-align:center">16</td><td style="text-align:center">December 2009</td><td style="text-align:center">Exploration（探索）</td></tr><tr><td style="text-align:center">17</td><td style="text-align:center">April 2010</td><td style="text-align:center">Islands（群岛，岛屿）</td></tr><tr><td style="text-align:center">18</td><td style="text-align:center">August 2010</td><td style="text-align:center">Enemies as weapons（敌人作为武器，作为武器的敌人）</td></tr><tr><td style="text-align:center">19</td><td style="text-align:center">December 2010</td><td style="text-align:center">Discovery（发现）</td></tr><tr><td style="text-align:center">20</td><td style="text-align:center">April 2011</td><td style="text-align:center">It’s dangerous to go alone! Take this!（一个人去是很危险的!拿着这个！）</td></tr><tr><td style="text-align:center">21</td><td style="text-align:center">August 2011</td><td style="text-align:center">Escape（逃脱）</td></tr><tr><td style="text-align:center">22</td><td style="text-align:center">December 2011</td><td style="text-align:center">Alone (kitten challenge)（单独（小猫挑战））</td></tr><tr><td style="text-align:center">23</td><td style="text-align:center">April 2012</td><td style="text-align:center">Tiny world（小世界）</td></tr><tr><td style="text-align:center">24</td><td style="text-align:center">August 2012</td><td style="text-align:center">Evolution（演变）</td></tr><tr><td style="text-align:center">25</td><td style="text-align:center">December 2012</td><td style="text-align:center">You are the villain (goat)（你是恶棍 （山羊））</td></tr><tr><td style="text-align:center">26</td><td style="text-align:center">April 2013</td><td style="text-align:center">Minimalism (potato)（简约主义（马铃薯））</td></tr><tr><td style="text-align:center">27</td><td style="text-align:center">August 2013</td><td style="text-align:center">10 seconds（十秒）</td></tr><tr><td style="text-align:center">28</td><td style="text-align:center">December 2013</td><td style="text-align:center">You only get one（你只得到一个）</td></tr><tr><td style="text-align:center">29</td><td style="text-align:center">April 2014</td><td style="text-align:center">Beneath the surface（表面下）</td></tr><tr><td style="text-align:center">30</td><td style="text-align:center">August 2014</td><td style="text-align:center">Connected Worlds（被连接的世界）</td></tr><tr><td style="text-align:center">31</td><td style="text-align:center">December 2014</td><td style="text-align:center">Entire Game on One Screen（整个游戏在一个屏幕上）</td></tr><tr><td style="text-align:center">32</td><td style="text-align:center">April 2015</td><td style="text-align:center">An Unconventional Weapon（非常规武器）</td></tr><tr><td style="text-align:center">33</td><td style="text-align:center">August 2015</td><td style="text-align:center">You are the Monster（你是怪兽）</td></tr><tr><td style="text-align:center">34</td><td style="text-align:center">December 2015</td><td style="text-align:center">Growing/two button controls（增长/两个按钮控件）</td></tr><tr><td style="text-align:center">35</td><td style="text-align:center">April 2016</td><td style="text-align:center">Shapeshift（变形）</td></tr><tr><td style="text-align:center">36</td><td style="text-align:center">August 2016</td><td style="text-align:center">Ancient Technology（古代科技）</td></tr><tr><td style="text-align:center">37</td><td style="text-align:center">December 2016</td><td style="text-align:center">One Room（一个房间）</td></tr><tr><td style="text-align:center">38</td><td style="text-align:center">April 2017</td><td style="text-align:center">A Small World（一个小世界）</td></tr><tr><td style="text-align:center">39</td><td style="text-align:center">July 2017</td><td style="text-align:center">Running out of Power（电源耗尽）</td></tr><tr><td style="text-align:center">40</td><td style="text-align:center">December 2017</td><td style="text-align:center">The more you have, the worse it is（你拥有的越多, 就越糟糕）</td></tr><tr><td style="text-align:center">41</td><td style="text-align:center">April 2018</td><td style="text-align:center">Combine two incompatible genres（结合两种不相容的体裁）</td></tr><tr><td style="text-align:center">42</td><td style="text-align:center">August 2018</td><td style="text-align:center">Running out of space（空间耗尽）</td></tr><tr><td style="text-align:center">43</td><td style="text-align:center">December 2018</td><td style="text-align:center">Sacrifices must be made（必须作出牺牲）</td></tr><tr><td style="text-align:center">44</td><td style="text-align:center">April 2019</td><td style="text-align:center">Your life is currency（你的生命（生活）是一种货币）</td></tr><tr><td style="text-align:center">45</td><td style="text-align:center">October 2019</td><td style="text-align:center">Start with nothing（从无到有）</td></tr><tr><td style="text-align:center">46</td><td style="text-align:center">April 2020</td><td style="text-align:center">Keep it Alive（保持或者）</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> 灵感 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[翻译]Integrating Lua</title>
      <link href="/2019/09/24/%E7%BF%BB%E8%AF%91/%E7%BF%BB%E8%AF%91-Integrating-Lua/"/>
      <url>/2019/09/24/%E7%BF%BB%E8%AF%91/%E7%BF%BB%E8%AF%91-Integrating-Lua/</url>
      
        <content type="html"><![CDATA[<p>一篇名为Integrating Lua的Wiki页面翻译。</p><a id="more"></a><p>原文链接：<a href="https://wiki.unrealengine.com/Integrating_Lua" target="_blank" rel="noopener">https://wiki.unrealengine.com/Integrating_Lua</a></p><h2 id="Integrating-Lua"><a href="#Integrating-Lua" class="headerlink" title="Integrating Lua"></a>Integrating Lua</h2><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p>欢迎来到我的第三个Wiki页面，这个页面是关于那个很棒的游戏引擎的——虚幻引擎！这篇文章包含了人们最近问我数次的那个问题，我认为这将对游戏逻辑编程和一个高水平的mod-abilty（模块化能力？）：整合Lua很有用。</p><h3 id="Requirements"><a href="#Requirements" class="headerlink" title="Requirements"></a>Requirements</h3><h3 id="Starting-off-code-in-our-project"><a href="#Starting-off-code-in-our-project" class="headerlink" title="Starting off : code in our project"></a>Starting off : code in our project</h3><h3 id="Aquiring"><a href="#Aquiring" class="headerlink" title="Aquiring:"></a>Aquiring:</h3><p>现在，我们需要向项目中引入Lua，以便于其与我们的项目一起编译并包含在最终游戏中。但是首先，我们需要获取到Lua的二进制文件。有些项目会为您提供预编译的二进制文件，或者您也可以自行编译！因为编译的过程耗费时间，而且这个过程是必要的，所以我们将使用预编译的版本。<a href="https://sourceforge.net/projects/luabinaries/files/" target="_blank" rel="noopener">LuaBinaries</a>是一个很棒的项目，它始终是最新的，并且具有适用于每个平台的二进制文件（在本文中，我们将只涉及Windows）。选择最新版本，然后选择Windows库，接着选择静态（Static），因为我们会将Lua嵌入到游戏的可执行文件中，然后根据需要搜索软件包。在我们下载过这些包后，我们应该在它们的结构中找到如下文件：</p><ul><li>Include/(essential includes for working with Lua)<ul><li>luaxlib.h</li><li>lua.h</li><li>lua.hpp</li><li>luaconf.h</li><li>lualib.h</li></ul></li><li>luaXX.lib（XX代表Lua的当前版本，例如Lua 5.3.3就为lu a53.lib）</li></ul><p>现在，我们拥有了二进制文件和包含文件，我们可以开始我们的集成工作了！</p><h3 id="Copying-the-files"><a href="#Copying-the-files" class="headerlink" title="Copying the files"></a>Copying the files</h3><p>在虚幻引擎中链接Lua很容易。首先，我们需要在项目目录中创建一个新文件夹，将Lua内容放入其中。我个人更喜欢在项目的主目录（.uproject所在的位置）中创建一个新文件夹，并将其命名为“ThirdParty”。然后在这个文件夹中，我创建了一个名为“Lua”的文件夹，并将其分为“includes”和“libraries”。结构如下：</p><ul><li>Project Home/<ul><li>ThirdParty/<ul><li>Lua/<ul><li>includes/（我们只需要复制一次，因为它们与体系结构没有区别，最后请注意“s”）</li><li>libraries/<ul><li>luaXX.x64.lib（这是您在Win64包中下载的库文件，重命名来做区分）</li><li>luaXX.x32.lib（这是您在Win32包中下载的库文件，重命名来做区分）</li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="Linking"><a href="#Linking" class="headerlink" title="Linking"></a>Linking</h3><p>在Visual Studio中，打开<strong>YourProjectName.Build.cs</strong>，这个文件位于 Source/YourProjectName/ 文件夹中。默认情况下，此文件仅链接默认引擎模块。要对此链接Lua，我们需要向其中添加一些代码。由于展示每一个细节实在是太多了，所以我只向你展示我对Build.cs文件的改动：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> UnrealBuildTool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ProjectName</span> : <span class="title">ModuleRules</span></span><br><span class="line">&#123;    </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">string</span> ThirdPartyPath</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">get</span> &#123; <span class="keyword">return</span> Path.GetFullPath(Path.Combine(ModuleDirectory, <span class="string">"../../ThirdParty/"</span>)); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ProjectName</span>(<span class="params">TargetInfo Target</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">PublicDependencyModuleNames.AddRange(<span class="keyword">new</span> <span class="keyword">string</span>[] &#123; <span class="string">"Core"</span>, <span class="string">"CoreUObject"</span>, <span class="string">"Engine"</span>, <span class="string">"InputCore"</span> &#125;);</span><br><span class="line"></span><br><span class="line">PrivateDependencyModuleNames.AddRange(<span class="keyword">new</span> <span class="keyword">string</span>[] &#123;  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果使用Slate UI，则取消注释</span></span><br><span class="line">    <span class="comment">// PrivateDependencyModuleNames.AddRange(new string[] &#123; "Slate", "SlateCore" &#125;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果使用在线功能，则取消注释</span></span><br><span class="line"><span class="comment">// PrivateDependencyModuleNames.Add("OnlineSubsystem");</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 要包含 OnlineSubsystemSteam, 请将其添加到uproject文件的plugins部分中，并将Enabled属性设置为true</span></span><br><span class="line"></span><br><span class="line">LoadLua(TargetRules); <span class="comment">// 此函数加载Lua</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">bool</span> <span class="title">LoadLua</span>(<span class="params">ReadOnlyTargetRules TargetRules</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> isLibSupported = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否使用的是Windows</span></span><br><span class="line"><span class="keyword">if</span> ((Target.Platform == UnrealTargetPlatform.Win64) || (Target.Platform == UnrealTargetPlatform.Win32))</span><br><span class="line">&#123;</span><br><span class="line">isLibSupported = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">string</span> PlatformString = (Target.Platform == UnrealTargetPlatform.Win64) ? <span class="string">"x64"</span> : <span class="string">"x86"</span>; <span class="comment">// 此字符串是“x64”或“x86”，因此我们可以将其附加到lib文件名</span></span><br><span class="line"><span class="keyword">string</span> LibrariesPath = Path.Combine(ThirdPartyPath, <span class="string">"Lua"</span>, <span class="string">"libraries"</span>);</span><br><span class="line"></span><br><span class="line">PublicAdditionalLibraries.Add(Path.Combine(LibrariesPath, <span class="string">"lua53."</span> + PlatformString + <span class="string">".lib"</span>));</span><br><span class="line"></span><br><span class="line">PublicIncludePaths.Add(Path.Combine(ThirdPartyPath, <span class="string">"Lua"</span>, <span class="string">"includes"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Definitions.Add(<span class="keyword">string</span>.Format(<span class="string">"WITH_LUA_BINDING=&#123;0&#125;"</span>, isLibSupported ? <span class="number">1</span> : <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> isLibSupported;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“LoadLua”方法检查我们是否在Windows上，如果是，则根据编译的体系结构创建一个包含“x64”或“x86”的字符串，因此我们可以轻松的找到lib文件。然后，我们创建库路径，该路径就是（在这个例子中为“ThirdParty/”）/Lua/libraries。从那里，我们将平台字符串附加到文件名的前缀和后缀，因此最后应该是lua53.xxx.lib。此路径已添加到PublicAdditionalLibraries中，这会强制编译器使用我们放在其中的lib文件。我们还将includes目录添加到PublicIncludePaths，以便编译器找到我们的includes。最后也很重要的一点是，我们向已编译的游戏中添加了一个定义：WITH_LUA_BINDING = x，其中x为0（不支持Lua）或1（支持Lua）。</p><h4 id="First-steps"><a href="#First-steps" class="headerlink" title="First steps"></a>First steps</h4><p>现在，我们已经将Lua二进制文件集成到我们的游戏中，让我们通过在Visual Studio中右键单击该项目并选择“Build”来进行尝试。它应该会成功！下一步：编写一个蓝图节点，该节点从我们输入的字符串中执行Lua代码。打开您创建的蓝图函数库的头文件（.h）。空文件如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Kismet/BlueprintFunctionLibrary.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"LuaBlueprints.generated.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">UCLASS()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YOURPROJECT_API</span> <span class="title">ULuaBlueprints</span> :</span> <span class="keyword">public</span> UBlueprintFunctionLibrary</span><br><span class="line">&#123;</span><br><span class="line">GENERATED_BODY()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先，在顶部添加Lua包含项，以便编译器知道声明函数的位置。为此，请在其他包含项的头部添加<code>#include &quot;lua.hpp&quot;</code>。接下来，我们向其中添加一个新的UFUNCTION，将其解析为带有以下声明的蓝图节点：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">UFUNCTION(BlueprintCallable, Category = <span class="string">"Lua"</span>)</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RunLua</span><span class="params">(<span class="keyword">const</span> FString&amp; code)</span></span>;</span><br></pre></td></tr></table></figure><p>这将创建一个可调用的蓝图节点，该节点带有一个字符串（FString），我们可以在其中输入将要运行的Lua代码。请注意，这是静态的，因为我们没有要在上下文中调用此对象的对象，换言之，我们想在没有任何目标的情况下从任何地方调用它。让我们进入LuaBlueprints.cpp文件，该文件应该为空（include文件除外）。我们为RunLua函数添加定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ULuaBlueprints::RunLua(<span class="keyword">const</span> FString&amp; code)</span><br><span class="line">&#123;</span><br><span class="line">lua_State* L = luaL_newstate();</span><br><span class="line">luaL_openlibs(L);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> result = luaL_dostring(L, TCHAR_TO_ANSI(*code));</span><br><span class="line"><span class="keyword">if</span> (result != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">UE_LOG(LogTemp, Error, TEXT(<span class="string">"Lua Script error: %s"</span>), ANSI_TO_TCHAR(lua_tostring(L, <span class="number">-1</span>)));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这很容易。它使用Lua C API创建一个新的Lua状态，将其分配给名为L的变量。然后，打开标准的lua库（例如math），然后通过执行luaL_dostring()运行代码。这将Lua状态L作为一个参数，并将要运行的代码作为另一个参数。该函数返回一个整数，如果一切正常，则返回0。如果不为0，则显然出了问题。在这种情况下，我使用UE_LOG将其打印到日志中。注意，我们通过lua_tostring(L,-1)得到Lua错误消息。</p>]]></content>
      
      
      <categories>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lua </tag>
            
            <tag> Unreal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac下配置OpenGL环境</title>
      <link href="/2019/09/11/OpenGL%E7%AC%94%E8%AE%B0/Mac%E4%B8%8B%E9%85%8D%E7%BD%AEOpenGL%E7%8E%AF%E5%A2%83/"/>
      <url>/2019/09/11/OpenGL%E7%AC%94%E8%AE%B0/Mac%E4%B8%8B%E9%85%8D%E7%BD%AEOpenGL%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<p>Mac下配置OpenGL环境。</p><a id="more"></a><h3 id="Mac下配置OpenGL"><a href="#Mac下配置OpenGL" class="headerlink" title="Mac下配置OpenGL"></a>Mac下配置OpenGL</h3><ol><li><p>安装homebrew</p><p><code>ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></p></li><li><p>安装GLEW与GLFW</p><p><code>brew install glew</code></p><p><code>brew install glfw3</code></p></li></ol><h4 id="CLion法（推荐）"><a href="#CLion法（推荐）" class="headerlink" title="CLion法（推荐）"></a>CLion法（推荐）</h4><ol><li><p>在<a href="https://www.jetbrains.com/clion/" target="_blank" rel="noopener">CLion:A cross-platform IDE for C and C++</a>下载CLion</p></li><li><p>配置GLAD：</p><ol><li>打开<a href="http://glad.dav1d.de" target="_blank" rel="noopener">在线服务（点击这个链接）</a>，API选择3.3及以上，Profile选择Core，勾选Options中的Generate a loader，点击GENERATE，会生成一个压缩包，下载。</li><li><p>将子目录中的/include/glad与/include/KHR复制到/usr/Local/include文件夹下。（如果/usr文件夹隐藏，可用快捷键<strong>command+shift+G</strong>输入访问）</p></li><li><p>新建一个项目，配置对应的Cmake文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION <span class="number">3.12</span>)</span><br><span class="line">project(OpenGL)</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_STANDARD <span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>(GLEW_H /usr/local/Cellar/glew/<span class="number">2.1</span><span class="number">.0</span>/include/GL)</span><br><span class="line"><span class="built_in">set</span>(GLFW_H /usr/local/Cellar/glfw/<span class="number">3.2</span><span class="number">.1</span>/include/GLFW)</span><br><span class="line"><span class="built_in">set</span>(GLAD_H /usr/local/include/glad)</span><br><span class="line"><span class="built_in">set</span>(KH_H /usr/local/include/KHR)</span><br><span class="line">include_directories($&#123;GLEW_H&#125; $&#123;GLFW_H&#125; $&#123;GLAD_H&#125; $&#123;KH_H&#125;)</span><br><span class="line"></span><br><span class="line"># 添加目标链接</span><br><span class="line"><span class="built_in">set</span>(GLEW_LINK /usr/local/Cellar/glew/<span class="number">2.1</span><span class="number">.0</span>/lib/libGLEW<span class="number">.2</span><span class="number">.1</span>.dylib)</span><br><span class="line"><span class="built_in">set</span>(GLFW_LINK /usr/local/Cellar/glfw/<span class="number">3.2</span><span class="number">.1</span>/lib/libglfw<span class="number">.3</span>.dylib)</span><br><span class="line">link_libraries($&#123;OPENGL&#125; $&#123;GLEW_LINK&#125; $&#123;GLFW_LINK&#125;)</span><br><span class="line"></span><br><span class="line"># 执行编译命令</span><br><span class="line"># 这个glad.c在第<span class="number">2</span>步中说过要拉到项目中，注意路径</span><br><span class="line"><span class="built_in">set</span>(SOURCE_FILES <span class="string">"src/glad.c"</span> <span class="string">"main.cpp"</span>)</span><br><span class="line">add_executable(OpenGL $&#123;SOURCE_FILES&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta"># mac下这步很重要</span></span><br><span class="line"><span class="keyword">if</span> (APPLE)</span><br><span class="line">    target_link_libraries(OpenGL <span class="string">"-framework OpenGL"</span>)</span><br><span class="line">    target_link_libraries(OpenGL <span class="string">"-framework GLUT"</span>)</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure></li></ol></li></ol><pre><code>4. 注意这样配置之后需要更改`/usr/local/include/glad文件夹下的glad.h`中的`#include &lt;KHR/khrplatform.h&gt;`更改为`#include &lt;khrplatform.h&gt;`，具体步骤：   1. 在CLion中打开`glad.c`文件，command+点按`#include &lt;glad.h&gt;`会跳到`glad.h`   2. 然后在`glad.h`中command+f找到`#include &lt;KHR/khrplatform.h&gt;`，将它改为`#include &lt;khrplatform.h&gt;`5. 运行测试代码（把下列代码复制到main.cpp中）：   <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">key_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> key, <span class="keyword">int</span> scancode, <span class="keyword">int</span> action, <span class="keyword">int</span> mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果按下ESC，把windowShouldClose设置为True，外面的循环会关闭应用</span></span><br><span class="line">    <span class="keyword">if</span>(key==GLFW_KEY_ESCAPE &amp;&amp; action == GLFW_PRESS)</span><br><span class="line">        glfwSetWindowShouldClose(window, GL_TRUE);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"ESC"</span>&lt;&lt;mode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化GLFW库</span></span><br><span class="line">    <span class="keyword">if</span>(!glfwInit())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//创建窗口以及上下文</span></span><br><span class="line">    GLFWwindow* window = glfwCreateWindow(<span class="number">640</span>, <span class="number">480</span>, <span class="string">"hello world"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(!window)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建失败会返回NULL</span></span><br><span class="line">        glfwTerminate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//建立当前窗口的上下文</span></span><br><span class="line">    glfwMakeContextCurrent(window);</span><br><span class="line"></span><br><span class="line">    glfwSetKeyCallback(window, key_callback); <span class="comment">//注册回调函数</span></span><br><span class="line">    <span class="comment">//循环，直到用户关闭窗口</span></span><br><span class="line">    <span class="keyword">while</span>(!glfwWindowShouldClose(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*******轮询事件*******/</span></span><br><span class="line">        glfwPollEvents();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*******渲染*******/</span></span><br><span class="line">        <span class="comment">//选择清空的颜色RGBA</span></span><br><span class="line">        glClearColor(<span class="number">0.2</span>, <span class="number">0.3</span>, <span class="number">0.3</span>, <span class="number">1</span>);</span><br><span class="line">        glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始画一个三角形</span></span><br><span class="line">        glBegin(GL_TRIANGLES);</span><br><span class="line">        glColor3f(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">//Red</span></span><br><span class="line">        glVertex3f(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        glColor3f(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>); <span class="comment">//Green</span></span><br><span class="line">        glVertex3f(<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        glColor3f(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">//Blue</span></span><br><span class="line">        glVertex3f(<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//结束一个画图步骤</span></span><br><span class="line">        glEnd();</span><br><span class="line"></span><br><span class="line">        glBegin(GL_POLYGON);</span><br><span class="line">        <span class="comment">//再画个梯形，需要注意笔顺</span></span><br><span class="line">        glColor3f(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>); <span class="comment">//Grey</span></span><br><span class="line">        glVertex2d(<span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line">        glVertex2d(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        glVertex2d(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        glVertex2d(<span class="number">0.5</span>, <span class="number">0</span>);</span><br><span class="line">        glEnd();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/******交换缓冲区，更新window上的内容******/</span></span><br><span class="line">        glfwSwapBuffers(window);</span><br><span class="line">    &#125;</span><br><span class="line">    glfwTerminate();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>如果出现如下窗口说明配置成功：<br><img src="https://i.loli.net/2019/09/11/CsKWBMOerqEcTUp.png" alt="屏幕快照 2019-09-11 下午9.45.32.png"></p><h4 id="XCode法"><a href="#XCode法" class="headerlink" title="XCode法"></a>XCode法</h4><ol><li><p>在App Store中搜索XCode并安装。</p></li><li><p>新建Xcode的Command Line C++项目，在<code>build settings</code>中设置<code>Header Search Path</code>与<code>Library Search Path</code>，在其中添加对应的<code>glew</code>与<code>glfw</code>的头文件(include)与库文件(lib)路径。</p></li><li><p>在<code>build Phases</code>中添加库文件<img src="https://wx3.sinaimg.cn/mw1024/007dFQ0Igy1ftpq5ygm41j31kw0eh0zx.jpg" alt="屏幕快照 2018-07-28 下午5.27.39"></p><pre><code>​        （在对应的文件夹中将两个/.dylib的文件直接拖拽进来）</code></pre></li><li><p>配置GLAD：</p><ol><li>打开<a href="http://glad.dav1d.de" target="_blank" rel="noopener">在线服务（点击这个链接）</a>，API选择3.3及以上，Profile选择Core，勾选Options中的Generate a loader，点击GENERATE，会生成一个压缩包，下载。</li><li>将子目录中的/include/glad与/include/KHR复制到/usr/Local/include文件夹下。（如果/usr文件夹隐藏，可用快捷键<strong>command+shift+G</strong>输入访问）</li><li>将/src中的glad.c复制到Xcode工程文件夹下。</li><li>在<code>build settings</code>中添加路径<code>/usr/local/include</code></li></ol></li><li><p>此时如果不出意外的话，你的第一个测试程序已经可以运行了，点击<a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/1.1.hello_window/hello_window.cpp" target="_blank" rel="noopener">测试代码</a>，复制到自己的.cpp文件中执行，会出现一个黑色窗口。(或者直接复制下面的代码)</p><pre><code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// settings</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// glfw: initialize and configure</span></span><br><span class="line">    <span class="comment">// ------------------------------</span></span><br><span class="line">    glfwInit();</span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line">    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); <span class="comment">// uncomment this statement to fix compilation on OS X</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// glfw window creation</span></span><br><span class="line">    <span class="comment">// --------------------</span></span><br><span class="line">    GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, <span class="string">"LearnOpenGL"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to create GLFW window"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        glfwTerminate();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    glfwMakeContextCurrent(window);</span><br><span class="line">    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// glad: load all OpenGL function pointers</span></span><br><span class="line">    <span class="comment">// ---------------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to initialize GLAD"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// render loop</span></span><br><span class="line">    <span class="comment">// -----------</span></span><br><span class="line">    <span class="keyword">while</span> (!glfwWindowShouldClose(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// input</span></span><br><span class="line">        <span class="comment">// -----</span></span><br><span class="line">        processInput(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.)</span></span><br><span class="line">        <span class="comment">// -------------------------------------------------------------------------------</span></span><br><span class="line">        glfwSwapBuffers(window);</span><br><span class="line">        glfwPollEvents();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// glfw: terminate, clearing all previously allocated GLFW resources.</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------</span></span><br><span class="line">    glfwTerminate();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly</span></span><br><span class="line"><span class="comment">// ---------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)</span><br><span class="line">        glfwSetWindowShouldClose(window, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// glfw: whenever the window size changed (by OS or user resize) this callback function executes</span></span><br><span class="line"><span class="comment">// ---------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// make sure the viewport matches the new window dimensions; note that width and </span></span><br><span class="line">    <span class="comment">// height will be significantly larger than specified on retina displays.</span></span><br><span class="line">    glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ol><p>如果运行出现如下窗口，说明配置成功：<br><img src="https://i.loli.net/2019/09/11/i4oQutflXhg8mRx.png" alt="屏幕快照 2019-09-11 下午9.47.29.png"></p><hr><p>参考：</p><ol><li><a href="https://www.cnblogs.com/shayue/p/Mac-CLion-xiaOpenGL-huan-jing-pei-zhi.html" target="_blank" rel="noopener">https://www.cnblogs.com/shayue/p/Mac-CLion-xiaOpenGL-huan-jing-pei-zhi.html</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机图形学 </tag>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lua源码阅读：虚拟机概述</title>
      <link href="/2019/08/21/Lua/Lua%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%9A%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A6%82%E8%BF%B0/"/>
      <url>/2019/08/21/Lua/Lua%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%9A%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<p>Lua 虚拟机的执行过程。</p><a id="more"></a><h3 id="Lua-执行过程概述："><a href="#Lua-执行过程概述：" class="headerlink" title="Lua 执行过程概述："></a>Lua 执行过程概述：</h3><p>解释型脚本语言与编译型语言的区别如下：</p><ul><li>由于每个脚本语言都有自己的一套字节码，与具体的硬件平台无关，所以不用修改脚本代码，就能运行在各个平台上。硬件、软件平台的差异都由语言自身的虚拟机解决。</li><li>由于脚本语言的字节码需要虚拟机执行，而不像机器代码能够直接执行，所以运行速度比编译型语言差不少。</li></ul><p>虚拟机需要完成以下工作：</p><ul><li>将源代码编译成虚拟机可以识别执行的字节码。</li><li>为函数调用准备调用栈。</li><li>内部维持一个 IP（Instruction Pointer，指令指针）来保存下一个将执行的指令地址。在 Lua 代码中，IP 对应的是 PC 指针。</li><li>模拟一个 CPU 的运行：循环拿出由 IP 指向的字节码，根据字节码格式进行解码，然后执行字节码。</li></ul><h4 id="虚拟机的实现方式："><a href="#虚拟机的实现方式：" class="headerlink" title="虚拟机的实现方式："></a>虚拟机的实现方式：</h4><p>虚拟机有两种不同的实现方式：基于栈的虚拟机和基于寄存器的虚拟机。Lua 是基于寄存器虚拟机的语言。</p><p>区别：</p><ul><li>在基于栈的虚拟机中，字节码的操作数是从栈顶上弹出（pop），在执行完操作后再压入栈顶的，这样的缺点是会多出几条指令来准备数据，优点是指令中不需要关心操作数的地址，在执行操作之前就已经将操作数准备在栈顶上了。</li><li>在基于寄存器的指令中，操作数是放在“CPU 的寄存器”中，因此，同样的操作不再需要 PUSH、POP 指令，取而代之的是在字节码中带上具体操作数所在的寄存器地址。对比需要栈的寄存器，这里的指令数会减少，但缺点是此时程序需要关注操作数所在的位置。</li></ul><p>实现一个脚本语言的解释器：</p><ul><li>设计一套字节码，分析源代码文件生成字节码。</li><li>在虚拟机中执行字节码。</li><li>如何在整个执行过程中保存整个执行环境。</li></ul><p>执行Lua文件调用的是luaL_dofile 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> luaL_dofile(L, fn) \</span></span><br><span class="line">(luaL_loadfile(L, fn) || lua_pcall(L, <span class="number">0</span>, LUA_MULTRET, <span class="number">0</span>))</span><br></pre></td></tr></table></figure><p>其中 luaL_loadfile 函数用于进行词法和语法分析，lua_pcall 用于将第一步中分析的结果（字节码）放在虚拟机中执行。</p><p>luaL_loadfile 函数，通过lua_load，luaD_protectedparser，最终调用 f_parser 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ldo.c</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f_parser</span> <span class="params">(lua_State *L, <span class="keyword">void</span> *ud)</span> </span>&#123;</span><br><span class="line">  LClosure *cl;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">SParser</span> *<span class="title">p</span> = <span class="title">cast</span>(<span class="title">struct</span> <span class="title">SParser</span> *, <span class="title">ud</span>);</span></span><br><span class="line">  <span class="keyword">int</span> c = zgetc(p-&gt;z);  <span class="comment">/* read first character */</span></span><br><span class="line">  <span class="keyword">if</span> (c == LUA_SIGNATURE[<span class="number">0</span>]) &#123;</span><br><span class="line">    checkmode(L, p-&gt;mode, <span class="string">"binary"</span>);</span><br><span class="line">    cl = luaU_undump(L, p-&gt;z, &amp;p-&gt;buff, p-&gt;name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    checkmode(L, p-&gt;mode, <span class="string">"text"</span>);</span><br><span class="line">    cl = luaY_parser(L, p-&gt;z, &amp;p-&gt;buff, &amp;p-&gt;dyd, p-&gt;name, c);</span><br><span class="line">  &#125;</span><br><span class="line">  lua_assert(cl-&gt;nupvalues == cl-&gt;p-&gt;sizeupvalues);</span><br><span class="line">  luaF_initupvals(L, cl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>完成词法分析之后，返回了 Proto 类型的指针tf，然后将其绑定在新创建的 Closure 指针上，初始化 Upvalue，最后压入栈中。</p><p>词法分析之后产生的字节码等相关数据都在这个 Proto 类型的结构体中，而这个数据又作为 Closure 保存了下来。</p></blockquote><p>lua_pcall 内部调用了lua_pcallk函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lapi.c</span></span><br><span class="line"></span><br><span class="line"><span class="function">LUA_API <span class="keyword">int</span> <span class="title">lua_pcallk</span> <span class="params">(lua_State *L, <span class="keyword">int</span> nargs, <span class="keyword">int</span> nresults, <span class="keyword">int</span> errfunc,</span></span></span><br><span class="line"><span class="function"><span class="params">                        lua_KContext ctx, lua_KFunction k)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">CallS</span> <span class="title">c</span>;</span></span><br><span class="line">  <span class="keyword">int</span> status;</span><br><span class="line">  <span class="keyword">ptrdiff_t</span> func;</span><br><span class="line">  lua_lock(L);</span><br><span class="line">  api_check(k == <span class="literal">NULL</span> || !isLua(L-&gt;ci),</span><br><span class="line">    <span class="string">"cannot use continuations inside hooks"</span>);</span><br><span class="line">  api_checknelems(L, nargs+<span class="number">1</span>);</span><br><span class="line">  api_check(L-&gt;status == LUA_OK, <span class="string">"cannot do calls on non-normal thread"</span>);</span><br><span class="line">  checkresults(L, nargs, nresults);</span><br><span class="line">  <span class="keyword">if</span> (errfunc == <span class="number">0</span>)</span><br><span class="line">    func = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    StkId o = index2addr(L, errfunc);</span><br><span class="line">    api_checkstackindex(errfunc, o);</span><br><span class="line">    func = savestack(L, o);</span><br><span class="line">  &#125;</span><br><span class="line">  c.func = L-&gt;top - (nargs+<span class="number">1</span>);  <span class="comment">/* function to be called */</span></span><br><span class="line">  <span class="keyword">if</span> (k == <span class="literal">NULL</span> || L-&gt;nny &gt; <span class="number">0</span>) &#123;  <span class="comment">/* no continuation or no yieldable? */</span></span><br><span class="line">    c.nresults = nresults;  <span class="comment">/* do a 'conventional' protected call */</span></span><br><span class="line">    status = luaD_pcall(L, f_call, &amp;c, savestack(L, c.func), func);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;  <span class="comment">/* prepare continuation (call is already protected by 'resume') */</span></span><br><span class="line">    CallInfo *ci = L-&gt;ci;</span><br><span class="line">    ci-&gt;u.c.k = k;  <span class="comment">/* save continuation */</span></span><br><span class="line">    ci-&gt;u.c.ctx = ctx;  <span class="comment">/* save context */</span></span><br><span class="line">    <span class="comment">/* save information for error recovery */</span></span><br><span class="line">    ci-&gt;extra = savestack(L, c.func);</span><br><span class="line">    ci-&gt;u.c.old_errfunc = L-&gt;errfunc;</span><br><span class="line">    L-&gt;errfunc = func;</span><br><span class="line">    setoah(ci-&gt;callstatus, L-&gt;allowhook);  <span class="comment">/* save value of 'allowhook' */</span></span><br><span class="line">    ci-&gt;callstatus |= CIST_YPCALL;  <span class="comment">/* function can do error recovery */</span></span><br><span class="line">    luaD_call(L, c.func, nresults, <span class="number">1</span>);  <span class="comment">/* do the call */</span></span><br><span class="line">    ci-&gt;callstatus &amp;= ~CIST_YPCALL;</span><br><span class="line">    L-&gt;errfunc = ci-&gt;u.c.old_errfunc;</span><br><span class="line">    status = LUA_OK;  <span class="comment">/* if it is here, there were no errors */</span></span><br><span class="line">  &#125;</span><br><span class="line">  adjustresults(L, nresults);</span><br><span class="line">  lua_unlock(L);</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，首先获取需要调用的函数指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.func = L-&gt;top - (nargs+<span class="number">1</span>);  <span class="comment">/* function to be called */</span></span><br></pre></td></tr></table></figure><p>这里的 nargs 是由函数参数传入的，在 lual_dofile 中调用 lua_pcall 时，这里传入的参数是 0。换句话说，这里得到的函数对象指针就是前面 f_parser 函数中最后两句代码放入 Lua 栈的 Closure 指针。</p><p>继续向下执行，在调用函数 luaD_pcall 时，最终会执行到 luaD_call 函数，其中有：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!luaD_precall(L, func, nResults))  <span class="comment">/* is a Lua function? */</span></span><br><span class="line">  luaV_execute(L);  <span class="comment">/* call it */</span></span><br></pre></td></tr></table></figure><p>首先调用 luaD_precall 函数进行执行前的准备工作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** returns true if function has been executed (C function)</span></span><br><span class="line"><span class="comment">...部分有省略</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">luaD_precall</span> <span class="params">(lua_State *L, StkId func, <span class="keyword">int</span> nresults)</span> </span>&#123;</span><br><span class="line">  lua_CFunction f;</span><br><span class="line">  CallInfo *ci;</span><br><span class="line">  <span class="keyword">int</span> n;  <span class="comment">/* number of arguments (Lua) or returns (C) */</span></span><br><span class="line">  <span class="keyword">ptrdiff_t</span> funcr = savestack(L, func);</span><br><span class="line">  <span class="keyword">switch</span> (ttype(func)) &#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">case</span> LUA_TLCL: &#123;  <span class="comment">/* Lua function: prepare its call */</span></span><br><span class="line">      StkId base;</span><br><span class="line">      Proto *p = clLvalue(func)-&gt;p;</span><br><span class="line">      ...</span><br><span class="line">      ci = next_ci(L);  <span class="comment">/* now 'enter' new function */</span></span><br><span class="line">      ci-&gt;nresults = nresults;</span><br><span class="line">      ci-&gt;func = func;</span><br><span class="line">      ci-&gt;u.l.base = base;</span><br><span class="line">      ci-&gt;top = base + p-&gt;maxstacksize;</span><br><span class="line">      </span><br><span class="line">      lua_assert(ci-&gt;top &lt;= L-&gt;stack_last);</span><br><span class="line">      </span><br><span class="line">      ci-&gt;u.l.savedpc = p-&gt;code;  <span class="comment">/* starting point */</span></span><br><span class="line">      ci-&gt;callstatus = CIST_LUA;</span><br><span class="line">      </span><br><span class="line">      L-&gt;top = ci-&gt;top;</span><br><span class="line">      luaC_checkGC(L);  <span class="comment">/* stack grow uses memory */</span></span><br><span class="line">      <span class="keyword">if</span> (L-&gt;hookmask &amp; LUA_MASKCALL)</span><br><span class="line">        callhook(L, ci);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>从 lua_State 的 CallInfo 数组中得到一个新的 CallInfo 结构体，设置它的func、base、top 指针</li><li>从前面分析阶段生成的 Closure 指针中，取出保存下来的 Proto 结构体。这个结构体中保存的是分析过程完结之后生成的字节码等信息。</li><li>将这里创建的 CallInfo 指针的 top、base 指针赋给 lua_State 结构体的 top、base 指针。将 Proto 结构体的 code 成员赋值给 lua_State 指针的 savedpc 字段，code 成员保留的就是字节码。</li><li>将多余的函数参数赋值为 nil，比如一个函数定义中需要的是两个参数，实际传入的只有一个，那么多出来的那个参数会被赋值为 nil。</li></ul><p>执行完 luaD_precall 函数之后，接着会进入 luaV_execute 函数，<strong>这里是虚拟机执行代码的主函数</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lvm.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">luaV_execute</span> <span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">  CallInfo *ci = L-&gt;ci;</span><br><span class="line">  LClosure *cl;</span><br><span class="line">  TValue *k;</span><br><span class="line">  StkId base;</span><br><span class="line"> newframe:  <span class="comment">/* reentry point when frame changes (call/return) */</span></span><br><span class="line">  lua_assert(ci == L-&gt;ci);</span><br><span class="line">  cl = clLvalue(ci-&gt;func);</span><br><span class="line">  k = cl-&gt;p-&gt;k;</span><br><span class="line">  base = ci-&gt;u.l.base;</span><br><span class="line">  <span class="comment">/* main loop of interpreter */</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    Instruction i = *(ci-&gt;u.l.savedpc++);</span><br><span class="line">    StkId ra;</span><br><span class="line">    <span class="keyword">if</span> ((L-&gt;hookmask &amp; (LUA_MASKLINE | LUA_MASKCOUNT)) &amp;&amp;</span><br><span class="line">        (--L-&gt;hookcount == <span class="number">0</span> || L-&gt;hookmask &amp; LUA_MASKLINE)) &#123;</span><br><span class="line">      Protect(luaG_traceexec(L));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* WARNING: several calls may realloc the stack and invalidate 'ra' */</span></span><br><span class="line">    ra = RA(i);</span><br><span class="line">    <span class="comment">/* 后面是各种字节码的处理流程 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 ci-&gt;u.l.savedpc存放的是虚拟机 OpCode 代码，这部分从 L-&gt;savepc 初始化而来，而 L-&gt;savepc 在 luaD_precall 中赋值。可以看到，luaV_execute 函数最主要的作用就是一个大循环，将当前传入的指令依次执行。</p><p>执行完毕后，会调用 luaD_poscall 函数恢复到上一次函数调用的环境。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">luaD_poscall</span> <span class="params">(lua_State *L, StkId firstResult)</span> </span>&#123;</span><br><span class="line">  StkId res;</span><br><span class="line">  <span class="keyword">int</span> wanted, i;</span><br><span class="line">  CallInfo *ci = L-&gt;ci;</span><br><span class="line">  <span class="keyword">if</span> (L-&gt;hookmask &amp; (LUA_MASKRET | LUA_MASKLINE)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;hookmask &amp; LUA_MASKRET) &#123;</span><br><span class="line">      <span class="keyword">ptrdiff_t</span> fr = savestack(L, firstResult);  <span class="comment">/* hook may change stack */</span></span><br><span class="line">      luaD_hook(L, LUA_HOOKRET, <span class="number">-1</span>);</span><br><span class="line">      firstResult = restorestack(L, fr);</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;oldpc = ci-&gt;previous-&gt;u.l.savedpc;  <span class="comment">/* 'oldpc' for caller function */</span></span><br><span class="line">  &#125;</span><br><span class="line">  res = ci-&gt;func;  <span class="comment">/* res == final position of 1st result */</span></span><br><span class="line">  wanted = ci-&gt;nresults;</span><br><span class="line">  L-&gt;ci = ci = ci-&gt;previous;  <span class="comment">/* back to caller */</span></span><br><span class="line">  <span class="comment">/* move results to correct place */</span></span><br><span class="line">  <span class="keyword">for</span> (i = wanted; i != <span class="number">0</span> &amp;&amp; firstResult &lt; L-&gt;top; i--)</span><br><span class="line">    setobjs2s(L, res++, firstResult++);</span><br><span class="line">  <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>)</span><br><span class="line">    setnilvalue(res++);</span><br><span class="line">  L-&gt;top = res;</span><br><span class="line">  <span class="keyword">return</span> (wanted - LUA_MULTRET);  <span class="comment">/* 0 iff wanted == LUA_MULTRET */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="虚拟机执行流程："><a href="#虚拟机执行流程：" class="headerlink" title="虚拟机执行流程："></a>虚拟机执行流程：</h4><ol><li>在f_parser函数中，对代码文件的分析返回了Proto指针。这个指针会保存在Closure指针中，留待后续继续使用。</li><li>在luaD_precall函数中，将lua_state的savedpc指针指向第一步中Proto结构体的code指针，同时准备好函数调用时的栈信息。</li><li>在luaV_execute函数中，pc指针指向第二步的savedpc指针（Lua5.3中似乎直接使用的savedpc指针），紧跟着就是一个大的循环体，依次取出其中的OpCode执行。</li><li>执行完毕后，调用luaD_poscall函数恢复到上一个函数的环境。</li></ol><p><img src="https://i.loli.net/2019/08/22/sUtLPaW61eX8jx7.png" alt="FlowchartDiagram2.png"></p><p>虚拟机指令执行的两大入口如下：</p><ul><li>词法、语法分析阶段的luaY_parser，Lua一次遍历脚本文件完成了词法分析和语法分析，生成的OpCode存放在Proto结构体的code数组中。</li><li>luaV_execute：虚拟机执行指令阶段的入口函数，取出第一步生成的Proto结构体中的指令执行。</li></ul><p>Proto结构体中的数据：</p><ul><li>函数的常量数组</li><li>编译生成的字节码信息</li><li>函数的局部变量信息</li><li>保存upvalue名字的数组</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Function Prototypes</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Proto</span> &#123;</span></span><br><span class="line">  CommonHeader;</span><br><span class="line">  lu_byte numparams;  <span class="comment">/* number of fixed parameters */</span></span><br><span class="line">  lu_byte is_vararg;</span><br><span class="line">  lu_byte maxstacksize;  <span class="comment">/* maximum stack used by this function */</span></span><br><span class="line">  <span class="keyword">int</span> sizeupvalues;  <span class="comment">/* size of 'upvalues' */</span></span><br><span class="line">  <span class="keyword">int</span> sizek;  <span class="comment">/* size of 'k' */</span></span><br><span class="line">  <span class="keyword">int</span> sizecode;</span><br><span class="line">  <span class="keyword">int</span> sizelineinfo;</span><br><span class="line">  <span class="keyword">int</span> sizep;  <span class="comment">/* size of 'p' */</span></span><br><span class="line">  <span class="keyword">int</span> sizelocvars;</span><br><span class="line">  <span class="keyword">int</span> linedefined;</span><br><span class="line">  <span class="keyword">int</span> lastlinedefined;</span><br><span class="line">  TValue *k;  <span class="comment">/* constants used by the function */</span></span><br><span class="line">  Instruction *code;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Proto</span> **<span class="title">p</span>;</span>  <span class="comment">/* functions defined inside the function */</span></span><br><span class="line">  <span class="keyword">int</span> *lineinfo;  <span class="comment">/* map from opcodes to source lines (debug information) */</span></span><br><span class="line">  LocVar *locvars;  <span class="comment">/* information about local variables (debug information) */</span></span><br><span class="line">  Upvaldesc *upvalues;  <span class="comment">/* upvalue information */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LClosure</span> *<span class="title">cache</span>;</span>  <span class="comment">/* last created closure with this prototype */</span></span><br><span class="line">  TString  *source;  <span class="comment">/* used for debug information */</span></span><br><span class="line">  GCObject *gclist;</span><br><span class="line">&#125; Proto;</span><br></pre></td></tr></table></figure><hr><p>该程序最终会调用 luaV_execute() 函数执行，开始会初始化 global_State、lua_State 两个结构体，用来保存上下文的相关信息。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">main()</span><br><span class="line"> |-luaL_newstate()                  # 创建global_State+lua_State，并初始化</span><br><span class="line"> |-lua_pcall()                      # 实际会调用pmain()函数</span><br><span class="line">   |                                # 根据不同的参数调用不同的函数</span><br><span class="line">   |-runargs()                      # 执行命令行通过-e指定的命令</span><br><span class="line">   |-doREPL()                       # 执行交互模式，也即<span class="built_in">read</span>-eval-<span class="built_in">print</span> loop</span><br><span class="line">   |-handle_script()                # 执行lua脚本</span><br><span class="line">     |-luaL_loadfile()              # 加载lua文件，后面详细介绍</span><br><span class="line">     | |-lua_load()</span><br><span class="line">     |</span><br><span class="line">     |-docall()                     # 调用执行</span><br><span class="line">       |-lua_pcall()</span><br><span class="line">         |-luaD_pcall()             # 实际会调用f_call()函数</span><br></pre></td></tr></table></figure><p>在调用函数执行过程中，最终会调用 luaV_execute() 函数。<br>其中，主要处理字节码的是 for(;;){} 循环，也即进入到解释器的主循环，处理很简单，取得当前指令，pc 递增，初始化 ra，然后根据指令的操作码进行选择；然后接下来是一大串的 switch … case … 处理。</p><p>接下来对其中有主要的几类指令进行说明。</p><hr><p>关于define部分符号用法详见：<a href="https://www.jianshu.com/p/e9f00097904a，先转一个，有时间了再写。" target="_blank" rel="noopener">https://www.jianshu.com/p/e9f00097904a，先转一个，有时间了再写。</a></p><p>另一个参考：<a href="https://gcc.gnu.org/onlinedocs/cpp/Macros.html#Macros" target="_blank" rel="noopener">https://gcc.gnu.org/onlinedocs/cpp/Macros.html#Macros</a></p>]]></content>
      
      
      <categories>
          
          <category> 源码阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lua与C交互相关</title>
      <link href="/2019/08/16/Lua/Lua%E4%B8%8EC%E4%BA%A4%E4%BA%92%E7%9B%B8%E5%85%B3/"/>
      <url>/2019/08/16/Lua/Lua%E4%B8%8EC%E4%BA%A4%E4%BA%92%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<p>C语言API总览。</p><a id="more"></a><p>C语言和Lua语言的两种交互形式：</p><ol><li>C语言拥有控制权，而Lua语言被用作库，这种交互形式中的C代码被称为应用代码。</li><li>Lua语言拥有控制权，而C语言被用作库，此时的C代码被称为库代码。</li></ol><p>应用代码和库代码都适用相同的API和Lua语言通信，这些API称为C API。</p><h3 id="一个简单的独立解释器："><a href="#一个简单的独立解释器：" class="headerlink" title="一个简单的独立解释器："></a>一个简单的独立解释器：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"lua.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"lauxlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"lualib.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buff[<span class="number">256</span>];</span><br><span class="line">  <span class="keyword">int</span> error;</span><br><span class="line">  lua_State *L = luaL_newstate();<span class="comment">/* 打开Lua */</span></span><br><span class="line">  luaL_openlibs(L);<span class="comment">/* 打开标准库 */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(fgets(buuff,<span class="keyword">sizeof</span>(buff),<span class="built_in">stdin</span>) != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    error = luaL_loadstring(L,buff) || lua_pcall(L,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(error)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"%s\n"</span>,lua_tostring(L,<span class="number">-1</span>));</span><br><span class="line">      lua_pop(L,<span class="number">1</span>);<span class="comment">/* 从栈中弹出错误信息 */</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  lua_close(L);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>头文件lua.h声明了Lua提供的基础函数，其中包括创建新Lua环境的函数、调用Lua函数的函数、读写环境中的全局变量的函数，以及注册供Lua语言调用的新函数的函数，等等。其中声明的所有内容都有一个前缀lua_。</p><p>头文件lauxlib.h声明了辅助库所提供的函数，其中所有的声明均以luaL_开头。</p><p>头文件lualib.h中声明了用于打开这些库的函数。</p><h3 id="栈："><a href="#栈：" class="headerlink" title="栈："></a>栈：</h3><p>Lua和C之间通信的主要组件是虚拟栈，几乎所有的API的调用都是在操作这个栈中的值，Lua和C之间所有的数据交换都是通过这个栈完成的，此外，还可以利用栈保存中间结果。</p><p>为了解决<strong>动态类型和静态类型体系之间不匹配</strong>，以及<strong>自动内存管理和手动内存管理之间不匹配</strong>：Lua API中没有定义任何类似于lua_Value的类型，而是使用栈在Lua和C之间交换数据。栈中的每个元素都能保存Lua中任意类型的值。当我们想要从Lua中获取一个值时，只需调用Lua，Lua就会将指定的值压入栈中。当想要将一个值传给Lua时，首先要将这个值压入栈，然后调用Lua将其从栈中弹出即可。这需要每个C语言类型都有一个函数将其压入栈，还需要每个类型都有一个弹出的函数，但是避免了过多的组合，<strong>另外由于这个栈是Lua状态的一部分，因此垃圾收集器知道C语言正在使用哪些值。</strong></p><h4 id="压入元素："><a href="#压入元素：" class="headerlink" title="压入元素："></a>压入元素：</h4><p>针对每一种能用C语言直接表示的Lua数据类型，C API中都有一个对应的压栈函数。</p><p>对栈空间的检查可以使用int lua_checkstack(lua_State *L,int sz);这里，sz是我们所需的额外栈位置的数量，如果可能，函数 lua_checkstack 会增加栈的大小，以容纳所需的额外空间；否则该函数返回0。</p><h4 id="查询元素："><a href="#查询元素：" class="headerlink" title="查询元素："></a>查询元素：</h4><p>第一个被压入栈的元素索引为1，第二个被压入的元素索引为2，依此类推。也可以使用负数索引来访问栈中的元素，栈顶的元素为-1，-2表示在它之前被压入栈中的元素。</p><p>与Lua栈相关的函数游一系列，在此不做赘述。</p><h3 id="使用C-API进行错误处理："><a href="#使用C-API进行错误处理：" class="headerlink" title="使用C API进行错误处理："></a>使用C API进行错误处理：</h3><h4 id="处理应用程序中的错误："><a href="#处理应用程序中的错误：" class="headerlink" title="处理应用程序中的错误："></a>处理应用程序中的错误：</h4><p>Lua语言通常通过长跳转来提示错误，但是如果没有相应的setjmp，解释器就无法进行长跳转。此时，API中的任何错误都会导致Lua调用紧急函数。当这个函数返回后，应用就会退出。</p><p>要正确的处理应用代码中的错误，就必须通过Lua语言调用我们自己的代码，即在setjmp的上下文中运行代码。</p><p>我们可以把C代码封装到一个函数F中，然后使用lua_pcall调用这个函数F，通过这种方式，我们的C代码会在保护模式下运行。即便发生内存分配失败，函数lua_pcall也会返回一个对应的错误码，使解释器能够保持一致的状态：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">foo</span><span class="params">(lua_State *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//code to run in protected mode</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">secure_foo</span><span class="params">(lua_State *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">lua_pushcfunction(L,foo);</span><br><span class="line"><span class="keyword">return</span> (lua_pcall(L,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>) == <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论发生什么，调用secure_foo时都会返回一个布尔值，来表示foo执行是否成功。</p><h4 id="处理库代码中的错误："><a href="#处理库代码中的错误：" class="headerlink" title="处理库代码中的错误："></a>处理库代码中的错误：</h4><p>当C语言库中的函数检测到错误时，只需简单的调用lua_error即可。</p><h3 id="内存分配："><a href="#内存分配：" class="headerlink" title="内存分配："></a>内存分配：</h3><p>Lua语言核心对内存分配不进行任何假设，只会通过一个分配函数来分配和释放内存，当用户创建lua状态时必须提供该函数。</p><p>luaL_newstate是一个用默认分配函数来创建Lua状态的辅助函数。该默认分配函数使用了来自C语言标准函数库的标准函数malloc-realloc-free，对于大多数应用程序来说已经够了，但是，要完全控制Lua的内存分配也很容易，使用原始的lua_newstate来创建我们自己的Lua状态即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">lua_State *<span class="title">lua_newstate</span><span class="params">(lua_Alloc f,<span class="keyword">void</span> *ud)</span></span></span><br></pre></td></tr></table></figure><p>该函数有两个参数：一个是分配函数，另一个是用户数据。用这种方式创建的Lua状态会通过调用f完成所有的内存分配和释放，甚至结构lua_State也是由f分配的。</p><p>分配函数f必须满足lua_Alloc的类型声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> *(*lua_Alloc)(<span class="keyword">void</span> *ud,<span class="comment">// 为lua_newstate所提供的用户数据</span></span><br><span class="line"> <span class="keyword">void</span> *ptr,<span class="comment">// 正要被分配或者释放的块的地址</span></span><br><span class="line"> <span class="keyword">size_t</span> osize,<span class="comment">// 原始块的大小</span></span><br><span class="line"> <span class="keyword">size_t</span> nsize);<span class="comment">// 请求的块大小</span></span><br></pre></td></tr></table></figure><p>如果ptr不是NULL，则lua会保证其之前被分配的大小就是osize。</p><p>当nsize为0时，分配函数必须释放ptr指向的块并返回NULL，对应于所要求的大小为零的块。当ptr时NULL时，该函数必须分配并返回一个指定大小的块；如果无法分配指定的块，则必须返回NULL。</p><h3 id="pcall："><a href="#pcall：" class="headerlink" title="pcall："></a>pcall：</h3><p>在调用函数lua_pcall时，第二个参数表示传递的参数数量，第三个参数是期望的结果数量，第四个参数代表错误处理函数。就像Lua语言的赋值一样，函数lua_pcall会根据所要求的数量来调整返回值的个数，即压入nil或丢弃多余的结果。在压入结果前，lua_pcall会把函数和其参数从栈中移除。当一个函数返回多个结果时，那么第一个结果最后被压入。</p><h3 id="在Lua中调用C语言："><a href="#在Lua中调用C语言：" class="headerlink" title="在Lua中调用C语言："></a>在Lua中调用C语言：</h3><p>当Lua调用C函数时，我们必须注册该函数，即必须以一种恰当的方式为Lua提供该C函数的地址。Lua调用C函数时，也使用了一个与C语言调用Lua函数时相同类型的栈，C函数从栈中获取参数，并将结果压入栈中。</p><p>这个栈不是一个全局结构；每个函数都有其私有的局部栈。当Lua调用一个C函数时，第一个参数总是位于这个局部栈中索引为1的位置。即使一个C函数调用了Lua代码，而且Lua代码又再次调用了同一个的C函数，这些调用每一个都只会看到本次调用自己的私有栈，其中索引为1的位置上就是第一个参数。</p><p>所有在Lua中注册的函数都必须使用一个相同的原型，该原型就是定义在lua.h中的lua_CFunction：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*lua_CFunction)</span><span class="params">(lua_State *L)</span></span></span><br></pre></td></tr></table></figure><p>在Lua中，调用这个函数前，还必须通过lua_pushcfunction注册该函数。函数lua_pushcfunction会获取一个指向C函数的指针，然后在Lua中创建一个“function”类型，代表待注册的函数。一旦完成注册，C函数就可以像其他Lua函数一样行事了。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lua源码阅读：基本数据类型Table</title>
      <link href="/2019/08/12/Lua/Lua%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8BTable/"/>
      <url>/2019/08/12/Lua/Lua%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8BTable/</url>
      
        <content type="html"><![CDATA[<p>Lua中Table数据结构的定义、初始化、查找等。</p><a id="more"></a><h3 id="Table数据结构的定义："><a href="#Table数据结构的定义：" class="headerlink" title="Table数据结构的定义："></a>Table数据结构的定义：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> TKey &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    TValuefields;</span><br><span class="line">    <span class="keyword">int</span> next;  <span class="comment">/* for chaining (offset for next node) */</span></span><br><span class="line">  &#125; nk;</span><br><span class="line">  TValue tvk;</span><br><span class="line">&#125; TKey;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  TValue i_val;</span><br><span class="line">  TKey i_key;</span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Table</span> &#123;</span></span><br><span class="line">  CommonHeader;</span><br><span class="line">  lu_byte flags;  <span class="comment">/* 1&lt;&lt;p means tagmethod(p) is not present */</span></span><br><span class="line">  lu_byte lsizenode;  <span class="comment">/* log2 of size of 'node' array */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> sizearray;  <span class="comment">/* size of 'array' array */</span></span><br><span class="line">  TValue *<span class="built_in">array</span>;  <span class="comment">/* array part */</span></span><br><span class="line">  Node *node;</span><br><span class="line">  Node *lastfree;  <span class="comment">/* any free position is before this position */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Table</span> *<span class="title">metatable</span>;</span></span><br><span class="line">  GCObject *gclist;</span><br><span class="line">&#125; Table;</span><br></pre></td></tr></table></figure><ul><li>Table的结构中有CommonHeader成员，这是一个在lObject.h中定义的宏，包含了一些成员，所有受gc管理的对象均含有CommonHeader，其继承自GObject对象。CommonHeader 相当于来自父类的数据，在整个结构的最前面，其他成员相当于子类数据。通过这种方式可以让GCObject 指针指向所有受gc管理的lua的对象，并且CommonHeader 结构中还有当前对象的类型，可以转换成具体类型的对象。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Common Header for all collectable objects (in macro form, to be</span></span><br><span class="line"><span class="comment">** included in other objects)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CommonHeaderGCObject *next; lu_byte tt; lu_byte marked</span></span><br></pre></td></tr></table></figure><p>TValue是所有lua数据类型的集合，其包含一个类型_tt和一个value，Value类型是一个union，可以是lua的任意类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Tagged Values. This is the basic representation of values in Lua,</span></span><br><span class="line"><span class="comment">** an actual value plus a tag with its type.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TValuefieldsValue value_; int tt_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lua_TValue</span> <span class="title">TValue</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> Value &#123;</span><br><span class="line">  GCObject *gc;    <span class="comment">/* collectable objects */</span></span><br><span class="line">  <span class="keyword">void</span> *p;         <span class="comment">/* light userdata */</span></span><br><span class="line">  <span class="keyword">int</span> b;           <span class="comment">/* booleans */</span></span><br><span class="line">  lua_CFunction f; <span class="comment">/* light C functions */</span></span><br><span class="line">  lua_Integer i;   <span class="comment">/* integer numbers */</span></span><br><span class="line">  lua_Number n;    <span class="comment">/* float numbers */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lua_TValue</span> &#123;</span></span><br><span class="line">  TValuefields;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Table主要有两部分，数组和哈希</strong>：</p><ol><li><p>array和node是两个一维数组，array是普通的数组，成员为TValue，node是一个hash表存放key,value键值对。node的key为TKey类型，Tkey是一个union，当没有hash冲突的时候是一个TValue，当有hash冲突的时候TKey是一个struct，多一个next值，指向下一个有冲突的节点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> TKey &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    TValuefields;</span><br><span class="line">    <span class="keyword">int</span> next;  <span class="comment">/* for chaining (offset for next node) */</span></span><br><span class="line">  &#125; nk;</span><br><span class="line">  TValue tvk;</span><br><span class="line">&#125; TKey;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* copy a value into a key without messing up field 'next' */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> setnodekey(L,key,obj) \</span></span><br><span class="line">&#123; TKey *k_=(key); <span class="keyword">const</span> TValue *io_=(obj); \</span><br><span class="line">  k_-&gt;nk.value_ = io_-&gt;value_; k_-&gt;nk.tt_ = io_-&gt;tt_; \</span><br><span class="line">  (<span class="keyword">void</span>)L; checkliveness(G(L),io_); &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  TValue i_val;</span><br><span class="line">  TKey i_key;</span><br><span class="line">&#125; Node;</span><br></pre></td></tr></table></figure></li><li><p>sizearray：是数组array的大小</p></li><li><p>lsizenode：2^lsizenode 的值为node 的大小</p></li><li><p>lastfree：lastfree 指针的右边均由非空的或者不能访问的node (即不属于自己的空间，访问会越界)组成</p></li><li><p>metatable ：元表</p></li><li><p>gclist：与gc 有关，将table加入到gray表中时，gclist指向gray表中的下一个元素或者NULL</p></li><li><p>flags : 这是一个byte类型的数据，用于表示这个表中提供了哪些元方法，最开始的flag为1，当查找了一次之后，如果该表中存在某个元方法，那么将该元方法对应的flag bit置为0，这样下一次查找时只需要比较这个bit就行了。每个元方法对应的bit定义在ltm.h中 。</p></li></ol><p><img src="https://i.loli.net/2019/08/21/sF6xuL3Y4eOKHUJ.png" alt="68747470733a2f2f7261772e6769746875622e636f6d2f6c69636875616e672f4c75612d536f757263652d496e7465726e616c2f6d61737465722f7069632f7461626c652e706e67.png"></p><h3 id="Table的初始化："><a href="#Table的初始化：" class="headerlink" title="Table的初始化："></a>Table的初始化：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Table *<span class="title">luaH_new</span> <span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">  GCObject *o = luaC_newobj(L, LUA_TTABLE, <span class="keyword">sizeof</span>(Table));</span><br><span class="line">  Table *t = gco2t(o);</span><br><span class="line">  t-&gt;metatable = <span class="literal">NULL</span>;</span><br><span class="line">  t-&gt;flags = cast_byte(~<span class="number">0</span>);</span><br><span class="line">  t-&gt;<span class="built_in">array</span> = <span class="literal">NULL</span>;</span><br><span class="line">  t-&gt;sizearray = <span class="number">0</span>;</span><br><span class="line">  setnodevector(L, t, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，为Table开辟空间，然后将其加到allgc链表上通过gc进行管理，之后初始化Table的内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setnodevector</span> <span class="params">(lua_State *L, Table *t, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> lsize;</span><br><span class="line">  <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;  <span class="comment">/* no elements to hash part? */</span></span><br><span class="line">    t-&gt;node = cast(Node *, dummynode);  <span class="comment">/* use common 'dummynode' */</span></span><br><span class="line">    lsize = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    lsize = luaO_ceillog2(size);</span><br><span class="line">    <span class="keyword">if</span> (lsize &gt; MAXHBITS)</span><br><span class="line">      luaG_runerror(L, <span class="string">"table overflow"</span>);</span><br><span class="line">    size = twoto(lsize);</span><br><span class="line">    t-&gt;node = luaM_newvector(L, size, Node);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)size; i++) &#123;</span><br><span class="line">      Node *n = gnode(t, i);</span><br><span class="line">      gnext(n) = <span class="number">0</span>;</span><br><span class="line">      setnilvalue(wgkey(n));</span><br><span class="line">      setnilvalue(gval(n));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  t-&gt;lsizenode = cast_byte(lsize);</span><br><span class="line">  t-&gt;lastfree = gnode(t, size);  <span class="comment">/* all positions are free */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dummynode(&amp;dummynode_)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isdummy(n)((n) == dummynode)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> Node dummynode_ = &#123;</span><br><span class="line">  &#123;NILCONSTANT&#125;,  <span class="comment">/* value */</span></span><br><span class="line">  &#123;&#123;NILCONSTANT, <span class="number">0</span>&#125;&#125;  <span class="comment">/* key */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>flag设置为全1表示没有元方法，node指向的不是NULL而是dummynode，dummynode是一个全局共享的对象（key和value均为nil），这样做可以减少NULL的判断：例如，刚初始化完table，需要查找一个key为“test”的对象，因为lsizenode为0，所以经过运算确定的位置肯定为node[0]，然后读取node[0].i_key和“test”的TKey进行比较，判断是否相同，node[0]是dummynode，所以比较结果肯定不相同，所以返回nil；如果node[0]为NULL，访问node[0]的时候必须先判断node[0]是否为NULL，否则直接访问会越界，dummynode的设计省去了NULL的判断。</p><h3 id="Table的查找："><a href="#Table的查找：" class="headerlink" title="Table的查找："></a>Table的查找：</h3><p>因为<strong>table有两部分，数组和hash表</strong>，所以查找也分为两部分来进行：</p><ol><li>在数组中查找，如果传入的key是integer类型，而且其值-1小于sizearray的话，在数组中查找。</li><li>其他情况在hash表中查找：计算出该key的散列值，根据此散列值访问Node数组得到散列桶所在的位置，遍历该散列桶下的所有链表元素，直到找到该key为止。</li></ol><p>在Lua中除了nil，其他类型均可以作为表的key，那么table的key是如何与其array数组与hash表的下标对应的呢？</p><p>对于array数组，如果是上述的第一种情况，则直接将key-1即得到了下标，对于hash表则需要将key转换成uint类型，然后通过计算得到下标。</p><p>通过运算将各类型转换为uint 类型的值，如将LUA_TNUMFLT 类型二进制数值转成以uint 型类 型表示，将LUA_TTABLE 的gc 指针转换为uint 类型， LUA_TSHRSTR 类型直接取其hash值，因为短字符串在构造时会计算其hash值，LUA_TLNGSTR 类型则需要通过hash函数计算其hash值。在 完成了对key 的hash运算以后，需要根据key 的hash值计算该key对应hash表中的哪个下标，计算的公式是:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index = hash_value &amp; ((<span class="number">2</span>^lsizenode) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>其中2^lsizenode - 1 为一个二进制低位全为1 的值，和hash_value 相与可以保证hash_value超过2^lsizenode - 1 的部分为0，则得到的值一定在[0，(2^lsizenode) - 1] 区间内，此时key和hash 表的下标就对应了起来，并且不会越界。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** main search function</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> TValue *<span class="title">luaH_get</span> <span class="params">(Table *t, <span class="keyword">const</span> TValue *key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (ttype(key)) &#123;</span><br><span class="line">    <span class="keyword">case</span> LUA_TSHRSTR: <span class="keyword">return</span> luaH_getstr(t, tsvalue(key));</span><br><span class="line">    <span class="keyword">case</span> LUA_TNUMINT: <span class="keyword">return</span> luaH_getint(t, ivalue(key));</span><br><span class="line">    <span class="keyword">case</span> LUA_TNIL: <span class="keyword">return</span> luaO_nilobject;</span><br><span class="line">    <span class="keyword">case</span> LUA_TNUMFLT: &#123;</span><br><span class="line">      lua_Integer k;</span><br><span class="line">      <span class="keyword">if</span> (numisinteger(fltvalue(key), &amp;k)) <span class="comment">/* index is int? */</span></span><br><span class="line">        <span class="keyword">return</span> luaH_getint(t, k);  <span class="comment">/* use specialized version */</span></span><br><span class="line">      <span class="comment">/* else go through */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>: &#123;</span><br><span class="line">      Node *n = mainposition(t, key);</span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;  <span class="comment">/* check whether 'key' is somewhere in the chain */</span></span><br><span class="line">        <span class="keyword">if</span> (luaV_rawequalobj(gkey(n), key))</span><br><span class="line">          <span class="keyword">return</span> gval(n);  <span class="comment">/* that's it */</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">int</span> nx = gnext(n);</span><br><span class="line">          <span class="keyword">if</span> (nx == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">          n += nx;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">return</span> luaO_nilobject;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** search function for integers</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> TValue *<span class="title">luaH_getint</span> <span class="params">(Table *t, lua_Integer key)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* (1 &lt;= key &amp;&amp; key &lt;= t-&gt;sizearray) */</span></span><br><span class="line">  <span class="keyword">if</span> (l_castS2U(key - <span class="number">1</span>) &lt; t-&gt;sizearray)</span><br><span class="line">    <span class="keyword">return</span> &amp;t-&gt;<span class="built_in">array</span>[key - <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    Node *n = hashint(t, key);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;  <span class="comment">/* check whether 'key' is somewhere in the chain */</span></span><br><span class="line">      <span class="keyword">if</span> (ttisinteger(gkey(n)) &amp;&amp; ivalue(gkey(n)) == key)</span><br><span class="line">        <span class="keyword">return</span> gval(n);  <span class="comment">/* that's it */</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> nx = gnext(n);</span><br><span class="line">        <span class="keyword">if</span> (nx == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        n += nx;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> luaO_nilobject;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Table的更新："><a href="#Table的更新：" class="headerlink" title="Table的更新："></a>Table的更新：</h3><p>table 更新也分两种情况:</p><ol><li>通过上述查找的 value 如果不是 luaO_nilobject ，直接将 value 更改即可，即table的修改和删除(将值置为nil)</li><li>查找返回的是 luaO_nilobject ，即 key 在 table 中不存在时( table 的插入操作)需要先找一个空的槽，然后完成插入操作，如果找不到空槽则需要扩容。</li></ol><p>散列表部分的数据组织是，首先计算数据的key所在的桶数组位置，这个位置称为mainposition。相同mainposition的数据以链表形式组织：</p><p><img src="https://i.loli.net/2019/08/21/YZegV9QXBEJTm8v.png" alt="FlowchartDiagram1.png"></p><p>这部分的API包括luaH_set、luaH_setnum、luaH_setstr 这三个函数，它们的实际行为并不在其函数内部对 key 所对应的数据进行添加或者修改，而是返回根据该 key 查找到的 TValue 指针，由外部的使用者来进行实际的替换操作。</p><p>当找不到对应的 key 时，这几个 API 最终都会调用内部的 newkey 函数分配一个新的 key 来返回。</p><p>具体的更新操作如下：</p><p><img src="https://i.loli.net/2019/08/20/jPHuwi6M2FgeSov.png" alt="TableUpdate.png"></p><ol><li><p>如果查找一个空槽：</p><p>在lua Table中有一个lastfree指针，在更新时通过该指针寻找一个空槽，lastfree 指针在最开始的时候指向NULL ，当空间不够rehash 时，lastfree 指针指向 node 数组中最后不可用的空间，如node 数组size为4 其指向的就是4 的位置(从0开始)。当需要找一个空槽时，lastfree指针向左移，判断当前位置有没有被占用，即key 是否为nil ，如果被占用则继续左移，直到找到一个空槽，或者地址大于node 的地址，即移动到了node 的前一个，表示没有找到。这种方式可以保证lastfree的右边和当前指向的位置均不可用或者被占用，可以减少在查找空槽时对非nil元素的遍历。</p></li><li><p>冲突时谁移动：</p><p>记冲突位置为index ，找到的空槽位置为freeindex ，发生冲突位置的key 为oldkey ， 新的key 为newkey 。发生冲突时计算oldkey 的下标，如果值为index ，则将newkey 建立 到freeindex 位置处，如果oldkey 计算后不是index ，而是因为冲突被移动到index 位置的，则移动oldkey 的node到新的槽。</p></li><li><p>Tkey的Next如何设置：</p><p>lua 中的Tkey 中添加了一个next 成员，通过next 可以查找冲突位置的所有元素。比如两个元素冲突了，冲突位置为index (下标，后面的freeindex 也是下标)，这两个元素分别 为node1 、node2 ，假设将node1 移动到了另一个位置freeindex ，那么node2 则在index位置，node2 的next 为freeindex 减去index ，当需要查找node1 时，通过hash 运算找到是node2 ，比较发现不是要找的元素，此时可以通过index + next 找到freeindex 的位置，继续比较判断发现是node1 则返回结果。这种方式可以减少查找时对非冲突元素的遍 历，加快查找效率，不过也有弊端就是每个节点占用的空间会增减四个字节。</p></li></ol><h4 id="Table的扩容："><a href="#Table的扩容：" class="headerlink" title="Table的扩容："></a>Table的扩容：</h4><p>rehash操作是hash 表不可避免的，当空间不够时就需要进行扩容，而扩容后每个元素的下标就需要重新计算。对于一般的开放地址法会有一个负载因子 ，当负载因子大于某个值的时候就需要扩容，这个是为了考虑效率问题，当负载因子越来越大的时候，元素之间冲突的可能性会越来越大，导致插入和查找的时间复杂度会增大所以需要扩容降低负载因子。lua 的table没有负载因子，而是当node 的所有空间都用完的时候才会扩容(被置为nil 也算，lastfree指针不会向右移动，而判断满的条件就是lastfree 已经到了第一个元素的位置)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** nums[i] = number of keys 'k' where 2^(i - 1) &lt; k &lt;= 2^i</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rehash</span> <span class="params">(lua_State *L, Table *t, <span class="keyword">const</span> TValue *ek)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> nasize, na;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> nums[MAXABITS + <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">int</span> totaluse;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= MAXABITS; i++) nums[i] = <span class="number">0</span>;  <span class="comment">/* reset counts */</span></span><br><span class="line">  nasize = numusearray(t, nums);  <span class="comment">/* count keys in array part */</span></span><br><span class="line">  totaluse = nasize;  <span class="comment">/* all those keys are integer keys */</span></span><br><span class="line">  totaluse += numusehash(t, nums, &amp;nasize);  <span class="comment">/* count keys in hash part */</span></span><br><span class="line">  <span class="comment">/* count extra key */</span></span><br><span class="line">  nasize += countint(ek, nums);</span><br><span class="line">  totaluse++;</span><br><span class="line">  <span class="comment">/* compute new size for array part */</span></span><br><span class="line">  na = computesizes(nums, &amp;nasize);</span><br><span class="line">  <span class="comment">/* resize the table to new computed sizes */</span></span><br><span class="line">  luaH_resize(L, t, nasize, totaluse - na);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩容前会先统计table中的数量，将其存至nasize中；建立了一个大小为32的数组并且初始化为0，然后统计array数组中不为nil的元素个数，统计时通过分段的方式进行统计，将所有的元素按(2\^(i-1),2\^i]分段，分为32 个区间段：(0.5, 1]、(1, 2]、(2, 4]、 (4, 8] ……，统计步骤如下：</p><ol><li>分配一个位图 nums，将其中的所有位置 0。这个位图的意义在于：nums 数组中第 i 个元素存放的是 key 在 2^(i-1)和 2^i 之间的元素数量。</li><li>遍历 Lua 表中的数组部分，计算其中的元素数量，更新对应的 nums 数组中的元素数量（numusearray函数）。</li><li>遍历 Lua 表中的散列桶部分，因为其中也可能存放了正整数，需要根据这里的正整数数量更新对应的 nums 数组元素数量（numusehash 函数）。</li><li>此时nums 数组已经拥有了当前这个 Table 中所有正整数的分配统计，逐个遍历 nums 数组，获得其范围区间内所包含的整数数量大于 50%的最大索引，作为重新散列之后的数组大小，超过这个范围的正整数，就分配到散列桶部分了（computesizes 函数）</li><li>根据上面计算得到的调整后的数组和散列桶大小调整表（resize 函数）。</li></ol><p>调整标准：<strong>希望在调整过后，数组在每一个二次方位置容纳的元素数量都超过该范围的 50%。能达到这个目标的话，我们就认为这个数组范围发挥了最大的效率</strong>。</p><h4 id="重新散列的代价与解决："><a href="#重新散列的代价与解决：" class="headerlink" title="重新散列的代价与解决："></a>重新散列的代价与解决：</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> a = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>,<span class="number">3</span> <span class="keyword">do</span></span><br><span class="line">a[i] = <span class="literal">true</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ol><li>最开始，Lua 创建了一个空表</li><li>在第一次迭代中，a[1]为 true 触发了一次重新散列操作，将数组部分长度设置为 2^0，即 1，散列表部分仍为空。</li><li>在第二次迭代中，a[2]为 true 触发了一次重新散列操作，将数组部分长度设置为 2^1，即 2。</li><li>最后一次迭代中，a[3]又触发了一次重新散列操作，将数组部分长度设置为 2^2，即 4。</li></ol><p>如果有很多很小的表要进行创建，则会对开销造成巨大的影响——可以<strong>预先填充</strong>以避免重新散列操作。</p><h3 id="Table-的迭代："><a href="#Table-的迭代：" class="headerlink" title="Table 的迭代："></a>Table 的迭代：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">luaH_next</span> <span class="params">(lua_State *L, Table *t, StkId key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i = findindex(L, t, key);  <span class="comment">/* find original element */</span></span><br><span class="line">  <span class="keyword">for</span> (; i &lt; t-&gt;sizearray; i++) &#123;  <span class="comment">/* try first array part */</span></span><br><span class="line">    <span class="keyword">if</span> (!ttisnil(&amp;t-&gt;<span class="built_in">array</span>[i])) &#123;  <span class="comment">/* a non-nil value? */</span></span><br><span class="line">      setivalue(key, i + <span class="number">1</span>);</span><br><span class="line">      setobj2s(L, key+<span class="number">1</span>, &amp;t-&gt;<span class="built_in">array</span>[i]);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (i -= t-&gt;sizearray; cast_int(i) &lt; sizenode(t); i++) &#123;  <span class="comment">/* hash part */</span></span><br><span class="line">    <span class="keyword">if</span> (!ttisnil(gval(gnode(t, i)))) &#123;  <span class="comment">/* a non-nil value? */</span></span><br><span class="line">      setobj2s(L, key, gkey(gnode(t, i)));</span><br><span class="line">      setobj2s(L, key+<span class="number">1</span>, gval(gnode(t, i)));</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">/* no more elements */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在数组部分查找数据：</span></span><br><span class="line"><span class="comment">查找成功，则返回该 key 的下一个数据</span></span><br><span class="line"><span class="comment">否则在散列桶部分查找数据：</span></span><br><span class="line"><span class="comment">查找成功，则返回该 key 的下一个数据</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>一开始进入 findindex 函数，返回一个整数索引，如果这个索引在表的 sizearray 之内，则说明落入到数组部分，否则就落入到散列桶部分。</p><h3 id="Table-取长度操作："><a href="#Table-取长度操作：" class="headerlink" title="Table 取长度操作："></a>Table 取长度操作：</h3><p>对Lua 中的表进行取长度的操作时，如果没有提供该表的原方法 _len，那么该操作只针对该表的序列部分进行——序列指的是该表的一个子集{1…n}，n是一个正整数，其中每个键对应的数据都不为 nil。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Try to find a boundary in table 't'. A 'boundary' is an integer index</span></span><br><span class="line"><span class="comment">** such that t[i] is non-nil and t[i+1] is nil (and 0 if t[1] is nil).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">luaH_getn</span> <span class="params">(Table *t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> j = t-&gt;sizearray;</span><br><span class="line">  <span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; ttisnil(&amp;t-&gt;<span class="built_in">array</span>[j - <span class="number">1</span>])) &#123;</span><br><span class="line">    <span class="comment">/* there is a boundary in the array part: (binary) search for it */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (j - i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">int</span> m = (i+j)/<span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span> (ttisnil(&amp;t-&gt;<span class="built_in">array</span>[m - <span class="number">1</span>])) j = m;</span><br><span class="line">      <span class="keyword">else</span> i = m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* else must find a boundary in hash part */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (isdummy(t-&gt;node))  <span class="comment">/* hash part is empty? */</span></span><br><span class="line">    <span class="keyword">return</span> j;  <span class="comment">/* that is easy... */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> unbound_search(t, j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Table的元表："><a href="#Table的元表：" class="headerlink" title="Table的元表："></a>Table的元表：</h3><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul><li>尽量不要在一个表中混用数组和散列桶部分，即一个表最好只存放一类数据。Lua 的实现上确实提供了两者统一表示的遍历，但这并不意味着使用者就应该混用这两种方式。</li><li>尽量不要在表中存放 nil 值，这会让取长度操作的行为不稳定。</li><li>尽量避免重新散列操作，因为这个操作的代价极大，通过预分配、只使用数组部分等策略规避这个 Lua 解释器背后的动作，能提升不少效率。</li></ul><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul><li>《lua 设计与实现》codedump 著</li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lua源码阅读：基本数据类型String</title>
      <link href="/2019/08/08/Lua/Lua%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8BString/"/>
      <url>/2019/08/08/Lua/Lua%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8BString/</url>
      
        <content type="html"><![CDATA[<p>Lua中对于String的实现。</p><a id="more"></a><p>Lua使用TString结构体代表一个字符串对象。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Header for string value; string bytes follow the end of this structure</span></span><br><span class="line"><span class="comment">** (aligned according to 'UTString'; see next).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TString</span> &#123;</span></span><br><span class="line">  CommonHeader;</span><br><span class="line">  lu_byte extra;  <span class="comment">/* reserved words for short strings; "has hash" for longs */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> hash;</span><br><span class="line">  <span class="keyword">size_t</span> len;  <span class="comment">/* number of characters in string */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">TString</span> *<span class="title">hnext</span>;</span>  <span class="comment">/* linked list for hash table */</span></span><br><span class="line">&#125; TString;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Ensures that address after this type is always fully aligned.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> UTString &#123;</span><br><span class="line">  L_Umaxalign dummy;  <span class="comment">/* ensures maximum alignment for strings 用于最大字节对齐 */</span></span><br><span class="line">  TString tsv;</span><br><span class="line">&#125; UTString;</span><br></pre></td></tr></table></figure><p>hash用来记录字符串对应的哈希值，len用来记录字符串的长度。</p><p>在Lua中，分为长字符串和短字符串，长度大于40的是长字符串，小于40的是短字符串，这部分在luaconf.h中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">@@ LUAI_MAXSHORTLEN is the maximum length for short strings, that is,</span></span><br><span class="line"><span class="comment">** strings that are internalized. (Cannot be smaller than reserved words</span></span><br><span class="line"><span class="comment">** or tags for metamethods, as these strings must be internalized;</span></span><br><span class="line"><span class="comment">** #("function") = 8, #("__newindex") = 10.)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LUAI_MAXSHORTLEN        40</span></span><br></pre></td></tr></table></figure><p>对于短字符串，在实际使用中一般用来作为索引或需要进行字符串比较，存放在global_State-&gt;strt中，这个字符串表（strt）是一个stringtable类型的全局唯一的哈希表，当需要创建一个短字符串对象时，会首先在这个表中查找已有对象。所有的短字符串都是全局唯一的，不会存在两个相同的短字符串对象，如果短字符串对象的extra&gt;0，表示这是一个系统保留的字符串；长字符串一般用来存放文本数据，很少需要比较或者索引，所以长字符串被挂接到allgc链表上当作普通的对象来处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** new string (with explicit length) 生成新字符串的函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">TString *<span class="title">luaS_newlstr</span> <span class="params">(lua_State *L, <span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">size_t</span> l)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= LUAI_MAXSHORTLEN)  <span class="comment">/* short string? */</span></span><br><span class="line">    <span class="keyword">return</span> internshrstr(L, str, l);</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l + <span class="number">1</span> &gt; (MAX_SIZE - <span class="keyword">sizeof</span>(TString))/<span class="keyword">sizeof</span>(<span class="keyword">char</span>))</span><br><span class="line">      luaM_toobig(L);</span><br><span class="line">    <span class="keyword">return</span> createstrobj(L, str, l, LUA_TLNGSTR, G(L)-&gt;seed);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在global_State中存储的哈希表结构体 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stringtable</span> &#123;</span></span><br><span class="line">  TString **hash;</span><br><span class="line">  <span class="keyword">int</span> nuse;  <span class="comment">/* number of elements  已装元素的个数 */</span></span><br><span class="line">  <span class="keyword">int</span> size;<span class="comment">/* 实际hash桶的大小 */</span></span><br><span class="line">&#125; stringtable;</span><br></pre></td></tr></table></figure><p>对于短字符串，在创建的时候，首先计算str的哈希值。计算时会得到一个随机种子，这个种子就是global_State-&gt;seed，然后通过LUAI_HASHLIMIT控制步长，每一个步长范围内取字符串中的一个字符，和上次hash的结果相加，得到新的hash结果，计算出hash后，开始找是否存在这个字符串，方法是遍历global_State-&gt;strt-&gt;hash，短字符串表申请内存的大小和实际使用大小由后两个字段表示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** checks whether short string exists and reuses it or creates a new one</span></span><br><span class="line"><span class="comment">** 检查短字符串的存在性，根据结果重用已存在的字符串或创建一个新的字符串</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> TString *<span class="title">internshrstr</span> <span class="params">(lua_State *L, <span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">size_t</span> l)</span> </span>&#123;</span><br><span class="line">  TString *ts;</span><br><span class="line">  global_State *g = G(L);</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> h = luaS_hash(str, l, g-&gt;seed);</span><br><span class="line">  TString **<span class="built_in">list</span> = &amp;g-&gt;strt.hash[lmod(h, g-&gt;strt.size)];</span><br><span class="line">  <span class="keyword">for</span> (ts = *<span class="built_in">list</span>; ts != <span class="literal">NULL</span>; ts = ts-&gt;hnext) &#123;</span><br><span class="line">    <span class="keyword">if</span> (l == ts-&gt;len &amp;&amp;</span><br><span class="line">        (<span class="built_in">memcmp</span>(str, getstr(ts), l * <span class="keyword">sizeof</span>(<span class="keyword">char</span>)) == <span class="number">0</span>)) &#123;</span><br><span class="line">      <span class="comment">/* found! */</span></span><br><span class="line">      <span class="keyword">if</span> (isdead(g, ts))  <span class="comment">/* dead (but not collected yet)? */</span></span><br><span class="line">        changewhite(ts);  <span class="comment">/* resurrect it */</span></span><br><span class="line">      <span class="keyword">return</span> ts;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (g-&gt;strt.nuse &gt;= g-&gt;strt.size &amp;&amp; g-&gt;strt.size &lt;= MAX_INT/<span class="number">2</span>) &#123;</span><br><span class="line">    luaS_resize(L, g-&gt;strt.size * <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">list</span> = &amp;g-&gt;strt.hash[lmod(h, g-&gt;strt.size)];  <span class="comment">/* recompute with new size */</span></span><br><span class="line">  &#125;</span><br><span class="line">  ts = createstrobj(L, str, l, LUA_TSHRSTR, h);</span><br><span class="line">  ts-&gt;hnext = *<span class="built_in">list</span>;</span><br><span class="line">  *<span class="built_in">list</span> = ts;</span><br><span class="line">  g-&gt;strt.nuse++;</span><br><span class="line">  <span class="keyword">return</span> ts;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对字符串按步长hash的函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">luaS_hash</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">size_t</span> l, <span class="keyword">unsigned</span> <span class="keyword">int</span> seed)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> h = seed ^ cast(<span class="keyword">unsigned</span> <span class="keyword">int</span>, l);</span><br><span class="line">  <span class="keyword">size_t</span> l1;</span><br><span class="line">  <span class="keyword">size_t</span> step = (l &gt;&gt; LUAI_HASHLIMIT) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (l1 = l; l1 &gt;= step; l1 -= step)</span><br><span class="line">    h = h ^ ((h&lt;&lt;<span class="number">5</span>) + (h&gt;&gt;<span class="number">2</span>) + cast_byte(str[l1 - <span class="number">1</span>]));</span><br><span class="line">  <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 源码阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lua中的垃圾回收机制</title>
      <link href="/2019/08/07/Lua/Lua%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/08/07/Lua/Lua%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>Lua中的垃圾回收机制：弱引用表，析构器和函数collectgarbage</p><a id="more"></a><h3 id="垃圾收集："><a href="#垃圾收集：" class="headerlink" title="垃圾收集："></a>垃圾收集：</h3><p>Lua语言使用自动内存管理，程序可以创建对象（表，闭包等），但却没有函数来删除对象。Lua语言通过垃圾收集自动的删除成为垃圾的对象。</p><p>弱引用表，析构器和函数<code>collectgarbage</code>是在Lua语言中用来辅助垃圾收集器的主要机制。弱引用表允许收集Lua语言中还可以被程序访问的对象；析构器允许收集不在垃圾收集器直接控制下的外部对象；函数collectgarbage则允许我们控制垃圾收集器的步长。</p><h4 id="弱引用表："><a href="#弱引用表：" class="headerlink" title="弱引用表："></a>弱引用表：</h4><p>垃圾收集器不能猜测我们认为哪些是垃圾，程序不会再用到的、存储在全局变量中的对象，对于Lua语言来说不是垃圾，需要我们的代码将这些对象所在的位置赋为nil，以便这些位置不会锁定可释放的对象。</p><p>简单的清除引用并不够，有些情况下，还需要程序和垃圾收集器之间的协作——当我们要保存某种类型的活跃对象的列表时，只需要将新对象插入数组即可；但是，一旦一个对象成为了数组的一部分，即使没有其他任何地方在引用它，但数组依然在引用它，无法被回收。</p><p><strong>弱引用表就是这样一种用来告知Lua语言一个引用不应阻止对一个对象回收的的机制。</strong></p><p>所谓<strong>弱引用是一种不在垃圾收集器考虑范围内的对象引用</strong>。如果对一个对象的所有引用都是弱引用，那么垃圾收集器将会回收这个对象并删除这些弱引用。Lua通过<strong>弱引用表</strong>来实现弱引用，弱引用表就是元素均为弱引用的表，这意味着如果一个对象只被一个弱引用表持有，那么Lua语言最终会回收这个对象。</p><p>表由键值对组成，其两者都可以容纳任意类型的对象。在正常情况下，垃圾收集器不会回收一个在可访问表中作为键和值的对象。也就是说，键和值都是<strong>强</strong>引用，他们会阻止对其所指向对象的回收。在一个弱引用表中，键和值都可以是弱引用的。这就意味着有<strong>三种类型</strong>的弱引用表：<strong>具有弱引用键的表</strong>、<strong>具有弱引用值的表</strong>及<strong>同时具有弱引用键和值的表</strong>。不论是哪种类型的弱引用表，只要有一个键或值被回收了，那么对应的整个键值对都会被从表中删除。</p><p>一个表是否为弱引用表是由其元表中的__mode字段所决定的。当这个字段存在时，其值应为一个字符串：如果这个字符串是”k”，则说明这个表的键（key）是弱引用的，如果这个字符串是”v”，那么这个表的值是弱引用的；如果这个字符串是“kv”，那么这个表的键和值都是弱引用的。</p><p>只有对象可以从弱引用表中被移除，而像数字和布尔这样的“值”是不可回收的。</p><h4 id="析构器："><a href="#析构器：" class="headerlink" title="析构器："></a>析构器：</h4><p>析构器是一个与对象关联的函数，当该对象即将被回收时该函数会被调用。</p><p>Lua语言通过元方法__gc实现析构器：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">o = &#123;x = <span class="string">"hi"</span>&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(o,&#123;<span class="built_in">__gc</span> = <span class="function"><span class="keyword">function</span><span class="params">(o)</span></span> <span class="built_in">print</span>(o.x) <span class="keyword">end</span>&#125;)</span><br><span class="line">o = <span class="literal">nil</span></span><br><span class="line"><span class="built_in">collectgarbage</span>()  <span class="comment">--&gt; hi</span></span><br></pre></td></tr></table></figure><p>通过给对象设置一个具有非空__gc元方法的元表，就可以将一个对象标记为需要进行析构处理，如果不标记对象，那么对象就不会被析构。</p><p>当垃圾收集器在同一个周期中析构多个对象时，它会按照对象被标记为需要析构处理的顺序<strong>逆序</strong>调用这些对象的析构器。</p><p>析构器的另一个特点是<strong>复苏</strong>：当一个析构器被调用时，它的参数是正在被析构的对象。因此，这个对象会至少在析构期间重新变成活跃的，这叫做“临时复苏”；在析构器执行期间，我们无法阻止析构器把该对象存储在全局变量中，使得该对象在析构器返回后仍然可访问，这称为“永久复苏”。</p><p>由于复苏的存在，Lua语言会在<strong>两个阶段</strong>中回收具有析构器的对象。当垃圾收集器<strong>首次发现</strong>某个具有析构器的对象不可达的时候，垃圾收集器就把这个对象<strong>复苏</strong>，并将其放入等待被析构的队列中。一旦析构器开始执行，Lua语言就将该对象标记为已被析构，当下一次垃圾收集器<strong>又发现</strong>这个对象不可达时，它就将这个对象删除。</p><p>如果想保证我们程序中的所有垃圾都被真正的释放了的话，那么必须调用<code>collectgarbage</code>两次，第二次调用才会删除第一次调用中被析构的对象。</p><p>由于Lua语言在被析构对象上设置的标记，每一个对象的析构器都会精确的运行一次，如果一个对象直到程序运行结束还没有被回收，那么Lua语言就会在整个Lua虚拟机关闭后调用它的析构器。</p><p>另一个有趣的技巧会允许程序在每次完成垃圾回收后调用指定的函数。由于析构器只运行一次，所以这种技巧是让每个析构器创建一个用来运行下一个析构器的新对象。</p><p>具有析构器的对象和弱引用表之间的交互也有些微妙：<strong>在每个垃圾收集周期内，垃圾收集器会在调用析构器前清理弱引用表的值，在调用析构器之后再清理键。</strong>这种行为的原理在于我们经常使用带有弱引用键来保存对象的属性，因此，析构器可能需要访问那些属性。不过，我们也会使用具有弱引用值的表来重用活跃的对象，在这种情况下，正在被析构的对象就不再有用了。</p><h4 id="垃圾收集器："><a href="#垃圾收集器：" class="headerlink" title="垃圾收集器："></a>垃圾收集器：</h4><p>一直到Lua5.0，Lua语言使用的都是一个简单的<strong>标记-清除式垃圾收集器</strong>，这种收集器又被称为<strong>全局暂停式</strong>的收集器，意味着Lua语言会时不时地停止主程序的运行来执行一次完整的垃圾收集周期。每一个垃圾收集周期由四个阶段组成：标记、清理、清除和析构。</p><ul><li>标记阶段：把根结点集合（由Lua语言可以直接访问的对象组成）标记为活跃。在Lua语言中，这个集合只包括C注册表。保存在一个活跃对象中的对象是程序可达的，因此也会被标记为活跃（弱引用表中的内容除外），当所有可达对象都被标记为活跃后，标记阶段完成。</li><li>清理阶段：首先，Lua语言遍历所有<strong>被标记为需要进行析构、但又没有被标记为活跃状态的对象</strong>。这些没有被标记为活跃状态的对象会被标记为活跃（<strong>复苏</strong>），并被放在一个单独的列表中，这个列表会在析构阶段用到。然后，Lua语言遍历弱引用表并从中移除键或值未被标记的元素。</li><li>清除阶段：遍历所有对象（Lua 语言把所有创建的对象放在一个链表中），如果一个对象没有被标记为活跃，Lua语言就将其回收。否则，Lua语言清理标记，然后准备进行下一个清理周期。</li><li>析构阶段：Lua语言调用清理阶段被分离出的对象的析构器。</li></ul><p>Lua5.1使用了增量式垃圾收集器。这种垃圾收集器像老版的垃圾收集器一样执行相同的步骤，但是不需要在垃圾收集期间停止主程序的运行：它与解释器一起交替运行，每当解释器分配了一定数量的内存时，垃圾收集器也执行一小步。</p><p>Lua5.2引入了紧急垃圾收集，当内存分配失败时，Lua语言会强制进行一次完整的垃圾收集，然后再次尝试分配。这些紧急情况可以发生在Lua语言进行内存分配的任意时刻，包括Lua语言处于不一致的代码执行状态时，因此，这些收集动作不能运行析构器。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lua源码阅读：C API</title>
      <link href="/2019/08/06/Lua/Lua%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%9AC%20API/"/>
      <url>/2019/08/06/Lua/Lua%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%9AC%20API/</url>
      
        <content type="html"><![CDATA[<p>Lua中关于C API的内容。</p><a id="more"></a><h2 id="Iapi-c"><a href="#Iapi-c" class="headerlink" title="Iapi.c"></a>Iapi.c</h2><h3 id="index2addr："><a href="#index2addr：" class="headerlink" title="index2addr："></a>index2addr：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> TValue *<span class="title">index2addr</span> <span class="params">(lua_State *L, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">  CallInfo *ci = L-&gt;ci;</span><br><span class="line">  <span class="keyword">if</span> (idx &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    TValue *o = ci-&gt;func + idx;</span><br><span class="line">    api_check(idx &lt;= ci-&gt;top - (ci-&gt;func + <span class="number">1</span>), <span class="string">"unacceptable index"</span>);</span><br><span class="line">    <span class="keyword">if</span> (o &gt;= L-&gt;top) <span class="keyword">return</span> NONVALIDVALUE;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> o;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!ispseudo(idx)) &#123;  <span class="comment">/* negative index */</span></span><br><span class="line">    api_check(idx != <span class="number">0</span> &amp;&amp; -idx &lt;= L-&gt;top - (ci-&gt;func + <span class="number">1</span>), <span class="string">"invalid index"</span>);</span><br><span class="line">    <span class="keyword">return</span> L-&gt;top + idx;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (idx == LUA_REGISTRYINDEX)</span><br><span class="line">    <span class="keyword">return</span> &amp;G(L)-&gt;l_registry;</span><br><span class="line">  <span class="keyword">else</span> &#123;  <span class="comment">/* upvalues */</span></span><br><span class="line">    idx = LUA_REGISTRYINDEX - idx;</span><br><span class="line">    api_check(idx &lt;= MAXUPVAL + <span class="number">1</span>, <span class="string">"upvalue index too large"</span>);</span><br><span class="line">    <span class="keyword">if</span> (ttislcf(ci-&gt;func))  <span class="comment">/* light C function? */</span></span><br><span class="line">      <span class="keyword">return</span> NONVALIDVALUE;  <span class="comment">/* it has no upvalues */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      CClosure *func = clCvalue(ci-&gt;func);</span><br><span class="line">      <span class="keyword">return</span> (idx &lt;= func-&gt;nupvalues) ? &amp;func-&gt;upvalue[idx<span class="number">-1</span>] : NONVALIDVALUE;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个index2addr函数的作用就是通过给定的 index 参数取出对应的TValue类型的对象指针。</p><table><thead><tr><th>情况</th><th>执行</th></tr></thead><tbody><tr><td>当 index &gt; 0 时</td><td>在当前function的栈空间找对应的TValue</td></tr><tr><td>当 LUA_REGISTRYINDEX &lt; index &lt;= 0 时</td><td>在当前function的栈空间逆向找对应的TValue</td></tr><tr><td>当LUA_REGISTRYINDEX == index 时</td><td>返回registry（注册表）</td></tr><tr><td>否则当 LUA_REGISTRYINDEX &gt; index 时</td><td>查找upvalues</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 源码阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lua源码阅读：标准库</title>
      <link href="/2019/08/06/Lua/Lua%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%9A%E6%A0%87%E5%87%86%E5%BA%93/"/>
      <url>/2019/08/06/Lua/Lua%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%9A%E6%A0%87%E5%87%86%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>Lua标准库中定义的一些函数及其实现方式。</p><a id="more"></a><h2 id="lmathlib-c"><a href="#lmathlib-c" class="headerlink" title="lmathlib.c"></a>lmathlib.c</h2><p>从一个简单的math.Abs()函数开始：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">math_abs</span> <span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (lua_isinteger(L, <span class="number">1</span>)) &#123;</span><br><span class="line">    lua_Integer n = lua_tointeger(L, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) n = (lua_Integer)(<span class="number">0u</span> - n);</span><br><span class="line">    lua_pushinteger(L, n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    lua_pushnumber(L, l_mathop(<span class="built_in">fabs</span>)(luaL_checknumber(L, <span class="number">1</span>)));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，先检查传入的值是否是int类型，这里调用了lapi.c中的lua_isinteger函数，检查传入值的TValue原始类型标签是否是LUA_TNUMINT，这部分的检查在lObject.h中定义的函数完成，同时数据类型LUA_TNUMINT也在lObject.h中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Variant tags for numbers */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LUA_TNUMFLT(LUA_TNUMBER | (0 &lt;&lt; 4))  <span class="comment">/* float numbers */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LUA_TNUMINT(LUA_TNUMBER | (1 &lt;&lt; 4))  <span class="comment">/* integer numbers */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// lObject.h</span></span><br></pre></td></tr></table></figure><p>如果传入的值的<strong>TValue</strong>是int类型的（传入的值是lua_state类型的），调用lua_tointeger将传入的值转换为int类型（实际上是lua_Integer类型，其最根源是longlong类型的，在luaconf.h中定义），将其赋给n，如果n小于零，则用一个unsigned 0减去它，将其置为正数，最后将n存入到TValue中，将其存放在lua_state的栈顶。</p><p>如果不是int类型的，则检查其是否是一个number类型的值，如果是一个number则调用fabs，将其push栈，否则返回一个错误提示。</p><h2 id="lstrlib-c"><a href="#lstrlib-c" class="headerlink" title="lstrlib.c"></a>lstrlib.c</h2><p>strlib中一部分是关于字符串的操作函数，一部分是关于模式匹配的函数，先挑选一个Reverse函数进行分析：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">str_reverse</span> <span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> l, i;</span><br><span class="line">  luaL_Buffer b;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *s = luaL_checklstring(L, <span class="number">1</span>, &amp;l);</span><br><span class="line">  <span class="keyword">char</span> *p = luaL_buffinitsize(L, &amp;b, l);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; l; i++)</span><br><span class="line">    p[i] = s[l - i - <span class="number">1</span>];</span><br><span class="line">  luaL_pushresultsize(&amp;b, l);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单来说就是利用一个指针（index）来对字符数组进行逆序的赋值，从数组s中获取赋值给数组p。</p>]]></content>
      
      
      <categories>
          
          <category> 源码阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lua源码阅读：目录及模块结构</title>
      <link href="/2019/08/05/Lua/Lua%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%9A%E7%9B%AE%E5%BD%95%E5%8F%8A%E6%A8%A1%E5%9D%97%E7%BB%93%E6%9E%84/"/>
      <url>/2019/08/05/Lua/Lua%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%9A%E7%9B%AE%E5%BD%95%E5%8F%8A%E6%A8%A1%E5%9D%97%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>Lua源码阅读的第一期，主要内容：系列内容计划以及目录。</p><a id="more"></a><h2 id="Lua源码阅读："><a href="#Lua源码阅读：" class="headerlink" title="Lua源码阅读："></a>Lua源码阅读：</h2><p>本篇转载于<a href="http://lua-users.org/wiki/LuaSource" target="_blank" rel="noopener">LuaSource</a></p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul><li><a href="https://bitzhangmo.github.io/2019/08/05/Lua/Lua源码阅读：目录及模块结构/">第一篇：目录及模块结构</a></li><li><a href="https://bitzhangmo.github.io/2019/08/06/Lua/Lua源码阅读：基本数据类型/">第二篇：基本数据类型</a></li><li><a href="https://bitzhangmo.github.io/2019/08/06/Lua/Lua源码阅读：实用函数/">第三篇：实用函数</a></li><li><a href="https://bitzhangmo.github.io/2019/08/06/Lua/Lua源码阅读：标准库/">第四篇：标准库</a></li><li><a href="https://bitzhangmo.github.io/2019/08/06/Lua/Lua源码阅读：C-API/">第五篇：C API</a></li></ul><h3 id="lua-c"><a href="#lua-c" class="headerlink" title="lua.c"></a>lua.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> status, result;</span><br><span class="line">  lua_State *L = luaL_newstate();  <span class="comment">/* create state */</span></span><br><span class="line">  <span class="keyword">if</span> (L == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    l_message(argv[<span class="number">0</span>], <span class="string">"cannot create state: not enough memory"</span>);</span><br><span class="line">    <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">  &#125;</span><br><span class="line">  lua_pushcfunction(L, &amp;pmain);  <span class="comment">/* to call 'pmain' in protected mode */</span></span><br><span class="line">  lua_pushinteger(L, argc);  <span class="comment">/* 1st argument */</span></span><br><span class="line">  lua_pushlightuserdata(L, argv); <span class="comment">/* 2nd argument */</span></span><br><span class="line">  status = lua_pcall(L, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>);  <span class="comment">/* do the call */</span></span><br><span class="line">  result = lua_toboolean(L, <span class="number">-1</span>);  <span class="comment">/* get result */</span></span><br><span class="line">  report(L, status);</span><br><span class="line">  lua_close(L);</span><br><span class="line">  <span class="keyword">return</span> (result &amp;&amp; status == LUA_OK) ? EXIT_SUCCESS : EXIT_FAILURE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模块结构"><a href="#模块结构" class="headerlink" title="模块结构"></a>模块结构</h3><p>Lua代码的模块概要介绍如下：</p><h4 id="以下模块实现了一些实用函数："><a href="#以下模块实现了一些实用函数：" class="headerlink" title="以下模块实现了一些实用函数："></a>以下模块实现了一些实用函数：</h4><ul><li><strong>ldebug.c</strong> - 调试接口，包含功能有：访问调试钩子（lua_sethook、lua_gethook、lua_gethookcount）；访问运行时栈（lua_getstack、lua_getlocal、lua_setlocal）；检测字节码（luaG_checkopenop、luaG_checkcode）；抛出错误（luaG_typeerror、luaG_concaterror、luaG_aritherror、luaG_ordererror、luaG_errormsg、luaG_runerror）</li><li><strong>lzio.c</strong> - 通用的输入流接口</li><li><strong>lmem.c</strong> - 内存管理接口。实现了luaM_realloc / luaM_growaux_ 两个函数，其中封装了内存分配函数</li><li><strong>lgc.c</strong> - 增量的垃圾回收器</li></ul><h4 id="以下模块实现了基本的数据类型："><a href="#以下模块实现了基本的数据类型：" class="headerlink" title="以下模块实现了基本的数据类型："></a>以下模块实现了基本的数据类型：</h4><ul><li><strong>lstate.c</strong> - 全局状态。包括打开、关闭Lua状态机（lua_newstate / lua_close）和线程（luaE_newthread / luaE_freethread）。</li><li><strong>lobject.c</strong> - 一些操作Lua Object的通用函数。包括一些数据类型到字符串的互转函数，原生类型的相等性测试（luaO_rawequalObj），和以2为底的对数函数（luaO_log2）</li><li><strong>lstring.c</strong> - 字符串哈希表（管理了所有被Lua用到的字符串）</li><li><strong>lfunc.c</strong> - 一些用于操作函数原型(Proto）和闭包（Closure）的辅助函数</li><li><strong>ltable.c</strong> - Lua的table实现</li></ul><h4 id="以下模块做语法解析和代码生成："><a href="#以下模块做语法解析和代码生成：" class="headerlink" title="以下模块做语法解析和代码生成："></a>以下模块做语法解析和代码生成：</h4><ul><li><strong>lcode.c</strong> - 代码生成器，被lparser.c用到</li><li><strong>llex.c</strong> - 词法分析器，被lparser.c用到</li><li><strong>lparser.c</strong> - Lua语法解析器</li><li><strong>lundump.c</strong> - 加载预编译的Lua代码块。实现了luaU_undump函数，此函数加载预编译的代码块。还提供了另外一个函数lua_header（被luaU_undump内部使用），用于加载代码块中的函数头信息。</li><li><strong>ldump.c</strong> - 保存预编译的Lua代码块。实现了luaU_dump函数，些函数导出Lua函数为二进制形式的字符串</li></ul><h4 id="以下模块处理Lua字节码的执行："><a href="#以下模块处理Lua字节码的执行：" class="headerlink" title="以下模块处理Lua字节码的执行："></a>以下模块处理Lua字节码的执行：</h4><ul><li><strong>lopcodes.c</strong> - 定义Lua虚拟机的操作码。定义了所有操作码的名字和操作模式等信息（通过列表luaP_opnames、luaP_opmodes定义的）</li><li><strong>lvm.c</strong> - Lua虚拟机（luaV_execute），可执行Lua字节码。另外还暴露了一些被lapi.c用到的函数，比如：luaV_concat</li><li><strong>ldo.c</strong> - 函数调用栈。处理函数调用（luaD_call、luaD_pcall），栈空间增长，协程等</li><li><strong>ltm.c</strong> - 元方法。实现从对象访问元方法的一些函数</li></ul><h4 id="以下模块实现标准库："><a href="#以下模块实现标准库：" class="headerlink" title="以下模块实现标准库："></a>以下模块实现标准库：</h4><ul><li><strong>lbaselib.c</strong> - 基础函数</li><li><strong>lstrlib.c</strong> - 字符串函数</li><li><strong>ltablib.c</strong> - 表函数</li><li><strong>lmathlib.c</strong> - 数学函数</li><li><strong>loslib.c</strong> - 系统函数</li><li><strong>liolib.c</strong> - 输入输出、文件读写</li><li><strong>loadlib.c</strong> - 包、模块</li><li><strong>ldblib.c</strong> - 调试函数</li></ul><h4 id="以下模块定义了C-API："><a href="#以下模块定义了C-API：" class="headerlink" title="以下模块定义了C API："></a>以下模块定义了C API：</h4><ul><li><strong>lapi.c</strong> - Lua API。实现了大部分Lua C API（lua_* 系列函数）</li><li><strong>lauxlib.c</strong> - 定义了luaL_*系列函数</li><li><strong>linit.c</strong> - 实现luaL_openlibs，这个函数中加载了所有的标准库函数</li></ul><h4 id="以下模块实现Lua和Luac两个程序："><a href="#以下模块实现Lua和Luac两个程序：" class="headerlink" title="以下模块实现Lua和Luac两个程序："></a>以下模块实现Lua和Luac两个程序：</h4><ul><li><strong>lua.c</strong> - Lua的独立解释器</li><li><strong>print.c</strong> - 定义了“PrintFunction”函数，它可以打印出一个函数的字节码（可在Luac中使用 -l 选项）</li><li><strong>luac.c</strong> - Lua编译器（可保存字节码到文件中，也可在控制台列出字节码）</li></ul><h3 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h3><p>一个函数的前缀表明了它来自哪个模块</p><pre><code>luaA_ - lapi.cluaB_ - lbaselib.cluaC_ - lgc.cluaD_ - ldo.cluaE_ - lstate.cluaF_ - lfunc.cluaG_ - ldebug.cluaH_ - ltable.cluaI_ - lauxlib.cluaK_ - lcode.cluaL_ - llauxlib.c/h linit.cluaM_ - lmem.cluaO_ - lobject.cluaP_ - lopcodes.cluaS_ - lstring.cluaT_ - ltm.cluaU_ - lundump.cluaV_ - lvm.cluaX_ - llex.cluaY_ - lparser.cluaZ_ - lzio.clua_  - lapi.c/h + luaconfig.h, ldebug.cluai_ - luaconf.hluaopen_ - luaconf.h + libraries (lbaselib.c, ldblib.c, liolib.c, lmathlib.c, loadlib.c, loslib.c, lstrlib.c, ltablib.c)</code></pre><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ol><li><a href="https://github.com/zgpxgame/lua-5.1.5/wiki/" target="_blank" rel="noopener">Lua源码阅读笔记</a></li><li>Lua有关的<a href="http://www.lua.org/docs.html" target="_blank" rel="noopener">论文</a>和<a href="http://pgl.yoyo.org/lua/docs/luaarchitecture.doc" target="_blank" rel="noopener">The Lua Architecture</a>从各个方面论述了Lua的实现</li><li>Lua VM指令在文档<a href="http://luaforge.net/docman/83/98/ANoFrillsIntroToLua51VMInstructions.pdf" target="_blank" rel="noopener">A No-Frills Introduction to Lua 5.1 VM Instructions</a>中</li><li><a href="http://luaforge.net/projects/yueliang/" target="_blank" rel="noopener">Yueliang</a>项目（用Lua实现Lua VM），其中的大量的源码注释，可以帮助理解相关的C代码</li><li>LuaAnnotate - C代码注释，注释单独存放在外部文件中，用某些文本工具可以将注释嵌入显示在代码中</li><li><a href="http://stevedonovan.github.com/lua-5.1.4" target="_blank" rel="noopener">stevedonovan.github.com/lua-5.1.4</a> 包含LuaAnnotate注释的源码</li><li>可在<a href="http://www.lua.org/source/网站上浏览Lua源码" target="_blank" rel="noopener">http://www.lua.org/source/网站上浏览Lua源码</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 源码阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;RayTracing In Weekend&gt;����ʼ�</title>
      <link href="/2019/07/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/RayTracing-In-Weekend-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/07/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/RayTracing-In-Weekend-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>����RayTracing In A Weekendһ���ʵ��ϸ�ڡ�</p><a id="more"></a><h3 id="Chapter1��Output-an-Image"><a href="#Chapter1��Output-an-Image" class="headerlink" title="Chapter1��Output an Image"></a>Chapter1��Output an Image</h3><p>����һ��ppm�����������ص���<a href="https://www.xnview.com/en/" target="_blank" rel="noopener">XnView</a>��</p><p>��һ����������Ĵ��벢�������������õ�PPM��ʽ���ļ��Ļ�����Ҫ�ڴ��������д��txt�ļ��Ĵ��룺</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pch.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> nx = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">int</span> ny = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ofstream <span class="title">outfile</span><span class="params">(<span class="string">".\\result\\FirstPicture.txt"</span>, ios_base::out)</span></span>;</span><br><span class="line">outfile &lt;&lt; <span class="string">"P3\n"</span> &lt;&lt; nx &lt;&lt; <span class="string">" "</span> &lt;&lt; ny &lt;&lt; <span class="string">"\n255\n"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = ny - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nx; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">float</span> r = <span class="keyword">float</span>(i) / <span class="keyword">float</span>(nx);</span><br><span class="line"><span class="keyword">float</span> g = <span class="keyword">float</span>(j) / <span class="keyword">float</span>(ny);</span><br><span class="line"><span class="keyword">float</span> b = <span class="number">0.2</span>;</span><br><span class="line"><span class="keyword">int</span> ir = <span class="keyword">int</span>(<span class="number">255.99</span>*r);</span><br><span class="line"><span class="keyword">int</span> ig = <span class="keyword">int</span>(<span class="number">255.99</span>*g);</span><br><span class="line"><span class="keyword">int</span> ib = <span class="keyword">int</span>(<span class="number">255.99</span>*b);</span><br><span class="line">outfile &lt;&lt; ir &lt;&lt; <span class="string">" "</span> &lt;&lt; ig &lt;&lt; <span class="string">" "</span> &lt;&lt; ib &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ir &lt;&lt; <span class="string">" "</span> &lt;&lt; ig &lt;&lt; <span class="string">" "</span> &lt;&lt; ib &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>��VmView�п��Կ�����Ӧ��ͼƬ��</p><p><img src="https://i.loli.net/2019/07/29/5d3e5c2ac5cfc71862.png" alt></p><h3 id="Chapter2��The-vec3-class"><a href="#Chapter2��The-vec3-class" class="headerlink" title="Chapter2��The vec3 class"></a>Chapter2��The vec3 class</h3><p>������һ�����vec3���������</p><p>����������ļӼ��˳�������������ļӼ��˳��������Ĳ������ȡ�</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">float</span> <span class="title">dot</span><span class="params">(<span class="keyword">const</span> vec3 &amp;v1, <span class="keyword">const</span> vec3 &amp;v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> v1.e[<span class="number">0</span>] * v2.e[<span class="number">0</span>] + v1.e[<span class="number">1</span>] * v2.e[<span class="number">1</span>] + v1.e[<span class="number">2</span>] * v2.e[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vec3 <span class="title">cross</span><span class="params">(<span class="keyword">const</span> vec3 &amp;v1, <span class="keyword">const</span> vec3 &amp;v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> vec3((v1.e[<span class="number">1</span>] * v2.e[<span class="number">2</span>] - v1.e[<span class="number">2</span>] * v2.e[<span class="number">1</span>]),</span><br><span class="line">(-(v1.e[<span class="number">0</span>] * v2.e[<span class="number">2</span>] - v1.e[<span class="number">2</span>] * v2.e[<span class="number">0</span>])),</span><br><span class="line">(v1.e[<span class="number">0</span>] * v2.e[<span class="number">1</span>] - v1.e[<span class="number">1</span>] * v2.e[<span class="number">0</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Chapter3��Rays-a-simple-camera-and-background"><a href="#Chapter3��Rays-a-simple-camera-and-background" class="headerlink" title="Chapter3��Rays,a simple camera, and background"></a>Chapter3��Rays,a simple camera, and background</h3><p>�����������࣬�������������������ֱ𷵻�ԭ�㡢�����Լ����߱��������߱�����һ��Vec3��ʾ��</p><h3 id="Chapter4"><a href="#Chapter4" class="headerlink" title="Chapter4:"></a>Chapter4:</h3><p>�����еĴ����м�����һ������������ཻ�ĺ���������������Դ�2D��������Բ���ཻ��⺯������ȥ���⡣</p><p>����Ὣ����뵽������ͷ�ļ��С�</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> sphere :: hit(<span class="keyword">const</span> ray&amp; r, <span class="keyword">float</span> t_min, <span class="keyword">float</span> t_max, hit_record&amp; rec)<span class="keyword">const</span> &#123;</span><br><span class="line">vec3 oc = r.origin() - center;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> a = dot(r.direction(), r.direction());</span><br><span class="line"><span class="keyword">float</span> b = dot(oc, r.direction());</span><br><span class="line"><span class="keyword">float</span> c = dot(oc, oc) - radius * radius;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> discriminant = b * b - a * c;</span><br><span class="line"><span class="keyword">if</span> (discriminant &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">float</span> temp = (-b - <span class="built_in">sqrt</span>(b*b - a * c)) / a;</span><br><span class="line"><span class="keyword">if</span> (temp &lt; t_max &amp;&amp; temp &gt; t_min)</span><br><span class="line">&#123;</span><br><span class="line">rec.t = temp;</span><br><span class="line">rec.p = r.point_at_parameter(rec.t);</span><br><span class="line">rec.normal = (rec.p - center) / radius;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">temp = (-b + <span class="built_in">sqrt</span>(b*b - a * c)) / a;</span><br><span class="line"><span class="keyword">if</span> (temp&lt;t_max &amp;&amp; temp&gt;t_min)</span><br><span class="line">&#123;</span><br><span class="line">rec.t = temp;</span><br><span class="line">rec.p = r.point_at_parameter(rec.t);</span><br><span class="line">rec.normal = (rec.p - center) / radius;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Chapter5��Surface-normals-and-multiple-objects"><a href="#Chapter5��Surface-normals-and-multiple-objects" class="headerlink" title="Chapter5��Surface normals and multiple objects."></a>Chapter5��Surface normals and multiple objects.</h3><p>�����˶Է��߷�������㣬������Ӧ�����߼�⺯�����뵽�˶�Ӧ��ͷ�ļ��С�</p><p>�����ĵ�����ĳ���������Ϊ�õ�ķ��߷���</p><p>���ⶨ����һ���࣬�������㲢�洢�����������������һ����о�������ԭ�������һ���㡣</p><h3 id="Chapter6��Antialasing"><a href="#Chapter6��Antialasing" class="headerlink" title="Chapter6��Antialasing"></a>Chapter6��Antialasing</h3><p>��Ŀ��Ϊ����ݡ�</p><p>�������������ÿ�������ص�Ϊ���ģ��������Ϊ1�ķ�Χ�ڲ���n�Σ���n��������ֵ����ƽ����Ϊ�õ����յ�����ֵ��</p><p>������ͼ���������Ƶķ�ʽ����Ϊ��ֵ�˲���</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vec3 <span class="title">col</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; ns; s++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">float</span> random = rand() % (<span class="number">100</span>) / (<span class="keyword">float</span>)(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">float</span> u = <span class="keyword">float</span>(i + random) / <span class="keyword">float</span>(nx);</span><br><span class="line"><span class="keyword">float</span> v = <span class="keyword">float</span>(j + random) / <span class="keyword">float</span>(ny);</span><br><span class="line">ray r = cam.get_ray(u, v);</span><br><span class="line">vec3 p = r.point_at_parameter(<span class="number">2.0</span>);</span><br><span class="line">col += color(r, world);</span><br><span class="line">&#125;</span><br><span class="line">col /= <span class="keyword">float</span>(ns);</span><br></pre></td></tr></table></figure><h3 id="Chapter7��Diffuse-Materials"><a href="#Chapter7��Diffuse-Materials" class="headerlink" title="Chapter7��Diffuse Materials"></a>Chapter7��Diffuse Materials</h3><p>��Ŀ��Ϊ��������ʡ�</p><blockquote><p>Pick a random point s from the unit radius sphere that is tangent to the hitpoint, and send a ray from the hitpoint p to the random point s. That sphere has center (p+N):</p><p>�������е����еĵ�λ�뾶����ѡ��һ�������s������һ�����ߴ����е����������s������Ϊ��p+N��</p></blockquote><p>����������ǽ����䷽�����һ������ķ�����Ϊ������ķ���</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vec3 <span class="title">random_in_unit_sphere</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vec3 p;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">float</span> random0 = rand() % (<span class="number">100</span>) / (<span class="keyword">float</span>)(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">float</span> random1 = rand() % (<span class="number">100</span>) / (<span class="keyword">float</span>)(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">float</span> random2 = rand() % (<span class="number">100</span>) / (<span class="keyword">float</span>)(<span class="number">100</span>);</span><br><span class="line">p = <span class="number">2.0</span>*vec3(random0, random1, random2) - vec3(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">while</span> (p.squared_length() &gt;= <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vec3 <span class="title">color</span><span class="params">(<span class="keyword">const</span> ray&amp; r, hitable *world)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">hit_record rec;</span><br><span class="line"><span class="keyword">if</span> (world-&gt;hit(r, <span class="number">0.001</span>, (numeric_limits&lt;<span class="keyword">float</span>&gt;::max)(), rec))</span><br><span class="line">&#123;</span><br><span class="line">vec3 target = rec.p + rec.normal + random_in_unit_sphere();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0.5</span>*color(ray(rec.p,target - rec.p), world);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">vec3 unit_direction = unit_vector(r.direction());</span><br><span class="line"><span class="keyword">float</span> t = <span class="number">0.5</span>*(unit_direction.y() + <span class="number">1.0</span>);</span><br><span class="line"><span class="keyword">return</span> (<span class="number">1.0</span> - t)*vec3(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>) + t * vec3(<span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Chapter8��Metal"><a href="#Chapter8��Metal" class="headerlink" title="Chapter8��Metal"></a>Chapter8��Metal</h3><p>�ڰ��¼����˼򵥵Ĳ��ʡ�</p><p>���Ƕ�����һ���򵥵��ʲ������������������һ���ʣ�����ġ����֡����������������ԡ����۹۲��ߵ��ӽ���Σ��ʲ�����Թ۲��ߵı������ȶ�����ͬ�ġ�</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LANBERTIANH</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LANBERTIANH</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"material.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lambertian</span> :</span><span class="keyword">public</span> material</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">lambertian(<span class="keyword">const</span> vec3&amp; a):albedo(a)&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">scatter</span><span class="params">(<span class="keyword">const</span> ray&amp; r_in, <span class="keyword">const</span> hit_record&amp; rec, vec3&amp; attenuation, ray&amp; scattered)</span><span class="keyword">const</span></span>;</span><br><span class="line">vec3 albedo;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">vec3 <span class="title">random_in_unit_sphere</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vec3 p;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">float</span> random0 = rand() % (<span class="number">100</span>) / (<span class="keyword">float</span>)(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">float</span> random1 = rand() % (<span class="number">100</span>) / (<span class="keyword">float</span>)(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">float</span> random2 = rand() % (<span class="number">100</span>) / (<span class="keyword">float</span>)(<span class="number">100</span>);</span><br><span class="line">p = <span class="number">2.0</span>*vec3(random0, random1, random2) - vec3(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">while</span> (p.squared_length() &gt;= <span class="number">1.0</span>);</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> lambertian::scatter(<span class="keyword">const</span> ray&amp; r_in, <span class="keyword">const</span> hit_record&amp; rec, vec3&amp; attenuation, ray&amp; scattered) <span class="keyword">const</span> &#123;</span><br><span class="line">vec3 target = rec.p + rec.normal + random_in_unit_sphere();</span><br><span class="line">scattered = ray(rec.p, target - rec.p);</span><br><span class="line">attenuation = albedo;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !LANBERTIANH</span></span></span><br></pre></td></tr></table></figure><p>ע��ԭ��������������û���ҵ���Ӧ�����ã���������ݴ�������rand()���档</p><p>����ԭ�黹������һ�����淴���࣬�����ķ��亯���ο�����������</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vec3 <span class="title">reflect</span><span class="params">(<span class="keyword">const</span> vec3&amp; v, <span class="keyword">const</span> vec3&amp; n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> v - <span class="number">2</span> * dot(v, n)*n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>�ڱ��µ��������������һ��ģ���Ĳ��������ģ���Ĳ���ʹ�÷�����ߵķ�������һ������ƫ�ơ�</p><h3 id="Chapter9��Dielectrics"><a href="#Chapter9��Dielectrics" class="headerlink" title="Chapter9��Dielectrics"></a>Chapter9��Dielectrics</h3><p>��һ�µı���Ϊ����ʣ�ʵ������˵�������ݰ���������ˮ����͸���Ŀ���������ߵĲ��ʣ�</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">refract</span><span class="params">(<span class="keyword">const</span> vec3&amp; v, <span class="keyword">const</span> vec3&amp; n, <span class="keyword">float</span> ni_over_nt, vec3&amp; refracted)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vec3 uv = unit_vector(v);</span><br><span class="line"><span class="keyword">float</span> dt = dot(uv, n);</span><br><span class="line"><span class="keyword">float</span> discriminant = <span class="number">1.0</span> - ni_over_nt * ni_over_nt*(<span class="number">1</span> - dt * dt);</span><br><span class="line"><span class="keyword">if</span> (discriminant &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">refracted = ni_over_nt * (uv - n * dt) - n * <span class="built_in">sqrt</span>(discriminant);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ע�⣬���������жϰ���һ��ȫ����������</p><p>��������Ĺ�ʽ��ο���<a href="[https://zh.wikipedia.org/wiki/%E6%96%AF%E6%B6%85%E5%B0%94%E5%AE%9A%E5%BE%8B](https://zh.wikipedia.org/wiki/˹��������">˹��������</a>)</p><h3 id="Chapter10��Positionable-camera"><a href="#Chapter10��Positionable-camera" class="headerlink" title="Chapter10��Positionable camera"></a>Chapter10��Positionable camera</h3><p>�ڵ�ʮ�£����Ƕ�����һ������͸�ӹ��ܵ�������ڹ۲쳡����</p><p>��������λ�ã��۲췽��fov�ȡ�</p><h3 id="Chapter11��Defocus-Blur"><a href="#Chapter11��Defocus-Blur" class="headerlink" title="Chapter11��Defocus Blur"></a>Chapter11��Defocus Blur</h3><p>��Ŀ�ķ���Ϊɢ��ģ�����������ͷ�ļ��м�����һ�����Ȧ�뽹�ർ�³���ģ���Ĺ��ܡ�</p><h3 id="Chapter12��"><a href="#Chapter12��" class="headerlink" title="Chapter12��"></a>Chapter12��</h3><p>��ʮ��������һ���ܽ��������������˽�����Ҫ������һЩϸ�ڣ�</p><blockquote><p>You now have a cool ray tracer! What next? </p><ol><li>Lights. You can do this explicitly, by sending shadow rays to lights. Or it can be done implicitly by making some objects emit light, </li><li>biasing scattered rays toward them, and then downweighting those rays to cancel out the bias. Both work. I am in the minority in favoring the latter approach. </li><li>Triangles. Most cool models are in triangle form. The model I/O is the worst and almost everybody tries to get somebody else��s code to do this. </li><li>Surface textures. This lets you paste images on like wall paper. Pretty easy and a good thing to do. </li><li>Solid textures. Ken Perlin has his code online. Andrew Kensler has some very cool info at his blog. </li><li>Volumes and media. Cool stuff and will challenge your software architecture. I favor making volumes have the hitable interface and probabilistically have intersections based on density. Your rendering code doesn��t even have to know it has volumes with that method. </li><li>Parallelism. Run N copies of your code on N cores with different random seeds. Average the N runs. This averaging can also be done hierarchically where N/2 pairs can be averaged to get N/4 images, and pairs of those can be averaged. That method of parallelism should extend well into the thousands of cores with very little coding. </li></ol><p>Have fun, and please send me your cool images! </p></blockquote><p>��������һ���ܿ��Ray Tracer�ˣ���ô�������أ�</p><ol><li>�ƣ�������ͨ����ƹⷢ����Ӱ��������ȷ��ִ�д˲���������������ͨ��ʹһЩ���巢������ʽ����ɡ�</li><li>��ɢ�����ƫ�����ǣ�Ȼ�������Щ�����Ե���ƫ����߶���Ч������Ϊ�������ϲ����һ���������ˡ�</li><li>�����Σ�����ģ���������εġ�ģ��I/O�������ģ�����ÿ���˶���ͼ���Ʊ��˵Ĵ�����������һ�㣨I/O����</li><li>�����������������Խ�������ǽֽһ�����������ϡ��ǳ��򵥣�Ҳ��һ��ֵ��ȥ���ĺ��¡�</li><li>��̵������� Ken Perlin�����ṩ���Ĵ��롣 Andrew Kensler�����Ĳ�������һЩ�ǳ������Ϣ��</li><li>����ý�塣�ܿ�Ķ���������ս���������ܹ������޳�ʹ�����пɵ����Ľ��棬���Ҹ����Ͼ��л����ܶȵĽ���㡣���ĳ��ִ�����������֪�������и÷����ľ����������Ҳ��Ǿ��������ɡ���</li><li>���С�ʹ�ò�ͬ�����������N������������N�����븱����ƽ��N�����С�����ƽ��Ҳ���Էֲ�ε���ɣ�����N / 2�Կ��Ա�ƽ���Ի��N / 4��ͼ�񣬲��ҿ��Զ���Щͼ��ĶԽ���ƽ�������ֲ��з���Ӧ�ÿ��Ժܺõ���չ����ǧ���ں��С�</li></ol><p>���������Ȥ���뽫��ܿ��ͼ���͸��Ұɡ�</p>]]></content>
      
      
      <categories>
          
          <category> �����ͼ��ѧ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> �����ͼ��ѧ </tag>
            
            <tag> ����׷�� </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lua迭代器和范型for</title>
      <link href="/2019/07/05/Lua/Lua%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E8%8C%83%E5%9E%8Bfor/"/>
      <url>/2019/07/05/Lua/Lua%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E8%8C%83%E5%9E%8Bfor/</url>
      
        <content type="html"><![CDATA[<p>关于Lua中的迭代器：ipairs与pairs。</p><a id="more"></a><h3 id="迭代器和泛型for："><a href="#迭代器和泛型for：" class="headerlink" title="迭代器和泛型for："></a>迭代器和泛型for：</h3><h4 id="迭代器和闭包："><a href="#迭代器和闭包：" class="headerlink" title="迭代器和闭包："></a>迭代器和闭包：</h4><p>所有的迭代器都需要在连续的调用之间保存一些状态，这样才能知道当前迭代所处的位置及如何从当前位置步进到下一位置。对于我们自己的迭代器而言，闭包为保存状态提供了一种良好的机制。<strong>一个闭包就是一个可以访问其自身的环境中一个或多个局部变量的函数</strong>。这些变量将连续调用过程中的值并将其保存在闭包中，从而使得闭包能够记住迭代所处的位置。当然，要创建一个新的闭包，我们还需要创建非局部变量。因此，一个闭包结构通常涉及两个函数：闭包本身和一个用于创建该闭包及其封装变量的工厂。</p><h4 id="泛型for："><a href="#泛型for：" class="headerlink" title="泛型for："></a>泛型for：</h4><p>泛型for在循环过程中在其内部保存了迭代函数，泛型for保存了三个值：一个迭代函数、一个不可变状态和一个控制变量。</p><p>语法如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> var-list <span class="keyword">in</span> <span class="built_in">exp</span>-list <span class="keyword">do</span></span><br><span class="line">body</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>其中，var-list是由一个或多个变量名组成的列表，以逗号分隔；exp-list是一个或多个表达式组成的列表，同样以逗号分隔。通常，表达式列表只有一个元素，即一句对迭代器工厂的调用。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(t) <span class="keyword">do</span> <span class="built_in">print</span>(k,v) <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>我们把变量列表的第一个变量称为控制变量，其值在循环过程中永远不会为nil，因为当其值为nil时循环就结束了。</p><p>for做的第一件事情是对in后面的表达式求值。这些表达式应该返回三个值供for保存：<strong>迭代函数、不可变状态和控制变量的初始值。</strong>类似于多重赋值，只有最后一个白哦大事能够产生不止一个值；表达式列表的结果只会保留三个，多余的值会被丢弃，不足三个则以nil补齐。</p><p>在上述的初始化步骤完成后，for使用不可变状态和控制变量为参数来调用迭代函数，从for代码结构的立足点来看，不可变状态根本没有意义，for只是把从初始化步骤得到的状态值传递给所有迭代函数，然后，for将迭代函数的返回值赋给变量列表中声明的变量。如果第一个返回值为nil，那么循环终止；否则，for执行它的循环体并再次调用迭代函数，再不断的重复这个过程。</p><p>两种语法等价：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> var_1,...,var_n <span class="keyword">in</span> explist <span class="keyword">do</span> block <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="keyword">local</span> _f,_s,_var = explist</span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span> </span><br><span class="line"><span class="keyword">local</span> var_1,...,var_n = _f(_s,_var)</span><br><span class="line">_var = var_1</span><br><span class="line"><span class="keyword">if</span> _var == <span class="literal">nil</span> <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span></span><br><span class="line">block</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>假设迭代函数是f，不可变状态为s，控制变量的初始值为a0，那么在循环中控制变量的值依次为a1=f(s,a0),a2=f(s,a1)，直到ai为nil。如果for还有其他变量，那么这些变量只是简单的在每次调用f后得到额外的返回值。</p><h4 id="无状态迭代器："><a href="#无状态迭代器：" class="headerlink" title="无状态迭代器："></a>无状态迭代器：</h4><p>无状态迭代器就是一种自身不保存任何状态的迭代器，因此，可以在多个循环中使用同一个无状态迭代器，从而避免创建新闭包的开销。</p><p>for循环会以不可变状态和控制变量为参数调用迭代函数，一个无状态迭代器之需要这两个值来为迭代生成下一个元素：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">"One"</span>,<span class="string">"Two"</span>,<span class="string">"Three"</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="built_in">ipairs</span>(a) <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(i,v)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>ipairs和迭代器都非常简单：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">iter</span><span class="params">(t,i)</span></span></span><br><span class="line">i = i + <span class="number">1</span></span><br><span class="line"><span class="keyword">local</span> v = t[i]</span><br><span class="line"><span class="keyword">if</span> v <span class="keyword">then</span></span><br><span class="line"><span class="keyword">return</span> i,v</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ipairs</span><span class="params">(t)</span></span></span><br><span class="line"><span class="keyword">return</span> iter,t,<span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>当调用for循环中的ipairs(t)时，ipairs(t)会返回三个值，即迭代函数iter，不可变状态表t和控制变量的初始值0。</p><p>然后Lua语言调用iter(t,0)，得到1，t[1]（除非t[1]已经变成了nil）。在第二次迭代中，Lua语言调用iter(t,1)，得到2，t[2]，依次类推，直至得到第一个为nil的元素。</p><p>函数pairs和函数ipairs类似，也用于遍历一个表中的所有元素，不同的是，函数pairs的迭代函数是Lua语言中的一个基本函数next：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pairs</span><span class="params">(t)</span></span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">next</span>,t,<span class="literal">nil</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在调用next(t,k)时，k是表t的一个键，该函数会以随机次序返回表中的下一个键以及k对应的值，调用next(t,nil)时，返回表中的第一个键值对。当所有的元素遍历完时，函数next返回nil。</p><p>区别：</p><ul><li>pairs：用于迭代table，可以遍历表中所有的key，可以返回nil</li><li>ipairs: 迭代数组，不能返回 nil,如果遇到 nil 则退出</li></ul>]]></content>
      
      
      <categories>
          
          <category> Lua </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lua模块与包</title>
      <link href="/2019/07/04/Lua/Lua%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85/"/>
      <url>/2019/07/04/Lua/Lua%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p>Lua中的模块和包。</p><a id="more"></a><blockquote><p>一个模块就是一些代码，这些代码可以通过函数require加载，然后创建和返回一个表。这个表就像是某种命名空间，其中定义的内容是模块中导出的东西，比如函数和常量。</p></blockquote><h3 id="函数require："><a href="#函数require：" class="headerlink" title="函数require："></a>函数require：</h3><p>函数require尝试对模块的定义做最小的假设。对于该函数来说，一个模块可以是定义了一些变量的（比如函数或者包含函数的表）的代码。</p><h4 id="require的加载机制"><a href="#require的加载机制" class="headerlink" title="require的加载机制"></a>require的加载机制</h4><p>首先，函数require在表package.loaded中检查模块是否已被加载，如果模块已经被加载，函数require就返回相应的值，因此，一旦一个模块被加载过，后续的对于同一模块的所有require调用都将返回同一个值，而不会再运行任何代码。</p><p>如果模块尚未加载，那么函数require则搜索具有指定模块名的Lua文件（搜索路径由变量package.path指定）。如果函数require找到了相应的文件，那么就用函数loadfile将其进行加载，结果是一个我们称之为加载器的函数。</p><p>如果函数require找不到指定模块名的Lua文件，那么它就搜索相应名称的C标准库。如果找到了一个C标准库，则使用底层函数package.loadlib进行加载，这个底层函数会查找名为luaopen_modname的函数。在这种情况下，加载函数就是loadlib的执行结果，也就是一个被表示为Lua函数的C语言函数。</p><p>为了最终加载模块，函数require带着两个参数调用加载函数：模块名和加载函数所在的文件的名称。如果加载函数有返回值，那么函数require会返回这个值，然后将其保存在表package.loaded中，以便于将来在加载统一模块时返回相同的值。如果加载函数没有返回值且表中的package.loaded[@rep{modname}]为空，函数require就假设模块的返回值为true。如果没有这种补偿，那么后续调用函数require时将会重复加载模块。</p><h4 id="编写模块的基本方法"><a href="#编写模块的基本方法" class="headerlink" title="编写模块的基本方法"></a>编写模块的基本方法</h4><p>在Lua语言中创建一个表，并将所有需要导出的函数放入其中，最后返回这个表。</p><p>另一种编写模块的方法是把所有的函数定义为局部变量，然后在最后构造返回的表。</p><h4 id="字模块和包"><a href="#字模块和包" class="headerlink" title="字模块和包"></a>字模块和包</h4><p>Lua支持具有层次结构的模块名，通过点来分隔名称中的层次，例如一个名为mod.sub的模块是模块mod的一个子模块。一个包（package）是一棵由模块组成的完整的树，它是Lua语言用于发行程序的单位。</p>]]></content>
      
      
      <categories>
          
          <category> Lua </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Unity] 不同设备屏幕适配问题</title>
      <link href="/2019/04/24/Unity%E7%AC%94%E8%AE%B0/Unity-%E4%B8%8D%E5%90%8C%E8%AE%BE%E5%A4%87%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D%E9%97%AE%E9%A2%98/"/>
      <url>/2019/04/24/Unity%E7%AC%94%E8%AE%B0/Unity-%E4%B8%8D%E5%90%8C%E8%AE%BE%E5%A4%87%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>面试问到了，不同设备屏幕适配问题。</p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Unity] 在Unity中纹理图该是什么格式？</title>
      <link href="/2019/04/17/Unity%E7%AC%94%E8%AE%B0/Unity-%E5%9C%A8Unity%E4%B8%AD%E7%BA%B9%E7%90%86%E5%9B%BE%E8%AF%A5%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%BC%E5%BC%8F%EF%BC%9F/"/>
      <url>/2019/04/17/Unity%E7%AC%94%E8%AE%B0/Unity-%E5%9C%A8Unity%E4%B8%AD%E7%BA%B9%E7%90%86%E5%9B%BE%E8%AF%A5%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%BC%E5%BC%8F%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>一个在Windows下的png格式图，在Unity中存储为什么格式？</p><a id="more"></a><h3 id="Unity下的资源导入问题："><a href="#Unity下的资源导入问题：" class="headerlink" title="Unity下的资源导入问题："></a>Unity下的资源导入问题：</h3><p>Unity会把我们放进去的外部资源转换成一种Unity内部格式的资源，这个过程就是资源导入。</p><p>比如说在Windows下显示为png格式的图片，在Unity内部会根据平台的不同而设置成不同的<a href="https://docs.unity3d.com/ScriptReference/TextureImporterFormat.html" target="_blank" rel="noopener">压缩格式</a>。</p><p>可以使用<a href="https://docs.unity3d.com/ScriptReference/AssetPostprocessor.html" target="_blank" rel="noopener">AssetPostProcessor</a>来对导入的资源进行规定化。</p><p><strong>AssetPostProcessor</strong>是一个编辑器类，用来管理资源导入，当资源导入之前和之后都会发送通知，可以根据不同的资源类型，在导入之前和之后做不同的处理，来修改Unity内部资源格式。</p><p>由于这是一个编辑器类，在UnityEditor命名空间下，所以在使用C#脚本时，需要在脚本前加上using UnityEditor引用，且放在工程目录下的Asset/Editor文件夹下。<br>一般我们通过修改这个类中<strong>OnPreprocessxxx</strong>和<strong>OnPostprocessxxx</strong>函数来修改资源数据和设置。<br>这两者的区别可以简单理解为：前者用来Inspector视图可见的选项，后者为不可见的。</p><p>下面的脚本可以自动设置不同文件夹下贴图的压缩格式以及大小：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Script_12_02</span> : <span class="title">AssetPostprocessor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnPreprocessTexture</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        TextureImporter textureImporter = (TextureImporter)assetImporter;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(textureImporter.assetPath.Contains(<span class="string">"UI"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            textureImporter.textureType = TextureImporterType.Sprite;</span><br><span class="line">            textureImporter.mipmapEnabled = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置UI贴图在三个平台下的压缩格式以及大小</span></span><br><span class="line">            textureImporter.SetPlatformTextureSettings(<span class="string">"Standalone"</span>,<span class="number">2048</span>,TextureImporterFormat.RGBA32);</span><br><span class="line">            textureImporter.SetPlatformTextureSettings(<span class="string">"iPhone"</span>,<span class="number">2048</span>,TextureImporterFormat.RGBA32,<span class="number">100</span>,<span class="literal">true</span>);</span><br><span class="line">            textureImporter.SetPlatformTextureSettings(<span class="string">"Android"</span>,<span class="number">2048</span>,TextureImporterFormat.RGBA32,<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(textureImporter.assetPath.Contains(<span class="string">"Texture"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            textureImporter.textureType = TextureImporterType.Default;</span><br><span class="line">            textureImporter.mipmapEnabled = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置模型贴图在三个平台下的压缩格式以及大小</span></span><br><span class="line">            textureImporter.SetPlatformTextureSettings(<span class="string">"Standalone"</span>,<span class="number">2048</span>,TextureImporterFormat.DXT5);</span><br><span class="line">            textureImporter.SetPlatformTextureSettings(<span class="string">"iPhone"</span>,<span class="number">2048</span>,TextureImporterFormat.ASTC_RGBA_4x4,<span class="number">100</span>,<span class="literal">true</span>);</span><br><span class="line">            textureImporter.SetPlatformTextureSettings(<span class="string">"Android"</span>,<span class="number">2048</span>,TextureImporterFormat.ETC_RGB4,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="拓展阅读："><a href="#拓展阅读：" class="headerlink" title="拓展阅读："></a>拓展阅读：</h4><p>为什么要进行纹理压缩：<a href="http://www.newhappy.com.cn/?p=907" target="_blank" rel="noopener">http://www.newhappy.com.cn/?p=907</a></p><h3 id="那么纹理有哪些压缩格式呢？"><a href="#那么纹理有哪些压缩格式呢？" class="headerlink" title="那么纹理有哪些压缩格式呢？"></a>那么纹理有哪些压缩格式呢？</h3><h4 id="桌面平台："><a href="#桌面平台：" class="headerlink" title="桌面平台："></a>桌面平台：</h4><ul><li>RGB Compressed DXT1 压缩的RGB纹理。这是最常见的漫反射纹理格式。4位/像素（32 KB 256x256）</li><li>RGBA Compressed DXT5 压缩的RGBA纹理。这是漫反射和高光控制纹理的主要格式。1 字节/像素（64 KB 256x256）</li><li>RGB 16 bit 65万颜色不带alpha。压缩的DXT格式使用较少的内存，通常会更好看。（128 KB 256x256）</li><li>RGB 24 bit    真彩色不带alpha。（192 KB 256x256）</li><li>Alpha 8 bit   高质量alpha通道，不带颜色。（64 KB 256x256）</li><li>RGBA 16 bit   低质量真彩色。有16级红，绿，蓝和alpha。压缩的DXT5格式使用较少的内存，通常会更好看。（128 KB 256x256）</li><li>RGBA 32 bit   高质量真彩色带alpha（256 KB 256x256），这个文件很大。大多数情况下</li><li>DXT5提供足够的质量，文件大小要小得多。这个主要用于法线贴图，DXT压缩往往带有一个可见的质量损失。</li></ul><h4 id="Android："><a href="#Android：" class="headerlink" title="Android："></a>Android：</h4><ul><li>RGB Compressed DXT1   压缩的RGB纹理。支持Nvidia Tegra。4位/像素（32 KB 256x256）</li><li>RGBA Compressed DXT5  压缩的RGBA纹理。支持Nvidia Tegra。6位/像素（64 KB 256x256）</li><li>RGB Compressed ETC 4 bits 压缩的RGB纹理。<strong>这是Android工程默认的纹理格式。</strong></li><li>ETC1是OpenGL ES 2.0标准的一部分，并且支持所有的OpenGL ES 2.0 GPU，但它不支持Alpha。4位/像素（32 KB 256x256）</li><li>RGB Compressed PVRTC 2 bits   压缩的RGB纹理。 支持Imagination PowerVR GPU。2位/像素（16 KB 256x256）</li><li>RGBA Compressed PVRTC 2 bits  压缩的RGBA纹理。支持Imagination PowerVR GPU。2位/像素（16 KB 256x256）</li><li>RGB Compressed PVRTC 4 bits   压缩的RGB纹理。 支持Imagination PowerVR GPU。4位/像素（32 KB 256x256）</li><li>RGBA Compressed PVRTC 4 bits  压缩的RGBA纹理。 支持Imagination PowerVR GPU。4位/像素（32 KB 256x256）</li><li>RGB Compressed ATC 4 bits 压缩的RGB纹理。 支持Qualcomm Snapdragon。4位/像素（32 KB 256x256）</li><li>RGBA Compressed ATC 8 bits    压缩的RGB纹理。 支持Qualcomm Snapdragon。6位/像素（64 KB 256x256）</li><li>RGB 16 bit    65万颜色不带alpha。比压缩的格式使用更多的内存，但更适用于UI或不带渐变的明快的纹理。128 KB 256x256</li><li>RGB 24 bit    真彩色不带alpha。（192 KB 256x256）</li><li>Alpha 8 bit   高质量alpha通道，不带颜色。（64 KB 256x256）</li><li>RGBA 16 bit   低质量真彩色。默认压缩的纹理带有alpha通道（128 KB 256x256）</li><li>RGBA 32 bit   真彩色带alpha - 这是高质量压缩的纹理带有alpha通道。（256 KB 256x256）</li></ul><h4 id="IOS："><a href="#IOS：" class="headerlink" title="IOS："></a>IOS：</h4><ul><li>RGB Compressed PVRTC 4 bits</li><li>PVRTC 4位，压缩的RGB纹理。这是最常见的漫反射纹理格式。4位/像素（32 KB 256x256）</li><li>RGBA Compressed PVRTC 4 bits 压缩的RGBA纹理。这是漫反射和高光控制纹理的主要格式。4 位/像素（32 KB 256x256）</li><li>RGB Compressed PVRTC 2 bits压缩的RGB纹理。 低质量格式，适用于漫反射纹理。2 位/像素（16 KB 256x256）</li><li>RGBA Compressed PVRTC 2 bits   压缩的RGBA纹理。 低质量格式，适用于漫反射纹理和高光控制纹理。2 位/像素（16 KB 256x256）</li><li>RGB Compressed DXT1    压缩的RGB纹理。 在iOS不支持此格式，但为桌面项目保持向后兼容性。</li><li>RGBA Compressed DXT5   压缩的RGBA纹理。在iOS不支持此格式，但为桌面项目保持向后兼容性。</li><li>RGB 16 bit     65万颜色不带alpha。比PVRTC格式使用更多的内存，但更适用于UI或不带渐变的明快的纹理。128 KB 256x256</li><li>RGB 24 bit     真彩色不带alpha。（192 KB 256x256）</li><li>Alpha 8 bit   高质量alpha通道，不带颜色。（64 KB 256x256）</li><li>RGBA 16 bit    低质量真彩色。具有16级的红、绿、蓝和alpha。比PVRTC格式使用更多的内存，但如果需要精确的alpha通道，会更方便。（128 KB 256x256）</li><li>RGBA 32 bit   真彩色带alpha - 这是最高质量。256KB 256x256，这个是很消耗性能的。大多数情况下，PVRTC格式提供足够的质量，但有更小的文件大小。</li></ul><p><img src="http://wx4.sinaimg.cn/large/007CSzD7ly1g26isghucpj319j0cvwkf.jpg" alt></p><p>(图片来自：<strong>喵小逗@UWA问答社区</strong>)</p><h3 id="几种主要的压缩格式介绍："><a href="#几种主要的压缩格式介绍：" class="headerlink" title="几种主要的压缩格式介绍："></a>几种主要的压缩格式介绍：</h3><h4 id="高清晰无压缩-RGBA32"><a href="#高清晰无压缩-RGBA32" class="headerlink" title="高清晰无压缩 - RGBA32"></a>高清晰无压缩 - RGBA32</h4><p>RGBA32等同于原图了，优点是清晰、与原图一致，缺点是内存占用十分大；对于一些美术要求最好清晰度的图片，是首选。</p><p>要注意一些png图片，在硬盘中占用几KB，怎么在Unity中显示却变大？因为Unity显示的是Texture大小，是实际运行时占用内存的大小，而png却是一种压缩显示格式；可以这样理解，png类似于zip格式，是一个压缩文件，只不过在运行时会自动解压解析罢了。</p><h4 id="中清晰中压缩-RGBA16-Dithering"><a href="#中清晰中压缩-RGBA16-Dithering" class="headerlink" title="中清晰中压缩 - RGBA16 + Dithering"></a>中清晰中压缩 - RGBA16 + Dithering</h4><p>Unity RGBA16，不抖动处理的渐变图片惨不忍睹</p><p>既然叫RGBA16，自然就是RGBA32的阉割版。<br>对于一些采用渐变的图片，从RGBA32转换成RGBA16，能明显的看出颜色的层叠变化。</p><p>采用Floyd Steinberg抖动处理后，除非放大，否则肉眼基本看不出区别</p><p>RGBA16的优点，内存占用是RGBA32的1/2；搭配上Dithering抖动，在原尺寸下看清晰度一模一样；</p><p>缺点，Unity原生不支持Dithering抖动，需要自己做工具对图片做处理；对于需要放大、拉伸的图片，Dithering抖动的支持不好，会有非常明显的颗粒感。</p><h4 id="RGB16"><a href="#RGB16" class="headerlink" title="RGB16"></a>RGB16</h4><p>而RGB16，是主要针对一些，不带透明通道，同时长宽又不是2的次方的图片；对于这些图片，使用RGB16可以降低一半的内存，但是效果会略逊于RGB32。</p><p>当然了，RGB16其实也是可以搭配抖动，也能提升显示效果；但同样的Dithering抖动对拉伸放大是不友好的。</p><h4 id="低清晰高压缩-ETC1-Alpha-PVRTC4"><a href="#低清晰高压缩-ETC1-Alpha-PVRTC4" class="headerlink" title="低清晰高压缩 - ETC1+Alpha/PVRTC4"></a>低清晰高压缩 - ETC1+Alpha/PVRTC4</h4><p>很多初学者都会疑惑，为什么游戏开发中经常看到一些图片，需要设置成2的次方？<strong>因为像ETC1、PVRTC4等这类在内存中无需解压、直接被GPU支持的格式，占用内存极低，而且性能效率也是最好的</strong>。</p><p>但是，相对RGBA32，还是能肉眼看出质量有所下降的。</p><ol><li><p>ETC1</p><p>ETC1+Alpha一般应用在Android版的UI图集中，ETC1不带透明通道，所以需要外挂一张同样是ETC1格式的Alpha通道图。方法是，在原RGBA32的原图中，提取RGB生成第一张ETC1，再提取A通道，填充另一张ETC1的R通道；游戏运行时，Shader将两张ETC1图片进行混合。</p></li><li><p>PVRTC4</p><p>PVRTC4在Unity中是直接支持的，不过要注意的细节是，它必须是二次方正方形；也就是说，长宽在二次方的同时，还必须要相等。</p><p><img src="https://wx4.sinaimg.cn/mw690/007CSzD7ly1g26jfrkg89j30k00b241o.jpg" alt></p><p>在项目中，尽可能是使用ETC1和PVRTV4等GPU直接支持的图片格式，不仅内存占用低、性能也更好；当出现质量不及格时，再逐步的提升压缩格式，来满足需要。</p></li></ol><hr><p>参考：</p><ol><li><a href="https://zhuanlan.zhihu.com/p/27438791" target="_blank" rel="noopener">Unity运用导入器规范资源格式和设置</a></li><li><a href="https://www.jianshu.com/p/b9a6feb6d7b5" target="_blank" rel="noopener">Unity3D 图片纹理格式(作者：JumboWu)</a></li><li><a href="https://zhuanlan.zhihu.com/p/25205686" target="_blank" rel="noopener">干货：Unity游戏开发图片纹理压缩方案</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Unity] 生命周期相关</title>
      <link href="/2019/04/17/Unity%E7%AC%94%E8%AE%B0/Unity-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9B%B8%E5%85%B3/"/>
      <url>/2019/04/17/Unity%E7%AC%94%E8%AE%B0/Unity-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<p>生命周期相关。</p><a id="more"></a><h3 id="脚本的生命周期："><a href="#脚本的生命周期：" class="headerlink" title="脚本的生命周期："></a>脚本的生命周期：</h3><p>Unity脚本有一套完整的生命周期，脚本需要挂在任意游戏对象上，并且同一个游戏对象可以挂不同的脚本，各脚本执行自己的生命周期，它们可以互相组合并且互不干预。生命周期中的所有方法都是Unity系统自己回调的，不需要手动调用，主要有编辑脚本、初始化、物理碰撞事件、更新回调、渲染和销毁等。学习脚本的生命周期之前，我们不得不引用文档中非常经典的一张图，它完整的描述了脚本的生命周期：</p><p><img src="https://docs.unity3d.com/uploads/Main/monobehaviour_flowchart.svg" alt></p><h4 id="第一个场景加载："><a href="#第一个场景加载：" class="headerlink" title="第一个场景加载："></a>第一个场景加载：</h4><p>这些函数将在场景开始加载时调用。(场景中的每个物体仅调用一次)</p><ul><li><strong>Awake</strong>：这个方法总是在在任何开始方法之前调用(可以理解成最先调用吧？)，并且在一个prefab<strong>刚被实例化后</strong>就调用。(如果一个游戏物体在开始时是不活跃的(inactive)则将不会调用awake函数，直到其变为活跃。)</li><li><strong>OnEnable</strong>：(仅在物体为活跃(active)状态调用)：这个函数仅在一个物体变为有效(enabled)后调用。这通常发生在一个MonoBehavior实例创建时，例如在一个场景加载时或者一个持有脚本组件的游戏物体被实例化时。</li><li><strong>OnLevelWasLoaded</strong>：这个函数用来通知游戏逻辑一个新的场景已经被加载完。</li></ul><p>注意：对于加到场景中的物体来说，Awake和OnEnable方法将在所有脚本的任何类似于Start、Update等方法被调用之前调用。自然的，这些方法也不能在游戏进行中强制调用。</p><h4 id="编辑器："><a href="#编辑器：" class="headerlink" title="编辑器："></a>编辑器：</h4><ul><li><strong>Reset</strong>：Reset被调用于第一次将脚本绑定到物体上时初始化脚本属性，或者在Reset指令被触发时调用。</li></ul><h4 id="在帧之间："><a href="#在帧之间：" class="headerlink" title="在帧之间："></a>在帧之间：</h4><ul><li><strong>OnApplicationPause</strong>:：这个方法在检测到暂停的帧的末尾调用，在正常帧更新间有效？之后将会发出一个额外的帧。调用<strong>OnApplicationPause</strong>以允许游戏显示指示暂停状态的图形。</li></ul><h4 id="更新顺序："><a href="#更新顺序：" class="headerlink" title="更新顺序："></a>更新顺序：</h4><p>当你追踪游戏逻辑和交互、动画、相机位置等，你可以使用几个不同的事件。常见的模式是在Update函数中执行大多数任务，但也可以使用其他功能。</p><ul><li><strong>FixedUpdate</strong>：FixedUpdate函数通常要比Update函数调用的更为频繁，会按照设置的时间固定频率来循环更新。如果帧速率低，则可以每帧调用多次，如果帧速率高，则可以不在帧之间调用。所有物理计算和更新在FixedUpdate之后立即发生。在FixedUpdate中应用移动计算时，不需要乘以Time.deltaTime。这是因为FixedUpdate在可靠的定时器上调用，与帧速率无关。</li><li><strong>Update</strong>：Update每帧调用一次。它是帧更新的主要功能。</li><li><strong>LateUpdate</strong>：LateUpdate每帧调用一次，但在Update执行结束之后。在LateUpdate开始时，在Update中执行的任何计算都应该已经完成。LateUpdate的一个常见用途是实现跟随的第三人称相机。如果你将角色移动放在Update中执行，那么你可以将所有的相机移动和旋转计算放在LateUpdate中执行。这将确保角色在摄像机跟踪其位置之前完全移动。</li></ul><blockquote><p>总体来说，Update()和LateUpdate()属于立即更新，更新之间的频率是不固定的，比如某一帧有一个耗时操作的时候，就会影响到下一帧更新的时间，所以对更新频率要求比较稳定的物理系统就不太适合在这里处理更新。</p><p>FixedUpdate()虽然是固定更新，但是其实也是相对固定的，比如某一帧耗了好几秒，它依然会卡住。不过正常的程序要优化耗时操作，小范围的帧率波动是正常的，可以让它更新的时间间隔稍微长一点，这样它的更新是比较平滑的。在实际的开发中，例如以秒为单位的倒计时，并不需要每一帧去判断时间，所以用FixedUpdate()就再合适不过了。</p></blockquote><h4 id="动画更新循环："><a href="#动画更新循环：" class="headerlink" title="动画更新循环："></a>动画更新循环：</h4><p>这些方法和Profiler Markers在Unity评估(？)动画系统时会调用。</p><p>(暂略)</p><h4 id="有用的profile-markers："><a href="#有用的profile-markers：" class="headerlink" title="有用的profile markers："></a>有用的profile markers：</h4><p>(暂略)</p><h4 id="渲染："><a href="#渲染：" class="headerlink" title="渲染："></a>渲染：</h4><ul><li><strong>OnPreCull</strong>：在相机剔除场景之前调用。剔除确定相机可以看到哪些对象。在剔除之前调用OnPreCull。</li><li><strong>OnBecameVisible/OnBecameInvisible</strong>：当对象变得对任何相机可见/不可见时调用。</li><li><strong>OnWillRenderObject</strong>：如果对象可见，则为每个摄像机调用一次。</li><li><strong>OnPreRender</strong>：在相机开始渲染场景之前调用一次。</li><li><strong>OnRenderObject</strong>：在完成所有常规场景渲染后调用。您可以使用GL类或Graphics.DrawMeshNow来绘制自定义几何体。</li><li><strong>OnPostRender</strong>：在相机完成渲染场景后调用。</li><li><strong>OnRenderImage</strong>：在场景渲染完成后调用以允许对图像进行后处理，请参阅后处理效果。</li><li><strong>OnGUI</strong>：响应GUI事件，每帧调用多次。首先处理Layout和Repaint事件，然后为每个输入事件处理Layout和keyboard / mouse事件。</li><li><strong>OnDrawGizmos</strong>：用于在场景视图中绘制Gizmo以进行可视化。</li></ul><h4 id="协程："><a href="#协程：" class="headerlink" title="协程："></a>协程：</h4><p>正常的协程在Update函数返回后更新。协程是一个可以暂停执行(yield)直到给定的YieldInstruction完成的函数。以下是协程的不同用处：</p><ul><li><strong>yield</strong>：在下一帧调用所有Update函数后，协程将继续。</li><li><strong>yield WaitForSeconds</strong>：在为帧调用了所有的Update函数后，协程在指定的延迟时间后继续。</li><li><strong>yield WaitForFixedUpdate</strong>：在所有脚本中的的所有FixedUpdate执行后继续协程。</li><li><strong>yield WWW</strong>：在一个WWW类的下载完成之后执行协程。</li><li><strong>yield StartCoroutine</strong>：链接协程，并将等待MyFunc协程首先完成。</li></ul><h4 id="当物体被销毁时："><a href="#当物体被销毁时：" class="headerlink" title="当物体被销毁时："></a>当物体被销毁时：</h4><ul><li><strong>OnDestroy</strong>：在对象存在的最后一帧的所有帧更新之后调用这个函数。(该对象可能在相应Object.Destory或者场景闭合时被销毁)。</li></ul><h4 id="当退出时："><a href="#当退出时：" class="headerlink" title="当退出时："></a>当退出时：</h4><p>在场景中的所有活动对象上调用这些函数：</p><ul><li><strong>OnApplicationQuit</strong>：在退出应用程序之前，将在所有游戏对象上调用此函数。在编辑器中，当用户停止播放模式时调用它。</li><li><strong>OnDisable</strong>：当行为被禁用或处于非活动状态时，将调用此函数。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Unity] Unity中的内存泄漏</title>
      <link href="/2019/04/11/Unity%E7%AC%94%E8%AE%B0/Unity-Unity%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
      <url>/2019/04/11/Unity%E7%AC%94%E8%AE%B0/Unity-Unity%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>Unity中的内存泄漏。</p><a id="more"></a><hr><p>参考：</p><ol><li><a href="https://wetest.qq.com/lab/view/135.html" target="_blank" rel="noopener">内存是手游的硬伤——Unity游戏Mono内存管理及泄漏</a></li><li><a href="https://wetest.qq.com/lab/view/150.html" target="_blank" rel="noopener">深入浅出再谈Unity内存泄漏</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[游戏AI] 状态机</title>
      <link href="/2019/04/01/%E6%B8%B8%E6%88%8FAI/%E6%B8%B8%E6%88%8FAI-%E7%8A%B6%E6%80%81%E6%9C%BA/"/>
      <url>/2019/04/01/%E6%B8%B8%E6%88%8FAI/%E6%B8%B8%E6%88%8FAI-%E7%8A%B6%E6%80%81%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<p>状态机的利与弊。</p><a id="more"></a><hr><p>参考：</p><ol><li><a href="http://www.cnblogs.com/fingerpass/p/discussion-about-game-ai.html" target="_blank" rel="noopener">漫谈游戏中的人工智能</a></li><li>《游戏人工智能编程案例精粹》</li></ol><hr><h2 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h2><h3 id="状态机是什么："><a href="#状态机是什么：" class="headerlink" title="状态机是什么："></a>状态机是什么：</h3><h3 id="为什么选择状态机："><a href="#为什么选择状态机：" class="headerlink" title="为什么选择状态机："></a>为什么选择状态机：</h3><h3 id="状态机的演进："><a href="#状态机的演进：" class="headerlink" title="状态机的演进："></a>状态机的演进：</h3><h4 id="最简单的状态机："><a href="#最简单的状态机：" class="headerlink" title="最简单的状态机："></a>最简单的状态机：</h4><p>首先很容易抽象出IUnit：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IUnit</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ChangeState</span>(<span class="params">UnitStateEnum state</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Patrol</span>(<span class="params"></span>)</span>; </span><br><span class="line">    <span class="function">IUnit <span class="title">GetNearestTarget</span>(<span class="params"></span>)</span>; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LockTarget</span>(<span class="params">IUnit unit</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">GetFleeBloodRate</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">CanMove</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">HpRateLessThan</span>(<span class="params"><span class="keyword">float</span> rate</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Flee</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Speak</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要注意的是，<strong>原作者的实现方式是定义一个单位接口，每个智能体要实现这个单位接口中定义的方法。</strong>(这样写会使每个单位类中有着一套自己所有行为的方法。我之前的实现方式是状态机来控制单位进行相应的行为，这样可以使每个状态仅有这个状态下自身的方法，但是耦合性较高。原作者这种接口是不是可以改写成虚方法的形式，在基类中实现基本行为，具体单位子类中再override出特定的行为？)</p><p>一个最简单的状态机定义：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface IState&lt;TState,TUnit&gt; where TState : IConvertible</span><br><span class="line">&#123;</span><br><span class="line">  TState Enum &#123;<span class="keyword">get</span>;&#125;</span><br><span class="line">  TUnit Self &#123;<span class="keyword">get</span>;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">OnEnter</span>(<span class="params"></span>)</span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Drive</span>(<span class="params"></span>)</span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">OnExit</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写有着一个明显的性能问题：状态机本质是描述状态迁移的，并不需要保存实体的上下文，如果实体的上下文都保存在State中(上文中的TUnit类型的Self)，那么这个状态机的每个状态迁移逻辑需要每个状态都保存一个实体的实例，这样浪费内存，应该将决策逻辑与实体的上下文分离。</p><h4 id="决策逻辑和上下文分离："><a href="#决策逻辑和上下文分离：" class="headerlink" title="决策逻辑和上下文分离："></a>决策逻辑和上下文分离：</h4><p>剥离后：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface IState&lt;TState,TUnit&gt; where TState : IConvertible</span><br><span class="line">&#123;</span><br><span class="line">  TState Enum &#123;<span class="keyword">get</span>;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">OnEnter</span>(<span class="params">TUnit self</span>)</span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Drive</span>(<span class="params">TUnit self</span>)</span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">OnExit</span>(<span class="params">TUnit self</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用单例模式保持静态的状态内容实例只有一个，此时状态之间的迁移逻辑变成了静态，动态的是状态迁移过程中的上下文。</p><h4 id="分层有限状态机："><a href="#分层有限状态机：" class="headerlink" title="分层有限状态机："></a>分层有限状态机：</h4><p>如果想要让状态机框架描述层级结构的概念，需要对其进行拓展：</p><p>例如一个怪物需要在巡逻一段时间后进行休息，在休息一段时间后再次进行巡逻，而巡逻与休息状态均保持着对于战斗的检查。这时如果按照之前的框架(我之前就是最初级的那种)，就需要手动进行装配，在每个状态中都写入一个关于是否进入战斗状态的检查。可以看出战斗状态的优先级较高，并且相对来说算是一种”全局检查”，可以将其抽离出来作为上层状态。</p><ul><li>父状态需要关注子状态的运行结果，所以状态的Drive接口需要一个运行结果的返回值。</li><li>子状态一定是由父状态驱动的。</li></ul><blockquote><p>考虑这样一个组合状态情景：巡逻时，需要依次得先走到一个点，然后怠工一会儿，再走到下一个点，然后再怠工一会儿，循环往复。这样就需要父状态（巡逻状态）注记当前激活的子状态，并且根据子状态执行结果的不同来修改激活的子状态集合。这样不仅是Unit自身有上下文，连组合状态也有了自己的上下文。</p></blockquote><p>状态定义：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface IState&lt;TState, TCleverUnit, TResult&gt; where TState : IConvertible</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="function">TResult <span class="title">Drive</span>(<span class="params"></span>)</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组合状态的定义：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">UnitCompositeStateBase</span> : <span class="title">UnitStateBase</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">readonly</span> LinkedList&lt;UnitStateBase&gt; subStates = <span class="keyword">new</span> LinkedList&lt;UnitStateBase&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Result <span class="title">ProcessSubStates</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (subStates.Count == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> Result.Success;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> front = subStates.First;</span><br><span class="line"><span class="keyword">var</span> res = front.Value.Drive();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (res != Result.Continue)</span><br><span class="line">&#123;</span><br><span class="line">subStates.RemoveFirst();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Result.Continue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>巡逻状态：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PatrolState</span> : <span class="title">UnitCompositeStateBase</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnEnter</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">base</span>.OnEnter();</span><br><span class="line">AddSubState(<span class="keyword">new</span> MoveToState(Self));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Result <span class="title">Drive</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (subStates.Count == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> Result.Success;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> unit = Self.GetNearestTarget();</span><br><span class="line"><span class="keyword">if</span> (unit != <span class="literal">null</span>)</span><br><span class="line"> &#123;</span><br><span class="line">Self.LockTarget(unit);</span><br><span class="line"><span class="keyword">return</span> Result.Success;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> front = subStates.First;</span><br><span class="line"><span class="keyword">var</span> ret = front.Value.Drive();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret != Result.Continue)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (front.Value.Enum == CleverUnitStateEnum.MoveTo)</span><br><span class="line">&#123;</span><br><span class="line">AddSubState(<span class="keyword">new</span> IdleState(Self));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">AddSubState(<span class="keyword">new</span> MoveToState(Self));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">            </span><br><span class="line"><span class="keyword">return</span> Result.Continue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分层有限状态机的上下文分离："><a href="#分层有限状态机的上下文分离：" class="headerlink" title="分层有限状态机的上下文分离："></a>分层有限状态机的上下文分离：</h4><p>　　我们对之前重构出来的层次状态机框架再进行一次Context分离优化。</p><p>　　要优化的点有这样几个：</p><ul><li>首先是继续之前的，unit不应该作为一个state自己的内部status。</li><li>组合状态的实例内部不应该包括自身执行的status。目前的组合状态，可以动态增删子状态，也就是根据status决定了结构的状态，理应分离静态与动态。巡逻状态组合了两个子状态——A和B，逻辑中是一个完成了就添加另一个，这样一想的话，其实巡逻状态应该重新描述——先进行A，再进行B，循环往复。</li></ul><ul><li>由于有了父状态的概念，其实状态接口的设计也可以再迭代，理论上只需要一个drive即可。因为状态内部的上下文要全部分离出来，所以也没必要对外提供OnEnter、OnExit，提供这两个接口的意义只是做一层内部信息的隐藏，但是现在内部的status没了，也就没必要隐藏了。</li></ul><p>　　具体分析一下需要拆出的status：</p><ul><li>一部分是entity本身的status，这里可以简单的认为是unit。</li><li>另一部分是state本身的status。<ul><li>对于组合状态，这个status描述的是我当前执行到哪个substate。</li><li>对于原子状态，这个status描述的种类可能有所区别。<ul><li>例如MoveTo/Flee，OnEnter的时候，修改了unit的status，然后Drive的时候去check。</li><li>例如Idle，OnEnter时改了自己的status，然后Drive的时候去check。</li></ul></li></ul></li></ul><p>　　经过总结，我们可以发现，每个状态的status本质上都可以通过一个变量来描述。一个State作为一个最小粒度的单元，具有这样的Concept： 输入一个Context，输出一个Result。</p><p>　　Context暂时只需要包括这个Unit，和之前所说的status。同时，考虑这样一个问题：</p><ul><li>父状态A，子状态B。</li><li>子状态B向上返回Continue的同时，status记录下来为b。</li><li>父状态ADrive子状态的结果为Continue，自身也需要向上抛出Continue，同时自己也有status为a。</li></ul><p>　　这样，再还原现场时，就需要即给A一个a，还需要让A有能力从Context中拿到需要给B的b。因此上下文的结构理应是递归定义的，是一个层级结构。</p><p>　　Context如下定义：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Continuation</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> Continuation SubContinuation &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> NextStep &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">object</span> Param &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public class Context&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> Continuation Continuation &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"><span class="keyword">public</span> T Self &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　修改State的接口定义为：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface IState&lt;TCleverUnit, TResult&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">TResult <span class="title">Drive</span>(<span class="params">Context&lt;TCleverUnit&gt; ctx</span>)</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>　　已经相当简洁了。</p><p>　　这样，我们对之前的巡逻状态也做下修改，达到一个ContextFree的效果。利用Context中的Continuation来确定当前结点应该从什么状态继续：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">public class PatrolState : IState&lt;ICleverUnit, Result&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> List&lt;IState&lt;ICleverUnit, Result&gt;&gt; subStates;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PatrolState</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            subStates = <span class="keyword">new</span> List&lt;IState&lt;ICleverUnit, Result&gt;&gt;()</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">new</span> MoveToState(),</span><br><span class="line">                <span class="keyword">new</span> IdleState(),</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Result <span class="title">Drive</span>(<span class="params">Context&lt;ICleverUnit&gt; ctx</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">var</span> unit = ctx.Self.GetNearestTarget();</span><br><span class="line">            <span class="keyword">if</span> (unit != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ctx.Self.LockTarget(unit);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> Result.Success;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> nextStep = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (ctx.Continuation != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Continuation</span></span><br><span class="line">                <span class="keyword">var</span> thisContinuation = ctx.Continuation;</span><br><span class="line"></span><br><span class="line">                ctx.Continuation = thisContinuation.SubContinuation;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">var</span> ret = subStates[nextStep].Drive(ctx);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (ret == Result.Continue)</span><br><span class="line">                &#123;</span><br><span class="line">                    thisContinuation.SubContinuation = ctx.Continuation;</span><br><span class="line">                    ctx.Continuation = thisContinuation;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> Result.Continue;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ret == Result.Failure)</span><br><span class="line">                &#123;</span><br><span class="line">                    ctx.Continuation = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> Result.Failure;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ctx.Continuation = <span class="literal">null</span>;</span><br><span class="line">                nextStep = thisContinuation.NextStep + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (; nextStep &lt; subStates.Count; nextStep++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> ret = subStates[nextStep].Drive(ctx);</span><br><span class="line">                <span class="keyword">if</span> (ret == Result.Continue)</span><br><span class="line">                &#123;</span><br><span class="line">                    ctx.Continuation = <span class="keyword">new</span> Continuation()</span><br><span class="line">                    &#123;</span><br><span class="line">                        SubContinuation = ctx.Continuation,</span><br><span class="line">                        NextStep = nextStep,</span><br><span class="line">                    &#125;;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> Result.Continue;</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ret == Result.Failure) </span><br><span class="line">                &#123;</span><br><span class="line">                    ctx.Continuation = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> Result.Failure;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ctx.Continuation = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> Result.Success;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>　　subStates是readonly的，在组合状态构造的一开始就确定了值。这样结构本身就是静态的，而上下文是动态的。不同的entity instance共用同一个树的instance。</p><p>​    (最后这个理解起来比较吃力了)</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[游戏引擎架构] 第十章：渲染引擎</title>
      <link href="/2019/03/26/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84-%E7%AC%AC%E5%8D%81%E7%AB%A0-%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E/"/>
      <url>/2019/03/26/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84-%E7%AC%AC%E5%8D%81%E7%AB%A0-%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<p>「占位」</p><a id="more"></a><h2 id="渲染引擎"><a href="#渲染引擎" class="headerlink" title="渲染引擎"></a>渲染引擎</h2><h3 id="采用深度缓冲的三角形光栅化基础"><a href="#采用深度缓冲的三角形光栅化基础" class="headerlink" title="采用深度缓冲的三角形光栅化基础"></a>采用深度缓冲的三角形光栅化基础</h3><p>三维场景渲染的本质涉及以下基本步骤：</p><ul><li>描述一个<strong>虚拟场景</strong>。这些场景一般是以某数学形式表示的三维表面。</li><li>定位及定向一个<strong>虚拟摄像机</strong>，为场景取景。</li><li>设置<strong>光源</strong>。</li><li>描述场景中物体表面的<strong>视觉特性</strong>。</li><li>对于每个位于影像矩形内的像素，渲染引擎会找出经过该像素而聚焦于虚拟摄像机焦点的光线，并计算其颜色和强度。此过程为<strong>求解渲染方程</strong>，也叫做<strong>着色方程</strong>。</li></ul><h4 id="场景描述："><a href="#场景描述：" class="headerlink" title="场景描述："></a>场景描述：</h4><h5 id="高端渲染软件所用的表示法"><a href="#高端渲染软件所用的表示法" class="headerlink" title="高端渲染软件所用的表示法"></a>高端渲染软件所用的表示法</h5><h5 id="三角形网格"><a href="#三角形网格" class="headerlink" title="三角形网格"></a>三角形网格</h5><p>游戏开发者会使用三角形网格来为表面建模。三角形是表面的分段线性逼近。</p><ul><li><p>为什么选取三角形？</p><ul><li>三角形是最简单的多边形</li><li>三角形必然是平坦的</li><li>三角形经过多种转换之后仍然维持是三角形，对于仿射转换与透视转换也成立</li><li>几乎所有的商用图形加速软件都是为三角形光栅化而设计的。</li></ul></li><li><p>镶嵌：</p><p>镶嵌是指把表面分割为一组离散多边形的过程。</p></li></ul><h5 id="构造三角形网格"><a href="#构造三角形网格" class="headerlink" title="构造三角形网格"></a>构造三角形网格</h5><ul><li><p>缠绕顺序</p><p>三角形由三个顶点的位置矢量定义，此三个矢量设为p1，p2，p3。每条棱的相邻顶点的位置矢量相减，就能求得三条棱的矢量。</p><p>任何两棱的<strong>叉积</strong>，归一化后就能定义为三角形的单位面法线N，若要知道面法线的方向，需要定义哪一面才是三角形的正面，哪一面是背面，这个可以简单用<a href="https://learnopengl-cn.github.io/04%20Advanced%20OpenGL/04%20Face%20culling/#_2" target="_blank" rel="noopener">缠绕顺序(winding order)</a>定义，缠绕顺序用来定义表面方向有两种方式，分别是顺时针方向和逆时针方向。</p></li></ul><h5 id="模型空间"><a href="#模型空间" class="headerlink" title="模型空间"></a>模型空间</h5><h5 id="世界空间及网格实例化"><a href="#世界空间及网格实例化" class="headerlink" title="世界空间及网格实例化"></a>世界空间及网格实例化</h5><h4 id="描述表面的视觉性质"><a href="#描述表面的视觉性质" class="headerlink" title="描述表面的视觉性质"></a>描述表面的视觉性质</h4><h5 id="光和颜色的概论"><a href="#光和颜色的概论" class="headerlink" title="光和颜色的概论"></a>光和颜色的概论</h5><h5 id="顶点属性"><a href="#顶点属性" class="headerlink" title="顶点属性"></a>顶点属性</h5><h5 id="顶点格式"><a href="#顶点格式" class="headerlink" title="顶点格式"></a>顶点格式</h5><h5 id="属性插值"><a href="#属性插值" class="headerlink" title="属性插值"></a>属性插值</h5><h5 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h5><h5 id="材质"><a href="#材质" class="headerlink" title="材质"></a>材质</h5><h4 id="光照基础"><a href="#光照基础" class="headerlink" title="光照基础"></a>光照基础</h4><h5 id="局部及全局光照模型"><a href="#局部及全局光照模型" class="headerlink" title="局部及全局光照模型"></a>局部及全局光照模型</h5><h5 id="Phong氏光照模型"><a href="#Phong氏光照模型" class="headerlink" title="Phong氏光照模型"></a>Phong氏光照模型</h5><h5 id="光源模型"><a href="#光源模型" class="headerlink" title="光源模型"></a>光源模型</h5><h4 id="虚拟摄像机"><a href="#虚拟摄像机" class="headerlink" title="虚拟摄像机"></a>虚拟摄像机</h4><h5 id="观察空间"><a href="#观察空间" class="headerlink" title="观察空间"></a>观察空间</h5><h5 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h5><h5 id="观察体积及平截头体"><a href="#观察体积及平截头体" class="headerlink" title="观察体积及平截头体"></a>观察体积及平截头体</h5><h5 id="投影及齐次裁剪空间"><a href="#投影及齐次裁剪空间" class="headerlink" title="投影及齐次裁剪空间"></a>投影及齐次裁剪空间</h5><h5 id="屏幕空间及长宽比"><a href="#屏幕空间及长宽比" class="headerlink" title="屏幕空间及长宽比"></a>屏幕空间及长宽比</h5><h5 id="帧缓冲"><a href="#帧缓冲" class="headerlink" title="帧缓冲"></a>帧缓冲</h5><h5 id="三角形光栅化及片段"><a href="#三角形光栅化及片段" class="headerlink" title="三角形光栅化及片段"></a>三角形光栅化及片段</h5><h5 id="遮挡及深度缓冲"><a href="#遮挡及深度缓冲" class="headerlink" title="遮挡及深度缓冲"></a>遮挡及深度缓冲</h5><h3 id="渲染管道"><a href="#渲染管道" class="headerlink" title="渲染管道"></a>渲染管道</h3><h3 id="高级光照及全局光照"><a href="#高级光照及全局光照" class="headerlink" title="高级光照及全局光照"></a>高级光照及全局光照</h3><h3 id="视觉效果和覆盖层"><a href="#视觉效果和覆盖层" class="headerlink" title="视觉效果和覆盖层"></a>视觉效果和覆盖层</h3>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机图形学 </tag>
            
            <tag> 游戏引擎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Unity] 托管堆与垃圾回收</title>
      <link href="/2019/03/25/Unity%E7%AC%94%E8%AE%B0/Unity-%E6%89%98%E7%AE%A1%E5%A0%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
      <url>/2019/03/25/Unity%E7%AC%94%E8%AE%B0/Unity-%E6%89%98%E7%AE%A1%E5%A0%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
      
        <content type="html"><![CDATA[<p>有关Unity中的托管堆与垃圾回收。</p><a id="more"></a><h2 id="托管堆与垃圾回收"><a href="#托管堆与垃圾回收" class="headerlink" title="托管堆与垃圾回收"></a>托管堆与垃圾回收</h2><h3 id="托管堆："><a href="#托管堆：" class="headerlink" title="托管堆："></a>托管堆：</h3><p>“托管堆”是一段内存，由项目脚本运行时（Mono或IL2CPP）的内存管理器自动管理。托管代码中创建的所有对象必须在托管堆上分配（<strong>注意：</strong>严格地说，必须在托管堆上分配所有非空引用类型对象和所有盒装值类型对象）。</p><p><img src="https://wx3.sinaimg.cn/mw690/007CSzD7gy1g1f2klldndj30iz03ct8m.jpg" alt></p><p>在上图中，白框表示分配给托管堆的内存量，其中的彩色框表示存储在托管堆内存空间中的数据值。当需要其他值时，将从托管堆中分配更多空间。</p><p>垃圾收集器定期运行（<strong>注意：</strong>确切的时间与平台有关）。这会扫描堆上的所有对象，标记删除任何不再引用的对象。然后删除未引用的对象，释放内存。</p><p>至关重要的是，Unity的垃圾收集 - 使用<a href="https://en.wikipedia.org/wiki/Boehm_garbage_collector" target="_blank" rel="noopener">Boehm GC算法</a> - 是非代数和非压缩的。“非世代”意味着GC在执行收集传递时必须扫描整个堆，因此其性能因堆扩展而降低。“非压缩”意味着内存中的对象不会被重新定位以便关闭对象之间的间隙。</p><p><img src="https://wx4.sinaimg.cn/mw690/007CSzD7gy1g1f2klnzgmj30j2039jrc.jpg" alt></p><p>上图显示了内存碎片的示例。释放对象时，将释放其内存。但是，释放的空间也<strong>不会</strong>成为“空闲内存”一家独大池的一部分。释放对象两侧的对象可能仍在使用中。因此，释放的空间是存储器的其他部分之间的“间隙”（该间隙由图中的红色圆圈表示）。因此，新释放的空间仅可用于存储与释放的对象相同或更小的数据。</p><p>分配对象时，请记住该对象必须始终占用内存中的连续空间块。</p><p>这导致了内存碎片的核心问题：虽然堆中可用的总空间量可能很大，但是该空间中的一些或全部可能在分配的对象之间存在小的“间隙”。在这种情况下，即使可能有足够的总空间来容纳某个分配，托管堆也找不到足够大的连续内存块来适应分配。</p><p><img src="https://wx3.sinaimg.cn/mw690/007CSzD7gy1g1f2klo5urj30j704oglm.jpg" alt></p><p>但是，如果分配了大对象并且没有足够的连续可用空间来容纳对象，则如上所述，Unity内存管理器执行两个操作。</p><p>首先，如果还没有这样做，垃圾收集器就会运行。这会尝试释放足够的空间来完成分配请求。</p><p>如果在GC运行后，仍然没有足够的连续空间来满足请求的内存量，则堆必须扩展。堆扩展的具体数量取决于平台; 但是，大多数Unity平台的大小都是托管堆的两倍。</p><h4 id="堆的关键问题"><a href="#堆的关键问题" class="headerlink" title="堆的关键问题"></a>堆的关键问题</h4><p>托管堆扩展的核心问题有两个：</p><ul><li>Unity在扩展时不会经常释放分配给托管堆的内存页; 它乐观地保留了扩展堆，即使它的大部分是空的。这是为了防止在进一步发生大量分配时需要重新扩展堆。</li><li>在大多数平台上，Unity最终将托管堆空部分使用的页面释放回操作系统。发生这种情况的间隔不能保证，不应该依赖。</li><li>托管堆使用的地址空间永远不会返回给操作系统。</li><li>对于32位程序，如果托管堆多次扩展和收缩，则可能导致地址空间耗尽。如果程序的可用内存地址空间已用尽，操作系统将终止该程序。</li><li>对于64位程序，地址空间足够大，对于运行时间不超过人类平均寿命的程序来说，这种情况极不可能发生。</li></ul><h3 id="了解自动内存管理："><a href="#了解自动内存管理：" class="headerlink" title="了解自动内存管理："></a>了解自动内存管理：</h3><p>创建对象，字符串或数组时，存储它所需的内存是从称为<strong>堆</strong>的中央池分配的。当项目不再使用时，它曾经占用的内存可以被回收并用于其他内容。在过去，通常由程序员通过适当的函数调用显式地分配和释放这些堆内存块。如今，Unity的Mono引擎等运行时系统会自动为您管理内存。自动内存管理比显式分配/释放需要更少的编码工作，并且大大降低了内存泄漏的可能性（分配内存但从未随后释放的情况）。</p><h4 id="分配和垃圾收集"><a href="#分配和垃圾收集" class="headerlink" title="分配和垃圾收集"></a>分配和垃圾收集</h4><p>内存管理器跟踪它知道未使用的堆中的区域。当请求新的存储器块时（例如，当实例化对象时），管理器选择一个未使用的区域，从该区域分配块，然后从已知的未使用空间中移除分配的存储器。后续请求以相同的方式处理，直到没有足够大的空闲区域来分配所需的块大小。此时极不可能从堆中分配的所有内存仍在使用中。只有存在可以找到它的引用变量时，才能访问堆上的引用项。如果对内存块的所有引用都消失了（即，引用变量已被重新分配，或者它们是现在超出范围的局部变量），则可以安全地重新分配它占用的内存。</p><p>为了确定哪些堆块不再使用，内存管理器搜索所有当前活动的引用变量，并将它们称为“实时”的块标记。在搜索结束时，内存管理器认为实时块之间的任何空格都是空的，并且可以用于后续分配。由于显而易见的原因，定位和释放未使用的内存的过程称为垃圾收集（或简称GC）。</p><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>垃圾收集是自动的，对于程序员不可见，但在采集过程中实际需要的背后显著CPU时间的场景。如果使用正确，自动内存管理通常会等于或超过手动分配以获得整体性能。但是，程序员必须避免错误，这些错误会比必要时更频繁地触发收集器并在执行时引入暂停。</p><h3 id="Unity中的垃圾回收："><a href="#Unity中的垃圾回收：" class="headerlink" title="Unity中的垃圾回收："></a>Unity中的垃圾回收：</h3><h4 id="堆分配期间会发生什么？"><a href="#堆分配期间会发生什么？" class="headerlink" title="堆分配期间会发生什么？"></a>堆分配期间会发生什么？</h4><p>堆分配比堆栈分配复杂得多。这是因为堆可用于存储长期和短期数据，以及许多不同类型和大小的数据。分配和解除分配并不总是以可预测的顺序发生，并且可能需要非常不同大小的存储器块。</p><p>创建堆变量时，将执行以下步骤：</p><ul><li>首先，Unity必须检查堆中是否有足够的可用内存。如果堆中有足够的可用内存，则分配变量的内存。</li><li>如果堆中没有足够的可用内存，Unity会尝试释放垃圾收集器，以释放未使用的堆内存。这可能是一个缓慢的操作。如果堆中现在有足够的可用内存，则会分配变量的内存。</li><li>如果垃圾回收后堆中没有足够的可用内存，Unity会增加堆中的内存量。这可能是一个缓慢的操作。然后分配变量的内存。</li></ul><p>堆分配可能很慢，特别是如果垃圾收集器必须运行并且必须扩展堆。</p><h4 id="垃圾收集期间会发生什么？"><a href="#垃圾收集期间会发生什么？" class="headerlink" title="垃圾收集期间会发生什么？"></a>垃圾收集期间会发生什么？</h4><p>当堆变量超出范围时，用于存储它的内存不会立即释放。只有在垃圾收集器运行时才会释放未使用的堆内存。</p><p>每次垃圾收集器运行时，都会发生以下步骤：</p><ul><li>垃圾收集器检查堆上的每个对象。</li><li>垃圾收集器搜索所有当前对象引用以确定堆上的对象是否仍在范围内。</li><li>任何不再在范围内的对象都被标记为删除。</li><li>将删除标记的对象，并将分配给它们的内存返回到堆中。</li></ul><p>垃圾收集可能是一项昂贵的操作。堆上的对象越多，它必须做的工作越多，代码中的对象引用越多，它必须做的工作就越多。</p><h4 id="垃圾收集什么时候发生？"><a href="#垃圾收集什么时候发生？" class="headerlink" title="垃圾收集什么时候发生？"></a>垃圾收集什么时候发生？</h4><p>有三件事可能导致垃圾收集器运行：</p><ul><li>无论何时请求堆分配都无法使用堆中的可用内存来执行垃圾收集器。</li><li>垃圾收集器会不时自动运行（尽管频率因平台而异）。</li><li>垃圾收集器可以强制手动运行。</li></ul><p>垃圾收集可能是一个频繁的操作。每当无法从可用堆内存中实现堆分配时，就会触发垃圾收集器，这意味着频繁的堆分配和解除分配会导致频繁的垃圾回收。</p><hr><p>参考：</p><ol><li><a href="https://docs.unity3d.com/Manual/BestPracticeUnderstandingPerformanceInUnity4-1.html" target="_blank" rel="noopener">Understanding the managed heap</a>（理解托管堆）</li><li><a href="https://docs.unity3d.com/Manual/UnderstandingAutomaticMemoryManagement.html" target="_blank" rel="noopener">Understanding Automatic Memory Management</a>(理解自动内存管理)</li><li><a href="https://unity3d.com/de/learn/tutorials/topics/performance-optimization/optimizing-garbage-collection-unity-games?playlist=44069" target="_blank" rel="noopener">Optimizing garbage collection in Unity games</a>(在Unity游戏中优化垃圾回收)</li><li><a href="https://en.wikipedia.org/wiki/Boehm_garbage_collector" target="_blank" rel="noopener">Boehm garbage collector</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Unity] 动画系统</title>
      <link href="/2019/03/25/Unity%E7%AC%94%E8%AE%B0/Unity-%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/"/>
      <url>/2019/03/25/Unity%E7%AC%94%E8%AE%B0/Unity-%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>Unity中的动画控制系统。</p><a id="more"></a><h2 id="动画系统"><a href="#动画系统" class="headerlink" title="动画系统"></a>动画系统</h2><p>Unity的动画系统支持引擎内编辑动画，也支持外部导入FBX动画。由于引擎内置的的动画编辑器没有骨骼动画的概念，所以只能编辑每一帧模型的Transform、整体的旋转、缩放和平移。</p><h3 id="模型："><a href="#模型：" class="headerlink" title="模型："></a>模型：</h3><p>Unity显示模型必须给游戏对象提供Mesh Filter和Mesh Renderer组件，前者表示模型需要用的Mesh文件，后者通过材质的贴图和Shader最终将这个模型渲染出来。</p><h4 id="Mesh-Filter："><a href="#Mesh-Filter：" class="headerlink" title="Mesh Filter："></a>Mesh Filter：</h4><h4 id="Mesh-Render："><a href="#Mesh-Render：" class="headerlink" title="Mesh Render："></a>Mesh Render：</h4><h4 id="Prefab："><a href="#Prefab：" class="headerlink" title="Prefab："></a>Prefab：</h4><h3 id="动画编辑器："><a href="#动画编辑器：" class="headerlink" title="动画编辑器："></a>动画编辑器：</h3><p>动画编辑器的原理就是通过时间线来修改组件的信息，比如修改Transform位置信息，修改Renderer组件或者修改颜色信息，控制模型显示隐藏；此外，还可以在时间线上添加动画事件，编辑后的动画需要配合Animator组件使用。</p><h3 id="导入类动画："><a href="#导入类动画：" class="headerlink" title="导入类动画："></a>导入类动画：</h3><h4 id="人形重定向动画："><a href="#人形重定向动画：" class="headerlink" title="人形重定向动画："></a>人形重定向动画：</h4><p>人形重定向动画就是多个身形不同的人物模型也可以共用一份骨骼动画，此技术应用在游戏中会大量减少内存和包体大小。<strong>重定向动画的原理就是将不同身形的骨骼信息套入相同的动画中来运算</strong>。</p><h4 id="通用动画："><a href="#通用动画：" class="headerlink" title="通用动画："></a>通用动画：</h4><h4 id="老版动画："><a href="#老版动画：" class="headerlink" title="老版动画："></a>老版动画：</h4><h4 id="导入类动画事件："><a href="#导入类动画事件：" class="headerlink" title="导入类动画事件："></a>导入类动画事件：</h4><h3 id="动画控制器："><a href="#动画控制器：" class="headerlink" title="动画控制器："></a>动画控制器：</h3><p>动画控制器的原理就是状态机：</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity Shader中的测试</title>
      <link href="/2019/03/18/Unity%E7%AC%94%E8%AE%B0/Unity-Shader%E4%B8%AD%E7%9A%84%E6%B5%8B%E8%AF%95/"/>
      <url>/2019/03/18/Unity%E7%AC%94%E8%AE%B0/Unity-Shader%E4%B8%AD%E7%9A%84%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>Unity Shader中的测试：Alpha测试、模版测试、深度测试。</p><a id="more"></a> <h3 id="Alpha测试："><a href="#Alpha测试：" class="headerlink" title="Alpha测试："></a>Alpha测试：</h3><p>Alpha Test和Alpha Blending是两种处理透明的方法。</p><h4 id="Alpha-Test："><a href="#Alpha-Test：" class="headerlink" title="Alpha Test："></a>Alpha Test：</h4><p>Alpha Test采用一种很霸道极端的机制，<strong>只要一个像素的alpha不满足条件，那么它就会被fragment shader舍弃。被舍弃的fragments不会对后面的各种Tests产生影响；否则，就会按正常方式写入到缓存中，并进行正常的深度检验等等，</strong>也就是说，Alpha Test是不需要关闭ZWrite的。Alpha Test产生的效果也很极端，要么完全透明，即看不到，要么完全不透明。</p><h4 id="Alpha-Blending："><a href="#Alpha-Blending：" class="headerlink" title="Alpha Blending："></a>Alpha Blending：</h4><p>而Alpha Blending则是一种中庸的方式，<strong>它使用当前fragment的alpha作为混合因子，来混合之前写入到缓存中颜色值。但Alpha Blending麻烦的一点就是它需要关闭ZWrite，并且要十分小心物体的渲染顺序。如果不关闭ZWrite，那么在进行深度检测的时候，它背后的物体本来是可以透过它被我们看到的，但由于深度检测时大于它的深度就被剔除了，从而我们就看不到它后面的物体了。</strong>因此，我们需要保证物体的渲染顺序是<strong>从后往前</strong>，并且<strong>关闭该半透明对象的ZWrite。</strong></p><p>注意：Alpha Blending只是关闭ZWrite，人家可没有关闭ZTest哦！这意味着，在<strong>输出一个Alpha Blending的fragment时，它还是会判断和当前Color Buffer中的fragment的深度关系，如果它比当前的fragment深度更远，那么它就不会再做后续的混合操作；否则，它就会和当前的fragment进行混合，但是不会把自己的深度信息写入Depth Buffer中。</strong>这是非常重要的，这一点决定了，即便一个不透明物体出现在一个透明物体的前面，不透明物体仍可以正常的遮挡住透明物体！也就是说，<strong>对于Alpha Blending来说，Depth Buffer是只读的。</strong></p><p><strong>尽可能使用Alpha Blending，而不要使用Alpha Test</strong>。</p><h3 id="模板测试："><a href="#模板测试：" class="headerlink" title="模板测试："></a>模板测试：</h3><p>模板测试stencil test是3d渲染管线中介于透明测试alpha test和深度测试depth test之间的测试，目的是根据条件来比较设置的参考值referenceValue和模板缓冲区stencil buff中对应的值stencilBuffValue的大小，如果条件满足就让片段fragment（候选的像素）进入下一测试，即深度测试，条件不满足就过滤掉片段，不把对应材质的片段输出到屏幕。</p><h3 id="深度测试："><a href="#深度测试：" class="headerlink" title="深度测试："></a>深度测试：</h3><ol><li><p>什么是<strong>深度</strong>？</p><p><strong>深度其实就是该像素点在3d世界中距离摄象机的距离</strong>，深度值Zbuffer（Z值）越大，则离摄像机越远。</p></li><li><p>什么是<strong>深度缓存</strong>？</p><p><strong>深度缓存中存储着每个像素点（绘制在屏幕上的）的深度值，如果启用了深度缓冲区，在绘制每个像素之前，OpenGL会把它的深度值和已经存储在这个像素的深度值进行比较。新像素深度值小于原先像素深度值，则新像素值会取代原先的；反之，新像素值被遮挡，其颜色值和深度将被丢弃，最终屏幕显示的就是深度缓存中深度对应的像素点的颜色！</strong>(深度主要起的是比较的作用)</p></li><li><p>什么是<strong>深度测试</strong>？</p><p><strong>在深度测试中，默认情况是将要绘制的新像素的z值与深度缓冲区中对应位置的z值进行比较，如果比深度缓存中的值小，那么用新像素的颜色值更新深度缓存中对应像素的颜色值。</strong></p></li><li><p>为什么需要深度？</p><p>在不使用深度测试的时候，如果我们先绘制一个距离较近的物体，再绘制距离较远的物体，则距离远的物体因为后绘制，会把距离近的物体覆盖掉，这样的效果并不是我们所希望的。而有了深度缓冲以后，绘制物体的顺序就不那么重要了，都能按照远近（Z值）正常显示，这很关键。(越后绘制的东西，距离相机就越近)</p></li></ol><h4 id="ZWrite："><a href="#ZWrite：" class="headerlink" title="ZWrite："></a>ZWrite：</h4><p>ZWrite可以取的值为：On/Off，默认值为On，代表<strong>是否要将像素的深度写入深度缓存中</strong>。</p><h4 id="ZTest："><a href="#ZTest：" class="headerlink" title="ZTest："></a>ZTest：</h4><p>ZTest可以取的值为：Greater/GEqual/Less/LEqual/Equal/NotEqual/Always/Never/Off，默认值为LEqual，<strong>代表如何将像素的颜色写入深度缓存中</strong>，例如当取默认值的情况下，如果将要绘制的新像素的z值小于等于深度缓存中的值，则将用新像素的颜色值更新深度缓存中对应像素的颜色值。<strong>需要注意的是，当ZTest取值为Off时，表示的是关闭深度测试，等价于取值为Always，而不是Never！Always指的是直接将当前像素颜色(不是深度)写进颜色缓冲区中；而Never指的是不要将当前像素颜色写进颜色缓冲区中，相当于消失。</strong></p><h4 id="Early-Z技术："><a href="#Early-Z技术：" class="headerlink" title="Early-Z技术："></a>Early-Z技术：</h4><p>传统的渲染管线中，<strong>ZTest其实是在Blending阶段，这时候进行深度测试，所有对象的像素着色器都会计算一遍，没有什么性能提升，仅仅是为了得出正确的遮挡结果，会造成大量的无用计算，因为每个像素点上肯定重叠了很多计算。</strong>因此现代GPU中运用了Early-Z的技术，<strong>在Vertex阶段和Fragment阶段之间（光栅化之后，fragment之前）进行一次深度测试，如果深度测试失败，就不必进行fragment阶段的计算了，因此在性能上会有很大的提升。但是最终的ZTest仍然需要进行，以保证最终的遮挡关系结果正确。</strong>前面的一次主要是Z-Cull为了裁剪以达到优化的目的，后一次主要是Z-Check。</p><p>Early-Z的实现，主要是通过一个Z-pre-pass实现，简单来说，<strong>对于所有不透明的物体（透明的没有用，本身不会写深度），首先用一个超级简单的shader进行渲染，这个shader不写颜色缓冲区，只写深度缓冲区，第二个pass关闭深度写入，开启深度测试，用正常的shader进行渲染。</strong>其实这种技术，我们也可以借鉴，在渲染透明物体时，因为关闭了深度写入，有时候会有其他不透明的部分遮挡住透明的部分，而我们其实不希望他们被遮挡，仅仅希望被遮挡的物体半透，这时我们就可以用两个pass来渲染，第一个pass使用Color Mask屏蔽颜色写入，仅写入深度，第二个pass正常渲染半透，关闭深度写入。</p><h4 id="Unity渲染顺序："><a href="#Unity渲染顺序：" class="headerlink" title="Unity渲染顺序："></a>Unity渲染顺序：</h4><p>如果我们先绘制后面的物体，再绘制前面的物体，就会造成over draw；而通过Early-Z技术，我们就可以先绘制较近的物体，再绘制较远的物体（仅限不透明物体），<strong>这样，通过先渲染前面的物体，让前面的物体先占坑，就可以让后面的物体深度测试失败，进而减少重复的fragment计算，达到优化的目的。</strong>Unity中默认应该就是按照最近距离的面进行绘制的。</p><hr><p>参考：</p><ol><li><a href="https://blog.csdn.net/candycat1992/article/details/41599167" target="_blank" rel="noopener">【Unity Shaders】Alpha Test和Alpha Blending</a></li><li><a href="http://www.unity.5helpyou.com/3090.html" target="_blank" rel="noopener">Unity Shader中的渲染队列、ZWrite和ZTest</a></li><li><a href="https://blog.csdn.net/puppet_master/article/details/53900568" target="_blank" rel="noopener">Unity Shader-渲染队列，ZTest，ZWrite，Early-Z</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> Shader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity Shader 使用噪声</title>
      <link href="/2019/03/10/Unity%E7%AC%94%E8%AE%B0/Unity-Shader-%E4%BD%BF%E7%94%A8%E5%99%AA%E5%A3%B0/"/>
      <url>/2019/03/10/Unity%E7%AC%94%E8%AE%B0/Unity-Shader-%E4%BD%BF%E7%94%A8%E5%99%AA%E5%A3%B0/</url>
      
        <content type="html"><![CDATA[<p>消融效果、水波效果、全局雾效。</p><a id="more"></a><h3 id="消融效果的实现："><a href="#消融效果的实现：" class="headerlink" title="消融效果的实现："></a>消融效果的实现：</h3><p>通过噪声纹理采样与设置好的消融属性相减，将算得结果小于0的像素剔除。对于剩下的像素进行正常的光照计算，然后在设定好的宽度范围内对两种溶解颜色进行插值，再将混合得到的颜色与环境光和漫反射光照混合输出。</p><p>后面还需要加一个用于处理阴影的Pass，否则已经消融的部分会投射影子。</p><p><img src="https://wx3.sinaimg.cn/mw690/007CSzD7ly1g0yn0oximmj313k0s6qso.jpg" alt></p><h4 id="定义属性："><a href="#定义属性：" class="headerlink" title="定义属性："></a>定义属性：</h4><p><img src="https://wx2.sinaimg.cn/mw690/007CSzD7ly1g0yn0ofirkj30yo0igdjv.jpg" alt="消融的属性"></p><h4 id="定义消融需要的Pass："><a href="#定义消融需要的Pass：" class="headerlink" title="定义消融需要的Pass："></a>定义消融需要的Pass：</h4><p>为了得到正确的光照，我们设置了Pass的LightMode和multi_compile_fwdbase的编译指令。</p><p>我们使用Cull off来关闭Shader的<strong>面片剔除</strong>，来使得其正面和背面都会被渲染。</p><p><img src="https://wx4.sinaimg.cn/mw690/007CSzD7ly1g0yn0o52rtj30ww0jy76n.jpg" alt="设置正确的光照模式与渲染队列"></p><h4 id="定义顶点着色器："><a href="#定义顶点着色器：" class="headerlink" title="定义顶点着色器："></a>定义顶点着色器：</h4><p><img src="https://wx4.sinaimg.cn/mw690/007CSzD7ly1g0yn0o8u6rj30x60r4dko.jpg" alt="定义顶点着色器"></p><h4 id="通过片元着色器实现模拟消融效果："><a href="#通过片元着色器实现模拟消融效果：" class="headerlink" title="通过片元着色器实现模拟消融效果："></a>通过片元着色器实现模拟消融效果：</h4><p><img src="https://wx4.sinaimg.cn/mw690/007CSzD7ly1g0yn0oqz2xj31100u0gv7.jpg" alt="实现片元着色器"></p><ul><li>首先对噪声纹理进行采样，并将结果和用于控制消融程度的属性相减，传递给clip函数，将结果小于0的像素剔除。</li><li>对于剩下的像素，进行正常的光照计算。我们根据漫反射纹理获得反射率albedo，并由此计算环境光照与漫反射光照。</li><li>计算烧焦颜色：在宽度为<code>_LineWidth</code>的范围内模拟一个烧焦的颜色变化，使用smoothstep来计算混合系数（当t为1时，表明该像素位于消融的边界处；当t为0时，表明该像素为正常的模型颜色），插值用来模拟一个烧焦效果：使用t来混合两种火焰颜色。同样使用step函数来保证剔除。</li></ul><h4 id="自定义投射阴影的Pass："><a href="#自定义投射阴影的Pass：" class="headerlink" title="自定义投射阴影的Pass："></a>自定义投射阴影的Pass：</h4><p><img src="https://wx4.sinaimg.cn/mw690/007CSzD7ly1g0yn0o0y8xj30lq0d4mya.jpg" alt="自定义投射阴影的Pass"></p><p><img src="https://wx3.sinaimg.cn/mw690/007CSzD7ly1g0yn0o4ipcj30t80n8acq.jpg" alt></p><p>同样使用clip函数来剔除片元，然后使用内置宏<code>SHADOW_CASTER_FRAGMENT()</code>来完成阴影投射，将结果输出到深度图和阴影映射纹理中。</p><h3 id="水波效果："><a href="#水波效果：" class="headerlink" title="水波效果："></a>水波效果：</h3><h3 id="全局雾效："><a href="#全局雾效：" class="headerlink" title="全局雾效："></a>全局雾效：</h3><h3 id="生成噪声："><a href="#生成噪声：" class="headerlink" title="生成噪声："></a>生成噪声：</h3><p><strong>噪声是怎么生成的</strong>：<a href="https://blog.csdn.net/candycat1992/article/details/50346469" target="_blank" rel="noopener">https://blog.csdn.net/candycat1992/article/details/50346469</a></p><ul><li><p>基于晶格的方法（Lattice based）</p></li><li><p>基于点的方法（Point based）</p></li><li><p>Perlin噪声：</p><p>Perlin噪声还是比较简单的，Perlin噪声的实现需要三个步骤：</p><ol><li>定义一个晶格结构，每个晶格的顶点有一个“伪随机”的梯度向量（其实就是个向量啦）。对于二维的Perlin噪声来说，晶格结构就是一个平面网格，三维的就是一个立方体网格。</li><li>输入一个点（二维的话就是二维坐标，三维就是三维坐标，n维的就是n个坐标），我们找到和它相邻的那些晶格顶点（二维下有4个，三维下有8个，n维下有2n2n个），计算该点到各个晶格顶点的距离向量，再分别与顶点上的梯度向量做点乘，得到2n2n个点乘结果。</li><li>使用缓和曲线（ease curves）来计算它们的权重和。在原始的Perlin噪声实现中，缓和曲线是s(t)=3t2−2t3s(t)=3t2−2t3。</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> Shader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity Shader 高级纹理</title>
      <link href="/2019/03/06/Unity%E7%AC%94%E8%AE%B0/Unity-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/"/>
      <url>/2019/03/06/Unity%E7%AC%94%E8%AE%B0/Unity-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>立方体纹理实现环境映射，渲染纹理以及程序纹理。</p><a id="more"></a><h3 id="立方体纹理："><a href="#立方体纹理：" class="headerlink" title="立方体纹理："></a>立方体纹理：</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>立方体纹理是环境映射的一种实现方式。环境映射可以模拟物体周围的环境，使用了环境映射的物体可以看起来像是镀了金属一样反射出周围的环境。</p><h4 id="采样方式"><a href="#采样方式" class="headerlink" title="采样方式"></a>采样方式</h4><p>正方体纹理一共包含了6张图像，这些图像对应了一个立方体的6个面。立方体的每个面表示沿着世界空间下的轴向观察所得来的图像。<strong>对立方体纹理采样需要我们提供一个三维的纹理坐标，这个三维纹理坐标表示了我们在世界空间下的一个3D方向。这个方向矢量从立方体的中心出发，当它向外部延伸时就会和立方体的6个纹理之一发生相交，而采样得到的结果就是由该交点计算而来的。</strong></p><h4 id="优点与缺点："><a href="#优点与缺点：" class="headerlink" title="优点与缺点："></a>优点与缺点：</h4><ul><li>优点：实现简单快速，得到的效果比较好。</li><li>缺点：<ul><li>当场景中引入了新的物体、光源，或者物体发生移动时，我们就需要重新生成立方体纹理。</li><li>立方体纹理只能反射环境，不能反射使用了该立方体纹理的物体本身。它不能模拟多次反射的结果，故应尽量对凸面体而不是凹面体使用立方体纹理。</li></ul></li></ul><h4 id="天空盒子（Skybox）："><a href="#天空盒子（Skybox）：" class="headerlink" title="天空盒子（Skybox）："></a>天空盒子（Skybox）：</h4><p>天空盒子是在所有不透明物体之后渲染的，而其背后使用的网格是一个立方体或一个细分后的球体。</p><h4 id="创建用于环境映射的立方体纹理："><a href="#创建用于环境映射的立方体纹理：" class="headerlink" title="创建用于环境映射的立方体纹理："></a>创建用于环境映射的立方体纹理：</h4><ol><li>直接由一些特殊布局的纹理创建：需要一张具有特殊布局的纹理，然后将其Texture Type设置成Cubemap即可。</li><li>手动创建一个Cubemap资源：创建一个Cubemap，将六张纹理拖拽到它的面板中。</li><li>由脚本生成：使用Camera.RenderToCubemap函数实现——从任意位置观察到的场景图像存储到6张图像中，从而创建出该位置上对应的正方体纹理。</li></ol><h4 id="反射效果："><a href="#反射效果：" class="headerlink" title="反射效果："></a>反射效果：</h4><blockquote><p>通过入射光线的方向和表面法线方向来计算反射方向，再利用反射方向对立方体纹理采样。</p></blockquote><ol><li><p>首先，声明需要用到的属性：</p><p> <img src="http://wx1.sinaimg.cn/large/007CSzD7ly1g0t8sl0d3wj30xy0ds40t.jpg" alt></p></li><li><p>在顶点着色器中计算该顶点处的反射方向，根据CG的<a href="https://developer.download.nvidia.cn/cg/reflect.html" target="_blank" rel="noopener">reflect</a>函数来实现：</p><p>物体反射到摄像机中的光线方向，可以由光路可逆的原则来反向求得。可以计算视角方向关于顶点法线的反射方向来求得入射光线的方向。</p><p><img src="http://wx2.sinaimg.cn/large/007CSzD7ly1g0t8slp4plj30wo0k8tbp.jpg" alt></p><p>(TRANSFER_SHADOW参见以前的博客：（此处应有链接）)</p></li><li><p>在片元着色器中，利用反射方向来对立方体纹理采样：</p><ul><li><p>对立方体纹理的采样需要使用CG的<a href="https://developer.download.nvidia.cn/cg/texCUBE.html" target="_blank" rel="noopener">texCUBE</a>函数，用于采样的参数仅仅是作为方向变量传递给texCUBE函数的，没有必要进行归一化。</p></li><li><p>然后使用<strong>_ReflectAmount</strong>来混合<strong>漫反射颜色</strong>和<strong>反射颜色</strong>，并和<strong>环境光</strong>照相加后返回。</p></li><li>可以在片元着色器中计算反射方向，这样效果更好，但是差别不大；处于性能考虑，我们选择在顶点着色器中计算反射方向。</li></ul><p><img src="http://wx2.sinaimg.cn/large/007CSzD7ly1g0t8slq83rj31dq0najwk.jpg" alt></p></li><li><p>效果：</p><p><img src="http://wx2.sinaimg.cn/large/007CSzD7ly1g0t8sp2vrmj311g0ngnpd.jpg" alt></p></li></ol><h4 id="折射效果："><a href="#折射效果：" class="headerlink" title="折射效果："></a>折射效果：</h4><blockquote><p>当光线从一种介质斜射入另一种介质时，传播方向一般会发生改变。当给定入射角时，可以使用斯涅尔定律来计算反射角。</p><p>​                                    $n_1sinθ_1 = n_2sinθ_2$</p><p>其中，n1和n2分别是两个介质的折射率。</p><p>一般对一个透明物体，准确的模拟需要计算两次折射——一次入射与一次出射。但是这样模拟很复杂，所以初学在此仅模拟一次折射。</p></blockquote><ol><li><p>声明属性：</p><p><img src="http://wx2.sinaimg.cn/large/007CSzD7ly1g0t8skzstpj30wc0dg415.jpg" alt></p></li><li><p>使用CG的<a href="https://developer.download.nvidia.cn/cg/reflect.html" target="_blank" rel="noopener">refract</a>函数来计算折射方向。</p><p>第一个参数是入射光线的方向，必须是归一化后的矢量；第二个参数是表面法线，法线方向同样需要是归一化的；第三个参数是入射光线所在介质的折射率与折射光线所在介质的折射率之间的比值。返回计算而得的折射方向，它的模则等于入射光线的模。</p><p><img src="http://wx3.sinaimg.cn/large/007CSzD7ly1g0t8sl2tlfj31eo0j2why.jpg" alt></p></li><li><p>在片元着色器中使用折射方向对立方体纹理进行采样：</p><p><img src="http://wx1.sinaimg.cn/large/007CSzD7ly1g0t8sl7aofj31e00osafb.jpg" alt></p></li><li><p>最后使用_RefractAmount来混合漫反射和折射颜色，并和环境光照相加后返回。</p></li><li><p>效果：</p><p><img src="http://wx1.sinaimg.cn/large/007CSzD7ly1g0t8soqgjlj31140nekjl.jpg" alt></p></li></ol><h4 id="菲涅尔反射："><a href="#菲涅尔反射：" class="headerlink" title="菲涅尔反射："></a>菲涅尔反射：</h4><blockquote><p>当光线照射到物体表面上时，一部分发生反射，一部分进入物体内部，发生折射或散射。被反射的光和入射光之间存在一定的比率关系，这个比例关系可以通过菲涅尔等式进行计算。</p></blockquote><ol><li><p>菲涅尔等式：</p><ul><li><strong>Schlick菲涅尔近似等式</strong>：</li></ul><p>​                $F_{Schlick}(v,n) = F_0 + (1 - F_0)(1 - v·n)^5$</p><p>​    $F_0$是反射系数，用于控制菲涅尔反射的强度，v是视角方向，n是表面法线。</p><ul><li><p><strong>Empricial菲涅尔近似等式</strong>：</p><p>​            $F_{Empricial}(v,n) = max(0, min(1,bias + scale * (1 - v·n)^{power})$</p><p>Bias、scale和power是控制项。</p></li></ul></li><li><p>定义属性：_FresnelScale属性用于调整菲涅尔反射</p><p><img src="http://wx1.sinaimg.cn/large/007CSzD7ly1g0tc4wsuy7j30uq0703zr.jpg" alt></p></li><li><p>在顶点着色器中计算世界空间下的法线方向、视角方向和反射方向：</p><p><img src="http://wx4.sinaimg.cn/large/007CSzD7ly1g0tc4x14fbj30w60ggdip.jpg" alt></p></li><li><p>在片元着色器中计算菲涅尔反射，并使用结果值混合漫反射光照和反射光照：</p><p><img src="http://wx3.sinaimg.cn/large/007CSzD7ly1g0tc4wwnuyj31hs0pmjxc.jpg" alt></p></li><li><p>效果：</p><p>当_FresnelScale为1时：</p><p><img src="http://wx1.sinaimg.cn/large/007CSzD7ly1g0tbxvzex5j31kj0u0hdt.jpg" alt></p><p>为0.5时：</p><p><img src="http://wx3.sinaimg.cn/large/007CSzD7ly1g0tbxy03h1j31kj0u04qp.jpg" alt></p><p>为0时：</p><p><img src="http://wx4.sinaimg.cn/large/007CSzD7ly1g0tbxxuq17j31kb0u04qp.jpg" alt></p></li></ol><h3 id="渲染纹理："><a href="#渲染纹理：" class="headerlink" title="渲染纹理："></a>渲染纹理：</h3><h4 id="镜子效果的实现："><a href="#镜子效果的实现：" class="headerlink" title="镜子效果的实现："></a>镜子效果的实现：</h4><h4 id="玻璃效果的实现："><a href="#玻璃效果的实现：" class="headerlink" title="玻璃效果的实现："></a>玻璃效果的实现：</h4><p>我们可以<strong>使用GrabPass来完成获取屏幕图像的目的。</strong>在Shader中定义了一个GrabPass后，Unity会把当前屏幕的图像绘制在一张纹理中，以便在后续的Pass中访问。与简单的透明混合不同，使用GrabPass可以让我们对物体后面的图像进行更复杂的处理，例如使用法线来模拟折射效果，而不是简单的与原屏幕颜色进行混合。</p><p>使用GrabPass时，要小心物体的渲染队列设置，往往需要把物体的渲染队列设置成透明队列（“Queue ” = “Transparent”），来保证当渲染该物体的时候，所有的不透明物体已经被绘制在屏幕上，获得正确的屏幕图像。</p><ol><li><p>整体思路：</p><p>首先使用一张<strong>法线纹理</strong>来修改模型的法线信息，然后使用<strong>反射</strong>方法，<strong>通过一个Cubemap来模拟玻璃的反射</strong>，而在模拟折射时，<strong>使用了GrabPass获取玻璃后面的屏幕图像</strong>，并<strong>使用切线空间下的法线对屏幕纹理坐标偏移</strong>后，再<strong>对屏幕图像进行采样</strong>来模拟近似的折射效果。</p></li><li><p>声明属性：</p><p><img src="http://wx2.sinaimg.cn/large/007CSzD7ly1g0u3epqe2pj30ww0gctc4.jpg" alt></p></li><li><p>定义相应的渲染队列</p><p><img src="http://wx2.sinaimg.cn/large/007CSzD7ly1g0u3epclb3j30wy07u0ub.jpg" alt></p></li><li><p>定义变量：</p><p><img src="http://wx4.sinaimg.cn/large/007CSzD7ly1g0u3epcdbzj30jy0eiwgd.jpg" alt></p></li><li><p>定义顶点着色器阶段：</p><p><img src="http://wx1.sinaimg.cn/large/007CSzD7ly1g0u3epwq01j316y0r2wkk.jpg" alt></p><ul><li>先进行必要的顶点坐标变换。</li><li>调用内置的ComputeGrabScreenPos函数来得到对应被抓取的屏幕图像的采样坐标。</li><li>计算<code>_MainTex</code>和<code>_BumpMap</code>的采样坐标，并存储在一个float4类型变量中。</li><li>接着计算<strong>顶点对应的从切线空间到世界空间的变换矩阵</strong>，并把该矩阵的每一行分别存储在三个TtoWx的xyz分量中。这样做是为了在片元着色器中把法线方向从切线空间转换到世界空间下，以便对CubeMap进行采样。</li><li>计算得到的分量被按列组成一个变换矩阵，w轴被用来存储世界空间下的顶点坐标。</li></ul></li><li><p>定义片元着色器：</p><p><img src="http://wx2.sinaimg.cn/large/007CSzD7ly1g0u3eq1kppj31fi0sawle.jpg" alt></p><ul><li>通过世界坐标得到该片元对应的视角方向。</li><li>对法线纹理进行采样，得到切线空间下的法线方向。</li><li>使用切线空间下的法线方向进行偏移（因为<strong>该空间下的法线可以反映顶点局部空间下的法线方向</strong>）</li><li>随后<strong>对scrPos透视除法得到真正的屏幕坐标</strong>，再使用该坐标<strong>对抓取的屏幕图像</strong><code>_RefractionTex</code><strong>进行采样</strong>，得到模拟的折射颜色。</li><li>下一步把法线方向从切线空间变换到了世界空间下，并据此得到视角方向相对于法线方向的反射方向。</li><li>使用反射方向对Cubemap进行采样，并把结果和主纹理颜色相乘后得到反射颜色。</li><li>最后使用<code>_RefractAmount</code>属性对反射和折射颜色进行混合，作为最终的输出颜色。</li></ul></li><li><p>效果：</p><p><img src="http://wx3.sinaimg.cn/large/007CSzD7ly1g0u3etapk7j31ji0u04qq.jpg" alt></p></li></ol><ul><li>为什么要在Pass中使用一个字符串指明被抓取的屏幕图像存储名称？<ul><li>直接使用GrabPass{}性能消耗较大，因为这样对于每个使用它的物体，Unity会为它单独进行一次昂贵的屏幕抓取工作。不过这样可以使不同的物体得到不同的屏幕图像。</li><li>指明字符串后，可以在后续的Pass中通过名称来访问屏幕图像。这样效果更高效，但是所有物体都会使用同一张屏幕图像。</li></ul></li></ul><h3 id="程序纹理："><a href="#程序纹理：" class="headerlink" title="程序纹理："></a>程序纹理：</h3><p>可以使用程序纹理来创建程序材质。</p><h4 id="波点纹理实例："><a href="#波点纹理实例：" class="headerlink" title="波点纹理实例："></a>波点纹理实例：</h4>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> Shader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[翻译] StateMachine</title>
      <link href="/2018/12/17/%E7%BF%BB%E8%AF%91/%E7%BF%BB%E8%AF%91-StateMachine/"/>
      <url>/2018/12/17/%E7%BF%BB%E8%AF%91/%E7%BF%BB%E8%AF%91-StateMachine/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>游戏中的状态机，分层状态机以及伪代码实现。</p><a id="more"></a><h2 id="Chapter-5-Decision-Making"><a href="#Chapter-5-Decision-Making" class="headerlink" title="Chapter 5 Decision Making"></a>Chapter 5 Decision Making</h2><h3 id="5-3-STATE-MACHINES：状态机"><a href="#5-3-STATE-MACHINES：状态机" class="headerlink" title="5.3 STATE MACHINES：状态机"></a>5.3 STATE MACHINES：状态机</h3><p>Often, characters in a game will act in one of a limited set of ways. They will carry on doing the same thing until some event or influence makes them change. A covenant warrior in Halo [Bungie Software, 2001], for example, will stand at its post until it notices the player, then it will switch into attack mode, taking cover and firing. </p><p>通常来说，游戏中的角色所进行的行为将会从有限的行为集合中选取。它们将会保持这个状态，直到一些事件或者影响使得它们改变。以 <em>光环：战斗进化</em> 为例，敌人将会一直驻守直到它们注意到玩家，此时将会转换到攻击状态，寻求掩体以及开火。</p><p>We can support this kind of behavior using decision trees, and we’ve gone some way to doing that using random decisions. In most cases, however, it is easier to use a technique designed for this purpose: state machines. </p><p>我们可以通过决策树来实现这种行为，并且我们已经采用某种方式使用随机决策来做到这一点。然而，在大多数情况下，对于这个目标，我们可以采用更为容易的技术设计：状态机。</p><p>State machines are the technique most often used for this kind of decision making and, along with scripting (see Section 5.9), make up the vast majority of decision making systems used in current games. </p><p>状态机是一种经常用于这类决策的技术，它与脚本一起使用（参见第5.9节），构成当前游戏中使用的绝大多数（vast majority）决策系统。</p><p>State machines take account of both the world around them (like decision trees) and their internal makeup (their state). </p><p>状态机既与它周围的世界相关（类似于决策树）又与其内部组成相关（它们自身的状态）。</p><h5 id="A-Basic-State-Machine-：一个基本状态机"><a href="#A-Basic-State-Machine-：一个基本状态机" class="headerlink" title="A Basic State Machine ：一个基本状态机"></a>A Basic State Machine ：一个基本状态机</h5><p>In a state machine each character occupies one state. Normally, actions or behaviors are associated with each state. So as long as the character remains in that state, it will continue carrying out the same action. </p><p>在状态机中，每个角色占据一个状态。通常，动作或行为与每个状态相关联。因此，只要角色保持在该状态，它将继续执行相同的动作。</p><p>States are connected together by transitions. Each transition leads from one state to another, the target state, and each has a set of associated conditions. If the game determines that the conditions of a transition are met, then the character changes state to the transition’s target state. When a transition’s conditions are met, it is said to trigger, and when the transition is followed to a new state, it has fired. </p><p>每个状态通过状态转换联系在一起。每个转换从一个状态引导到另一个状态，即目标状态，并且每个转换具有一组相关条件。如果游戏确定满足转换的条件，则角色将状态改变为要转换的目标状态。当满足转换条件时，它会被触发，当转换到新状态时，它就会被触发。</p><p>Figure 5.13 shows a simple state machine with three states: On Guard, Fight, and Run Away. Notice that each state has its own set of transitions. </p><p>图5.13显示了一个具有三种状态的简单状态机：On Guard，Fight和Run Away。请注意，每个状态都有自己的一组转换。</p><p>The state machine diagrams in this chapter are based on the UML state chart di- agram format, a standard notation used throughout software engineering. States are shown as curved corner boxes. Transitions are arrowed lines, labelled by the condition that triggers them. Conditions are contained in square brackets. </p><p>本章中的状态机图表基于UML状态图表格式，这是整个软件工程中使用的标准符号。状态显示为弯角框。过渡是箭头线，由触发它们的条件标记。条件包含在方括号中。</p><p>The solid circle in Figure 5.13 has only one transition without a trigger condition. The transition points to the initial state that will be entered when the state machine is first run. </p><p>图5.13中的实心圆只有一个没有触发条件的转换。转换指向首次运行状态机时将进入的初始状态。</p><p><img src="/Users/zhangmo/Library/Application Support/typora-user-images/image-20181122004651145.png" alt="image-20181122004651145"></p><p>You won’t need an in-depth understanding of UML to understand this chapter. If you want to find out more about UML, I’d recommend Pilone [2005]. </p><p>您不需要深入了解UML来理解本章。如果你想了解更多关于UML的信息，我推荐<em>Pilone [2005]</em>。</p><p>In a decision tree the same set of decisions is always used, and any action can be reached through the tree. In a state machine only transitions from the current state are considered, so not every action can be reached. </p><p>在决策树中，始终使用相同的决策集，并且可以通过树到达任何操作。在状态机中，仅考虑从当前状态的转换，因此不是每个动作都可以到达。</p><h5 id="Finite-State-Machines-：有限状态机"><a href="#Finite-State-Machines-：有限状态机" class="headerlink" title="Finite State Machines ：有限状态机"></a>Finite State Machines ：有限状态机</h5><p>In game AI any state machine with this kind of structure is usually called a finite state machine (FSM). This and the following sections will cover a range of increasingly powerful state machine implementations, all of which are often referred to as FSMs. </p><p>在游戏AI中，具有这种结构的任何状态机通常称为有限状态机（FSM）。本节和以下部分将介绍一系列日益强大的状态机实现，所有这些实现通常都称为FSM。</p><p>This causes confusion with non-games programmers, for whom the term FSM is more commonly used for a particular type of simple state machine. An FSM in computer science normally refers to an algorithm used for parsing text. Compilers use an FSM to tokenize the input code into symbols that can be interpreted by the compiler. </p><p>这导致与非游戏程序员的混淆，对于他们来说，术语FSM更常用于特定类型的简单状态机。计算机科学中的FSM通常是指用于解析文本的算法。编译器使用FSM将输入代码标记为可由编译器解释的符号。</p><h5 id="The-Game-FSM-：游戏中的有限状态机"><a href="#The-Game-FSM-：游戏中的有限状态机" class="headerlink" title="The Game FSM ：游戏中的有限状态机"></a>The Game FSM ：游戏中的有限状态机</h5><p>The basic state machine structure is very general and admits any number of imple- mentations. I have seen tens of different ways to implement a game FSM, and it is rare to find any two developers using exactly the same technique. That makes it difficult to put forward a single algorithm as being the “state machine” algorithm. </p><p>基本状态机结构非常通用，允许任意数量的实现。我已经看到了几种不同的方法来实现游戏FSM，并且很少发现任何两个开发人员使用完全相同的技术。这使得将单个算法提出为“状态机”算法变得困难。</p><p>Later in this section, I’ll look at a range of different implementation styles for the FSM, but the main algorithm I work through is just one. I chose it for its flexibility and the cleanness of its implementation. </p><p>在本节的后面部分，我将介绍FSM的一系列不同的实现样式，但我使用的主要算法只有一个。我之所以选择它是因为它的灵活性和实现的优雅性。</p><h4 id="5-3-1-THE-PROBLEM-：问题"><a href="#5-3-1-THE-PROBLEM-：问题" class="headerlink" title="5.3.1 THE PROBLEM ：问题"></a>5.3.1 THE PROBLEM ：问题</h4><p>We would like a general system that supports arbitrary state machines with any kind of transition condition. The state machine will conform to the structure given above and will occupy only one state at a time. </p><p>我们想要一个支持具有任何转换条件的任意状态机的通用系统。这个状态机将符合上面给出的结构，并且一次只占用一个状态。</p><h4 id="5-3-2-THE-ALGORITHM-：算法"><a href="#5-3-2-THE-ALGORITHM-：算法" class="headerlink" title="5.3.2 THE ALGORITHM ：算法"></a>5.3.2 THE ALGORITHM ：算法</h4><p>We will use a generic state interface which can be implemented to include any spe- cific code. The state machine keeps track of the set of possible states and records the current state it is in. Alongside each state, a series of transitions are maintained. Each transition is again a generic interface that can be implemented with the appropriate conditions. It simply reports to the state machine whether it is triggered or not. </p><p>我们将使用通用状态接口，可以实现包含任何特定代码。 状态机跟踪可能状态的集合并记录它所处的当前状态。在每个状态下，保持一系列转换。 每次转换都是一个通用接口，可以使用适当的条件实现。 它只是向状态机报告它是否被触发。</p><p>At each iteration (normally each frame), the state machine’s update function is called. This checks to see if any transition from the current state is triggered. The first transition that is triggered is scheduled to fire. The method then compiles a list of actions to perform from the currently active state. If a transition has been triggered, then the transition is fired. </p><p>在每次迭代（通常是每个帧），调用状态机的更新函数。 这将检查是否触发了当前状态的任何转换。 触发的第一个转换将会被执行。 然后，该方法维护一个要从当前活动状态执行的动作列表(actions)。 如果已触发某个转换，则会执行这个转换。</p><p>This separation of the triggering and firing of transitions allows the transitions to also have their own actions. Often, transitioning from one state to another also involves carrying out some action. In this case a fired transition can add the action it needs to those returned by the state. </p><p>这种转换的触发和触发的分离允许转换也具有它们自己的动作。 通常，从一个状态转换到另一个状态也涉及执行某些行动。 //在这种情况下，触发转换可以将所需的操作添加到状态返回的操作。</p><h4 id="5-3-3-PSEUDO-CODE-：伪代码实现"><a href="#5-3-3-PSEUDO-CODE-：伪代码实现" class="headerlink" title="5.3.3 PSEUDO-CODE ：伪代码实现"></a>5.3.3 PSEUDO-CODE ：伪代码实现</h4><p>The state machine holds a list of states, with an indication of which one is the current state. It has an update function for triggering and firing transitions and a function that returns a set of actions to carry out.</p><p>状态机保存状态列表，指示哪一个是当前状态。 //它具有用于执行和触发转换的更新功能以及返回要执行的一组操作的功能。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">machine</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 维护一个状态机的状态列表</span></span><br><span class="line">    <span class="built_in">list</span>&lt;State&gt; states;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始状态</span></span><br><span class="line">    State initialState；</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前状态</span></span><br><span class="line">    currentState = initialState;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查并执行转换，同时返回一个动作列表</span></span><br><span class="line">    Update()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 假定没有转换被触发</span></span><br><span class="line">        triggeredTransition = None;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历所有状态并保存第一个被触发的状态</span></span><br><span class="line">        <span class="keyword">for</span> transition in currentState.getTransitions()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> transition.isTriggered():</span><br><span class="line">triggeredTransition = transition;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查是否有状态被触发？</span></span><br><span class="line">        <span class="keyword">if</span> triggeredTransition</span><br><span class="line">        &#123;</span><br><span class="line">targetState = triggeredTransition.getTargetState();</span><br><span class="line">            </span><br><span class="line"><span class="comment">// 在行为列表之中增加旧状态的退出操作、状态转移的操作以及新状态的入口操作</span></span><br><span class="line">actions = currentState.getExitAction()</span><br><span class="line">actions += triggeredTransition.getAction()</span><br><span class="line">actions += targetState.getEntryAction()</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 完成状态转移并返回行为列表</span></span><br><span class="line">            currentState = targetState</span><br><span class="line"><span class="keyword">return</span> actions</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则直接返回当前状态的行为列表</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> currentState.getAction()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-3-4-DATA-STRUCTURES-AND-INTERFACES-：数据结构与接口"><a href="#5-3-4-DATA-STRUCTURES-AND-INTERFACES-：数据结构与接口" class="headerlink" title="5.3.4 DATA STRUCTURES AND INTERFACES ：数据结构与接口"></a>5.3.4 DATA STRUCTURES AND INTERFACES ：数据结构与接口</h4><p>The state machine relies on having states and transitions with a particular interface.<br>The state interface has the following form:</p><p>状态机依赖于具有特定接口的状态和转换。<br>状态接口具有以下形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">State</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function">def <span class="title">getAction</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">def <span class="title">getEntryAction</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">def <span class="title">getExitAction</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">def <span class="title">getTransitions</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Each of the getAction methods should return a list of actions to carry out. As we will see below, the getEntryAction is only called when the state is entered from a transition, and the getExitAction is only called when the state is exited. The rest of the time that the state is active, getAction is called. The getTransitions method should return a list of transitions that are outgoing from this state. </p><p>The transition interface has the following form: </p><p>每个getAction方法都应返回要执行的操作列表。 正如我们将在下面看到的，只有在从转换进入状态时才调用getEntryAction，并且仅在退出状态时调用getExitAction。 其余时间状态为活动状态，调用getAction。 getTransitions方法应返回从此状态传出的转换列表。</p><p>转换接口具有以下形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transition</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="function">def <span class="title">isTriggered</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">def <span class="title">getTargetState</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">def <span class="title">getAction</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The isTriggered method returns true if the transition can fire; the getTarget-State method reports which state to transition to; and the getAction method returns a list of actions to carry out when the transition fires.</p><p>如果转换可以触发，则isTriggered方法返回true; getTarget-State方法报告要转换到的状态; 并且getAction方法返回转换触发时要执行的操作列表。</p><h5 id="Transition-Implementation-：实现转换"><a href="#Transition-Implementation-：实现转换" class="headerlink" title="Transition Implementation ：实现转换"></a>Transition Implementation ：实现转换</h5><p>Only one implementation of the state class should be required: it can simply hold the three lists of actions and the list of transitions as data members, returning them in the corresponding get methods. </p><p>只需要一个状态类的实现：它可以简单地将三个动作列表和转换列表保存为数据成员，并在相应的get方法中返回它们。</p><p>In the same way, we can store the target state and a list of actions in the transition class and have its methods return the stored values. The isTriggered method is more difficult to generalize. Each transition will have its own set of conditions, and much of the power in this method is allowing the transition to implement any kind of tests it likes. </p><p>以同样的方式，我们可以在转换类中存储目标状态和操作列表，并使其方法返回存储的值。 isTriggered方法更难以概括。 每个转换都有自己的一组条件，这种方法的大部分功能是允许转换实现它喜欢的任何类型的条件测试。</p><p>Because state machines are often defined in a data file and read into the game at run time, it is a common requirement to have a set of generic transitions. The state machine can then be set up from the data file by using the appropriate transitions for each state. </p><p>由于状态机通常在数据文件中定义并在运行时读入游戏，因此通常需要具有一组通用转换。 然后，可以通过使用每个状态的适当转换从数据文件中设置状态机。</p><p>In the previous section on decision trees, we saw generic testing decisions that operated on basic data types. The same principle can be used with state machine transitions: we have generic transitions that trigger when data they are looking at is in a given range. </p><p>在上一节关于决策树的部分中，我们看到了对基本数据类型进行操作的通用测试决策。 相同的原理可以与状态机转换一起使用：我们具有通用转换，当它们正在查看的数据处于给定范围内时触发。</p><p>Unlike decision trees, state machines don’t provide a simple way of combining these tests together to make more complex queries. If we need to transition based on the condition that the enemy is far away AND health is low, then we need some way of combining triggers together. </p><p>与决策树不同，状态机不提供将这些测试组合在一起以进行更复杂查询的简单方法。// 如果我们需要根据敌人在远处且健康状况低的条件进行过渡，那么我们需要一些将触发器组合在一起的方法。</p><p>In keeping with our polymorphic design for the state machine, we can accom- plish this with the addition of another interface: the condition interface. We can use a general transition class of the following form:</p><p> 为了与状态机的多态设计保持一致，我们可以通过添加另一个接口来实现这一点：条件接口。 我们可以使用以下形式的一般转换类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transition</span></span></span><br><span class="line"><span class="class">&#123;</span><span class="comment">// 条件接口类</span></span><br><span class="line">actions</span><br><span class="line">  def getAction(): return actions</span><br><span class="line">  </span><br><span class="line">  targetState</span><br><span class="line">  def getTargetState(): return targetState</span><br><span class="line">  </span><br><span class="line">  condition</span><br><span class="line">  def isTriggered(): return condition.test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The isTriggered function now delegates the testing to its condition member.<br>Conditions have the following simple format:</p><p>isTriggered函数现在将测试委托给其条件成员。<br>条件具有以下简单格式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Condition</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="function">def <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We can then make a set of sub-classes of condition for particular tests, just like we did for decision trees:</p><p>然后，我们可以为特定测试创建一组条件子类，就像我们为决策树所做的那样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">class <span class="title">FloatCondition</span> <span class="params">(Condition)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">// 数值条件</span></span><br><span class="line">minValue;</span><br><span class="line">maxValue;</span><br><span class="line">  testValue; <span class="comment">// 我们想关注的游戏数据</span></span><br><span class="line"><span class="function">def <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> minValue &lt;= testValue &lt;= maxValue</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We can combine conditions together using Boolean sub-classes, such as AND, NOT, and OR:</p><p>我们可以使用布尔子类将条件组合在一起，例如AND，NOT和OR：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">class <span class="title">AndCondition</span> <span class="params">(Condition)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">// 布尔条件</span></span><br><span class="line">conditionA</span><br><span class="line">conditionB</span><br><span class="line"><span class="function">def <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> conditionA.test() <span class="keyword">and</span> conditionB.test();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">class <span class="title">NotCondition</span> <span class="params">(Condition)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">condition</span><br><span class="line"><span class="function">def <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">not</span> condition.test();</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">class <span class="title">OrCondition</span> <span class="params">(Condition)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">conditionA</span><br><span class="line">conditionB</span><br><span class="line"><span class="function">def <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> conditionA.test() <span class="keyword">or</span> conditionB.test() </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>and so on, for any level of sophistication we need.</p><p>等等……，支持我们需要的任何复杂程度。</p><h5 id="Weaknesses-：缺点"><a href="#Weaknesses-：缺点" class="headerlink" title="Weaknesses ：缺点"></a>Weaknesses ：缺点</h5><p>This approach to transitions gives a lot of flexibility, but at the price of lots of method calls. In C++ these method calls have to be polymorphic, which can slow down the call and confuse the processor. All this adds time, which may make it unsuitable for use in every frame on lots of characters. </p><p>这种转换方法提供了很大的灵活性，但代价是大量的方法调用。 在C ++中，这些方法调用必须是多态的，这会降低调用速度并使处理器混淆。 所有这些都增加了时间，这可能使其不适合在许多角色的每个帧中使用。</p><p>Several developers I have come across use a homegrown scripting language to ex- press conditions for transitions. This still allows designers to create the state machine rules, but can be slightly more efficient. In practice, however, the speed up over this approach is quite small, unless the scripting language includes some kind of compila- tion into machine code (i.e., Just In Time Compiling). For all but the simplest code, interpreting a script is at least as time-consuming as calling polymorphic functions. </p><p>我遇到的几个开发人员使用自己开发的脚本语言来表达转换条件。 这仍然允许设计人员创建状态机规则，但可以稍微提高效率。 然而，在实践中，除非脚本语言包括对机器代码的某种编译（即，及时编译），否则这种方法的速度非常快。 对于除最简单代码之外的所有代码，解释脚本至少与调用多态函数一样耗时。</p><h4 id="5-3-6-PERFORMANCE-：开销"><a href="#5-3-6-PERFORMANCE-：开销" class="headerlink" title="5.3.6 PERFORMANCE ：开销"></a>5.3.6 PERFORMANCE ：开销</h4><p>The state machine algorithm only requires memory to hold a triggered transition and the current state. It is O(1) in memory, and O(m) in time, where m is the number of transitions per state. </p><p>状态机算法仅需要存储器来保持触发转换和当前状态。 它在存储器中是O（1），在时间上是O（m），其中m是每个状态的转换数。</p><p>The algorithm calls other functions in both the state and the transition classes, and in most cases the execution time of these functions accounts for most of the time spent in the algorithm. </p><p>该算法调用状态和转换类中的其他函数，并且在大多数情况下，这些函数的执行时间占算法中花费的大部分时间。</p><h4 id="5-3-7-IMPLEMENTATION-NOTES-：实现的一些说明"><a href="#5-3-7-IMPLEMENTATION-NOTES-：实现的一些说明" class="headerlink" title="5.3.7 IMPLEMENTATION NOTES ：实现的一些说明"></a>5.3.7 IMPLEMENTATION NOTES ：实现的一些说明</h4><p>As I mentioned earlier, there are any number of ways to implement a state machine. The state machine described in this section is as flexible as possible. I’ve tried to aim for an implementation that allows you to experiment with any kind of state machine and add interesting features. In many cases it may be too flexible. If you’re only planning to use a small subset of its flexibility, then it is very likely to be unnecessarily inefficient. </p><p>正如我之前提到的，有许多方法可以实现状态机。 本节中描述的状态机尽可能灵活。 我试图实现一个允许您尝试任何类型的状态机并添加有趣功能的实现。 在许多情况下，它可能过于灵活。 如果您只计划使用其灵活性的一小部分，则很可能会产生不必要的低效率。</p><h4 id="5-3-8-HARD-CODED-FSM-：FSM的硬编码问题"><a href="#5-3-8-HARD-CODED-FSM-：FSM的硬编码问题" class="headerlink" title="5.3.8 HARD-CODED FSM ：FSM的硬编码问题"></a>5.3.8 HARD-CODED FSM ：FSM的硬编码问题</h4><p>A few years back, almost all state machines were hard-coded. The rules for transitions and the execution of actions were part of the game code. It has become less common as level designers get more control over building the state machine logic, but it is still an important approach. </p><p>几年前，几乎所有的状态机都是硬编码的。 转换规则和动作的执行是游戏代码的一部分。 随着关卡设计师对构建状态机逻辑的更多控制，它变得不那么常见，但它仍然是一种重要的方法。</p><h5 id="Pseudo-Code-：伪代码"><a href="#Pseudo-Code-：伪代码" class="headerlink" title="Pseudo-Code ：伪代码"></a>Pseudo-Code ：伪代码</h5><p>In a hard-coded FSM, the state machine consists of an enumerated value, indicating which state is currently occupied, and a function that checks if a transition should be followed. Here I’ve combined the two into a class definition (although I personally tend to associate hard-coded FSMs with developers still working in C). </p><p>在硬编码的FSM中，状态机由枚举值组成，指示当前占用的状态，以及检查是否应遵循转换的函数。 在这里，我将两者合并为一个类定义（尽管我个人倾向于将硬编码的FSM与仍在C中工作的开发人员联系起来）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFSM</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">// 声明所有状态名</span></span><br><span class="line"><span class="keyword">enum</span> State</span><br><span class="line">&#123;</span><br><span class="line">PATROL,</span><br><span class="line">DEFEND,</span><br><span class="line">SLEEP </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 当前状态</span></span><br><span class="line">myState；</span><br><span class="line"><span class="function">def <span class="title">update</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 寻找当前状态</span></span><br><span class="line"><span class="keyword">if</span> myState == PATROL</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> canSeePlayer()</span><br><span class="line">        myState = DEFEND</span><br><span class="line">    <span class="keyword">if</span> tired()</span><br><span class="line">        myState = SLEEP</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> myState == DEFEND</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> canSeePlayer()</span><br><span class="line">myState = PATROL </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> myState == SLEEP</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> tired()</span><br><span class="line">myState = PATROL</span><br><span class="line">&#125;  </span><br><span class="line">def notifyNoiseHeard(volume)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> myState == SLEEP <span class="keyword">and</span> volume &gt; <span class="number">10</span>:</span><br><span class="line">    myState = DEFEND</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Notice that this is pseudo-code for a particular state machine rather than a type of state machine. In the update function there is a block of code for each state. In that block of code the conditions for each transition are checked in turn, and the state is updated if required. The transitions in this example all call functions (tired and canSeePlayer), which I am assuming have access to the current game state. </p><p>请注意，这是特定状态机的伪代码，而不是一种状态机。 在更新功能中，每个状态都有一个代码块。 在该代码块中，依次检查每个转换的条件，并在需要时更新状态。 这个例子中的转换都是调用函数（tired()和canSeePlayer()），我假设它们可以访问当前的游戏状态。</p><p>In addition, I’ve added a state transition in a separate function, notifyNoiseHeard. I am assuming that the game code will call this function whenever the character hears a loud noise. This illustrates the difference between a polling (asking for informa- tion explicitly) and an event-based (waiting to be told information) approach to state transitions. Chapter 10 on world interfacing contains more details on this distinction. </p><p>另外，我在一个单独的函数notifyNoiseHeard中添加了一个状态转换。 我假设只要角色听到很大的噪音，游戏代码就会调用此函数。 <strong>这说明了轮询（明确要求信息）和基于事件（等待被告知信息）的状态转换方法之间的区别。</strong> 关于世界接口的第10章包含有关这种区别的更多细节。</p><p>The update function is called in each frame, as before, and the current state is used to generate an output action. To do this, the FSM might have a method containing conditional blocks of the following form: </p><p>更新函数像以前一样在每个帧中调用，当前状态用于生成输出动作。 为此，FSM可能有一个包含以下形式的条件块的方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">getAction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> myState == PATROL: <span class="keyword">return</span> PatrolAction</span><br><span class="line">elif myState == DEFEND: <span class="keyword">return</span> DefendAction</span><br><span class="line">elif myState == SLEEP: <span class="keyword">return</span> SleepAction</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Often, the state machine simply carries out the actions directly, rather than returning details of the action for another piece of code to execute. </p><p>通常，状态机只是直接执行操作，而不是返回要执行的另一段代码的操作细节。</p><h5 id="Performance-：开销"><a href="#Performance-：开销" class="headerlink" title="Performance ：开销"></a>Performance ：开销</h5><p>This approach requires no memory and is O(n + m), where n is the number of states, and m is the number of transitions per state. </p><p>这种方法不需要存储器，并且是O（n + m），其中n是状态数，m是每个状态的转换数。</p><p>Although this appears to perform worse than the flexible implementation, it is usually faster in practice for all but huge state machines (i.e., thousands of states). </p><p>虽然这似乎比灵活的实现更糟糕，但实际上除了巨大的状态机（即数千个状态）之外通常更快。</p><h5 id="Weaknesses-：缺点-1"><a href="#Weaknesses-：缺点-1" class="headerlink" title="Weaknesses ：缺点"></a>Weaknesses ：缺点</h5><p>Although hard-coded state machines are easy to write, they are notoriously difficult to maintain. State machines in games can often get fairly large, and this can appear as ugly and unclear code. </p><p>虽然硬编码的状态机很容易编写，但它们很难维护。 游戏中的状态机通常会变得相当大，这可能看起来像丑陋和不清楚的代码。</p><p>Most developers, however, find that the main drawback is the need for program- mers to write the AI behaviors for each character. This implies a need to recompile the game each time the behavior changes. While it may not be a problem for a hobby game writer, it can become critical in a large game project that takes many minutes or hours to rebuild. </p><p>然而，大多数开发人员发现主要缺点是程序员需要为每个角色编写AI行为。 这意味着每次行为改变时都需要重新编译游戏。 虽然它可能不是一个业余爱好游戏开发者的问题，但它可能在一个大型游戏项目中变得至关重要，需要花费很多分钟或几小时来重建。</p><p>More complex structures, such as hierarchical state machines (see below), are also difficult to coordinate using hard-coded FSMs. With a more flexible implementation, debugging output can easily be added to all state machines, making it easier to track down problems in the AI. </p><p>更复杂的结构，例如分层状态机（见下文），也很难使用硬编码的FSM进行协调。 通过更灵活的实现，可以轻松地将调试输出添加到所有状态机，从而更容易跟踪AI中的问题。</p><h4 id="5-3-9-HIERARCHICAL-STATE-MACHINES：分层状态机"><a href="#5-3-9-HIERARCHICAL-STATE-MACHINES：分层状态机" class="headerlink" title="5.3.9 HIERARCHICAL STATE MACHINES：分层状态机"></a>5.3.9 HIERARCHICAL STATE MACHINES：分层状态机</h4><p>On its own, one state machine is a powerful tool, but it can be difficult to express some behaviors. One common source of difficulty is “alarm behaviors.” </p><p>就其本身而言，一台状态机是一种强大的工具，但表达某些行为可能很困难。一个常见的例子是“警报行为”。</p><p>Imagine a service robot that moves around a facility cleaning the floors. It has a state machine allowing it to do this. It might search around for objects that have been dropped, pick one up when it finds it, and carry it off to the trash compactor. This can be simply implemented using a normal state machine (see Figure 5.14). </p><p>想象一下一个机器人在清洁地板的设施周围移动。 它有一个状态机允许它这样做。 它可能会搜索掉落的物体，找到它时拾取一个物体，然后将它带到垃圾压缩机。 这可以使用普通状态机简单地实现（参见图5.14）。</p><p><img src="/Users/zhangmo/Library/Application Support/typora-user-images/image-20181121110155364.png" alt="image-20181121110155364"></p><p>Unfortunately, the robot can run low on power, whereupon it has to scurry off to the nearest electrical point and get recharged. Regardless of what it is doing at the time, it needs to stop, and when it is fully charged again, it needs to pick up where it left off. The recharging periods could allow the player to sneak by unnoticed, for example, or allow the player to disable all electricity to the area and thereby disable the robot. </p><p>不幸的是，机器人的能源不是无限的，因此它必须赶到最近的电气点并进行充电。 不管它当时在做什么，它需要停止。当它再次充满电时，它需要从它停止的地方开始。 例如，充电时段可允许玩家不加注意地潜行，或允许玩家禁用该区域的所有电力，从而禁用机器人。（注：游戏场景模拟）</p><p>This is an alarm mechanism: something that interrupts normal behavior to respond to something important. Representing this in a state machine leads to a dou- bling in the number of states. </p><p>这是一种警报机制：可以中断正常行为以回应重要事件。 在状态机中表示这一点会导致状态数量的增加。</p><p>With one level of alarm this isn’t a problem, but what would happen if we wanted the robot to hide when fighting breaks out in the corridor. If its hiding instinct is more important than its refuelling instinct, then it will have to interrupt refuelling to go hide. After the battle it will need to pick up refuelling where it left off, after which it will pick up whatever it was doing before that. For just 2 levels of alarm, we would have 16 states. </p><p>通过一层警报，这不是问题，但如果我们希望机器人在走廊中发生战斗时隐藏会发生什么。 如果它的隐藏决策比加油决策优先级更高，那么就不得不中断加油才能隐藏起来。 在战斗结束后，它需要在停止的地方接受加油，之后它将重拾它之前做的事情。 对于仅2层警报，我们将有16个状态。（？）</p><p>Rather than combining all the logic into a single state machine, we can separate it into several. Each alarm mechanism has its own state machine, along with the original behavior. They are arranged in a hierarchy, so the next state machine down is only considered when the higher level state machine is not responding to its alarm. </p><p>我们可以将它分成几个，而不是将所有逻辑组合到一个状态机中。 每个报警机制都有自己的状态机以及原始行为。 它们按层次结构排列，因此仅当较高级别的状态机未响应其警报时才考虑下一个状态机。</p><p>Figure 5.15 shows one alarm mechanism and corresponds exactly to the diagram above. </p><p>图5.15显示了一种报警机制，与上图完全一致。</p><p><img src="/Users/zhangmo/Library/Application Support/typora-user-images/image-20181121111241030.png" alt="image-20181121111241030"></p><p>We will nest one state machine inside another to indicate a hierarchical state ma- chine (Figure 5.16). The solid circle again represents the start state of the machine. When a composite state is first entered, the circle with H* inside it indicates which sub-state should be entered. </p><p>我们将一个状态机嵌套在另一个状态机中以指示分层状态机（图5.16）。 实心圆圈再次表示机器的启动状态。 首次输入复合状态时，其中带有H *的圆圈表示应输入哪个子状态。</p><p><img src="/Users/zhangmo/Library/Application Support/typora-user-images/image-20181121111547584.png" alt="image-20181121111547584"></p><p>If the composite state has already been entered, then the previous sub-state is returned to. The H* node is called the “history state” for this reason. </p><p>如果已经输入复合状态，则返回先前的子状态。 由于这个原因，H *节点被称为“历史状态”。</p><p>The details of why there’s an asterisk after the H, and some of the other vagaries of the UML state chart diagram, are beyond the scope of this chapter. Refer back to Pilone [2005] for more details. </p><p>H之后有一个星号的原因以及UML状态图表中的一些其他变幻莫测的细节超出了本章的范围。 有关更多详细信息，请参阅Pilone [2005]。</p><p>Rather than having separate states to keep track of the non-alarm state, we intro- duce nested states. We still keep track of the state of the cleaning state machine, even if we are in the process of refuelling. When the refuelling is over, the cleaning state machine will pick up where it left off. </p><p>我们引入嵌套状态，而不是使用单独的状态来跟踪非警报状态。 即使我们正在加油，我们仍然会跟踪清洁状态机的状态。 当加油结束时，清洁状态机将从停止的地方开始。</p><p>In effect, we are in more than one state at once: we might be in the “Refuel” state in the alarm mechanism, while at the same time be in the “Pick Up Object” state in the cleaning machine. Because there is a strict hierarchy, there is never any confusion about which state wins out: the highest state in the hierarchy is always in control. </p><p>实际上，我们同时处于多个状态：我们可能处于报警机制中的“加油”状态，同时处于清洗机制中的“拾取对象”状态。 因为存在严格的层次结构，所以对于执行哪个状态并不存在任何混淆：层次结构中的最高状态始终处于控制之中。</p><p>To implement this, we could simply arrange the state machines in our program so that one state machine calls another if it needs to. So if the refuelling state ma- chine is in its “Clean Up” state, it calls the cleaning state machine and asks it for the action to take. When it is in the “Refuel” state, it returns the refuelling action directly. </p><p>为了实现这一点，我们可以简单地在我们的程序中安排状态机，以便一个状态机在需要时调用另一个状态机。 因此，如果加油状态机处于“清理”状态，它会调用清洁状态机并要求其采取措施。 当它处于“加油”状态时，它直接返回加油动作。</p><p>While this would lead to slightly ugly code, it would implement our scenario. Most hierarchical state machines, however, support transitions between levels of the hierarchy, and for that we’ll need more complex algorithms. </p><p>虽然这会导致稍微丑陋的代码，但它会实现我们的场景。 但是，大多数分层状态机支持层次结构级别之间的转换，为此我们需要更复杂的算法。</p><p>For example, let’s expand our robot so that it can do something useful if there are no objects to collect. It makes sense that it will use the opportunity to go and recharge, rather than standing around waiting for its battery to go flat. The new state machine is shown in Figure 5.17. </p><p>例如，让我们扩展我们的机器人，以便在没有要收集的对象时它可以做一些有用的事情。 这是有意义的，它会利用这个机会去充电，而不是站在那里等待电池电量消失。 新的状态机如图5.17所示。</p><p><img src="/Users/zhangmo/Library/Application Support/typora-user-images/image-20181121112706544.png" alt="image-20181121112706544"></p><p>Notice that we’ve added one more transition: from the “Search” state right out into the “Refuel” state. This transition is triggered when there are no objects to collect. Because we transitioned directly out of this state, the inner state machine no longer has any state. When the robot has refuelled and the alarm system transitions back to cleaning, the robot will not have a record of where to pick up from, so it must start the state machine again from its initial node (“Search”). </p><p>请注意，我们又添加了一个转换：从“搜索”状态直接进入“加油”状态。 没有要收集的对象时会触发此转换。 因为我们直接从这个状态转换，内部状态机不再具有任何状态。 当机器人加满了油并且报警系统转换回清洁时，机器人将无法记录从哪里取货，因此它必须从其初始节点（“搜索”）再次启动状态机。</p><h5 id="The-Problem-：问题"><a href="#The-Problem-：问题" class="headerlink" title="The Problem ：问题"></a>The Problem ：问题</h5><p>We’d like an implementation of a state machine system that supports hierarchical state machines. We’d also like transitions that pass between different layers of the machine. </p><p>我们想要一个支持分层状态机的状态机系统的实现。 我们也喜欢在机器的不同层之间传递的过渡。</p><h6 id="The-Algorithm-：算法"><a href="#The-Algorithm-：算法" class="headerlink" title="The Algorithm ：算法"></a>The Algorithm ：算法</h6><p>In a hierarchical state machine each state can be a complete state machine in its own right. We therefore rely on recursive algorithms to process the whole hierarchy. As with most recursive algorithms, this can be pretty tricky to follow. The simplest im- plementation covered here is doubly tricky because it recurses up and down the hier- archy at different points. I’d encourage you to use the informal discussion and exam- ples in this section alongside the pseudo-code in the next section and play with the Hierarchical State Machine program on the CD to get a feel for how it is all working. </p><p>在分层状态机中，每个状态本身可以是完整的状态机。 因此，我们依靠递归算法来处理整个层次结构。 与大多数递归算法一样，这可能非常棘手。 这里涉及的最简单的实现是双重棘手的，因为它在不同的点上上下起伏。 我鼓励您使用本节中的非正式讨论和示例以及下一节中的伪代码，并使用CD上的Hierarchical State Machine程序来了解它是如何工作的。</p><p>The first part of the system returns the current state. The result is a list of states, from highest to lowest in the hierarchy. The state machine asks its current state to return its hierarchy. If the state is a terminal state, it returns itself; otherwise, it returns itself and adds to it the hierarchy of state from its own current state. </p><p>系统的第一部分返回当前状态。 结果是状态列表，从层次结构的最高到最低。 状态机要求其当前状态返回其层次结构。 如果状态是终端状态，则返回自身; 否则，它返回自身并从其当前状态向其添加状态层次结构。</p><p>In Figure 5.18 the current state is [State L, State A]. </p><p>在图5.18中，当前状态是[状态L，状态A]。</p><p><img src="/Users/zhangmo/Library/Application Support/typora-user-images/image-20181121113748202.png" alt="image-20181121113748202"></p><p>The second part of the hierarchical state machine is its update. In the original state machine we assumed that each state machine started off in its initial state. Because the state machine always transitioned from one state to another, there was never any need to check if there was no state. State machines in a hierarchy can be in no state; they may have a cross hierarchy transition. The first stage of the update, then, is to check if the state machine has a state. If not, it should enter its initial state. </p><p>分层状态机的第二部分是它的更新。 在原始状态机中，我们假设每个状态机在其初始状态下启动。 因为状态机总是从一个状态转换到另一个状态，所以从来没有必要检查是否没有状态。 <strong>层次结构中的状态机可以处于无状态; 他们可能有一个跨层次的过渡。 然后，更新的第一阶段是检查状态机是否具有状态。 如果没有，它应该进入其初始状态。</strong></p><p>Next, we check if the current state has a transition it wants to execute. Transitions at higher levels in the hierarchy always take priority, and the transitions of sub-states will not be considered if the super-state has one that triggers. </p><p>接下来，我们检查当前状态是否有要执行的转换。 层次结构中较高级别的转换始终具有优先级，如果父状态已经被触发，则不会考虑子状态的转换。</p><p>A triggered transition may be one of three types: it might be a transition to an- other state at the current level of the hierarchy; it might be a transition to a state higher up in the hierarchy; or it might be a transition to a state lower in the hierarchy. Clearly, the transition needs to provide more data than just a target state. We allow it to return a relative level: how many steps up or down the hierarchy the target state is. </p><p>触发转换可以是以下三种类型之一：它可能是在层次结构的当前级别转换到另一种状态; 它可能是向层次结构中更高级别的状态过渡; 或者它可能是转换到层次结构中较低的状态。 <strong>显然，转换需要提供的数据多于目标状态。 我们允许它返回一个相对级别：目标状态在层次结构中向上或向下的步数。</strong></p><p>We could simply search the hierarchy for the target state and not require an ex- plicit level. While this would be more flexible (we wouldn’t have to worry about the level values being wrong), it would be considerably more time-consuming. A hybrid, but fully automatic, extension could search the hierarchy once offline and store all appropriate level values. </p><p>我们可以简单地在层次结构中搜索目标状态，而不需要一个明确的级别。 虽然这会更灵活（我们不必担心水平值是错误的），但它会更加耗时。 混合但全自动的扩展可以在离线时搜索层次结构并存储所有适当的级别值。</p><p>So the triggered transition has a level of zero (state is at the same level), a level greater than zero (state is higher in the hierarchy), or a level less than zero (state is lower in the hierarchy). It acts differently depending on which category the level falls into. </p><p>因此，触发转换拥有三种情况：级别为零（状态处于同一级别），级别大于零（层次结构中的状态较高），或小于零的级别（状态在层次结构中较低）。 它的行为取决于级别所属的类别。</p><p>If the level is zero, then the transition is a normal state machine transition and can be performed at the current level, using the same algorithm used in the finite state machine. </p><p>如果级别为零，则转换是正常状态机转换，并且可以使用在有限状态机中使用的相同算法在当前级别执行。</p><p>If the level is greater than zero, then the current state needs to be exited and noth- ing else needs to be done at this level. The exit action is returned, along with an indication to whoever called the update function that the transition hasn’t been com- pleted. We will return the exit action, the transition outstanding, and the number of levels higher to pass the transition. This level value is decreased by one as it is returned. As we will see, the update function will be returning to the next highest state machine in the hierarchy. </p><p>如果级别大于零，则需要退出当前状态，而不需要在此级别完成其他操作。 返回退出操作，同时向任何调用Update()的位置指示转换尚未完成。 我们将返回退出时执行的行为、未完成的转换以及更高级别的数量以通过转换。 该级别值在返回时减少一。 正如我们将看到的，更新功能将返回到层次结构中的下一个最高状态机。</p><p>If the level is less than zero, then the current state needs to transition to the ancestor of the target state on the current level in the hierarchy. In addition, each of the children of that state also needs to do the same, down to the level of the final desti- nation state. To achieve this we use a separate function, updateDown, that recursively performs this transition from the level of the target state back up to the current level and returns any exit and entry actions along the way. The transition is then complete and doesn’t need to be passed on up. All the accumulated actions can be returned. </p><p>// 如果级别小于零，则当前状态需要转换到层次结构中当前级别上的目标状态的父状态。 此外，该状态的每个孩子也需要做同样的事情，直到最终目标状态的水平。 为了实现这一点，我们使用一个单独的函数updateDown，它递归地执行从目标状态级别到当前级别的转换，并返回任何退出和进入操作。 然后转换完成，不需要向上传递。 可以返回所有累积的动作。</p><p>So we’ve covered all possibilities if the current state has a transition that triggers. If it does not have a transition that triggers, then its action depends on whether the current state is a state machine itself. If not, and if the current state is a plain state, then we can return the actions associated with being in that state, just as before. </p><p>因此，如果当前状态具有触发的转换，我们已经涵盖了所有可能性。 如果它没有触发的转换，那么它的动作取决于当前状态是否是状态机本身。 如果不是，并且如果当前状态是普通状态，那么我们可以像以前一样返回与处于该状态相关联的动作。</p><p>If the current state is a state machine, then we need to give it the opportunity to trigger any transitions. We can do this by calling its update function. The update func- tion will handle any triggers and transitions automatically. As we saw above, a lower level transition that fires may have its target state at a higher level. The update func- tion will return a list of actions, but it may also return a transition that it is passing up the hierarchy and that hasn’t yet been fired. </p><p>如果当前状态是状态机，那么我们需要给它机会来触发任何转换。 我们可以通过调用它的更新函数来实现。 更新功能将自动处理任何触发和转换。 如上所述，触发的较低级别转换可能使其目标状态处于较高级别。 更新功能将返回一个操作列表，但它也可能返回一个它正在向层次结构传递但尚未触发的转换。</p><p>If such a transition is received, its level is checked. If the level is zero, then the transition should be acted on at this level. The transition is honored, just as if it were a regular transition for the current state. If the level is still greater than zero (it should never be less than zero, because we are passing up the hierarchy at this point), then the state machine should keep passing it up. It does this, as before, by exiting the current state and returning the following pieces of information: the exit action; any actions provided by the current state’s update function; the transition that is still pending; and the transition’s level, less one. </p><p>如果收到这样的转换，则检查其级别。 如果级别为零，则应在此级别上执行转换。转换已经执行，就像它是当前状态的常规过渡一样。 如果级别仍然大于零（它应该永远不会小于零，因为我们此时正在调整层次结构），那么状态机应该继续传递它。 它像以前一样通过退出当前状态并返回以下信息来执行此操作：退出操作; 当前状态更新功能提供的任何行动; 仍未决的状态转换; 和转换的层级//，少一个。</p><p>If no transition is returned from the current state’s update function, then we can simply return its list of actions. If we are at the top level of the hierarchy, the list alone is fine. If we are lower down, then we are also within a state, so we need to add the action for the state we’re in to the list we return. </p><p>如果没有从当前状态的更新函数返回转换，那么我们可以简单地返回其动作列表。 如果我们处于层次结构的顶层，那么单独列表就可以了。 如果我们处于较低的层级，那么我们也处于一个状态，所以我们需要为我们返回的列表中的状态添加动作。</p><p>Fortunately, this algorithm is at least as difficult to explain as it is to implement. To see how and why it works, let’s work through an example. </p><p>幸运的是，这种算法至少与实现一样难以解释。 为了了解它的工作原理和原因，让我们来看一个例子。</p><h5 id="Examples-：例子"><a href="#Examples-：例子" class="headerlink" title="Examples ：例子"></a>Examples ：例子</h5><p>Figure 5.19 shows a hierarchical state machine that we will use as an example.</p><p>图5.19显示了我们将用作示例的分层状态机。</p><p><img src="/Users/zhangmo/Library/Application Support/typora-user-images/image-20181121133703875.png" alt="image-20181121133703875"></p><p>To clarify the actions returned for each example, we will say S-entry is the set of entry actions for state S, similarly S-active and S-exit for active and exit actions. In transitions we use the same format 1-actions for the actions associated with transi- tion 1. </p><p>为了阐明每个示例返回的操作，我们将说S-entry是状态S的入口操作集，类似于活动和退出操作的S-active和S-exit。 在转换中，我们对与转换1相关的操作使用相同的格式1动作。</p><p>These examples can appear confusing if you skim them through. If you’re having trouble with the algorithm, I urge you to follow through step by step with both the diagram above and the pseudo-code from the next section. </p><p>如果您浏览它们，这些示例可能会让您感到困惑。 如果您在使用算法时遇到问题，我建议您按照上图和下一部分的伪代码一步一步地进行操作。</p><p>Suppose we start just in State L, and no transition triggers. We will transition into State [L, A], because L’s initial state is A. The update function will return: L-active and A-entry, because we are staying in L and just entering A. </p><p>假设我们只是在状态L开始，没有转换触发器。 我们将转换到状态[L，A]，因为L’的初始状态是A.更新函数将返回：L-active和A-entry，因为我们留在L并且只是进入A.</p><p>Now suppose transition 1 is the only one that triggers. The top-level state ma- chine will detect no valid transitions, so will call state machine L to see if it has any. L finds that its current state (A) has a triggered transition. Transition 1 is a transition at the current level, so it is handled within L and not passed anywhere. A transitions to A, and L’s update function returns: A-exit, 1-actions, B-entry. The top-level state machine accepts these actions and adds its own active action. Because we have stayed in State L throughout, the final set of actions is A-exit, 1-actions, B-entry, L-active. The current state is [L, B]. </p><p>现在假设转换1是唯一触发的转换。 顶层状态机将检测到无有效转换，因此将调用状态机L以查看它是否有任何转换。 L发现其当前状态（A）具有触发转换。 转换1是当前级别的转换，因此它在L内处理，不会在任何地方传递。 转换到A，并且L的更新函数返回：A-exit，1–actions，B-entry。 顶层状态机接受这些操作并添加其自己的活动操作。 因为我们始终处于状态L，所以最后一组动作是A-exit，1-actions，B-entry，L-active。 当前状态是[L，B]。</p><p>From this state, transition 4 triggers. The top-level state machine sees that transi- tion 4 triggers, and because it is a top-level transition, it can be honored immediately. The transition leads to State M, and the corresponding actions are L-exit, 4-actions, M-entry. The current state is [M]. Note that L is still keeping a record of being in State B, but because the top-level state machine is in State M, this record isn’t used at the moment. </p><p>从这个状态，转换4触发。 顶级状态机看到转换4触发，并且因为它是顶级转换，所以它可以立即兑现。 转换导致状态M，并且相应的动作是L-exit，4-actions，M-entry。 当前状态是[M]。 请注意，L仍然保留在状态B中的记录，但由于顶级状态机处于状态M，因此此记录不会被使用。</p><p>We’ll go from State M to State N in the normal way through transition 5. The pro- cedure is exactly the same as for the previous example and the non-hierarchical state machine. Now transition 6 triggers. Because it is a level zero transition, the top-level state machine can honor it immediately. It transitions into State L and returns the ac- tions N-exit, 6-actions, L-entry. But now, L’s record of being in State B is important: we end up in State [L, B] again. In our implementation we don’t return the B-entry action, because we didn’t return the B-exit action when we left State L previously. This is a personal preference on my part and isn’t fixed in stone. If you want to exit and re-enter State B, then you can modify your algorithm to return these extra actions at the appropriate time. </p><p>我们将通过转换5以正常方式从状态M转到状态N.该过程与前一个示例和非分层状态机完全相同。 现在转换6个触发器。 因为它是一个零级转换，所以顶级状态机可以立即兑现它。 它转换到状态L并返回N-exit，6-actions，L-entry的动作。 但是现在，L在状态B的记录很重要：我们再次进入状态[L，B]。 在我们的实现中，我们不返回B-entry动作，因为我们之前离开状态L时没有返回B-exit动作。 这是我个人的偏好，并不是固定的。 如果要退出并重新输入状态B，则可以修改算法以在适当的时间返回这些额外的操作。</p><p>Now suppose from State [L, B] transition 3 triggers. The top-level state machine finds no triggers, so it will call state machine L to see if it has any. L finds that State B has a triggered transition. This transition has a level of one: its target is one level higher in the hierarchy. This means that State B is being exited, and it means that we can’t honor the transition at this level. We return B-exit, along with the uncompleted transition, and the level minus one (i.e., zero, indicating that the next level up needs to handle the transition). So control returns to the top-level update function. It sees that L returned an outstanding transition, with zero level, so it honors it, transitioning in the normal way to State N. It combines the actions that L returned (namely,B-exit) with the normal transition actions to give a final set of actions: B-exit, L-exit,3-actions, N-entry. Note that, unlike in our third example, L is no longer keeping track of the fact that it is in State B, because we transitioned out of that state. If we fire transition 6 to return to State L, then State L’s initial state, A, would be entered, just like in the first example.</p><p>现在假设从状态[L，B]过渡3触发。顶级状态机找不到触发器，因此它将调用状态机L以查看它是否有任何触发器。 L发现状态B已经触发转换。此转换的级别为1：其目标在层次结构中高一级。这意味着状态B正在退出，并且我们无法履行这一级别的过渡。我们返回B-exit，以及未完成的转换，以及级别减1（即，零，表示下一级需要处理转换）。因此控制移交回上层的Update函数。Update函数得到了一个未完成的状态转换，零级别，所以Update函数将执行这个转换：以正常方式转换到状态N。它将L返回的动作（即B-exit）与正常的过渡动作结合起来给出一组最终动作集：B-exit，L-exit，3-actions，N-entry。请注意，与我们的第三个示例不同，L不再跟踪它在状态B中执行的事，因为我们已经转换出该状态。如果我们触发转换6返回到状态L，则将输入State L’的初始状态A，就像在第一个示例中一样。</p><p>Our final example covers transitions with level less than zero. Suppose we moved from State N to State M via transition 7. Now we make transition 2 trigger. The top- level state machine looks at its current state (M) and finds transition 2 triggered. It has a level of minus one, because it is descending one level in the hierarchy. Because it has a level of minus one, the state machine calls the updateDown function to perform the recursive transition. The updateDown function starts at the state machine (L) that contains the final target state (C), asking it to perform the transition at its level. State machine L, in turn, asks the top-level state machine to perform the transition at its level. The top-level state machine changes from State M to State L, returning M-exit, L-entry as the appropriate actions. Control returns to state machine L’s updateDown function. State machine L checks if it is currently in any state (it isn’t, since we left State B in the last example). It adds its action, C-entry, to those returned by the top- level machine. Control then returns to the top-level state machine’s update function: the descending transition has been honored, it adds the transition’s actions to the result, and returns M-exit, C-entry, L-entry, 2-actions. </p><p>我们的最后一个示例涵盖了级别小于零的转换。假设我们通过转换7从状态N移动到状态M，现在我们通过触发器2执行转换。顶级状态机查看其当前状态（M）并找到触发的转换2。它的级别为-1，因为它在层次结构中下降一级。因为它的级别为-1，所以状态机调用updateDown函数来执行递归转换。 updateDown函数从包含最终目标状态（C）的状态机（L）开始，要求它在其级别执行转换。状态机L反过来要求顶级状态机在其级别执行转换。顶级状态机从状态M变为状态L，返回M-exit，L-entry作为适当的动作。控制返回状态机L的updateDown函数。状态机L检查它当前是否处于任何状态（它不是，因为我们在最后一个例子中离开了状态B）。它将其操作C-entry添加到顶级计算机返回的操作中。然后，Control返回到顶级状态机的Update函数：已经执行过降序转换，它将转换的动作添加到结果中，并返回M-exit，C-entry，L-entry，2-actions。</p><p>If state machine L had still been in State B, then when L’s updateDown function was called, it would transition out of B and into C. It would add B-exit and C-entry to the actions that it received from the top-level state machine.</p><p>如果状态机L仍处于状态B，那么当调用L的 updateDown函数时，它将从B转换为C。它会将B-exit和C-entry添加到它从顶层状态机接收的操作集中。</p><h5 id="Pseudo-Code-：伪代码-1"><a href="#Pseudo-Code-：伪代码-1" class="headerlink" title="Pseudo-Code ：伪代码"></a>Pseudo-Code ：伪代码</h5><p>The hierarchical state machine implementation is made up of five classes and forms one of the longest algorithms in this book. The State and Transition classes are similar to those in the regular finite state machine. The HierarchicalStateMachine class runs state transitions, and SubMachineState combines the functionality of the state machine and a state. It is used for state machines that aren’t at the top level of the hierarchy. All classes but the Transition inherit from a HSMBase class, which simpli- fies the algorithm by allowing functions to treat anything in the hierarchy in the same way. </p><p>分层状态机实现由五个类组成，并形成本书中最长的算法之一。 <strong>State和Transition类与常规有限状态机中的类相似。 HierarchicalStateMachine类运行状态转换，SubMachineState结合状态机和状态的功能。 它用于不在层次结构顶层的状态机。 除了Transition之外的所有类都继承自HSMBase类，它通过允许函数以相同的方式处理层次结构中的任何内容来简化算法。</strong></p><p>The HSMBase has the following form:</p><p>HSMBase类如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HSMBase</span></span></span><br><span class="line"><span class="class">    # <span class="title">The</span> <span class="title">structure</span> <span class="title">returned</span> <span class="title">by</span> <span class="title">update</span></span></span><br><span class="line"><span class="class">    // <span class="title">Update</span>函数返回结果的结构体</span></span><br><span class="line"><span class="class">    <span class="title">struct</span> <span class="title">UpdateResult</span></span></span><br><span class="line"><span class="class">      <span class="title">actions</span>// 行为</span></span><br><span class="line"><span class="class">      <span class="title">transition</span>// 转换路径</span></span><br><span class="line"><span class="class">      <span class="title">level</span>// 层级</span></span><br><span class="line"><span class="class">    <span class="title">def</span> <span class="title">getAction</span>():</span> <span class="keyword">return</span> []</span><br><span class="line">    def update()</span><br><span class="line">    &#123;</span><br><span class="line">    UpdateResult result</span><br><span class="line">result.actions = getAction()</span><br><span class="line">result.transition = None</span><br><span class="line">result.level = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result        </span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 未实现的功能？</span></span><br><span class="line">    def getStates() # unimplemented function</span><br></pre></td></tr></table></figure><p>The HierarchicalStateMachine class has the following implementation:</p><p>HierarchicalStateMachine类有着如下实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">class <span class="title">HierarchicalStateMachine</span> <span class="params">(HSMBase)</span></span></span><br><span class="line">    # List of states at this level of the hierarchy</span><br><span class="line">    <span class="comment">// 本层次的状态列表</span></span><br><span class="line">    states</span><br><span class="line"></span><br><span class="line">    # The initial state <span class="keyword">for</span> when the machine has to</span><br><span class="line">    <span class="meta"># current state.</span></span><br><span class="line">    <span class="comment">// 机器必须处于当前状态的初始状态</span></span><br><span class="line">    initialState</span><br><span class="line">    </span><br><span class="line">    # The current state of the machine.</span><br><span class="line">    <span class="comment">// 状态机的当前状态</span></span><br><span class="line">    currentState = initialState</span><br><span class="line">    </span><br><span class="line">    # Gets the current state <span class="built_in">stack</span></span><br><span class="line">    <span class="comment">// 获得当前状态栈</span></span><br><span class="line">    def getStates():</span><br><span class="line">      <span class="keyword">if</span> currentState: <span class="keyword">return</span> currentState.getStates()</span><br><span class="line">      <span class="keyword">else</span>: <span class="keyword">return</span> []</span><br><span class="line">      </span><br><span class="line">    # Recursively updates the machine.</span><br><span class="line">    <span class="comment">// 递归更新状态机</span></span><br><span class="line">    def update():</span><br><span class="line"># If we’re in no state, use the initial state</span><br><span class="line"><span class="comment">// 如果没有处于任何状态，使用初始状态</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> currentState:</span><br><span class="line">currentState = initialState</span><br><span class="line"><span class="keyword">return</span> currentState.getEntryAction()</span><br><span class="line">        </span><br><span class="line"># Try to find a transition in the current state</span><br><span class="line"><span class="comment">// 从当前状态尝试找到一个转换</span></span><br><span class="line">triggeredTransition = None</span><br><span class="line"><span class="keyword">for</span> transition in currentState.getTransitions():</span><br><span class="line"><span class="keyword">if</span> transition.isTriggered():</span><br><span class="line">triggeredTransition = transition</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        # If we’ve found one, make a result structure <span class="keyword">for</span> it</span><br><span class="line"><span class="comment">// 如果我们找到了一个转换，为其生成一个结果结构体</span></span><br><span class="line"><span class="keyword">if</span> triggeredTransition:</span><br><span class="line">        result = UpdateResult()</span><br><span class="line">result.actions = []</span><br><span class="line">result.transition = triggeredTransition</span><br><span class="line">result.level = triggeredTransition.getLevel()</span><br><span class="line">        </span><br><span class="line">        # Otherwise recurse down <span class="keyword">for</span> a result</span><br><span class="line">        <span class="comment">// 否则递归获得结果</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">result = currentState.update()</span><br><span class="line">        </span><br><span class="line">        # Check <span class="keyword">if</span> the result contains a transition</span><br><span class="line">        <span class="comment">// 检查结果中是否包含转换</span></span><br><span class="line"><span class="keyword">if</span> result.transition:</span><br><span class="line"></span><br><span class="line"># Act based on its level</span><br><span class="line"><span class="comment">// 基于本层执行</span></span><br><span class="line"><span class="keyword">if</span> result.level == <span class="number">0</span>:</span><br><span class="line"># Its on our level: honor it</span><br><span class="line"><span class="comment">// 结果行为在本层：执行</span></span><br><span class="line">targetState = result.transition.getTargetState()</span><br><span class="line">result.actions += currentState.getExitAction()</span><br><span class="line">result.actions += result.transition.getAction()</span><br><span class="line">result.actions += targetState.getEntryAction()</span><br><span class="line">                # Set our current state</span><br><span class="line">                <span class="comment">// 设置当前状态</span></span><br><span class="line">                currentState = targetState</span><br><span class="line">                </span><br><span class="line">                # Add our normal action (we may be a state)</span><br><span class="line">                <span class="comment">// 添加基本操作</span></span><br><span class="line">result.actions += getAction()</span><br><span class="line">                # Clear the transition, so nobody <span class="keyword">else</span> does it</span><br><span class="line"><span class="comment">// 清除转换，因此没有其他(?)执行它</span></span><br><span class="line">                result.transition = None</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> result.level &gt; <span class="number">0</span>:</span><br><span class="line"># Its destined <span class="keyword">for</span> a higher level</span><br><span class="line"><span class="comment">// 这表示一个更高的层级</span></span><br><span class="line"># Exit our current state</span><br><span class="line"><span class="comment">// 退出当前状态</span></span><br><span class="line">result.actions += currentState.getExitAction()</span><br><span class="line">currentState = None</span><br><span class="line"></span><br><span class="line"># Decrease the number of levels to go</span><br><span class="line"><span class="comment">// 当相对于目标层级为降低时</span></span><br><span class="line">result.level -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line"> # It needs to be passed down</span><br><span class="line"><span class="comment">// 它需要向下迁移</span></span><br><span class="line">targetState = result.transition.getTargetState()</span><br><span class="line">targetMachine = targetState.parent</span><br><span class="line">    result.actions += result.transition.getAction()</span><br><span class="line">    result.actions += targetMachine.updateDown(targetState, -result.level)</span><br><span class="line"></span><br><span class="line">    # Clear the transition, so nobody <span class="keyword">else</span> does it</span><br><span class="line">                <span class="comment">// 清除转换，因此没有其他(?)执行它</span></span><br><span class="line">    result.transition = None</span><br><span class="line">    </span><br><span class="line">    # If we didn’t get a transition</span><br><span class="line">    <span class="comment">// 如果我们没有（从结果中）取得转换</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  # We can simply <span class="keyword">do</span> our normal action</span><br><span class="line"><span class="comment">// 我们可以简单的执行我们的基本行为</span></span><br><span class="line">result.action += getAction()</span><br><span class="line"># Return the accumulated result</span><br><span class="line">        <span class="comment">// 返回积累的结果</span></span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line"># Recurses up the parent hierarchy, transitioning into</span><br><span class="line"># each state in turn <span class="keyword">for</span> the given number of levels</span><br><span class="line"><span class="comment">// 递归父层次结构，依次转换到指定层级号的每个状态</span></span><br><span class="line">def updateDown(state, level):</span><br><span class="line"># If we’re <span class="keyword">not</span> at top level, <span class="keyword">continue</span> recursing</span><br><span class="line"><span class="comment">// 如果不在顶层，继续递归</span></span><br><span class="line"><span class="keyword">if</span> level &gt; <span class="number">0</span>:</span><br><span class="line">  </span><br><span class="line"># Pass ourself as the transition state to our parent</span><br><span class="line"><span class="comment">// 将自己作为转换状态传递给父状态</span></span><br><span class="line">  actions = parent.updateDown(<span class="keyword">this</span>, level<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">    # Otherwise we have no actions to add to</span><br><span class="line">    <span class="comment">// 否则我们将没有要添加的行为</span></span><br><span class="line"><span class="keyword">else</span>: actions = []</span><br><span class="line"></span><br><span class="line"># If we have a current state, <span class="built_in">exit</span> it</span><br><span class="line"><span class="comment">// 如果当前状态存在，退出</span></span><br><span class="line"><span class="keyword">if</span> currentState:</span><br><span class="line">actions += currentState.getExitAction()</span><br><span class="line"># Move to the <span class="keyword">new</span> state, <span class="keyword">and</span> <span class="keyword">return</span> all the actions</span><br><span class="line"><span class="comment">// 转移到新的状态，并且返回所有行为</span></span><br><span class="line">    currentState = state</span><br><span class="line">actions += state.getEntryAction()</span><br><span class="line"><span class="keyword">return</span> actions</span><br></pre></td></tr></table></figure><p>The state class is substantially the same as before, but adds an implementation for getStates:</p><p>状态类的实现与之前的实现大体相同，但是增加了一个有关getStates的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class State (HSMBase):</span><br><span class="line">def getStates():</span><br><span class="line">    # If we’re just a state, then the <span class="built_in">stack</span> is just us</span><br><span class="line">    <span class="comment">// 如果是一个状态，那么要返回的状态栈仅有这个状态自身</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">this</span>]</span><br><span class="line"># As before...</span><br><span class="line">def getAction()</span><br><span class="line">  def getEntryAction()</span><br><span class="line">  def getExitAction()</span><br><span class="line">  def getTransitions()</span><br></pre></td></tr></table></figure><p>Similarly, the Transition class is the same, but adds a method to retrieve the level of the transition.</p><p>无独有偶，Transition类的实现也一样，但是添加了一个方法来返回的转换所在的层级。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transition</span>:</span></span><br><span class="line"># Returns the different in levels of the hierarchy from</span><br><span class="line">  <span class="meta"># the source to the target of the transition.</span></span><br><span class="line">  <span class="comment">// 返回</span></span><br><span class="line">  <span class="function">def <span class="title">getLevel</span><span class="params">()</span></span></span><br><span class="line">  # As before...</span><br><span class="line">  <span class="function">def <span class="title">isTriggered</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  def <span class="title">getTargetState</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  def <span class="title">getAction</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>Finally, the SubMachineState class merges the functionality of a state and a state machine.</p><p>最后，SubMachineState类整合了一个状态的功能与一个状态机。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class SubMachineState (State, HierarchicalStateMachine):</span><br><span class="line"># Route get action to the state</span><br><span class="line">  <span class="comment">// 转换</span></span><br><span class="line">  def getAction(): return State::getAction()</span><br><span class="line">  # Route update to the state machine</span><br><span class="line"><span class="comment">// 转换 </span></span><br><span class="line">  def update(): return HierarchicalStateMachine::update()</span><br><span class="line">  # We get states by adding ourself to our active children</span><br><span class="line">  <span class="comment">// 通过将自身加入活跃子节点集中获取当前状态</span></span><br><span class="line">  def getStates():</span><br><span class="line">    <span class="keyword">if</span> currentState:</span><br><span class="line">      <span class="keyword">return</span> [<span class="keyword">this</span>] + currentState.getStates()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">return</span> [<span class="keyword">this</span>]</span><br></pre></td></tr></table></figure><h5 id="Implementation-Notes：实现说明"><a href="#Implementation-Notes：实现说明" class="headerlink" title="Implementation Notes：实现说明"></a>Implementation Notes：实现说明</h5><p>I’ve used multiple inheritance to implement SubMachineState. For languages (or programmers) that don’t support multiple inheritance, there are two options. The Sub- MachineState could encapsulate HierarchicalStateMachine, or the Hierarchical- StateMachine can be converted so that it is a sub-class of State. The downside with the latter approach is that the top-level state machine will always return its active action from the update function, and getStates will always have it as the head of the list.</p><p>我已经使用多重继承来实现SubMachineState类。对于不支持多重继承的语言（或程序员），有两种选择。 Sub-MachineState可以封装HierarchicalStateMachine，或者Hierarchical-StateMachine可以被转换，使其成为State的子类。后一种方法的缺点是顶级状态机将始终从更新函数返回其活动操作，并且getStates将始终将其作为列表的头部。</p><p>I’ve elected to use a polymorphic structure for the state machine again. It is possible to implement the same algorithm without any polymorphic method calls. Given that it is complex enough already, however, I’ll leave that as an exercise. My experience deploying a hierarchical state machine involved an implementation using poly- morphic method calls (provided on the CD). In-game profiling on both PC and PS2 showed that the method call overhead was not a bottleneck in the algorithm. In a system with hundreds or thousands of states, it may well be, as cache efficiency issues come into play.<br>Some implementations of hierarchical state machines are significantly simpler than this by making it a requirement that transitions can only occur between states at the same level. With this requirement, all the recursion code can be eliminated. If you don’t need cross hierarchy transitions, then the simpler version will be easier to implement. It is unlikely to be any faster, however. Because the recursion isn’t used when the transition is at the same level, the code above will run about as fast if all the transitions have a zero level.</p><p>我已经选择再次使用状态机的多态结构。没有任何多态方法调用就可以实现相同的算法。鉴于它已经足够复杂了，我将把它留作练习。我部署分层状态机的经验涉及使用多态方法调用的实现（在CD上提供）。 PC和PS2上的游戏内分析表明，方法调用开销不是算法中的瓶颈。在具有数百或数千个状态的系统中，很可能会出现缓存效率问题。<br>分层状态机的一些实现比这更简单，因为要求转换只能在同一级别的状态之间发生。根据此要求，可以消除所有递归代码。如果您不需要跨层次转换，则更简单的版本将更容易实现。然而，它不太可能更快。因为当转换处于相同级别时不使用递归，所以如果所有转换具有零级别，则上述代码将以相同的速度运行。</p><h5 id="Performance-：开销-1"><a href="#Performance-：开销-1" class="headerlink" title="Performance ：开销"></a>Performance ：开销</h5><p>The algorithm is O(n) in memory, where n is the number of layers in the hierarchy. It requires temporary storage for actions when it recurses down and up the hierarchy. </p><p>该算法在内存中是O（n），其中n是层次结构中的层数。它需要临时存储操作，以便在向下和向下递增层次结构时执行操作。</p><p>Similarly, it is O(nt) in time, where t is the number of transitions per state. To find the correct transition to fire, it potentially needs to search each transition at each level of the hierarchy and O(nt) process. The recursion, both for a transition level <0 and for a level>0 is O(n), so it does not affect the O(nt) for the whole algorithm. </0></p><p>类似地，它是时间上的O（nt），其中t是每个状态的转换数。要找到正确的触发转换，可能需要在层次结构的每个级别和O（nt）进程中搜索每个转换。对于转换级别&lt;0和级别&gt; 0的递归都是O（n），因此它不会影响整个算法的O（nt）。</p><h4 id="5-3-10-COMBINING-DECISION-TREES-AND-STATE-MACHINES-：决策树与状态机的结合"><a href="#5-3-10-COMBINING-DECISION-TREES-AND-STATE-MACHINES-：决策树与状态机的结合" class="headerlink" title="5.3.10 COMBINING DECISION TREES AND STATE MACHINES ：决策树与状态机的结合"></a>5.3.10 COMBINING DECISION TREES AND STATE MACHINES ：决策树与状态机的结合</h4><p>The implementation of transitions bears more than a passing resemblance to the implementation of decision trees. This is no coincidence, but we can take it even further. Decision trees are an efficient way of matching a series of conditions, and this has application in state machines for matching transitions.</p><p>We can combine the two approaches by replacing transitions from a state with a decision tree. The leaves of the tree, rather than being actions as before, are transitions to new states. </p><p>转换的实现不仅仅与决策树的实现有相似之处。这不是巧合，但我们可以更进一步。决策树是匹配一系列条件的有效方式，而且具有这种行为在用于匹配转换的状态机中有效。</p><p>我们可以通过用状态替换状态转换的方式来组合这两种方法决策树。树的叶子，而不是像以前那样的动作，是向新状态的过渡。</p><p>A simple state machine might look like Figure 5.20. </p><p>一个简单的状态机可能如图5.20所示。</p><p><img src="/Users/zhangmo/Library/Application Support/typora-user-images/image-20181122004826206.png" alt="image-20181122004826206"></p><p>The diamond symbol is also part of the UML state chart diagram format, repre- senting a decision. In UML there is no differentiation between decisions and transi- tions, and the decisions themselves are usually not labelled. </p><p>In this book I’ve labelled the decisions with the test that they perform, which is clearer for our needs. </p><p>菱形符号也是UML状态图表格式的一部分，代表了一个决定。在UML中，决策和转换之间没有区别，决策本身通常没有标记。</p><p>在本书中，我用他们执行的测试标记了决策，这更符合我们的需求。</p><p>When in the “Alert” state, a sentry has only one possible transition: via the de- cision tree. It quickly ascertains whether the sentry can see the player. If the sentry is not able to see the player, then the transition ends and no new state is reached. If the sentry is able to see the player, then the decision tree makes a choice based on the distance of the player. Depending on the result of this choice, two different states may be reached: “Raise Alarm” or “Defend.” The latter can only be reached if a further test (distance to the player) passes. </p><p>当处于“警报”状态时，哨兵只有一个可能的过渡：通过决策树。它可以快速确定哨兵是否可以看到玩家。如果哨兵无法看到该玩家，则转换结束并且不会达到新的状态。如果哨兵能够看到玩家，则决策树根据玩家的距离做出选择。根据此选择的结果，可能会达到两种不同的状态：“提升警报”或“防御”。只有在进一步测试（与玩家的距离）通过后才能达到后者。</p><p>To implement the same state machine without the decision nodes, the state ma- chine in Figure 5.21 would be required. Note that now we have two very complex con- ditions and both have to evaluate the same information (distance to the player and distance to the alarm point). If the condition involved a time-consuming algorithm (such as the line of sight test in our example), then the decision tree implementation<br>would be significantly faster.</p><p>要在没有决策节点的情况下实现相同的状态机，将需要图5.21中的状态机。请注意，现在我们有两个非常复杂的条件，两者都必须评估相同的信息（到播放器的距离和到报警点的距离）。如果条件涉及耗时的算法（例如我们示例中的视线测试），那么决策树实现将明显更快。</p><p><img src="/Users/zhangmo/Library/Application Support/typora-user-images/image-20181122004853810.png" alt="image-20181122004853810"></p><h5 id="Pseudo-Code-：伪代码-2"><a href="#Pseudo-Code-：伪代码-2" class="headerlink" title="Pseudo-Code ：伪代码"></a>Pseudo-Code ：伪代码</h5><p>We can incorporate a decision tree into the state machine framework we’ve developed so far. </p><p>我们可以将决策树合并到我们迄今为止开发的状态机框架中。</p><p>The decision tree, as before, consists of DecisionTreeNodes. These may be decisions (using the same Decision class as before) or TargetStates (which replace the Action class in the basic decision tree). TargetStates hold the state to transition to and can contain actions. As before, if a branch of the decision tree should lead to no result, then we can have some null value at the leaf of the tree. </p><p>与以前一样，决策树由DecisionTreeNodes组成。这些可能是决策（使用与之前相同的Decision类）或TargetStates（它们替换基本决策树中的Action类）。 TargetStates保持状态转换并可以包含操作。和以前一样，如果决策树的一个分支应该导致没有结果，那么我们可以在树的叶子上有一些空值。</p><p>The decision making algorithm needs to change. Rather than testing for Actions to return, it now tests for TargetState instances:</p><p>决策算法需要改变。它不是测试要返回的Actions，而是测试TargetState实例：</p><p>We can then build an implementation of the Transition interface which supports these decision trees. It has the following algorithm: </p><p>然后我们可以构建支持的Transition接口的实现这些决策树。它有以下算法：</p><h5 id="Implementation：实现"><a href="#Implementation：实现" class="headerlink" title="Implementation：实现"></a>Implementation：实现</h5><p>As before, this implementation relies heavily on polymorphic methods in an object- oriented framework. The corresponding performance overhead may be unacceptable in some cases where lots of transitions or decisions are being considered.<br>和以前一样，这种实现在很大程度上依赖于面向对象框架中的多态方法。在考虑大量转换或决策的某些情况下，相应的性能开销可能是不可接受的。</p>]]></content>
      
      
      <categories>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Artificial Intelligence for Games </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>unity shader 渲染管线</title>
      <link href="/2018/10/22/Unity%E7%AC%94%E8%AE%B0/unity-shader-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/"/>
      <url>/2018/10/22/Unity%E7%AC%94%E8%AE%B0/unity-shader-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h3 id="GPU图形渲染管线流程"><a href="#GPU图形渲染管线流程" class="headerlink" title="GPU图形渲染管线流程"></a>GPU图形渲染管线流程</h3><h3 id="流程概述"><a href="#流程概述" class="headerlink" title="流程概述"></a>流程概述</h3><h4 id="应用程序阶段"><a href="#应用程序阶段" class="headerlink" title="应用程序阶段"></a>应用程序阶段</h4><p>应用程序阶段，使用高级编程语言(C、C++、JAVA 等)进行开发，主要和CPU、内存打交道，诸如碰撞检测、场景图建立、空间八叉树更新、视锥裁剪等经典算法都在此阶段执行。在该阶段的末端，几何体数据(顶点坐标、法向量、纹理坐标、纹理等)通过数据总线传送到图形硬件。</p><ul><li>工作：<ul><li>准备场景数据：如摄像机的位置、视锥体、场景中包含的模型、光源等</li><li>粗粒度剔除：把不可见的物体剔除</li><li>设置好每个模型的渲染状态：包括材质、使用的纹理、使用的Shader等</li></ul></li><li>输出：<ul><li><strong>渲染图元</strong>：渲染所需的几何信息</li></ul></li></ul><h4 id="几何阶段"><a href="#几何阶段" class="headerlink" title="几何阶段"></a>几何阶段</h4><p>几何阶段，主要负责顶点坐标变换、光照、裁剪、投影以及屏幕映射，该阶段基于GPU进行运算，在该阶段的末端得到了经过变换和投影之后的顶点坐标、颜色、以及纹理坐标。<br>光照计算属于几何阶段，因为光照计算涉及视点、光源和物体的世界坐标，所以通常放在世界坐标系中进行计算。</p><ul><li>工作：<ul><li>决定需要绘制的图元是什么</li><li>怎样绘制</li><li>在哪里绘制</li></ul></li><li>输出：<ul><li>屏幕空间的二维顶点坐标</li><li>每个顶点的深度值、着色等相关信息</li></ul></li></ul><h4 id="光栅阶段"><a href="#光栅阶段" class="headerlink" title="光栅阶段"></a>光栅阶段</h4><p>  光栅阶段，基于几何阶段的输出数据，为像素(Pixel)正确配色，以便绘制完整图像，该阶段进行的都是单个像素的操作，每个像素的信息存储在颜色缓冲器(color buffer 或者 frame buffer)中。</p><p>  雾化以及涉及物体透明度的计算属于光栅化阶段，因为上述两种计算都需要深度值信息(Z 值)，而深度值是在几何阶段中计算，并传递到光栅阶段的。</p><ul><li>工作：根据上个阶段传递的数据来产生屏幕上的像素，并渲染出最终的图像。</li><li>输出：逐像素处理过的渲染图元。</li></ul><h3 id="从几何阶段到光栅化阶段："><a href="#从几何阶段到光栅化阶段：" class="headerlink" title="从几何阶段到光栅化阶段："></a>从几何阶段到光栅化阶段：</h3><ol><li>几何阶段：变换三维顶点坐标和光照计算<ol start="2"><li>将模型空间坐标（object space coordinate）通过四阶矩阵变换矩阵（world matrix）转换为世界空间坐标（ world space coordinate ）。<ul><li>进行光照计算。</li><li>将模型空间下的顶点法向量转换为世界空间下的，所用的转换矩阵为world matrix的转置矩阵的逆矩阵。</li></ul></li><li>将物体顶点坐标从世界空间（world space）转换到观察空间下（eye space）。</li><li>将顶点坐标从观察空间下转换到裁剪空间下（project and clip space）。<ul><li>投影：用透视变换矩阵把顶点从视锥体（viewing frustum）中变换到裁剪空间的规范立方体（CVV）中。</li><li>图元装配（Primitive Assembly）：将顶点根据原始的连接关系还原出网格结构。</li><li>裁剪：在CVV中将位于视体外的场景数据去除。</li></ul></li><li>将得到的完全位于视体中的场景数据映射到屏幕坐标系上。</li></ol></li><li>光栅化阶段：决定哪些像素被集合图元覆盖。<strong>光栅化是将几何数据经过一系列变换后最终转换为像素，从而呈现在显示设备上的过程，光栅化的本质是坐标变换，几何离散化。</strong><ol><li><strong>三角形设置</strong>：计算光栅化一个三角网格所需的信息</li><li><strong>三角形遍历：</strong>检查每个像素是否被一个三角网格所覆盖，被覆盖则生成一个片元（对顶点信息插值）。<ol><li>读取模型的顶点，3个3个的读，因为要画三角形。</li><li>将3个顶点两两连成线，形成三角形。</li><li>计算屏幕像素点在三角形内还是三角形外。在三角形内部的，就上色（颜色是之前算出来的），在三角形外部的，就不上色。<a href="http://www.cnblogs.com/graphics/archive/2010/08/05/1793393.html（可以通过叉积来实现，连接PA，将PA和AB做叉积，再将CA和AB做叉积，如果两个叉积的结果方向一致，那么两个点在同一测。判断两个向量的是否同向可以用点积实现，如果点积大于0，则两向量夹角是锐角，否则是钝角。）" target="_blank" rel="noopener">http://www.cnblogs.com/graphics/archive/2010/08/05/1793393.html（可以通过叉积来实现，连接PA，将PA和AB做叉积，再将CA和AB做叉积，如果两个叉积的结果方向一致，那么两个点在同一测。判断两个向量的是否同向可以用点积实现，如果点积大于0，则两向量夹角是锐角，否则是钝角。）</a></li></ol></li><li>Pixel Operation<ul><li>纹理操作（Texture operation）：根据像素的纹理坐标，查询对应的纹理值。</li><li>消除遮挡面：深度测试，模版测试等。</li><li>混色（Blending）：根据目前已经画好的颜色，与正在计算的颜色的透明度(Alpha)，混合为两种颜色，作为新的颜色输出。</li><li>滤波（Filtering）：将正在算的颜色通过某种滤波后输出。</li></ul></li></ol></li></ol><h3 id="HLSL、GLSL与Cg："><a href="#HLSL、GLSL与Cg：" class="headerlink" title="HLSL、GLSL与Cg："></a>HLSL、GLSL与Cg：</h3><p>常见的着色语言：</p><ol><li>DirectX的HLSL：微软控制着色器编译，编译结果在不同硬件上相同，但平台有限。</li><li>OpenGL的GLSL：跨平台性良好，编译结果取决于硬件供应商。</li><li>NVIDIA的Cg：真正的跨平台。</li></ol><h3 id="DrawCall："><a href="#DrawCall：" class="headerlink" title="DrawCall："></a>DrawCall：</h3><p>CPU调用图像编程接口，命令GPU进行渲染的操作。</p><h3 id="Shader："><a href="#Shader：" class="headerlink" title="Shader："></a>Shader：</h3><ul><li>GPU流水线上一些可高度编程的阶段，由着色器编译出来的最终代码会在GPU上运行</li><li>有一些特定类型的着色器</li><li>依靠着色器来控制流水线中的渲染细节。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> Shader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>六月七日随笔</title>
      <link href="/2018/06/07/%E9%9A%8F%E7%AC%94/%E5%85%AD%E6%9C%88%E4%B8%83%E6%97%A5%E9%9A%8F%E7%AC%94/"/>
      <url>/2018/06/07/%E9%9A%8F%E7%AC%94/%E5%85%AD%E6%9C%88%E4%B8%83%E6%97%A5%E9%9A%8F%E7%AC%94/</url>
      
        <content type="html"><![CDATA[<p>无聊夜晚的碎碎念罢了。</p><a id="more"></a><p>近来还好。</p><p>不知道是什么原因，现在拿起笔或者打开word，面对着一片空白，总不知道该敲下点什么。但是偏偏又觉得应该写点什么，作为一种记录被遗忘，在机缘巧合之下向某个尘封已久的服务器发出一个请求，再把这点文字翻出来，以一种陌生人的眼光重新审视当时的自己。</p><p>事实上，以上所描述的情况很可能不会发生，于我自己而言，以往写过的那些烂东西（包括这一篇），我只能让它静静地躺在我的日志列表里，并不指望以后翻出来再得到什么愉悦的享受。</p><p>之所以有记录的想法，与对他人的效仿不无关系。去年工程实训的时候偶然接触到学长的游戏——《没有人知道的大冒险》，后来在种子班宣讲的时候才得知，原来这款游戏是学长所做。我对这个游戏本身所表达的内容很有感触，便由此对学长其人也生出了些许好奇。互联网是有记忆的，我还是找到了学长的博客，虽然它已经好久没有更新，但是我还是从他当时的文字中依稀看到他当时的状态。我想，文字的魅力在于，它无法向你描述所有，但是你却可以从文字本身生发出基于你人生经验的幻想世界。它或许只是一个截面、一个场景、甚至是一种氛围，但是却可以给你无比真实的代入感。</p><p>但是记录仅仅是记录本身，它代表着我当下思想的一部分——用文字所能表述的那部分。</p><p>很久没有读过书，我是指文学类的书籍。笼统的把原因归结为每天太忙其实是不成立的，每天固然有很多事情要去做，但是闲下来的时间，还是投入到了无限的收割快速愉悦事业中去了。刷刷微博、看看视频、翻翻好友的动态（所幸目前还没有接触短视频），我的大脑就告诉我：“哦，我感受到多巴胺了！”。纵使我知道这世界也没那么需要我，也没有什么动态是非我知道不可的，我还是这样做了。低级并快乐。</p><p>伴随而来的就是，快乐的阈值提高了，而表达自己的水平降低了。可表达的事情越来越少，能感触到的事情也越来越少。我从心底里觉得这不是什么好事，当一部分情绪很久不再出现在你的备选项中，其实是一件非常无聊的事情。就如同炒菜少了那么几位调料，寡淡而无趣。</p><p>很清楚的意识到这一点的时候，大概是在成都站的gamejam结束，当主持人宣布第二组入围的时候，我以为我会很开心，但是并没有发生。对事物的好奇、对成就的满足和那种单纯的想要做某件事情的欲望——这些好像都在离我而去。</p><p>当然，这或许可以解释为所谓的“佛系”或者“人间不值得”或者随便一句什么用烂了的腔调，但是我想我不该是这样，我想象中的自己是一个有血有肉的、愚蠢的、有着清楚欲望的年轻人，而不是一个默认着某些事情发生、而盲从于某些“看起来好”的人。</p><p>我知道这团火终归会熄，但至少不应该是现在。</p><p>无知且狂妄总要好过纠结且麻木，起码前者看起来还活着。</p><p>先记到这。</p>]]></content>
      
      
      <categories>
          
          <category> 文字 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity Shader 基础</title>
      <link href="/2018/05/11/Unity%E7%AC%94%E8%AE%B0/Unity-Shader-%E5%9F%BA%E7%A1%80/"/>
      <url>/2018/05/11/Unity%E7%AC%94%E8%AE%B0/Unity-Shader-%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>Unity Shader的一些基础知识<br><a id="more"></a></p><h3 id="Chapter3-Unity-Shader-基础"><a href="#Chapter3-Unity-Shader-基础" class="headerlink" title="Chapter3 Unity Shader 基础"></a>Chapter3 Unity Shader 基础</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>在Unity需要材质（Material）与Unity Shader配合使用来达到满意的效果。</p><ol><li>Unity Shader定义了渲染需要的各种<strong>代码</strong>（顶点着色器与片元着色器等），<strong>属性</strong>（使用哪些纹理）和<strong>指令</strong>（渲染和标签设置），我们通过材质调节这些属性，再赋给相应的模型。</li><li>材质：配合GameObject的Mesh或者Particle Systems组件来工作。</li><li>Unity Shader：<ol><li>Standard Surface Shader:使用了一个包含了标准光照模型的表面着色器模板</li><li>Unlit Shader: 一个不包含光照但是包含雾效的基本顶点/片元着色器</li><li>Image Effect Shader: 为实现屏幕后处理提供基本模板</li><li>Compute Shader: 借助GPU的并行性来进行一些与渲染流水线无关的计算</li></ol></li></ol><h4 id="ShaderLab"><a href="#ShaderLab" class="headerlink" title="ShaderLab"></a>ShaderLab</h4><p>一款专门为Unity Shader服务的语言。</p><h5 id="Properties-属性"><a href="#Properties-属性" class="headerlink" title="Properties 属性"></a>Properties 属性</h5><ol><li>语句格式：<code>Name(&quot;display name&quot;,PropertyType)=DefaultValue</code></li><li>支持的属性类型：<br> |属性类型|定义语法|<br> |:——–:|:——–:|<br> |Int|number|<br> |Float|number|<br> |Range(min,max)|number|<br> |Color|(number,number,number,number)|<br> |Vector|(number,number,number,number)|<br> |2D|”defaulttexture”{}|<br> |Cube|”defaulttexture”{}|<br> |3D|”defaulttexture”{}|</li></ol><blockquote><p>Unity允许重载默认的材质编辑面板以提供更多的自定义数据类型。 关键词“Custom Shader GUI”<br>Properties语义块的作用仅仅是为了让这些属性可以出现在材质面板里。</p></blockquote><h5 id="SubShader-表面着色器"><a href="#SubShader-表面着色器" class="headerlink" title="SubShader:表面着色器"></a>SubShader:表面着色器</h5><ol><li><p>语句格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SubShader&#123;</span><br><span class="line">//可选的，标签</span><br><span class="line">[Tags]</span><br><span class="line"></span><br><span class="line">//可选的，状态</span><br><span class="line">[RenderSetup]</span><br><span class="line"></span><br><span class="line">//一次完整的渲染流程，如果pass的数目过多，会造成渲染性能的下降。</span><br><span class="line">Pass&#123;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>RenderSetup 状态：关于渲染状态的设置指令<br>| 状态名称 | 设置指令 |解释|<br>|:——–:|:——–:|:—-:|<br>|   Cull     |Cull Back/Front/Off|  剔除模式：剔除背面/正面/关闭剔除|<br>|ZTest|ZTest Less Greater/LEqual/GEqual/Equal/NotEqual/Always|设置深度剔除时使用的函数|<br>|ZWrite|ZWrite On/Off|关闭/开启深度写入|<br>|Blend|Blend SrcFactor DstFactor|开启并设置混合模式|</p></li><li><p>Tags 标签：希望怎样以及何时渲染这个对象<code>Tags{&quot;TagName1&quot;=&quot;Value1&quot; &quot;TagName2&quot;=&quot;Value2&quot;}</code><br>| 标签类型 | 说明 |<br>|——–|——–|<br>| Queue | 控制渲染顺序，指定该物体属于哪一个渲染队列 |<br>|RenderType|对着色器进行分类，可以用于着色器替换功能|<br>|DisableBatching|指明是否对该SubShader使用批处理|<br>|ForceNoShadowCasting|控制使用该SubShader的物体是否会投射阴影|<br>|IgnoreProjector|控制使用该SubShader的物体是否受projector（投影仪？）的影响|<br>|CanUseSpriteAtlas|当该SubShader是用于sprite时，将该标签设为“false”|<br>|PreviewType|指明材质面板将如何预览该材质。默认材质下，材质将显示为一个球形，我们可以通过将该标签的值设为“Plane”“SkyBox”来改变预览类型|<br>上述标签可以在SubShader中声明，而不可以在Pass块中声明，Pass块有专属于自己的标签。</p></li><li><p>Pass语义块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Pass&#123;</span><br><span class="line">    [Name]</span><br><span class="line">    [Tag]</span><br><span class="line">    [RenderSetup]</span><br><span class="line">    // Other code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>Name “MyPassName”：定义该Pass的名称，可以使用UsePass命令来直接使用其他unity shader中的Pass，例如：<code>UsePass &quot;MyShader/MYPASSNAME&quot;</code>，由于Unity 内部会将所有Pass 名称转换为大写字母的表示，所以在使用UsePass的时候必须使用大写形式的名字。</li><li>RenderSetup：我们可以对Pass设置渲染状态，除上述状态设置以外，我们还可以使用固定管线的着色器。</li><li><p>Tag：<br>|标签类型|说明|例子|<br>|—|—-|—|<br>|LightMode|定义该Pass在Unity渲染流水线中的角色|Tags{“LightMode”=”ForwardBase”}|<br>|RequireOptions|用于制定当满足某些条件的时候才渲染该Pass，它的值是一个由空格分割的字符串，目前支持的选项：SoftVegetation|Tags{“RequireOptions”=”SoftVegetation”}|</p></li><li><p>特殊的Pass：</p><ul><li><p>UsePass：使用该指令复用其他UnityShader中的Pass。</p></li><li><p>GrabPass：负责抓取屏幕并将结果存储在一张纹理之中，以用于后续的Pass 处理。</p></li></ul></li></ol></li></ol><h5 id="FallBack"><a href="#FallBack" class="headerlink" title="FallBack"></a>FallBack</h5><p>如果上面所有的SubShader在这块显卡上都不能运行，那么就用这个最低级的Shader。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FallBack &quot;name&quot;</span><br><span class="line">// 或者</span><br><span class="line">FallBack Off</span><br></pre></td></tr></table></figure><p>通过一个字符串通知引擎最低级的Shader是哪个，也可以关闭Fallback功能——如果上述的SubShader无法使用，那就不要管它了。</p><h5 id="其他语义"><a href="#其他语义" class="headerlink" title="其他语义"></a>其他语义</h5><ul><li>拓展编辑界面：CustomEditor</li><li>对命令进行分组：CateGory</li></ul><h4 id="UnityShader的形式"><a href="#UnityShader的形式" class="headerlink" title="UnityShader的形式"></a>UnityShader的形式</h4><p>ShaderLab语句块：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Myshader&quot;&#123;</span><br><span class="line">    Properties&#123;</span><br><span class="line">        // 所需的各种属性</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader&#123;</span><br><span class="line">        // 真正意义上的SubShdaer代码会出现在这里</span><br><span class="line">        // 表面着色器(Surface Shader)</span><br><span class="line">        // 顶点/片元着色器(Vertex/Fragment Shader)</span><br><span class="line">        // 固定函数着色器(Fixed Function Shader)</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader&#123;</span><br><span class="line">        // 与上一个Shader类似</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="表面着色器"><a href="#表面着色器" class="headerlink" title="表面着色器"></a>表面着色器</h5><p>当给Unity提供一个表面着色器的时候，它在背后依旧将其转换为对应的顶点/片元着色器。意义在于Unity为我们处理了很多光照细节，使得我们无需再操心这些事情。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Custom/Simple Surface Shader&quot;&#123;</span><br><span class="line">    SubShader&#123;</span><br><span class="line">        Tags&#123; &quot;RenderType&quot; = &quot;Opaque&quot; &#125;</span><br><span class="line">        CGPROGRAM</span><br><span class="line">        #pragma surface surf Lambert</span><br><span class="line">        struct Input &#123;</span><br><span class="line">            float4 color:COLOR;</span><br><span class="line">        &#125;;</span><br><span class="line">        void surf (Input IN,inout SurfaceOutput o)</span><br><span class="line">        &#123;</span><br><span class="line">            o.Albedo = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        ENDCG</span><br><span class="line">    &#125;</span><br><span class="line">    Fallback &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表面着色器被定义在SubShader语义块中的CGPROGRAM与ENDCG之间。之间的代码使用Cg/HLSL语言编写，它嵌套在ShaderLab语言中。</p><h5 id="顶点-片元着色器"><a href="#顶点-片元着色器" class="headerlink" title="顶点/片元着色器"></a>顶点/片元着色器</h5><p>顶点/片元着色器的代码需要定义在CGPROGRAM与ENDCG之间，而着色器是写在Pass语义块内，而非SubShader内，这样做来定义每个Pass需要的Shader代码，灵活性更高，同时控制渲染的实现细节。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Custom/Simple VertexFragment Shader&quot;&#123;</span><br><span class="line">    SubShader&#123;</span><br><span class="line">        Pass&#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line"></span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line"></span><br><span class="line">            float4 vert(float4 v:POSITION):SV_POSITION&#123;</span><br><span class="line">                return mul(UNITY_MATRIX_MVP,v);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag():SV_Target&#123;</span><br><span class="line">                return fixed4(1.0,0.0,0.0,1.0);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="固定函数着色器"><a href="#固定函数着色器" class="headerlink" title="固定函数着色器"></a>固定函数着色器</h5><p>上面两种UnityShader形式都使用了可编程管线，而对于一些旧的设备不支持可编程管线着色器，此时需要使用固定函数着色器来完成渲染，这些着色器往往只可以完成一些非常简单的效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Tutorial/Basic&quot;&#123;</span><br><span class="line">    Properties&#123;</span><br><span class="line">        _Color(&quot;Main Color&quot;,color)=(1.0,5.0,5.1)</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader&#123;</span><br><span class="line">        Pass&#123;</span><br><span class="line">            Material&#123;</span><br><span class="line">                Diffuse[_Color]</span><br><span class="line">            &#125;</span><br><span class="line">            Lighting On</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="乐乐女神的一些建议："><a href="#乐乐女神的一些建议：" class="headerlink" title="乐乐女神的一些建议："></a>乐乐女神的一些建议：</h5><ul><li>除非有明确的需求必须要使用固定函数着色器，否则请使用可编程管线的着色器。</li><li>如果想和各种光源打交道，你可能更喜欢表面着色器，但需要小心它在移动平台的性能表现。</li><li>如果需要使用的光照数目非常少，使用顶点/片元着色器是一个更好的选择。</li><li>如果有很多自定义的渲染效果，请选择顶点/片元着色器。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> Shader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Unity】 Cursor学习</title>
      <link href="/2018/04/11/Unity%E7%AC%94%E8%AE%B0/Unity-Cursor%E5%AD%A6%E4%B9%A0/"/>
      <url>/2018/04/11/Unity%E7%AC%94%E8%AE%B0/Unity-Cursor%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>关于CursorLockMode 光标锁定模式的一个随手记。<br><a id="more"></a></p><ul><li><p>CursorLockMode.None 光标行为未修改，第一人称视角下鼠标可以突破窗口。</p></li><li><p>CursorLockMode.Locked 光标锁定到游戏窗口的中心，与全屏与否无关，同时<strong>隐藏光标</strong>（这一点在3D相机下成立，在2D相机下貌似不成立，还需要用visible来控制隐藏），无论如何移动光标光标都无法出现，按‘esc’切换到None模式。</p></li><li><p>CursorLockMode.Confined 光标限制在游戏窗口内，光标不会隐藏，在窗口模式下无法突破窗口，限制在窗口区域内。</p></li><li><p>Cursor.visible 光标可见性，和人感觉用来实现鼠标隐藏的效果并不好，或许和Confined联合可以有Locked的效果？那为什么不用Locked呢……</p></li></ul><h5 id="示例代码：https-docs-unity3d-com-ScriptReference-Cursor-lockState-html"><a href="#示例代码：https-docs-unity3d-com-ScriptReference-Cursor-lockState-html" class="headerlink" title="示例代码：https://docs.unity3d.com/ScriptReference/Cursor-lockState.html"></a>示例代码：<a href="https://docs.unity3d.com/ScriptReference/Cursor-lockState.html" target="_blank" rel="noopener">https://docs.unity3d.com/ScriptReference/Cursor-lockState.html</a></h5><h5 id="资料来源：http-wiki-ceeger-com-script-unityengine-enumerations-cursorlockmode-cursorlockmode"><a href="#资料来源：http-wiki-ceeger-com-script-unityengine-enumerations-cursorlockmode-cursorlockmode" class="headerlink" title="资料来源：http://wiki.ceeger.com/script/unityengine/enumerations/cursorlockmode/cursorlockmode"></a>资料来源：<a href="http://wiki.ceeger.com/script/unityengine/enumerations/cursorlockmode/cursorlockmode" target="_blank" rel="noopener">http://wiki.ceeger.com/script/unityengine/enumerations/cursorlockmode/cursorlockmode</a></h5>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> unity学习 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
