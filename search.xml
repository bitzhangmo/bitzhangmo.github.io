<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[“2020年第16周周报”]]></title>
    <url>%2F2020%2F04%2F20%2F%E4%B8%AA%E4%BA%BA%E6%8A%A5%E5%91%8A%2F202016%2F</url>
    <content type="text"><![CDATA[这是2020年的第16周报告。 上周计划完成情况上周实际上没有什么计划，说起来这是第一次正式记录周报，就写这些好了。 本周做了什么本周实际上也没有完成什么特别值得拿来说说的事情。 消费： 路由器：京东上买的TP-LINK WDR7660千兆路由器，189.90元。 动机：买这个的缘由是觉得内蒙广电这里的机顶盒&amp;路由器太垃圾了（误），所以想换一个相对好一点点的路由器，上知乎看了一圈，买了这个。家里的宽带实际上只有100M，想着饱和式配置，就直接上了一个千兆的路由器，如果以后升级宽带就能派上用场了，就算不能，那其实这100M的宽带也能跑满。 体验：目前还可以，算是从东非走出来了，终于从手动在浏览器里输入192.168.1.1变成了在手机&amp;电脑双端都能进行控制，美中不足的是这个路由器貌似可玩性小一点，不能自己设置加速器的相关配置，不过一分钱一分货，也没什么奢望了。 输出： 博客相关：探索了一下关于hexo模版以及生成命令的知识 比如这篇博客，生成的命令就是hexo new report -p /个人报告/202016 “2020年第16周周报”，这行命令会从我写好的report模版出发，在-post文件夹下的「个人报告」文件夹中生成一篇报告，这样做的好处是省去了一些手动复制的过程，比较省事，同时看起来比较整洁。 社交媒体：没有什么值得一说的更新。 输入： 《我是于欢水》：看了这部电视剧，感觉还可以，一开始在朋友的豆瓣动态里看过，后来因为有关女权的争论所以打算看看。不到一下午的时间，用2倍速看完了这部剧。一些内容不能细品，另外一些内容又详细的出人意料，我不喜欢国产电视剧的一个原因在于感觉房间里的布景太亮了，过于惨白，以至于有一种隔阂感。日剧里的房间给我的印象都是暖黄色的光，比较柔和。此外还有一点就是有的时候主人公居住的环境往往超过他的消费水平，让我感觉非常突兀。说回这部剧，如果你把他当作一个重逻辑的电视剧去推敲可能会大失所望；但如果你就把他当作茶余饭后打发时间的剧，那还是能看看的。 《OpenGL ES 3.0 编程指南》：非常粗浅的翻阅了开头，记录了一下ES2.0与ES3.0的差别，作为毕业设计测试API的选取标准。 看了一下有关斐讯的新闻，为了骗钱真是什么手段都有啊，防不胜防。 事件： 笔记本电脑电池彻底不行了，只有33%的容量了，而且现在也完全充不进去电了，打算忙完毕设之后就保存数据，再之后要么换个新电脑，要么换个新电池了。 忘了买大头菜了，血亏。 下周打算做点什么 毕设：把测试用例写完，虽然感觉大概率是我自己写，而不是从CTS这个项目里移植过来。然后把日志整理出来，再写一份论文初稿。 出门走走：买了相机之后利用率不高，希望下周开始能出门透透气，顺便拍点东西。 调整作息：就像这篇周报写完的此刻，已经是00:52分了，希望之后能12点前睡觉，早上早点起床。]]></content>
      <categories>
        <category>reports</category>
      </categories>
      <tags>
        <tag>report</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[转载]C++ typedef的详细用法]]></title>
    <url>%2F2020%2F03%2F18%2FC%2B%2BPrimer%E7%AC%94%E8%AE%B0%2F%E8%BD%AC%E8%BD%BD-C-typedef%E7%9A%84%E8%AF%A6%E7%BB%86%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[转自知乎的一段解释 作者：婉儿飞飞链接：https://www.zhihu.com/question/29798061/answer/144423125来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 不太想谈#define, 在题主的例子的这种用法里, 它就是个文本替换工具, 预处理器完成的, 无脑替换, 跟word里的replace一模一样, 不关编译器的事. 我想谈一下typedef. 搞懂了c++创始人写的the design and evolution of cpp中的下面这个例子, 有助于你理解typedef: 123456typedef int P();typedef int Q();class X &#123; static P(Q); // 等价于`static int Q()`, Q在此作用域中不再是一个类型 static Q(P); // 等价于`static int Q(int ())`, 定义了一个名为Q的function&#125;; 这是一个极好的例子, 先问一下 typedef int P()到底做了什么? 其实是: declares a function type P as returning an int and taking no arguments. 1. 官方定义初次接触此类typedef用法的程序员直观上理解这个例子比较困难, 我们来看一下typedef的官方定义: Typedef does not work like typedef [type] [new name]. The [new name] part does not always come at the end. You should look at it this way: if [some declaration] declares a variable, typedef [same declaration] would define a type. 看我标黑的这句话, 总结一下就是: 任何声明变量的语句前面加上typedef之后，原来是变量的都变成一种类型。不管这个声明中的标识符号出现在中间还是最后. 2. 隐藏技能 typedef 定义的新类型, 使用时可以省略括号. 什么意思? 123typedef int NUM;NUM a = 10; // 也可写成`NUM(a) = 10;`NUM(b) = 12; // 也可写成`NUM b = 12;` 3. 举例先从初级的开始: 整形 1typedef int x; // 定义了一个名为x的int类型 结构体 1typedef struct &#123; char c; &#125; s; // 定义名为s的struct类型 指针 1typedef int *p; //定义了一个名为p的指针类型, 它指向int (中文描述指针好累) 接下来是高级的(注意标识符不一定在最后):数组 1typedef int A[]; // 定义一个名为A的ints数组的类型 函数 12typedef int f(); // 定义一个名为f, 参数为空, 返回值为int的函数类型typedef int g(int); // 定义一个名为g, 含一个int参数, 返回值为int行的函数类型 现在回过头看: 12typedef int P();static P(Q); 应该就比较好理解了, P是一个新定义的function类型, 它返回值为int, 无参数根据我的第2点说明, P(Q); 实际上等价于P Q, 声明Q是一个返回值为int, 无参数的函数. 这玩意有什么用呢?我们都知道C++语言里, 函数都是先声明后使用的(除非在使用之前定义), 看以下例子: 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;string&gt;typedef int P(); // 简单的typedef void Q(int *p, const std::string&amp; s1, const std::string&amp; s2, size_t size, bool is_true); // 复杂的class X &#123;public: P(eat_shit); // 等价于声明`int eat_shit();` Q(bullshit); // 等价于声明`void bullshit(int *p, const string&amp; s1, const string&amp; s2, size_t size, bool is_true);`&#125;;int main() &#123; X *xx; printf("shit ret: %d\n", xx-&gt;eat_shit()); int a[] = &#123;1, 3, 4, 5, 7&#125;; xx-&gt;bullshit(a, "foo", "bar", sizeof(a)/sizeof(int), true);&#125;int X::eat_shit() &#123; return 888;&#125;void X::bullshit(int *p, const std::string&amp; s1, const std::string&amp; s2, size_t size, bool is_true) &#123; std::cout &lt;&lt; "s1: " &lt;&lt; s1 &lt;&lt; ", s2: " &lt;&lt; s2 &lt;&lt; ", size: " &lt;&lt; size &lt;&lt; std::endl; printf("elems:\n"); for(int i = 0; i &lt; size; i++) &#123; printf("%d %s", *p++, (i == size-1) ? "" : ","); &#125; printf("\n");&#125; 怎么样, typedef技能点亮了吗? :) 转自CSDN的一段解释 作者：hai008007 链接：https://blog.csdn.net/hai008007/article/details/80651886 在阅读Linux的内核代码是经常会遇到一些复杂的声明和定义，例如： 12345678void* (*(*fp1)(int)) [10];float (*(*fp2)(int,int,float)) (int);typedef double (*(*(*fp3)()) [10]) ();fp3 a;int (*(*fp4())[10]) (); 刚看到这些声明或者定义时，一些初学者甚至有一定经验的工程师都有可能头皮发毛，基于大惑不解。如果缺乏经验和方法来对这些内容进行理解，势必会让我们浪费大量的时间。 我尝试对这些内容进行疏理和总结，为自己和有同样困惑的同学答疑解惑。要理解这些复杂的声明和定义，我觉得首先不能着急，应该由浅而深，逐步突破。下面先看一些简单的定义： 123456//1. 定义一个整型数int a;//2. 定义一个指向整型数的指针int *p;//3. 定义一个指向指针的指针，它指向的指针指向一个整型数int **pp; 到这一步我想大多数人都还好理解，我们可以用一些简单的代码把这三条给串起来： 12p = &amp;a; // p指向整数a所在的地址pp = &amp;p; // pp指向指针p 1234//4. 定义一个包含10个整型数的数组int arr[10];//5. 定义一个指向包含10个整型数数组的指针int (*pArr) [10]; 用几行代码将4、5两个定义串起来： 123int arr[10];int (*pArr) [10];pArr = &amp;arr; 1234//6. 定义一个指向函数的指针，被指向的函数有一个整型参数并返回整型值int (*pfunc) (int);//7. 定义一个包含10个指针的数组，其中包含的指针指向函数，这些函数有一个整型参数并返回整型值int (*arr[10]) (int); 用几行代码将6、7两个定义串起来： 123int (*pfunc) (int);int (*arr[10]) (int);arr[0] = pfunc; 到这一步，似乎就不是那么好理解了。现在需要请出用于理解复杂定义的“右左法则”： 从变量名看起，先往右，再往左，碰到圆括号就调转阅读的方向；括号内分析完就跳出括号，还是先右后左的顺序。如此循环，直到分析完整个定义。 让我们用这个方法来分析上面的第6条定义：int (*pfunc) (int); 找到变量名pfunc，先往右是圆括号，调转方向，左边是一个*号，这说明pfunc是一个指针；然后跳出这个圆括号，先看右边，又遇到圆括号，这说明(*pfunc)是一个函数，所以pfunc是一个指向这类函数的指针，即函数指针，这类函数具有一个int类型的参数，返回值类型是int。 接着分析第7条定义：int (*arr[10]) (int); 找到变量名arr，先往右是[]运算符，说明arr是一个数组；再往左是一个*号，说明arr数组的元素是指针（注意：这里的*修饰的不是arr，而是arr[10]。原因是[]运算符的优先级比*要高，arr先与[]结合。）；跳出圆括号，先往右又遇到圆括号，说明arr数组的元素是指向函数的指针，它指向的函数有一个int类型的参数，返回值类型是int。 分析完这两个定义，相信多数人心里面应该有点谱了。可应该还有人会问：怎么判断定义的是函数指针（定义6），还是数组指针（定义5），或是数组（定义7）？可以抽象出几个模式： type (*var)(...); ：变量名var与结合，被圆括号括起来，右边是参数列表。表明这是*函数指针 type (*var)[]; ：变量名var与结合，被圆括号括起来，右边是[]运算符。表示这是*数组指针 type (*var[])...; ： 变量名var先与[]结合，说明这是一个数组（至于数组包含的是什么，由旁边的修饰决定） 至此，我们应该有能力分析文章开始列出来了几条声明和定义： 1void *(*(*fp1)(int)) [10]; 找到变量名fp1，往右看是圆括号，调转方向往左看到*号，说明fp1是一个指针；跳出内层圆括号，往右看是参数列表，说明fp1是一个函数指针，接着往左看是*号，说明指向的函数返回值是指针；再跳出外层圆括号，往右看是[]运算符，说明函数返回的是一个数组指针，往左看是void *，说明数组包含的类型是void *。简言之，fp1是一个指向函数的指针，该函数接受一个整型参数并返回一个指向含有10个void指针数组的指针。 1float (*(*fp2)(int, int, float)) (int); 找到变量名fp2，往右看是圆括号，调转方向往左看到*号，说明fp2是一个指针；跳出内层圆括号，往右看是参数列表，说明fp2是一个函数指针，接着往左看是*号，说明指向的函数返回值是指针；再跳出外层圆括号，往右看还是参数列表，说明返回的指针是一个函数指针，该函数有一个int类型的参数，返回值类型是float。简言之，fp2是一个指向函数的指针，该函数接受三个参数(int,int,float)，且返回一个指向函数的指针，该函数接受一个整型参数并返回一个float。 12typedef double (*(*(*fp3)()) [10]) ();fp3 a; 如果创建许多复杂的定义，可以使用typedef。这一条显示typedef是如何缩短复杂的定义的。 跟前面一样，先找到变量名fp3（这里fp3其实是新类型名），往右看是圆括号，调转方向往左是*，说明fp3是一个指针；跳出圆括号，往右看是空参数列表，说明fp3是一个函数指针，接着往左是*号，说明该函数的返回值是一个指针；跳出第二层圆括号，往右是[]运算符，说明函数的返回值是一个数组指针，接着往左是*号，说明数组中包含的是指针；跳出第三层圆括号，往右是参数列表，说明数组中包含的是函数指针，这些函数没有参数，返回值类型是double。简言之，fp3是一个指向函数的指针，该函数无参数，且返回一个含有10个指向函数指针的数组的指针，这些函数不接受参数且返回double值。 这二行接着说明：a是fp3类型中的一个。 1int (*(*fp4()) [10]) (); 这里fp4不是变量定义，而是一个函数声明。 找到变量名fp4，往右是一个无参参数列表，说明fp4是一个函数，接着往左是*号，说明函数返回值是一个指针；跳出里层圆括号，往右是[]运算符，说明fp4的函数返回值是一个指向数组的指针，往左是*号，说明数组中包含的元素是指针；跳出外层圆括号，往右是一个无参参数列表，说明数组中包含的元素是函数指针，这些函数没有参数，返回值的类型是int。简言之，fp4是一个返回指针的函数，该指针指向含有10个函数指针的数组，这些函数不接受参数且返回整型值。 用typedef简化复杂的声明和定义以上我们已经看到了不少复杂的声明和定义，这里再举一个例子： 1int *(*a[10]) (int, char*); 用前面的“右左法则”，我们可以很快弄清楚：a是一个包含10个函数指针的数组，这些函数的参数列表是(int, char*)，返回值类型是int*。理解已经不成问题，这里的关键是如果要定义相同类型的变量b，都得重复书写： 1int *(*b[10]) (int, char*); 这里有没有方便的办法避免这样没有价值的重复？答案就是用typedef来简化复杂的声明和定义。 typedef可以给现有的类型起个别名。这里用typedef给以上a、b的类型起个别名： 1typedef int *(*A[10]) (int, char*); // 在之前定义的前面加入typedef，然后将变量名a替换成类型名A 现在要再定义相同类型的变量c，只需要： 1A c; 再看一例： 1void (*b[10]) (void (*)()); 先替换右边括号里面的参数，将void (*)()的类型起个别名pParam： 1typedef void(*pParam) (); 再替换左边的变量b，为b的类型起个别名B： 1typedef void(*B) (pParam); 原声明的简化版： 1B b[10];]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《小狗钱钱》读书笔记]]></title>
    <url>%2F2020%2F03%2F10%2F%E9%9A%8F%E7%AC%94%2F%E3%80%8A%E5%B0%8F%E7%8B%97%E9%92%B1%E9%92%B1%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[书中的一些观点收录： 关于培养自信 「尝试」纯粹是一种借口，你还没有做，就已经给自己想好了退路。不能试验，你只有两个选择——做或者不做。 你的自信程度决定了你是否相信自己的能力，是否相信你自己。假如你根本不相信你能做到的话，那么你就根本不会动手去做，而假如你不开始去做，那么你就什么也得不到。 首先，在遇到困难的时候，仍然要坚持自己的想法。一切正常的时候，每个人都能做到这一点。只有当真正的困难出现时才能见分晓。只有少数人能坚定不移地贯彻自己的计划。那些非常成功的人，甚至有能力在他们最困难的时候作出最杰出的表现。 最珍贵的礼物是我们自己争取来的。克服了丢面子的恐惧，世界就会向你敞开大门！ 恐惧总是出现在我们设想事情会如何不顺的时候。我们对失败的可能性想得越多，就会越害怕。而当你看着自己的成功日记时，你就会注意到那些成功的事情，自然而然也就会想到应该怎样去做。——当你朝着积极的目标去思考的时候，就不会心生畏惧。 如果你没有做今天这件事情，你就永远不会知道，给自己一些压力之后，你能够做到些什么。一个人觉得最引以为自豪的事情，往往是那些做起来最艰难的事情。这一点你千万不要忘记。 我自己是一个很没有自信的人，时常会因为对未知的恐惧和对自己能力的不相信去逃避一些事情，还会因为过高的自尊心导致胆怯占了上风，这点是我性格上的一个缺陷，如果能更坚定和自信一点应该会有更多的产出。 首先相信自己可以做到，其次决定了去做就坚定去做，不要留退路，最后遇到困难要坚持想法，坚定不移的贯彻自己的计划。 遇到事情想的周全并不是坏处，但是思考并不是搁置不做的理由，看清某件事情的利害关系，然后积极的推动这件事情向积极的方向转变。 推自己一把。 关于自我提升 学习就是认识新观念和新想法的过程。我们对一件事投入的精力越多，成功的可能性也越大。可是大多数人把精力放在自己并不喜欢的事情上，而不去想象自己希望得到的东西。 吉娅，你现在可能不相信我说的话，但如果你的零花钱是现在的10倍的话，你的问题只会变得更加严重。因为我们的支出永远是随着我们的收入而增长的。 第一，无论在什么时候都不能把希望只寄托在一份工作上，它持续的时间不会像你设想的那么长，所以你要立即寻找另一份替代的工作。 第二，你肯定会遇到一些困难，”马赛尔接着说，“这些困难是你现在还难以预料的。到那时候就能看出来，你到底是一个洋娃娃似的胆小鬼呢，还是一个像我一样能挣很多钱的人。情况顺利的时候，人人都能挣到钱。只有在逆境中，一切才能见分晓。 困难总是在不断地出现。尽管如此，你每天还是要不间断地去做对你的未来意义重大的事情。你为此花费的时间不会超过10分钟，但是就是这10分钟会让一切变得不同。大多数人总是在现有的水平上停滞不前，就是因为他们没有拿出这10分钟。他们总是期望情况能向有利于自己的方向转变，但是他们忽视了一点，那就是他们首先必须改变自己。 在一切进展非常顺利的情况下，你也应该做这些事情。 很简单。当你决定做一件事情的时候，你必须在72小时之内完成，否则你很可能永远不会再做了。 大多数人都认为工作肯定是一件艰苦而令人不愉快的事情，”他向我解释道，“其实只有做自己喜欢的事情的人，才能真正获得成功。 以前我总是告诉自己：“一旦我真的好好学习，拼命做题，就能马上得到好成绩。”现在我发觉这只不过是自己用来推脱的一个借口而已。此刻，当我真的付出全部努力的时候，就不再需要这个借口了。我显露出了自己真正的潜能。我对自己的这一切变化感到又惊讶又兴奋。 保持对世界的好奇，享受探求新知的过程，确定一个欲望清单并有计划的去清理掉。欲望清单这一点虽然之前会列一个大致的内容，但是对这个清单执行的方法并不合适，这一点需要重新审视一下。 王权没有永恒。要保持对于时代、对于行业、对于自身的危机感。培养自己一技之长以外的另一项技术（手艺）算是人生银行的第二投资，太平顺的人生或许会有，但是问问自己是否有那种运气，这种危机感实际上是对于自身增加抗风险能力的内在驱动。 坚持。改变自己这件事要有意识的去做，无论是个人健康、技能、认知还是财富增长，不进则退。 执行力，如果一件事情已经决定去做那就要不折不扣的去执行。 关于消费 第一，欠债的人应当毁掉所有的信用卡。因为大多数人在使用信用卡的时候，会比使用现金时花的钱要多得多。 第二个忠告是，应当尽可能少地偿还贷款——也就是大人们说的分期付款。也许这个忠告听起来有点儿可笑，但你要知道，分期付款额越高，每个月剩下的生活费就越少。 第三个忠告是针对消费贷款的。消费贷款是与住房无关的贷款。假如人们为了购置新的汽车、家具、电视机或其他用于生活的商品而贷款，就是消费贷款。这时候贷款的人应当遵守的一个原则，就是将不用于生活的那部分钱的一半存起来，另一半用于偿还贷款。 债务人都应该在自己的钱包里贴一张纸条，上面写着‘这真的有必要吗’。这样的话，当他站在收银台前的时候，就会想到不应该花太多的钱。 这一段实际上说了几点：对于超前消费的谨慎；对于消费与储蓄占比的调配；对于非理性消费的警惕。 超前消费实际上是向未来借贷，其所花费的成本要比直观上的金钱要多，除了因超前消费带来的利息以外，还有一些丧失掉的机会成本，所以超前消费需要谨慎。虽然并不是完全抵制，但是要计算好实际发生的成本。 消费如果投入了所有的资金，就没有资金去进行再生产。 非理性消费实际上是最亏的一种消费（想起了之前买过的网课）；既白白花费了金钱，又会带来一些管理上的成本以及情绪成本，非常不值得。 关于金钱观 这完全要根据你的目标来决定。如果你总是把10%的钱变成‘鹅’，那么你一定会变得富有。但如果你想有一天真的非常有钱的话，你存的比例可能得再高一些。我的习惯是把我收入的50%变成我的‘鹅’。 你干的活最多只值报酬的一半，另一半报酬源于你的想法和实施这个想法的勇气。 金钱本身既不会使人幸福，也不会带来不幸。金钱是中性的，既不好，也不坏。只有当钱属于某一个人的时候，它才会对这个人产生好的影响或者坏的影响。钱可以被用于好的用途，也可以被用于坏的用途。一个幸福的人有了钱会更幸福；而一个悲观忧虑的人，钱越多，烦恼就越多。 要养成储蓄的好习惯，这里的储蓄不是单纯将钱存起来，而是让钱再去生钱，即文中所说的“鹅”。 对于自己应得的报酬不要羞愧，哪怕它看起来高于市场价；观念本身与实际行动都是一种资源，不应厚此薄彼。 正确看待金钱，并加以利用，利用到积极的方面去。 关于投资 应该把钱投资在安全的地方；我的钱应该下很多“金蛋“；我们的投资应该简单明了。 但是只有当你出售股票的时候，你才会亏损。如果你保留着这些股份，将来可能会有人愿意付更多的钱来买进。 基金符合投资的一切要求。由于它的这些特点，它也非常适合儿童和青少年。如果能够在5～10年内不动用这些钱，基金投资是很保险的，它会带来丰厚的利润…… 挑选基金时的注意事项：1．基金应该至少有10年历史。假如它在这么长时间内一直有丰厚的利润，那我们可以认为，未来它也会运作良好。2．应该选择大型的跨国股票基金。这种基金在世界各地购买股票，以此分散风险，所以十分安全。3．对基金的走势图进行比较。我们应该观察在过去10年间哪些基金的年终利润最好。 你们直接用72除以你们投资的年利润百分比，得出的数字就是这笔钱翻一倍所要的年数。 可是如果行情继续下跌怎么办呢？所以你最好不要投入太多的钱。而且如果行情真的继续下跌，那时要是你手头还有钱用来再一次买进的话，不是更好吗？ 没错，我们是不知道。没有人能知道，所有试图预测未来走势的专家总是计算失误，意想不到的情况很多。正因为如此，你应该始终储备一些现金。决不能把你全部的钱都投资在股票或者基金上面。的确很保险，尤其是当你有足够的时间可以等待的时候。就算行情暂时处于谷底，到时总会回升的。但是出于分散风险的考虑，你应该把一部分钱投资在绝对安全的地方。 你说得也对，但是我们几乎没有别的选择。你总不能把你所有的钱都投资买股票。就算你还很年轻，也该留一些现金做储备。只有这样才能达到分散风险的最佳效果。”我将信将疑地说：“银行的利率没有超过3.5%的吗？”“当然也有一些储蓄种类的利率比较高，可是你必须把钱放在银行里存很长一段时间。这种方式的坏处是，碰上再次买进的合适时机，你不能马上采取行动。 安全，安全，还是他妈的安全。当然这里指的是相对安全，风险伴随着安全，也可以看作是安全的一部分，或者说成本的一部分，注意安全并不妨碍冒一定的风险，前提是对自己抗风险能力有一个清楚认知的情况下。君不见各种P2P暴雷倾家荡产的案例，一部分当然归结于盲目、贪婪等人性上的弱点，但还有一部分要归结到对自己风险控制能力的过于自信——后人哀之而不鉴之，则…… 没卖等于没亏很反我的直觉，但是思考了一下，理想情况下（非理想情况指停牌或者其他的奇怪的情况）是这样的。 对基金的看法保留意见，需要再详细了解下这种投资形式。 合理分配自己的生产资料，使得自己在良好的抗风险情况下，去用一部分生产资料换取更多的生产资料。甚至可以递归抗风险，把冒风险的一部分再分成相对危险和相对安全的部分，进一步稀释风险。可能有什么专业术语描述这种行为，但是以我现在的认知水准说不出来。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>投资</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ Primer 读书笔记（1）字符串、向量和数组]]></title>
    <url>%2F2020%2F03%2F07%2FC%2B%2BPrimer%E7%AC%94%E8%AE%B0%2FC-Primer-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[3.1 命名空间的using声明头文件不应该包含using声明，因为头文件的内容会拷贝到所有引用它的文件中去，如果头文件中里有某个using声明，那么每个使用了该头文件的文件就都会有这个声明。对于某些程序来说，由于不经意间包含了一些名字，反而可能产生始料未及的名字冲突。 3.2 标准库类型string标准库类型string表示可变长的字符序列。 123456string s1; // 默认初始化，s1是一个空串string s2(s1); // s2是s1的副本string s2 = s1; // 等价于上条string s3("value"); // s3是字面值“value”的副本，除了字面值最后的那个空字符外，直接初始化string s3 = "value"; // 等价于上条，拷贝初始化string s4(n,'c'); // 把s4初始化为由连续n个字符c组成的串 当把string对象和字符字面值及字符串字面值混在一条语句中使用时，必须确保每个加法运算符（+）两侧的运算对象至少有一个是string： 12345678string s4 = s1 + ","; // 正确：把一个string对象和一个字面值相加string s5 = "hello" + ","; // 错误，两个运算对象都不是stringstring s6 = s1 + "," + "world"; // 正确，每个加法运算符都有一个运算对象是string// 等价于string s6 = (s1 + ",") + "world";string tmp = s1 + ",";s6 = tmp + "world";string s7 = "hello" + "," + s2; // 错误，不能把字面值直接相加 C++语言中的字符串字面值并不是标准库类型string的对象，字符串字面值与string是不同的类型。 3.3 标准库类型vector标准库类型vector表示对象的集合，其中所有对象的类型都相同。 C++既有类模版，也有函数模版，其中vector是一个类模版。模版本身不是类或函数，相反可以将模版看作为编译器生成类或函数编写的一份说明。编译器根据模版创建类或函数的过程称为实例化，当使用模版时，需要指出编译器应把类或函数实例化成何种类型。 对于类模版来说，我们通过提供一些额外信息来指定模版到底实例化成什么样的类，需要提供哪些信息由模版决定。vector能容纳绝大多数类型的对象作为其元素，但是因为引用不是对象，所以不存在包含引用的vector。 两个vector对象相等当且仅当它们所含的元素个数相同，而且对应位置的元素值也相同。关系运算符依照字典顺序进行比较：如果两个vector对象的容量不同，但是在相同位置上的元素值都一样，则元素较少的vector对象小于元素较多的vector对象；若元素的值有区别，则vector对象的大小关系由第一对相异的元素值的大小关系决定。 vector对象（以及string对象）的下标运算符可用于访问已存在的元素，而不能用于添加元素。 3.4 迭代器介绍C++程序员习惯性的使用!=，其原因和他们更愿意使用迭代器而非下标的原因一样：因为这种编程风格在标准库提供的所有容器上都有效。 只有string和vector等一些标准库类型有下标运算符，并非全都如此。与之类似，所有标准库容器的迭代器都定义了==和！=，但是它们中的大多数都没有定义&lt;运算符。 一般来说我们不知道迭代器的精确类型，而实际上，那些拥有迭代器的标准库类型使用iterator和const_iterator来表示迭代器的类型： 12345vector&lt;int&gt;::iterator it; // it能读写vector&lt;int&gt;的元素string::iterator it2; // it2能读写string对象中的元素vector&lt;int&gt;::const_iterator it3; // it3只能读元素，不能写元素string::const_iterator it4； // it4只能读字符，不能写字符 某些对vector对象的操作会使迭代器失效不能在范围for循环中向vector对象添加元素。 任何一种可能改变vector对象容量的操作，比如push_back，都会使该vector对象的迭代器失效。 3.5 数组不允许拷贝和赋值不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值： 123int a[] = &#123;0,1,2&#125;; // 含有3个整数的数组int a2[] = a; // 错误，不允许使用一个数组初始化另一个数组a2 = a; // 错误，不能把一个数组直接赋值给另一个数组 要想理解数组声明的含义，最好的办法就是从数组的名字开始按照由内向外的顺序阅读。 在大多数表达式中，使用数组类型的对象其实是使用一个指向该数组首元素的指针。由上可知，在一些情况下数组的操作实际上是指针的操作，当使用一个数组作为一个auto变量的初始值时，推断得到的类型是指针而非数组： 12345678int ia[] = &#123;0,1,2,3,4,5,6&#125;;auto ia2(ia); // ia2是一个整型指针，指向ia的第一个元素ia2 = 42; // 错误，ia2是一个指针，不能用int值给指针赋值auto ia2(&amp;ia[0]); // 使用ia作为初始值时，编译器实际执行的初始化过程类似// 使用decltype关键字时上述转换不会发生decltype(ia) ia3 = &#123;0,1,2,3,4,5,6&#125;; // ia3是一个数组ia3 = p; // 错误，不能用整型指针给数组赋值ia3[4] = i; // 正确，把i的值赋给ia3的元素]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ Primer 读书笔记（0）]]></title>
    <url>%2F2020%2F03%2F05%2FC%2B%2BPrimer%E7%AC%94%E8%AE%B0%2FC-Primer-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%880%EF%BC%89%2F</url>
    <content type="text"><![CDATA[2.22 变量声明和定义的关系声明使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而定义负责创建与名字关联的实体。 变量声明规定了变量的类型和名字，在这一点上定义与之相同。但是除此之外，定义还申请存储空间，也可能会为变量赋一个初始值。 如果想声明一个变量而非定义它，就在变量名前添加关键字extern，而且不要显式的初始化变量。 123extern int i; // 声明i并非定义iint j; // 声明并定义iextern double pi = 3.1415; // 定义 在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。 变量能且只能被定义一次，但是可以被多次声明。 如果要在多个文件中使用同一个变量，就必须将声明和定义分离。此时，变量的定义必须出现在且只能出现在同一个文件中，而其他用到该变量的文件必须对其进行声明，却绝对不能重复定义。 静态类型：C++是一种静态类型语言，其含义是在编译阶段检查类型。其中，检查类型的过程称为类型检查。这要求我们使用某个变量之前必须声明其类型。 复合类型：引用：引用为对象起了另外一个名字，引用类型引用另外一种类型，通过将声明符写成&amp;d的形式来定义引用类型，其中d是声明的变量名： 12int ival = 1024;int &amp;refVal = ival; //refVal指向ival 一般在初始化变量时，初始值会被拷贝到新建的对象中。然而定义引用时，程序把引用和它的初始值绑定在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起，因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。 引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字。 因为引用本身不是一个对象，所以不能定义引用的引用。 引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起。 指针：指针也实现了对其他对象的间接访问，但与引用相比又有很多不同点： 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期里他可以先后指向几个不同的对象。 指针无需在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。 因为引用不是对象，没有实际地址，所以不能定义指向引用的指针。 指针值应属下列四种状态之一： 指向一个对象 指向紧邻对象所占空间的下一个位置 空指针，意味着指针没有指向任何对象 无效指针，也就是上述情况之外的其他值 试图拷贝或以其他方式访问无效指针的值都将引发错误。 void是一种特殊的指针类型，可用于存放任意对象的地址。我们可以拿它和别的指针比较、作为函数的输入或输出，或者赋给另外一个void\指针，不能直接操作其所指的对象，因为我们并不知道这个对象到底是什么类型，也就无法确定能在对象上做哪些操作。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ludum Dare 历届主题]]></title>
    <url>%2F2019%2F12%2F18%2F%E9%9A%8F%E7%AC%94%2FLudum-Dare-%E5%8E%86%E5%B1%8A%E4%B8%BB%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Ludum Dare 历届主题 No. Month Theme (bonus) 0† April 2002 Indirect interaction（间接干扰） 1 July 2002 Guardian（保卫者） 2 November 2002 Construction/destruction (sheep)（建立/毁灭（绵羊）） 3 April 2003 Preparation – Set it up, let it go（准备—设置好，放手） 4 April 2004 Infection（感染） 5 October 2004 Random（随机） 6 April 2005 Light and darkness（光与暗） 7 December 2005 Growth（生长） 8 April 2006 Swarms（密集） 8.5† January 2007 Moon/anti-text（月/反文本（不知道这个在中文中表达什么）） 9 April 2007 Build the level you play（构建你玩的关卡） 10 December 2007 Chain reaction（连锁反应） 10.5 February 2008 Weird/unexpected/surprise（奇怪/意想不到/惊奇） 11 April 2008 Minimalist（极简主义者） 12 August 2008 The tower（塔） 13 December 2008 Roads（路） 14 April 2009 Advancing wall of doom（前进的末日之墙） 15 August 2009 Caverns（洞穴） 16 December 2009 Exploration（探索） 17 April 2010 Islands（群岛，岛屿） 18 August 2010 Enemies as weapons（敌人作为武器，作为武器的敌人） 19 December 2010 Discovery（发现） 20 April 2011 It’s dangerous to go alone! Take this!（一个人去是很危险的!拿着这个！） 21 August 2011 Escape（逃脱） 22 December 2011 Alone (kitten challenge)（单独（小猫挑战）） 23 April 2012 Tiny world（小世界） 24 August 2012 Evolution（演变） 25 December 2012 You are the villain (goat)（你是恶棍 （山羊）） 26 April 2013 Minimalism (potato)（简约主义（马铃薯）） 27 August 2013 10 seconds（十秒） 28 December 2013 You only get one（你只得到一个） 29 April 2014 Beneath the surface（表面下） 30 August 2014 Connected Worlds（被连接的世界） 31 December 2014 Entire Game on One Screen（整个游戏在一个屏幕上） 32 April 2015 An Unconventional Weapon（非常规武器） 33 August 2015 You are the Monster（你是怪兽） 34 December 2015 Growing/two button controls（增长/两个按钮控件） 35 April 2016 Shapeshift（变形） 36 August 2016 Ancient Technology（古代科技） 37 December 2016 One Room（一个房间） 38 April 2017 A Small World（一个小世界） 39 July 2017 Running out of Power（电源耗尽） 40 December 2017 The more you have, the worse it is（你拥有的越多, 就越糟糕） 41 April 2018 Combine two incompatible genres（结合两种不相容的体裁） 42 August 2018 Running out of space（空间耗尽） 43 December 2018 Sacrifices must be made（必须作出牺牲） 44 April 2019 Your life is currency（你的生命（生活）是一种货币） 45 October 2019 Start with nothing（从无到有） 46 April 2020 Keep it Alive（保持或者）]]></content>
      <tags>
        <tag>灵感</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搬瓦工配置记录]]></title>
    <url>%2F2019%2F10%2F05%2F%E9%9A%8F%E7%AC%94%2F%E6%90%AC%E7%93%A6%E5%B7%A5%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[上网工具搬瓦工的配置。 购买服务器：购买服务器这部分内容略过，感兴趣可以浏览搬瓦工中文网 配置服务器： 操作系统：Centos 7 x86_64 bbr 搭建方法： 执行如下命令： yum -y install wget 123wget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.shchmod +x shadowsocks-all.sh./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log 进入安装界面后： 1. 选择安装版本为SS-libev 2. 设置端口和密码，端口建议小于15000（虽然我也没考证过为什么），密码随意设置。 3. 选择加密方式（aes-256-gcm 或者 rc4-md5） 4. 等脚本执行成功，如果成功安装后会返回安装成功信息。 配置客户端： 下载ss客户端：https://github.com/shadowsocks（不同的操作系统选择不同的库下载即可，Mac为后缀为NG的那个） 如果前面服务器配置成功的话会返回一个形如ss://ajkfhjksjkdhfkjahsjkdfk=的链接，把这一串复制到剪切板，通过ss的“从剪贴板导入服务器配置链接”进行快速配置。 当然也可以手动输入你的ip，端口，密码以及加密方式进行配置。 一点备忘： 如果重装了远程机器，可能会显示Add correct host key in /Users/somebody/.ssh/known_hosts to get rid of this message.这样的报错信息，可以输入vi /Users/wangdong/.ssh/known_hosts进入编辑器，找到以你之前连接的ip开头的key，删除之，然后ESC+:wq保存，最后重新连接。 Mac下可以用终端直接连接远程主机，Window建议安装Putty等软件。 参考： 手动搭建教程：https://www.wervps.com/we/2252.html 远程登录异常：https://blog.csdn.net/wd2014610/article/details/79945424 测速网站：http://ping.chinaz.com/ 更换搬瓦工机房教程：https://banwagong.cn/genghuan.html Mac终端通过特定端口连接远程服务器：https://blog.csdn.net/zhangzehai2234/article/details/79816411]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[翻译]Integrating Lua]]></title>
    <url>%2F2019%2F09%2F24%2F%E7%BF%BB%E8%AF%91%2F%E7%BF%BB%E8%AF%91-Integrating-Lua%2F</url>
    <content type="text"><![CDATA[一篇名为Integrating Lua的Wiki页面翻译。 原文链接：https://wiki.unrealengine.com/Integrating_Lua Integrating LuaOverview欢迎来到我的第三个Wiki页面，这个页面是关于那个很棒的游戏引擎的——虚幻引擎！这篇文章包含了人们最近问我数次的那个问题，我认为这将对游戏逻辑编程和一个高水平的mod-abilty（模块化能力？）：整合Lua很有用。 RequirementsStarting off : code in our projectAquiring:现在，我们需要向项目中引入Lua，以便于其与我们的项目一起编译并包含在最终游戏中。但是首先，我们需要获取到Lua的二进制文件。有些项目会为您提供预编译的二进制文件，或者您也可以自行编译！因为编译的过程耗费时间，而且这个过程是必要的，所以我们将使用预编译的版本。LuaBinaries是一个很棒的项目，它始终是最新的，并且具有适用于每个平台的二进制文件（在本文中，我们将只涉及Windows）。选择最新版本，然后选择Windows库，接着选择静态（Static），因为我们会将Lua嵌入到游戏的可执行文件中，然后根据需要搜索软件包。在我们下载过这些包后，我们应该在它们的结构中找到如下文件： Include/(essential includes for working with Lua) luaxlib.h lua.h lua.hpp luaconf.h lualib.h luaXX.lib（XX代表Lua的当前版本，例如Lua 5.3.3就为lu a53.lib） 现在，我们拥有了二进制文件和包含文件，我们可以开始我们的集成工作了！ Copying the files在虚幻引擎中链接Lua很容易。首先，我们需要在项目目录中创建一个新文件夹，将Lua内容放入其中。我个人更喜欢在项目的主目录（.uproject所在的位置）中创建一个新文件夹，并将其命名为“ThirdParty”。然后在这个文件夹中，我创建了一个名为“Lua”的文件夹，并将其分为“includes”和“libraries”。结构如下： Project Home/ ThirdParty/ Lua/ includes/（我们只需要复制一次，因为它们与体系结构没有区别，最后请注意“s”） libraries/ luaXX.x64.lib（这是您在Win64包中下载的库文件，重命名来做区分） luaXX.x32.lib（这是您在Win32包中下载的库文件，重命名来做区分） Linking在Visual Studio中，打开YourProjectName.Build.cs，这个文件位于 Source/YourProjectName/ 文件夹中。默认情况下，此文件仅链接默认引擎模块。要对此链接Lua，我们需要向其中添加一些代码。由于展示每一个细节实在是太多了，所以我只向你展示我对Build.cs文件的改动： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849using System.IO;using UnrealBuildTool;public class ProjectName : ModuleRules&#123; private string ThirdPartyPath &#123; get &#123; return Path.GetFullPath(Path.Combine(ModuleDirectory, "../../ThirdParty/")); &#125; &#125; public ProjectName(TargetInfo Target) &#123; PublicDependencyModuleNames.AddRange(new string[] &#123; "Core", "CoreUObject", "Engine", "InputCore" &#125;); PrivateDependencyModuleNames.AddRange(new string[] &#123; &#125;); // 如果使用Slate UI，则取消注释 // PrivateDependencyModuleNames.AddRange(new string[] &#123; "Slate", "SlateCore" &#125;); // 如果使用在线功能，则取消注释 // PrivateDependencyModuleNames.Add("OnlineSubsystem"); // 要包含 OnlineSubsystemSteam, 请将其添加到uproject文件的plugins部分中，并将Enabled属性设置为true LoadLua(TargetRules); // 此函数加载Lua &#125; private bool LoadLua(ReadOnlyTargetRules TargetRules) &#123; bool isLibSupported = false; // 检查是否使用的是Windows if ((Target.Platform == UnrealTargetPlatform.Win64) || (Target.Platform == UnrealTargetPlatform.Win32)) &#123; isLibSupported = true; string PlatformString = (Target.Platform == UnrealTargetPlatform.Win64) ? "x64" : "x86"; // 此字符串是“x64”或“x86”，因此我们可以将其附加到lib文件名 string LibrariesPath = Path.Combine(ThirdPartyPath, "Lua", "libraries"); PublicAdditionalLibraries.Add(Path.Combine(LibrariesPath, "lua53." + PlatformString + ".lib")); PublicIncludePaths.Add(Path.Combine(ThirdPartyPath, "Lua", "includes")); &#125; Definitions.Add(string.Format("WITH_LUA_BINDING=&#123;0&#125;", isLibSupported ? 1 : 0)); return isLibSupported; &#125;&#125; “LoadLua”方法检查我们是否在Windows上，如果是，则根据编译的体系结构创建一个包含“x64”或“x86”的字符串，因此我们可以轻松的找到lib文件。然后，我们创建库路径，该路径就是（在这个例子中为“ThirdParty/”）/Lua/libraries。从那里，我们将平台字符串附加到文件名的前缀和后缀，因此最后应该是lua53.xxx.lib。此路径已添加到PublicAdditionalLibraries中，这会强制编译器使用我们放在其中的lib文件。我们还将includes目录添加到PublicIncludePaths，以便编译器找到我们的includes。最后也很重要的一点是，我们向已编译的游戏中添加了一个定义：WITH_LUA_BINDING = x，其中x为0（不支持Lua）或1（支持Lua）。 First steps现在，我们已经将Lua二进制文件集成到我们的游戏中，让我们通过在Visual Studio中右键单击该项目并选择“Build”来进行尝试。它应该会成功！下一步：编写一个蓝图节点，该节点从我们输入的字符串中执行Lua代码。打开您创建的蓝图函数库的头文件（.h）。空文件如下所示： 12345678910111213#pragma once#include "Kismet/BlueprintFunctionLibrary.h"#include "LuaBlueprints.generated.h"/** * */UCLASS()class YOURPROJECT_API ULuaBlueprints : public UBlueprintFunctionLibrary&#123; GENERATED_BODY()&#125;; 首先，在顶部添加Lua包含项，以便编译器知道声明函数的位置。为此，请在其他包含项的头部添加#include &quot;lua.hpp&quot;。接下来，我们向其中添加一个新的UFUNCTION，将其解析为带有以下声明的蓝图节点： 123public: UFUNCTION(BlueprintCallable, Category = "Lua") static void RunLua(const FString&amp; code); 这将创建一个可调用的蓝图节点，该节点带有一个字符串（FString），我们可以在其中输入将要运行的Lua代码。请注意，这是静态的，因为我们没有要在上下文中调用此对象的对象，换言之，我们想在没有任何目标的情况下从任何地方调用它。让我们进入LuaBlueprints.cpp文件，该文件应该为空（include文件除外）。我们为RunLua函数添加定义： 1234567891011void ULuaBlueprints::RunLua(const FString&amp; code)&#123; lua_State* L = luaL_newstate(); luaL_openlibs(L); int result = luaL_dostring(L, TCHAR_TO_ANSI(*code)); if (result != 0) &#123; UE_LOG(LogTemp, Error, TEXT("Lua Script error: %s"), ANSI_TO_TCHAR(lua_tostring(L, -1))); &#125;&#125; 这很容易。它使用Lua C API创建一个新的Lua状态，将其分配给名为L的变量。然后，打开标准的lua库（例如math），然后通过执行luaL_dostring()运行代码。这将Lua状态L作为一个参数，并将要运行的代码作为另一个参数。该函数返回一个整数，如果一切正常，则返回0。如果不为0，则显然出了问题。在这种情况下，我使用UE_LOG将其打印到日志中。注意，我们通过lua_tostring(L,-1)得到Lua错误消息。]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>Lua</tag>
        <tag>Unreal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下配置OpenGL环境]]></title>
    <url>%2F2019%2F09%2F11%2FOpenGL%E7%AC%94%E8%AE%B0%2FMac%E4%B8%8B%E9%85%8D%E7%BD%AEOpenGL%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[Mac下配置OpenGL环境。 Mac下配置OpenGL 安装homebrew ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 安装GLEW与GLFW brew install glew brew install glfw3 CLion法（推荐） 在CLion:A cross-platform IDE for C and C++下载CLion 配置GLAD： 打开在线服务（点击这个链接），API选择3.3及以上，Profile选择Core，勾选Options中的Generate a loader，点击GENERATE，会生成一个压缩包，下载。 将子目录中的/include/glad与/include/KHR复制到/usr/Local/include文件夹下。（如果/usr文件夹隐藏，可用快捷键command+shift+G输入访问） 新建一个项目，配置对应的Cmake文件： 1234567891011121314151617181920212223242526cmake_minimum_required(VERSION 3.12)project(OpenGL)set(CMAKE_CXX_STANDARD 14)set(GLEW_H /usr/local/Cellar/glew/2.1.0/include/GL)set(GLFW_H /usr/local/Cellar/glfw/3.2.1/include/GLFW)set(GLAD_H /usr/local/include/glad)set(KH_H /usr/local/include/KHR)include_directories($&#123;GLEW_H&#125; $&#123;GLFW_H&#125; $&#123;GLAD_H&#125; $&#123;KH_H&#125;)# 添加目标链接set(GLEW_LINK /usr/local/Cellar/glew/2.1.0/lib/libGLEW.2.1.dylib)set(GLFW_LINK /usr/local/Cellar/glfw/3.2.1/lib/libglfw.3.dylib)link_libraries($&#123;OPENGL&#125; $&#123;GLEW_LINK&#125; $&#123;GLFW_LINK&#125;)# 执行编译命令# 这个glad.c在第2步中说过要拉到项目中，注意路径set(SOURCE_FILES "src/glad.c" "main.cpp")add_executable(OpenGL $&#123;SOURCE_FILES&#125;)# mac下这步很重要if (APPLE) target_link_libraries(OpenGL "-framework OpenGL") target_link_libraries(OpenGL "-framework GLUT")endif() 4. 注意这样配置之后需要更改`/usr/local/include/glad文件夹下的glad.h`中的`#include &lt;KHR/khrplatform.h&gt;`更改为`#include &lt;khrplatform.h&gt;`，具体步骤： 1. 在CLion中打开`glad.c`文件，command+点按`#include &lt;glad.h&gt;`会跳到`glad.h` 2. 然后在`glad.h`中command+f找到`#include &lt;KHR/khrplatform.h&gt;`，将它改为`#include &lt;khrplatform.h&gt;` 5. 运行测试代码（把下列代码复制到main.cpp中）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;glew.h&gt;#include &lt;glfw3.h&gt;#include &lt;iostream&gt;using namespace std;void key_callback(GLFWwindow* window, int key, int scancode, int action, int mode)&#123; //如果按下ESC，把windowShouldClose设置为True，外面的循环会关闭应用 if(key==GLFW_KEY_ESCAPE &amp;&amp; action == GLFW_PRESS) glfwSetWindowShouldClose(window, GL_TRUE); std::cout&lt;&lt;"ESC"&lt;&lt;mode;&#125;int main(void)&#123; //初始化GLFW库 if(!glfwInit()) return -1; //创建窗口以及上下文 GLFWwindow* window = glfwCreateWindow(640, 480, "hello world", NULL, NULL); if(!window) &#123; //创建失败会返回NULL glfwTerminate(); &#125; //建立当前窗口的上下文 glfwMakeContextCurrent(window); glfwSetKeyCallback(window, key_callback); //注册回调函数 //循环，直到用户关闭窗口 while(!glfwWindowShouldClose(window)) &#123; /*******轮询事件*******/ glfwPollEvents(); /*******渲染*******/ //选择清空的颜色RGBA glClearColor(0.2, 0.3, 0.3, 1); glClear(GL_COLOR_BUFFER_BIT); //开始画一个三角形 glBegin(GL_TRIANGLES); glColor3f(1, 0, 0); //Red glVertex3f(0, 1, 1); glColor3f(0, 1, 0); //Green glVertex3f(-1, -1, 0); glColor3f(0, 0, 1); //Blue glVertex3f(1, -1, 0); //结束一个画图步骤 glEnd(); glBegin(GL_POLYGON); //再画个梯形，需要注意笔顺 glColor3f(0.5, 0.5, 0.5); //Grey glVertex2d(0.5, 0.5); glVertex2d(1, 1); glVertex2d(1, 0); glVertex2d(0.5, 0); glEnd(); /******交换缓冲区，更新window上的内容******/ glfwSwapBuffers(window); &#125; glfwTerminate(); return 0;&#125; 如果出现如下窗口说明配置成功： XCode法 在App Store中搜索XCode并安装。 新建Xcode的Command Line C++项目，在build settings中设置Header Search Path与Library Search Path，在其中添加对应的glew与glfw的头文件(include)与库文件(lib)路径。 在build Phases中添加库文件 ​ （在对应的文件夹中将两个/.dylib的文件直接拖拽进来） 配置GLAD： 打开在线服务（点击这个链接），API选择3.3及以上，Profile选择Core，勾选Options中的Generate a loader，点击GENERATE，会生成一个压缩包，下载。 将子目录中的/include/glad与/include/KHR复制到/usr/Local/include文件夹下。（如果/usr文件夹隐藏，可用快捷键command+shift+G输入访问） 将/src中的glad.c复制到Xcode工程文件夹下。 在build settings中添加路径/usr/local/include 此时如果不出意外的话，你的第一个测试程序已经可以运行了，点击测试代码，复制到自己的.cpp文件中执行，会出现一个黑色窗口。(或者直接复制下面的代码) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;glad/glad.h&gt;#include &lt;GLFW/glfw3.h&gt;#include &lt;iostream&gt;void framebuffer_size_callback(GLFWwindow* window, int width, int height);void processInput(GLFWwindow *window);// settingsconst unsigned int SCR_WIDTH = 800;const unsigned int SCR_HEIGHT = 600;int main()&#123; // glfw: initialize and configure // ------------------------------ glfwInit(); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);#ifdef __APPLE__ glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); // uncomment this statement to fix compilation on OS X#endif // glfw window creation // -------------------- GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, "LearnOpenGL", NULL, NULL); if (window == NULL) &#123; std::cout &lt;&lt; "Failed to create GLFW window" &lt;&lt; std::endl; glfwTerminate(); return -1; &#125; glfwMakeContextCurrent(window); glfwSetFramebufferSizeCallback(window, framebuffer_size_callback); // glad: load all OpenGL function pointers // --------------------------------------- if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) &#123; std::cout &lt;&lt; "Failed to initialize GLAD" &lt;&lt; std::endl; return -1; &#125; // render loop // ----------- while (!glfwWindowShouldClose(window)) &#123; // input // ----- processInput(window); // glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.) // ------------------------------------------------------------------------------- glfwSwapBuffers(window); glfwPollEvents(); &#125; // glfw: terminate, clearing all previously allocated GLFW resources. // ------------------------------------------------------------------ glfwTerminate(); return 0;&#125;// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly// ---------------------------------------------------------------------------------------------------------void processInput(GLFWwindow *window)&#123; if(glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) glfwSetWindowShouldClose(window, true);&#125;// glfw: whenever the window size changed (by OS or user resize) this callback function executes// ---------------------------------------------------------------------------------------------void framebuffer_size_callback(GLFWwindow* window, int width, int height)&#123; // make sure the viewport matches the new window dimensions; note that width and // height will be significantly larger than specified on retina displays. glViewport(0, 0, width, height);&#125; 如果运行出现如下窗口，说明配置成功： 参考： https://www.cnblogs.com/shayue/p/Mac-CLion-xiaOpenGL-huan-jing-pei-zhi.html]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unreal插件学习：实例源码阅读]]></title>
    <url>%2F2019%2F08%2F30%2FUnreal4%E7%AC%94%E8%AE%B0%2FUnreal%E6%8F%92%E4%BB%B6%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%AE%9E%E4%BE%8B%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[从阅读一个小规模的插件源码开始学习Unreal插件写作。 源码地址：TextAsset 主要功能就是在Unreal编辑器中创建一个TextAsset格式的文本文件，并提供对这个文本文件中的内容进行反转的功能。 代码结构：123456789101112131415161718TextAsset |-Binaries |-Docs |-Intermediate |-Resources |-Source | |-TextAsset | | |-Private | | |-Public | |-TextAssetEditor | | |-Private | | | |-AssetTools | | | |-Factories | | | |-Shared | | | |-Styles | | | |-Toolkits | | | |-Widgets |-TextAsset.uplugin 描述符文件TextAsset.uplugin：前面的内容都是一些插件的基本属性，包括版本，引擎版本，开发者等等；最后一个Modules字段定义了两个模块：一个是运行时加载（Runtime）的TextAsset模块，一个是编辑器模块（Editor）TextAssetEditor。 TextAsset： TextAssetModule重写了IModuleInterface接口的方法，实现了SupportsDynamicReloading 方法，这个方法返回 true，允许模块即时卸载。 UTextAsset中使用一个 FText 类型的变量：Text 用来将输入的字符串作为资源存储。 TextAssetEditor： TextAssetEditorModule.cpp：定义了FTextAssetEditorModule类，这个类实现了IHasMenuExtensibility（表示类具有可扩展的默认菜单）、IHasToolBarExtensibility（表示类具有可扩展的默认工具栏）、IModuleInterface（所有模块实现应该派生自的接口类）等接口。 对IModuleInterface 接口的实现主要是 StartupModule 与 ShutdownModule 两个函数，在 StartupModule 中，先对插件的样式进行了赋值，然后对 AssetTool 进行了注册，对菜单栏进行了注册，同时进行了设置；当然，在 ShutdownModule 中就进行了取消注册的函数。 RegisterSettings 具体负责？ TextAssetAction.cpp：这个类继承自FAssetTypeActions_Base类，实现了若干关于Asset的函数，主要有： GetActions：这里在AddMenuEntry中添加了资源可以执行的操作和这个操作相关的说明 对应着引擎中的： FUIAction对应了一些UI操作，详见：https://docs.unrealengine.com/en-US/API/Runtime/Slate/Framework/Commands/FUIAction/index.html 总而言之，这里使用两个委托函数定义了激活此操作时执行的委托与在确定此操作是否可以执行时执行的委托，Reverse的具体实现其实就是双指针法，不做赘述；PostEditChange内部调用了 PostEditChangeProperty，这个函数在外部修改此对象上的属性时调用，用于传递编辑前和编辑后更改事件的结构；最后调用MarkPackageDirty用来将修改过但未保存的资源进行标记。 OpenAssetEditor：这个函数用来设置编辑器的布局，包括独立编辑的程序和以世界为中心的资产编辑器，两种布局根据EditWithinLevelEditor是否可用来决定。 TextAssetFactory.cpp 这个类继承自UFactory类，负责通过从文件名导入新对象来创建新对象，在这个类的具体实现中，对父类的方法进行了重写，通过一个传入的参数Filename对该文件进行读取，得到其中的字符串，然后创建一个UTextAsset类型的资源文件，将字符串的内容赋给TextAsset的Text字段进行存储。 TextAssetFactoryNew.cpp 与前一个文件大致相同，只不过没有具体的Create函数实现，仅仅通过NewObject返回了一个新的对象。 TextAssetEditorSettings.cpp 这个类定义了若干关于插件属性的变量，包括： 编辑器背景颜色 编辑器文字颜色 在编辑器窗口中使用的字体 文本资源编辑器窗口周围的边距 TextAssetEditorStyle.h 这个类继承自FSlateStyleSet（一个平板样式块，包含一组指定Slate外观的命名属性），可以参考：https://docs.unrealengine.com/en-US/API/Runtime/SlateCore/Styling/FSlateStyleSet/index.html，在这个类中，定义了一系列UI的外观，例如不同尺寸的图标。 TextAssetEditorToolkit.cpp 这个类继承自FAssetEditorToolKit、FEditorUndoClient、FGCObject，负责初始化编辑器工具的相关功能，包括撤销，重新执行，对TextAsset的Text字段进行修改等。 同时定义了UI的层级，如下所述： 1234567891011121314151617181920212223242526272829// create tab layoutconst TSharedRef&lt;FTabManager::FLayout&gt; Layout = FTabManager::NewLayout("Standalone_TextAssetEditor") -&gt;AddArea ( FTabManager::NewPrimaryArea() -&gt;SetOrientation(Orient_Horizontal) // 垂直布局 -&gt;Split ( // 此处是一个视图窗口 FTabManager::NewSplitter() -&gt;SetOrientation(Orient_Vertical) // 水平布局 -&gt;SetSizeCoefficient(0.66f) // 尺寸 -&gt;Split ( FTabManager::NewStack() -&gt;AddTab(GetToolbarTabId(), ETabState::OpenedTab) -&gt;SetHideTabWell(true) -&gt;SetSizeCoefficient(0.1f) ) -&gt;Split ( FTabManager::NewStack() -&gt;AddTab(TextAssetEditor::TabId, ETabState::OpenedTab) -&gt;SetHideTabWell(true) -&gt;SetSizeCoefficient(0.9f) ) ) ); STextAssetEditor.cpp 这个类继承自SCompoundWidget，保存了编辑器的Slate格式： 123456789101112131415161718192021222324252627void STextAssetEditor::Construct(const FArguments&amp; InArgs, UTextAsset* InTextAsset, const TSharedRef&lt;ISlateStyle&gt;&amp; InStyle)&#123; TextAsset = InTextAsset; auto Settings = GetDefault&lt;UTextAssetEditorSettings&gt;(); ChildSlot [ SNew(SVerticalBox) + SVerticalBox::Slot() .FillHeight(1.0f) [ SAssignNew(EditableTextBox, SMultiLineEditableTextBox) .BackgroundColor((Settings != nullptr) ? Settings-&gt;BackgroundColor : FLinearColor::White) .Font((Settings != nullptr) ? Settings-&gt;Font : FSlateFontInfo()) .ForegroundColor((Settings != nullptr) ? Settings-&gt;ForegroundColor : FLinearColor::Black) .Margin((Settings != nullptr) ? Settings-&gt;Margin : 4.0f) .OnTextChanged(this, &amp;STextAssetEditor::HandleEditableTextBoxTextChanged) .OnTextCommitted(this, &amp;STextAssetEditor::HandleEditableTextBoxTextCommitted) .Text(TextAsset-&gt;Text) ] ]; FCoreUObjectDelegates::OnObjectPropertyChanged.AddSP(this, &amp;STextAssetEditor::HandleTextAssetPropertyChanged);&#125; 包括一系列设置，以及回调函数的注册等。]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Unreal Engine4</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua源码阅读：表操作的指令]]></title>
    <url>%2F2019%2F08%2F26%2FLua%2FLua%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%9A%E8%A1%A8%E6%93%8D%E4%BD%9C%E7%9A%84%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[表操作的相关指令。 创建表：创建一个空表，代码： 1local p = &#123;&#125; 对应的OPCODE为OP_NEWTABLE，用于创建一个表，将结果存入寄存器。 1OP_NEWTABLE,/* A B C R(A) := &#123;&#125; (size = B,C) */ simpleexp最终调用Constructor 函数，这个函数专门负责构造表。 解析表的信息会存放在 ConsControl 结构体中： 1234567struct ConsControl &#123; expdesc v; /* last list item read 存储表构造过程中最后一个表达式的信息 */ expdesc *t; /* table descriptor 构造表相关的表达式信息，因为是外部传入的字段所以使用指针 */ int nh; /* total number of 'record' elements 初始化表时，散列部分数据的数量 */ int na; /* total number of array elements 初始化表时，数组部分数据的数量 */ int tostore; /* number of array elements pending to be stored 当前构造表时内部的数组部分的数据如果超过这个值，就首先调用一次 OP_SETLIST 函数写入寄存器中 */&#125;; 接下来进入 Constructor 函数： 123456789101112131415161718192021222324static void constructor (LexState *ls, expdesc *t) &#123; /* constructor -&gt; '&#123;' [ field &#123; sep field &#125; [sep] ] '&#125;' sep -&gt; ',' | ';' */ FuncState *fs = ls-&gt;fs; int line = ls-&gt;linenumber; int pc = luaK_codeABC(fs, OP_NEWTABLE, 0, 0, 0); struct ConsControl cc; cc.na = cc.nh = cc.tostore = 0; cc.t = t; init_exp(t, VRELOCABLE, pc); init_exp(&amp;cc.v, VVOID, 0); /* no value (yet) */ luaK_exp2nextreg(ls-&gt;fs, t); /* fix it at stack top */ checknext(ls, '&#123;'); do &#123; lua_assert(cc.v.k == VVOID || cc.tostore &gt; 0); if (ls-&gt;t.token == '&#125;') break; closelistfield(fs, &amp;cc); field(ls, &amp;cc); &#125; while (testnext(ls, ',') || testnext(ls, ';')); check_match(ls, '&#125;', '&#123;', line); lastlistfield(fs, &amp;cc); SETARG_B(fs-&gt;f-&gt;code[pc], luaO_int2fb(cc.na)); /* set initial array size */ SETARG_C(fs-&gt;f-&gt;code[pc], luaO_int2fb(cc.nh)); /* set initial table size */&#125; 第六行：生成一条 OP_NEWTABLE 指令，这条指令创建的表最终会根据指令中的参数 A 存储的寄存器地址，赋值给本函数栈内的寄存器，所以这条指令是需要重定向的。 第七行到第十一行：初始化 ConsControl 结构体。需要说明的是第 11 行，此时将ConsControl 结构体中的对象 v 初始化为 VVOID。前面说过这个数据存储的是表构造过程中最后一个表达式的信息，因为这里还没有解析到表构造中的信息，所以这个表达式的类型为 VVOID。 第十二行：调用前面提到的解析表达式到寄存器的函数 luaK_exp2nextreg，将寄存器地址修正为前面创建的 OP_NEWTABLE的指令 A。 第 22 行~23 行：将 ConsControl 结构体中存放的散列和数组部分的大小，写入前面生成的 OP_NEWTABLE 指令的 B 和 C 部分。 上面创建了一个简单的空表，如果添加上数组部分： 1local p = &#123;1,2&#125; 与前面相比，多了两条 loadk 指令以及一条setlist 指令。loadk 指令用于把表构造表达式中的常量 1 和 2 加载到函数栈中，而紧跟着的 setlist 指令则使用这两个常量初始化表的数组部分。 setlist 指令的格式如下，对应 OP_SETLIST 指令，用于以一个基地址和数量来将数据写入表的数组部分： 1OP_SETLIST,/* A B C R(A)[(C-1)*FPF+i] := R(A+i), 1 &lt;= i &lt;= B */ A：OP_NEWTABLE 指令中创建好的表所在的寄存器，它后面紧跟着待写入的数据 B：待写入数据的数量 C：FPF 索引，即每次写入最多的是 LFIELDS_PER_FLUSH 在 Lua5.3中，使用field(ls, &amp;cc);函数对散列、数组部分解析构造： 1234567891011121314151617181920static void field (LexState *ls, struct ConsControl *cc) &#123; /* field -&gt; listfield | recfield */ switch(ls-&gt;t.token) &#123; case TK_NAME: &#123; /* may be 'listfield' or 'recfield' */ if (luaX_lookahead(ls) != '=') /* expression? */ listfield(ls, cc); else recfield(ls, cc); break; &#125; case '[': &#123; recfield(ls, cc); break; &#125; default: &#123; listfield(ls, cc); break; &#125; &#125;&#125; 当没有解析到符号}时，有一个解析表达式的循环会一直执行（上层函数constructor执行）。 调用closelistfield 函数生成上一个表达式的相关指令。这里调用了luaK_exp2nextreg(fs, &amp;cc-&gt;v);，注意上面提到过，最开始初始化 ConsControl 表达式时，其成员变量 v 的表达式类型是 VVOID，因此这种情况下进入这个函数并不会有什么效果，这就把循环和前面的初始化语句衔接在了一起。 针对具体的类型来做解析： 如果解析到一个变量，那么看紧跟着这个符号的是不是=，如果不是，就是一个数组方式的赋值，否则就是散列方式的赋值。 如果看到的是[符号，就认为这是一个散列部分的构造。 否则就是数组部分的构造了。如果是数组部分的构造，那么进入的是listfiled函数，否则就是 recfield 函数了。 关于 listfiled 函数： 1234567static void listfield (LexState *ls, struct ConsControl *cc) &#123; /* listfield -&gt; exp */ expr(ls, &amp;cc-&gt;v); checklimit(ls-&gt;fs, cc-&gt;na, MAX_INT, "items in a constructor"); cc-&gt;na++; cc-&gt;tostore++;&#125; 调用 expr 函数解析这个表达式，得到对应的 ConsControl 结构体中成员 v 的数据。前面提过，这个对象会暂存表构造过程中当前表达式的结果。 检查当前表中数组部分的数据梳理是否超过限制了。 依次将 ConsControl 结构体中的成员 na 和 toshore 加 1。 每解析完一个表达式，会调用 closelistfield，它的工作是针对数组部分的。 123456789static void closelistfield (FuncState *fs, struct ConsControl *cc) &#123; if (cc-&gt;v.k == VVOID) return; /* there is no list item */ luaK_exp2nextreg(fs, &amp;cc-&gt;v); cc-&gt;v.k = VVOID; if (cc-&gt;tostore == LFIELDS_PER_FLUSH) &#123; luaK_setlist(fs, cc-&gt;t-&gt;u.info, cc-&gt;na, cc-&gt;tostore); /* flush */ cc-&gt;tostore = 0; /* no more items pending */ &#125;&#125; 调用 luaK_exp2nextreg 函数将前面得到的 ConsControl 结构体中成员 v 的信息存入寄存器中。 如果此时 tostroe 成员的值等于 LFIELDS_PER_FLUSH，那么生成一个 OP_SETLIST 指令，用于将当前寄存器上的数据写入表的数组部分。需要注意的是，这个地方存取的数据在栈上的位置是紧跟着 OP_NEWTABLE 指令中的参数 A 在栈上的位置，这样的话使用一个参数既可以得到表的地址，又可以知道待存入的数据是哪些。之所以需要限制每次调用 OP_SETLIST 指令中的数据量不超过 LFIELDS_PER_FLUSH，是因为如果不做这个限制，会导致数组部分数据过多时，占用过多的寄存器，而 Lua 栈对寄存器数量是有限制的。 如果是散列表部分： 1local p = &#123;["a"] = 1&#125; 紧跟着 newtable 的是 settable，这个指令用来完成散列部分的初始化，格式如下： 1OP_SETTABLE,/* A B C R(A)[RK(B)] := RK(C) */ 作用是向一个表的散列部分赋值，其中各个参数： A：表所在的寄存器。 B：key 存放的位置，注意其格式是 RK，也就是说这个值可能来自寄存器，也可能来自常量数组。 C：value 存放的位置，注意其格式是 RK，也就是说这个值可能来自寄存器，也可能来自常量数组。 初始化散列部分的代码会走入 recfield 中，需要注意： key 是一个常量。 key 是一个变量，需要首先去获取这个变量的值。 12345678910111213141516171819static void recfield (LexState *ls, struct ConsControl *cc) &#123; /* recfield -&gt; (NAME | '['exp1']') = exp1 */ FuncState *fs = ls-&gt;fs; int reg = ls-&gt;fs-&gt;freereg; expdesc key, val; int rkkey; if (ls-&gt;t.token == TK_NAME) &#123; checklimit(fs, cc-&gt;nh, MAX_INT, "items in a constructor"); checkname(ls, &amp;key); &#125; else /* ls-&gt;t.token == '[' */ yindex(ls, &amp;key); cc-&gt;nh++; checknext(ls, '='); rkkey = luaK_exp2RK(fs, &amp;key); expr(ls, &amp;val); luaK_codeABC(fs, OP_SETTABLE, cc-&gt;t-&gt;u.info, rkkey, luaK_exp2RK(fs, &amp;val)); fs-&gt;freereg = reg; /* free registers */&#125; 上面的 lua 代码是第一种情况，具体如下： 得到 key 常量在常量数组中的索引，根据这个值调用 luaK_exp2RK 函数生成 RK 值。 得到 value 表达式的索引，根据这个值调用 luaK_exp2RK 函数生成 RK 值。 将前两步的值以及表在寄存器中的索引，写入 OP_SETTABLE 的参数中。 主要的步骤就是查找表达式，然后转换为对应的RK值写入OPCODE中。 当键是变量时，情况如下： 12local a = "a"local p = &#123;[a] = 1&#125; 首先需要一条语句将常量“a”加载到局部变量a中，这里需要一条loadk指令。此外，这里的键来自局部变量，那么对应的RK格式也会有差异，因为此时不是从常量数组中获取key的数据，而是从寄存器中： 解析变量形成表达式相关的expdesc结构体； 根据不同的表达式类型将表达式大的值存入寄存器。 查询表：最后一个表相关的指令：OP_GETTABLE，其格式如下： 1OP_GETTABLE,/* A B C R(A) := R(B)[RK(C)] */ 其作用是根据key从表中获取数据存入寄存器中，各参数如下： A：存放结果的寄存器 B：表所在的寄存器 C：key存放的位置，其格式为RK，意味着这个值可能来自寄存器，也可能来自常量数组 查询表中的数据分为以下两步： 将待查询的字符串变量赋值到栈上的一个位置中。 以第一步中已经存储了该变量字符串值的数据作为键，在表中进行查询。 元表的实现原理：在lua 初始化时，首先会调用 luaT_init 函数初始化其中定义的几种元方法对应的字符串。这些都是全局共用的，在初始化完毕之后只可读不可写，也不能回收： 12345678910111213141516void luaT_init (lua_State *L) &#123; static const char *const luaT_eventname[] = &#123; /* ORDER TM */ "__index", "__newindex", "__gc", "__mode", "__len", "__eq", "__add", "__sub", "__mul", "__mod", "__pow", "__div", "__idiv", "__band", "__bor", "__bxor", "__shl", "__shr", "__unm", "__bnot", "__lt", "__le", "__concat", "__call" &#125;; int i; for (i=0; i&lt;TM_N; i++) &#123; G(L)-&gt;tmname[i] = luaS_new(L, luaT_eventname[i]); luaC_fix(L, obj2gco(G(L)-&gt;tmname[i])); /* never collect these names */ &#125;&#125; 这里将遍历前面定义的枚举类型 TMS，将每一个类型对应的字符串赋值给 global_State 结构体中的 tmname，同时调用函数 luaC_fix 将这些字符串设置为不可回收的。因为在这个系统运行的过程中，这些字符串会一直用到，至于如何让它们变成不可回收的，后面 GC 的部分会做分析。 Lua 虚拟机从一个表中查询数据的过程如下： 12345678910111213141516171819202122232425262728/*** Main function for table access (invoking metamethods if needed).** Compute 'val = t[key]'*/void luaV_gettable (lua_State *L, const TValue *t, TValue *key, StkId val) &#123; int loop; /* counter to avoid infinite loops */ for (loop = 0; loop &lt; MAXTAGLOOP; loop++) &#123; const TValue *tm; if (ttistable(t)) &#123; /* 't' is a table? */ Table *h = hvalue(t); const TValue *res = luaH_get(h, key); /* do a primitive get */ if (!ttisnil(res) || /* result is not nil? */ (tm = fasttm(L, h-&gt;metatable, TM_INDEX)) == NULL) &#123; /* or no TM? */ setobj2s(L, val, res); /* result is the raw get */ return; &#125; /* else will try metamethod */ &#125; else if (ttisnil(tm = luaT_gettmbyobj(L, t, TM_INDEX))) luaG_typeerror(L, t, "index"); /* no metamethod */ if (ttisfunction(tm)) &#123; /* metamethod is a function */ luaT_callTM(L, tm, t, key, val, 1); return; &#125; t = tm; /* else repeat access over 'tm' */ &#125; luaG_runerror(L, "gettable chain too long; possible loop");&#125; 这个函数根据该对象的元方法表中的_index 表逐层向上查找： 第 9 行~第 16 行：如果 t 是表，则尝试根据 key 在该表中查找数据，如果找到了非空数据，或者找到该表的元方法表中_index 为空，都返回查找结果。反之，如果不返回查找结果，只可能是上面两个条件的反面情况，即在原表中查找的数据为空，同时原表的元方法表存在 _index成员，而且此时该成员已经赋值给了 tm。 第 19 行~第 20 行：这说明前面判断 t 不是一个表，于是调用 luaT_gettmbyobj 函数，尝试拿到这个数据的 metatable[“__index”]，如果返回空，那么报错并返回。 第 21 行~第 24 行：此时 tm 不是一个空值，于是判断它是不是函数，如果是，就通过 luaT_callTM函数来调用它，然后返回。 第 25 行：来到这里，说明前面得到的 tm，既不是空值，也不是函数，而是 t-&gt;metatable[“__index”]，此时将这个值赋值为下一个循环中处理的 t，继续前面的操作。 第 27 行：如果这个逐层查找过程的层次过多，超过了 MAXTAGLOOP，就终止循环，报错并返回。 关于 luaT_gettmbyobj 函数，它的作用是根据一个数据的类型返回它的元表： 1234567891011121314const TValue *luaT_gettmbyobj (lua_State *L, const TValue *o, TMS event) &#123; Table *mt; switch (ttnov(o)) &#123; case LUA_TTABLE: mt = hvalue(o)-&gt;metatable; break; case LUA_TUSERDATA: mt = uvalue(o)-&gt;metatable; break; default: mt = G(L)-&gt;mt[ttnov(o)]; &#125; return (mt ? luaH_getstr(mt, G(L)-&gt;tmname[event]) : luaO_nilobject);&#125; 只有在数据类型为 Table 和 udata 的时候，才能拿到对象的 metatable 表，其他时候是到 global_State结构体的成员 mt 中获取的，但是这对于其他数据类型而言，一直是空值。 fasttm宏的作用是从这个数据的元表中查询相应的对象返回： 123456789101112131415161718#define gfasttm(g,et,e) ((et) == NULL ? NULL : \ ((et)-&gt;flags &amp; (1u&lt;&lt;(e))) ? NULL : luaT_gettm(et, e, (g)-&gt;tmname[e]))#define fasttm(l,et,e) gfasttm(G(l), et, e)/*** function to be used with macro "fasttm": optimized for absence of** tag methods*/const TValue *luaT_gettm (Table *events, TMS event, TString *ename) &#123; const TValue *tm = luaH_getstr(events, ename); lua_assert(event &lt;= TM_EQ); if (ttisnil(tm)) &#123; /* no tag method? */ events-&gt;flags |= cast_byte(1u&lt;&lt;event); /* cache this fact */ return NULL; &#125; else return tm;&#125;]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua源码阅读：指令的解析与执行]]></title>
    <url>%2F2019%2F08%2F23%2FLua%2FLua%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%9A%E6%8C%87%E4%BB%A4%E7%9A%84%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%89%A7%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[具体分析文件如何被解析、生成对应指令以及到虚拟机执行的流程。 Lua词法：Lua使用一遍扫描代码文件的方式生成字节码，即在第一遍扫描代码的时候就生成字节码了，这么做主要是为了加快解释执行的速度。 赋值类指令：局部变量：lua代码： 1local a = 10 相关的EBNF词法： 1234567chunk -&gt; &#123; stat [`;&apos;] &#125;stat -&gt; localstatlocalstat -&gt; LOCAL NAME &#123;`,&apos; NAME&#125;[`=&apos; explist1]explist1 -&gt; expr &#123;`,&apos; expr&#125;exp -&gt; subexprsubexpr -&gt; simpleexpsimpleexp -&gt; NUMBER 第3行为赋值，涉及几个问题： = 左边是一个变量，只有变量才能赋值，于是涉及以下问题：如何存储局部变量，如何查找变量，怎么确定一个变量是局部变量、全局变量还是UpValue？ = 右边是一个表达式列表 explist1，在这个最简单的例子中，这个表达式是常量数字 10。这种情况很简单，如果不是一个立即能得到的值，比如是一个函数调用的返回值，或者是对这个 block 之外的其他变量的引用，又怎么处理呢？ 第一个问题，如何识别局部变量？ 首先在函数 localstat 中，会有一个循环调用函数 new_localvar，将=左边的所有以逗号分隔的变量都生成一个相应的局部变量。 存储每个局部变量的信息时，我们使用的是 LocVar 结构体： 12345678910// lObject.h/*** Description of a local variable for function prototypes** (used for debug information)*/typedef struct LocVar &#123; TString *varname; int startpc; /* first point where variable is active */ int endpc; /* first point where variable is dead */&#125; LocVar; 其中变量名放在 LocVar 结构体的变量 varname 中。函数中所有局部变量的 LocVar 信息，一般存放在 Proto 结构体的 LocVar 中。 在结构体FuncState 中，成员变量 freereg 存放的就是当前函数栈的下一个可用位置。 在每一个 chunk 函数中，都会根据当前函数栈存放的变量数量（包括函数的局部变量、函数的参数）进行调整（该书基于 lua 5.14版本写成） 12345678910&gt; // lparser.c&gt; static void chunk (LexState *ls)&gt; &#123;&gt; /* chunk -&gt; &#123; stat [`;']&#125; */&gt; while (!islast &amp;&amp; !block_follow(ls-&gt;t.token))&gt; &#123;&gt; ls-&gt;fs-&gt;freereg = ls-&gt;fs-&gt;nactvar; /* free registers */&gt; &#125;&gt; &#125;&gt; 在 Lua5.3 版本中，我找到了一个类似的函数： 1234567891011// lparser.cstatic void statlist (LexState *ls) &#123; /* statlist -&gt; &#123; stat [';'] &#125; */ while (!block_follow(ls, 1)) &#123; if (ls-&gt;t.token == TK_RETURN) &#123; statement(ls); return; /* 'return' must be last statement */ &#125; statement(ls); &#125;&#125; 这里调用 statement()函数： 123456789101112131415161718static void statement (LexState *ls) &#123; int line = ls-&gt;linenumber; /* may be needed for error messages */ enterlevel(ls); switch (ls-&gt;t.token) &#123; case TK_LOCAL: &#123; /* stat -&gt; localstat */ luaX_next(ls); /* skip LOCAL */ if (testnext(ls, TK_FUNCTION)) /* local function? */ localfunc(ls); else localstat(ls); break; &#125; &#125; lua_assert(ls-&gt;fs-&gt;f-&gt;maxstacksize &gt;= ls-&gt;fs-&gt;freereg &amp;&amp; ls-&gt;fs-&gt;freereg &gt;= ls-&gt;fs-&gt;nactvar); ls-&gt;fs-&gt;freereg = ls-&gt;fs-&gt;nactvar; /* free registers */ leavelevel(ls);&#125; 可以看到在第 9 行对当前函数栈存放的变量数量（包括函数的局部变量、函数的参数等）进行调整。 那么，nactvar 这个变量又是何时调整的呢？在这个例子中，变量 a 是一个局部变量，最后会在解析局部变量的函数 adjustlocalvars 中进行调整： 1234567static void adjustlocalvars (LexState *ls, int nvars) &#123; FuncState *fs = ls-&gt;fs; fs-&gt;nactvar = cast_byte(fs-&gt;nactvar + nvars); for (; nvars; nvars--) &#123; getlocvar(fs, fs-&gt;nactvar - nvars)-&gt;startpc = fs-&gt;pc; &#125;&#125; 至此，第一个问题得到了解决：在函数 localstat 中，会读取=号左边的所有变量，并在 Proto 结构体中创建相应的局部变量信息；而变量在 Lua 函数栈中的存储位置存放在 freereg 变量中，它会根据当前函数栈中变量的数量进行调整。 第二个问题：表达式的结果如何存储？ 解析表达式的结果会存储在一个临时数据结构 expdesc 中： 123456789101112131415typedef struct expdesc &#123; expkind k; union &#123; struct &#123; /* for indexed variables (VINDEXED) 索引变量（VINDEXED） */ short idx; /* index (R/K) 索引 */ lu_byte t; /* table (register or upvalue) 表（寄存器或者上值） */ lu_byte vt; /* whether 't' is register (VLOCAL) or upvalue (VUPVAL) t 是寄存器（局部变量）或者上值（上值） */ &#125; ind; int info; /* for generic use */ lua_Number nval; /* for VKFLT */ lua_Integer ival; /* for VKINT */ &#125; u; int t; /* patch list of 'exit when true' */ int f; /* patch list of 'exit when false' */&#125; expdesc; 变量 k 表示具体的类型 后面紧跟的 union u 根据不同的类型存储的数据有所区分，具体可以看 expkind 类型定义后面的注释 至于 t 和 f 这两个变量，目前可以暂时不管，这是跳转相关的指令。 解析表达式列表：解析表达式列表的函数为explist： 1234567891011static int explist (LexState *ls, expdesc *v) &#123; /* explist -&gt; expr &#123; ',' expr &#125; */ int n = 1; /* at least one expression */ expr(ls, v); while (testnext(ls, ',')) &#123; luaK_exp2nextreg(ls-&gt;fs, v); expr(ls, v); n++; &#125; return n;&#125; 调用函数expr解析表达式 当解析的表达式列表中还存在其他的表达式时，即有逗号（，）分隔的式子时，针对每个表达式继续调用expr函数解析表达式，将结果缓存在expdesc结构体中，然后调用函数 luaK_exp2nextreg 将表达式存入当前函数的下一个可用寄存器中。 根据上面的调用路径，最终会走入 simpleexp 中： 123456789101112131415161718static void simpleexp (LexState *ls, expdesc *v) &#123; /* simpleexp -&gt; FLT | INT | STRING | NIL | TRUE | FALSE | ... | constructor | FUNCTION body | suffixedexp */ switch (ls-&gt;t.token) &#123; ... case TK_INT: &#123; init_exp(v, VKINT, 0); v-&gt;u.ival = ls-&gt;t.seminfo.i; break; &#125; ... default: &#123; suffixedexp(ls, v); return; &#125; &#125; luaX_next(ls);&#125; 使用类型 VKINT 初始化 expdesc 结构体，这个类型表示数字常量 将具体的数据赋值给 expdesc 结构体中的 ival，前面说过，expdesc 结构体中 union u 的数据根据不同的类型会存储不同的信息，在 VKINT 这个类型下就是用来存储数字的。 现在这个表达式的信息已经存放在 expdesc 结构体中，需要进一步根据这个结构体的信息来生成对应的字节码。 这个工作由函数 luaK_exp2nextreg 完成，需要根据 expdesc 结构体生成字节码时，都要经过它： 调用 luaK_dischargevars 函数，根据变量所在的不同作用域（local，global，upvalue）来决定这个变量是否需要重定向 调用 luaK_reserveregs 函数，分配可用的函数寄存器空间，得到这个空间对应的寄存器索引。有了空间，才能存储变量 调用exp2reg 函数，真正完成把表达式的数据放入寄存器空间的工作。在这个函数中，最终又会调用dischargereg函数，这个函数式根据不同的表达式类型（NIL，布尔表达式，数字等）来生成存取表达式的值到寄存器的字节码 在函数 discharge2reg 中最终会走到这里： 12345678910111213141516static void discharge2reg (FuncState *fs, expdesc *e, int reg) &#123; luaK_dischargevars(fs, e); switch (e-&gt;k) &#123; ... case VKINT: &#123; luaK_codek(fs, reg, luaK_intK(fs, e-&gt;u.ival)); break; &#125; default: &#123; lua_assert(e-&gt;k == VVOID || e-&gt;k == VJMP); return; /* nothing to do... */ &#125; &#125; e-&gt;u.info = reg; e-&gt;k = VNONRELOC;&#125; 在这个函数的参数中，reg 参数就是前面得到的寄存器索引，于是最后根据 k 值生成了OP_LOADK指令（另一种情况是生成OP_LOADKX指令），将数字 10 加载到 reg 参数对应的寄存器中。 至此，通过对这个最简单的向局部变量赋值操作的分析，完成了 Lua 解释器从词法分析到生成字节码的全过程分析： 每个局部变量都有一个对应的 LocVar 结构体存储它的变量名信息。 每个局部变量都会对应分配一个函数栈的位置来保存它的数据。 解析表达式的结果会存在 expdesc 结构体中。根据不同的类型，内部使用的联合体存放的数据有不同的意义。 luaK_exp2nextreg 是一个非常重要的函数，它用于将 expdesc 结构体的信息中存储的表达式信息转换成对应的 opcode。 流程图： 如果代码变为： 1local a,b = 10 则在localstat函数中进入： 12345static void localstat (LexState *ls) &#123; ... adjust_assign(ls, nvars, nexps, &amp;e); adjustlocalvars(ls, nvars);&#125; 第一个函数adjust_assign用于根据等号两边变量和表达式的数量来调整赋值。具体来说，在上面这个例子中，当变量数量多于等号右边的表达式数量时，会将多余的变量置为NIL。 第二个函数adjustlocalvars会根据变量的数量调整FuncState结构体中记录局部变量数量的nactvar对象，并记录这些局部变量的startpc值。 如果代码变为： 12local a = 10local b = a 主要区别在于走到simpleexp函数时，进入的是另一条路径，走入了primaryexp函数中。然后在prefixexp函数中，判断这是一个变量时，会调用singlevar函数（实际上，最后会调用递归函数 singlevaraux）来进行变量的查找，这个函数的大体流程如下： 如果变量在当前函数的 LocVar 结构体数组中找到，那么这个变量就是局部变量，类型为 VLOCAL。 如果在当前函数中找不到，就逐层往上面的 block 来查找，如果在某一层查到了，那么这个变量就是 UpValue，类型为 VUPVAL。 如果最后那层都没有查到，那么这个变量就是全局变量，类型为 VGLOBAL。 在 luaK_dischargevars 函数中，根据三种不同的类型有不同的操作。 如果赋值的源数据是局部变量，则使用 MOVE 指令来完成赋值。 全局变量：12a = 10local b = a 这时对应的 luaK_dischargevars 函数这样： 123456789101112void luaK_dischargevars (FuncState *fs, expdesc *e) &#123; switch (e-&gt;k) &#123; ... case VGLOBAL: &#123; e-&gt;u.s.info = luaK_codeABx(fs, OP_GETGLOBAL, 0, e-&gt;u.s.info); e-&gt;k = VRELOCABLE; break; &#125; ... &#125;&#125;// lua 5.1.5 而在 Lua 5.3版本中，应该是在这部分函数中对全局变量进行处理的（存疑）。 1234567891011static void singlevar (LexState *ls, expdesc *var) &#123; TString *varname = str_checkname(ls); FuncState *fs = ls-&gt;fs; if (singlevaraux(fs, varname, var, 1) == VVOID) &#123; /* global name? */ expdesc key; singlevaraux(fs, ls-&gt;envn, var, 1); /* get environment variable */ lua_assert(var-&gt;k == VLOCAL || var-&gt;k == VUPVAL); codestring(ls, &amp;key, varname); /* key is variable name */ luaK_indexed(fs, var, &amp;key); /* env[varname] */ &#125;&#125; 参考： 扩展巴科斯范式)]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua源码阅读：数据结构与栈]]></title>
    <url>%2F2019%2F08%2F22%2FLua%2FLua%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E6%A0%88%2F</url>
    <content type="text"><![CDATA[承接上篇虚拟机概述，解析函数执行流程。 数据结构与栈：每个Lua 虚拟机对应一个 lua_State 结构体，它使用 TValue 数组来模拟栈，其中包括几个与栈相关的成员： stack：栈数组的起始位置 base：当前函数栈的基地址 top：当前栈的下一个可用位置 这些成员的初始化操作在 stack_init 函数中完成。 然而 lua_State 里面存放的是一个 lua 虚拟机的全局状态，当执行到一个函数时，需要有对应的数据结构来表示函数相关的信息，这个数据结构就是 CallInfo，这个结构体中同样有 top、base这两个与栈相关的成员。 12345678910111213141516171819202122232425262728/*** Information about a call.** When a thread yields, 'func' is adjusted to pretend that the** top function has only the yielded values in its stack; in that** case, the actual 'func' value is saved in field 'extra'. ** When a function calls another with a continuation, 'extra' keeps** the function index so that, in case of errors, the continuation** function can be called with the correct top.*/typedef struct CallInfo &#123; StkId func; /* function index in the stack */ StkId top; /* top for this function */ struct CallInfo *previous, *next; /* dynamic call link */ union &#123; struct &#123; /* only for Lua functions */ StkId base; /* base for this function */ const Instruction *savedpc; &#125; l; struct &#123; /* only for C functions */ lua_KFunction k; /* continuation in case of yields */ ptrdiff_t old_errfunc; lua_KContext ctx; /* context info. in case of yields */ &#125; c; &#125; u; ptrdiff_t extra; short nresults; /* expected number of results from this function */ lu_byte callstatus;&#125; CallInfo; 在 lua_State 中，有一个 base_ci 的 CallInfo 数组，存储的就是 CallInfo 的信息，而另一个 ci 成员，指向的就是当前函数的 CallInfo 指针。 在调用函数之前，一般会调用 luaD_precall 函数： 保存当前虚拟机执行的指令 savedpc 到当前 CallInfo 的 savedpc 中。此处保存下来是为了后面调用完毕之后恢复执行。 分别计算出待调用函数的 base、top 值，这些值的计算依赖于函数的参数数量。 从 lua_State 的 base_ci 数组中分配一个新的 CallInfo 指针，存储前面两步计算出来的信息，切换到这个函数准备调用。 指令的解析：首先，分析阶段要用到的数据结构是 FuncState。这个结构体用于在语法分析时保存解析函数之后相关的信息，根据其中的 prev 指针成员来串联起来。对于下面的 Lua 代码： 12345-- 最外层 FuncState fs1local function a() -- 函数 a 的 FuncState fsa local function b() -- 函数 b 的 FuncState fsb endend 涉及到三个 FuncState 指针，一层一层嵌套包围，其中fs1是 fsa 的父指针: 在 FuncState 结构体中，有一个成员 Proto *f，它用来保存这个 FuncState 解析指令后生成的指令，其中除了自己的，还包括内部嵌套的子函数的： 1234567891011121314151617/* state needed to generate code for a given function */typedef struct FuncState &#123; Proto *f; /* current function header */ struct FuncState *prev; /* enclosing function */ struct LexState *ls; /* lexical state */ struct BlockCnt *bl; /* chain of current blocks */ int pc; /* next position to code (equivalent to 'ncode') */ int lasttarget; /* 'label' of last 'jump label' */ int jpc; /* list of pending jumps to 'pc' */ int nk; /* number of elements in 'k' */ int np; /* number of elements in 'p' */ int firstlocal; /* index of first local var (in Dyndata array) */ short nlocvars; /* number of elements in 'f-&gt;locvars' */ lu_byte nactvar; /* number of active local variables */ lu_byte nups; /* number of upvalues */ lu_byte freereg; /* first free register */&#125; FuncState; 各个层次的 Proto 数据是逐层包含的，因此最外层的全局 FuncState 结构体中的 Proto 数组一定有这个全局结构中所有 Proto 的信息，也就是解析完毕之后的指令信息。 而 luaY_parser 这个函数，它是分析阶段的唯一入口函数，这个函数的返回值就是 Proto 指针，而 FuncState 等数据结构仅是用于分析过程中的临时数据结构，它们最终都是为了解析代码生成指令到 Proto 结构体服务的。 Proto 结构体：1234567891011121314151617181920212223242526/*** Function Prototypes*/typedef struct Proto &#123; CommonHeader; lu_byte numparams; /* number of fixed parameters */ lu_byte is_vararg; lu_byte maxstacksize; /* maximum stack used by this function */ int sizeupvalues; /* size of 'upvalues' */ int sizek; /* size of 'k' */ int sizecode; int sizelineinfo; int sizep; /* size of 'p' */ int sizelocvars; int linedefined; int lastlinedefined; TValue *k; /* constants used by the function 函数使用的常量（数组） */ Instruction *code; /* 保存分析之后生成的 OpCode 数组 */ struct Proto **p; /* functions defined inside the function 函数内定义的函数 */ int *lineinfo; /* map from opcodes to source lines (debug information) */ LocVar *locvars; /* information about local variables (debug information) 局部变量的数组（调试信息） */ Upvaldesc *upvalues; /* upvalue information 保存 upvalue 的数组 */ struct LClosure *cache; /* last created closure with this prototype */ TString *source; /* used for debug information */ GCObject *gclist;&#125; Proto; 指令格式：lua 虚拟机的指令格式： 首先，Lua 的指令是 32 位的： Opcode：操作数 A、B、C：参数 不同操作数的指令格式不同、含义不同。操作数是 6 位的，所以 Lua 最多支持 2^6-1 = 31 个指令。Lua 代码中，将每个操作数及其对应的指令格式都在 lopcodes.h 中的 OpCode 枚举类型中定义。 Lua 虚拟机指令中有着不同的参数： 格式 说明 R(A) A参数作为寄存器索引，R(B)、R(C)依此类推 pc 程序计数器，这个数据用于指示当前指令的地址 Kst(n) 常量数组中的第n个数据 Upvalue(n) upvalue 数组中的第 n 个数据 Gbl[sym] 全局符号表中取名为 sym 的数据 RK(B) B 可能是寄存器索引，也可能是常量数组索引，RK(C)类似 sBx 有符号整数，用于表示跳转偏移量 在lopcodes.h 文件中还定义了每个指令的格式，以及相关的宏；这里定义了在一个指令中每个参数对应的大小和位置。 RK(B)的意思有两层，一是这个指令格式只可能作用在 OpCode 的 B、C 参数上，不会作用在参数 A 上；二是这个数据除了从函数栈获取之外，还有可能从常量数组中获取，关键在于宏 ISK 的判断。 12/* test whether value is a constant */#define ISK(x) ((x) &amp; BITRK) 判断这个数据的第 8 位是不是 1，如果是，则认为应该从 K 数组获取数据，否则就是从函数栈寄存器中获取数据。 从寄存器中取指令是在以 R 开头的宏中，实际代码中会使用一个 base 再加上对应的地址，base 值保存的是函数栈基址： 1234#define RA(i) (base+GETARG_A(i))/* to be used after possible stack reallocation */#define RB(i) check_exp(getBMode(GET_OPCODE(i)) == OpArgR, base+GETARG_B(i))#define RC(i) check_exp(getCMode(GET_OPCODE(i)) == OpArgR, base+GETARG_C(i)) 指令的执行：指令执行的入口函数是 luaV_execute： 12345678910111213141516171819202122void luaV_execute (lua_State *L) &#123; CallInfo *ci = L-&gt;ci; LClosure *cl; TValue *k; StkId base; newframe: /* reentry point when frame changes (call/return) */ lua_assert(ci == L-&gt;ci); cl = clLvalue(ci-&gt;func); k = cl-&gt;p-&gt;k; base = ci-&gt;u.l.base; /* main loop of interpreter */ for (;;) &#123; Instruction i = *(ci-&gt;u.l.savedpc++); StkId ra; if ((L-&gt;hookmask &amp; (LUA_MASKLINE | LUA_MASKCOUNT)) &amp;&amp; (--L-&gt;hookcount == 0 || L-&gt;hookmask &amp; LUA_MASKLINE)) &#123; Protect(luaG_traceexec(L)); &#125; /* WARNING: several calls may realloc the stack and invalidate 'ra' */ ra = RA(i); lua_assert(base == ci-&gt;u.l.base); lua_assert(base &lt;= L-&gt;top &amp;&amp; L-&gt;top &lt; L-&gt;stack + L-&gt;stacksize); ci：用于保存当前指令的执行位置（以及一些其他信息，包括动态调用链的双向链表） cl：当前所在的函数环境 base：当前函数环境的栈 base 地址 k：当前函数环境的常量数组 总结： 分析阶段最后的结果就是Proto结构体。在这个结构体中，code成员用于存储指令，f数组用于保存里面嵌套的函数的Proto结构体。 每个环境都有自己对应的栈，base指向这个栈的基地址，top指向这个栈的栈顶地址。取函数栈内的数据，都是以base基地址为基础地址的操作。 在虚拟机开始执行指令之前，需要把对应的指令和栈地址切换到所要执行的函数的数据上。 参考： 《Lua设计与实现》（codedump 著） Lua 源码解析]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua源码阅读：虚拟机概述]]></title>
    <url>%2F2019%2F08%2F21%2FLua%2FLua%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%9A%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[Lua 虚拟机的执行过程。 Lua 执行过程概述：解释型脚本语言与编译型语言的区别如下： 由于每个脚本语言都有自己的一套字节码，与具体的硬件平台无关，所以不用修改脚本代码，就能运行在各个平台上。硬件、软件平台的差异都由语言自身的虚拟机解决。 由于脚本语言的字节码需要虚拟机执行，而不像机器代码能够直接执行，所以运行速度比编译型语言差不少。 虚拟机需要完成以下工作： 将源代码编译成虚拟机可以识别执行的字节码。 为函数调用准备调用栈。 内部维持一个 IP（Instruction Pointer，指令指针）来保存下一个将执行的指令地址。在 Lua 代码中，IP 对应的是 PC 指针。 模拟一个 CPU 的运行：循环拿出由 IP 指向的字节码，根据字节码格式进行解码，然后执行字节码。 虚拟机的实现方式：虚拟机有两种不同的实现方式：基于栈的虚拟机和基于寄存器的虚拟机。Lua 是基于寄存器虚拟机的语言。 区别： 在基于栈的虚拟机中，字节码的操作数是从栈顶上弹出（pop），在执行完操作后再压入栈顶的，这样的缺点是会多出几条指令来准备数据，优点是指令中不需要关心操作数的地址，在执行操作之前就已经将操作数准备在栈顶上了。 在基于寄存器的指令中，操作数是放在“CPU 的寄存器”中，因此，同样的操作不再需要 PUSH、POP 指令，取而代之的是在字节码中带上具体操作数所在的寄存器地址。对比需要栈的寄存器，这里的指令数会减少，但缺点是此时程序需要关注操作数所在的位置。 实现一个脚本语言的解释器： 设计一套字节码，分析源代码文件生成字节码。 在虚拟机中执行字节码。 如何在整个执行过程中保存整个执行环境。 执行Lua文件调用的是luaL_dofile 函数： 12#define luaL_dofile(L, fn) \ (luaL_loadfile(L, fn) || lua_pcall(L, 0, LUA_MULTRET, 0)) 其中 luaL_loadfile 函数用于进行词法和语法分析，lua_pcall 用于将第一步中分析的结果（字节码）放在虚拟机中执行。 luaL_loadfile 函数，通过lua_load，luaD_protectedparser，最终调用 f_parser 函数： 1234567891011121314151617// ldo.cstatic void f_parser (lua_State *L, void *ud) &#123; LClosure *cl; struct SParser *p = cast(struct SParser *, ud); int c = zgetc(p-&gt;z); /* read first character */ if (c == LUA_SIGNATURE[0]) &#123; checkmode(L, p-&gt;mode, "binary"); cl = luaU_undump(L, p-&gt;z, &amp;p-&gt;buff, p-&gt;name); &#125; else &#123; checkmode(L, p-&gt;mode, "text"); cl = luaY_parser(L, p-&gt;z, &amp;p-&gt;buff, &amp;p-&gt;dyd, p-&gt;name, c); &#125; lua_assert(cl-&gt;nupvalues == cl-&gt;p-&gt;sizeupvalues); luaF_initupvals(L, cl);&#125; 完成词法分析之后，返回了 Proto 类型的指针tf，然后将其绑定在新创建的 Closure 指针上，初始化 Upvalue，最后压入栈中。 词法分析之后产生的字节码等相关数据都在这个 Proto 类型的结构体中，而这个数据又作为 Closure 保存了下来。 lua_pcall 内部调用了lua_pcallk函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344// lapi.cLUA_API int lua_pcallk (lua_State *L, int nargs, int nresults, int errfunc, lua_KContext ctx, lua_KFunction k) &#123; struct CallS c; int status; ptrdiff_t func; lua_lock(L); api_check(k == NULL || !isLua(L-&gt;ci), "cannot use continuations inside hooks"); api_checknelems(L, nargs+1); api_check(L-&gt;status == LUA_OK, "cannot do calls on non-normal thread"); checkresults(L, nargs, nresults); if (errfunc == 0) func = 0; else &#123; StkId o = index2addr(L, errfunc); api_checkstackindex(errfunc, o); func = savestack(L, o); &#125; c.func = L-&gt;top - (nargs+1); /* function to be called */ if (k == NULL || L-&gt;nny &gt; 0) &#123; /* no continuation or no yieldable? */ c.nresults = nresults; /* do a 'conventional' protected call */ status = luaD_pcall(L, f_call, &amp;c, savestack(L, c.func), func); &#125; else &#123; /* prepare continuation (call is already protected by 'resume') */ CallInfo *ci = L-&gt;ci; ci-&gt;u.c.k = k; /* save continuation */ ci-&gt;u.c.ctx = ctx; /* save context */ /* save information for error recovery */ ci-&gt;extra = savestack(L, c.func); ci-&gt;u.c.old_errfunc = L-&gt;errfunc; L-&gt;errfunc = func; setoah(ci-&gt;callstatus, L-&gt;allowhook); /* save value of 'allowhook' */ ci-&gt;callstatus |= CIST_YPCALL; /* function can do error recovery */ luaD_call(L, c.func, nresults, 1); /* do the call */ ci-&gt;callstatus &amp;= ~CIST_YPCALL; L-&gt;errfunc = ci-&gt;u.c.old_errfunc; status = LUA_OK; /* if it is here, there were no errors */ &#125; adjustresults(L, nresults); lua_unlock(L); return status;&#125; 可以看到，首先获取需要调用的函数指针： 1c.func = L-&gt;top - (nargs+1); /* function to be called */ 这里的 nargs 是由函数参数传入的，在 lual_dofile 中调用 lua_pcall 时，这里传入的参数是 0。换句话说，这里得到的函数对象指针就是前面 f_parser 函数中最后两句代码放入 Lua 栈的 Closure 指针。 继续向下执行，在调用函数 luaD_pcall 时，最终会执行到 luaD_call 函数，其中有： 12if (!luaD_precall(L, func, nResults)) /* is a Lua function? */ luaV_execute(L); /* call it */ 首先调用 luaD_precall 函数进行执行前的准备工作： 1234567891011121314151617181920212223242526272829303132333435/*** returns true if function has been executed (C function) ...部分有省略*/int luaD_precall (lua_State *L, StkId func, int nresults) &#123; lua_CFunction f; CallInfo *ci; int n; /* number of arguments (Lua) or returns (C) */ ptrdiff_t funcr = savestack(L, func); switch (ttype(func)) &#123; ... case LUA_TLCL: &#123; /* Lua function: prepare its call */ StkId base; Proto *p = clLvalue(func)-&gt;p; ... ci = next_ci(L); /* now 'enter' new function */ ci-&gt;nresults = nresults; ci-&gt;func = func; ci-&gt;u.l.base = base; ci-&gt;top = base + p-&gt;maxstacksize; lua_assert(ci-&gt;top &lt;= L-&gt;stack_last); ci-&gt;u.l.savedpc = p-&gt;code; /* starting point */ ci-&gt;callstatus = CIST_LUA; L-&gt;top = ci-&gt;top; luaC_checkGC(L); /* stack grow uses memory */ if (L-&gt;hookmask &amp; LUA_MASKCALL) callhook(L, ci); return 0; &#125; ... &#125;&#125; 从 lua_State 的 CallInfo 数组中得到一个新的 CallInfo 结构体，设置它的func、base、top 指针 从前面分析阶段生成的 Closure 指针中，取出保存下来的 Proto 结构体。这个结构体中保存的是分析过程完结之后生成的字节码等信息。 将这里创建的 CallInfo 指针的 top、base 指针赋给 lua_State 结构体的 top、base 指针。将 Proto 结构体的 code 成员赋值给 lua_State 指针的 savedpc 字段，code 成员保留的就是字节码。 将多余的函数参数赋值为 nil，比如一个函数定义中需要的是两个参数，实际传入的只有一个，那么多出来的那个参数会被赋值为 nil。 执行完 luaD_precall 函数之后，接着会进入 luaV_execute 函数，这里是虚拟机执行代码的主函数： 1234567891011121314151617181920212223// lvm.cvoid luaV_execute (lua_State *L) &#123; CallInfo *ci = L-&gt;ci; LClosure *cl; TValue *k; StkId base; newframe: /* reentry point when frame changes (call/return) */ lua_assert(ci == L-&gt;ci); cl = clLvalue(ci-&gt;func); k = cl-&gt;p-&gt;k; base = ci-&gt;u.l.base; /* main loop of interpreter */ for (;;) &#123; Instruction i = *(ci-&gt;u.l.savedpc++); StkId ra; if ((L-&gt;hookmask &amp; (LUA_MASKLINE | LUA_MASKCOUNT)) &amp;&amp; (--L-&gt;hookcount == 0 || L-&gt;hookmask &amp; LUA_MASKLINE)) &#123; Protect(luaG_traceexec(L)); &#125; /* WARNING: several calls may realloc the stack and invalidate 'ra' */ ra = RA(i); /* 后面是各种字节码的处理流程 */&#125; 这里的 ci-&gt;u.l.savedpc存放的是虚拟机 OpCode 代码，这部分从 L-&gt;savepc 初始化而来，而 L-&gt;savepc 在 luaD_precall 中赋值。可以看到，luaV_execute 函数最主要的作用就是一个大循环，将当前传入的指令依次执行。 执行完毕后，会调用 luaD_poscall 函数恢复到上一次函数调用的环境。 1234567891011121314151617181920212223int luaD_poscall (lua_State *L, StkId firstResult) &#123; StkId res; int wanted, i; CallInfo *ci = L-&gt;ci; if (L-&gt;hookmask &amp; (LUA_MASKRET | LUA_MASKLINE)) &#123; if (L-&gt;hookmask &amp; LUA_MASKRET) &#123; ptrdiff_t fr = savestack(L, firstResult); /* hook may change stack */ luaD_hook(L, LUA_HOOKRET, -1); firstResult = restorestack(L, fr); &#125; L-&gt;oldpc = ci-&gt;previous-&gt;u.l.savedpc; /* 'oldpc' for caller function */ &#125; res = ci-&gt;func; /* res == final position of 1st result */ wanted = ci-&gt;nresults; L-&gt;ci = ci = ci-&gt;previous; /* back to caller */ /* move results to correct place */ for (i = wanted; i != 0 &amp;&amp; firstResult &lt; L-&gt;top; i--) setobjs2s(L, res++, firstResult++); while (i-- &gt; 0) setnilvalue(res++); L-&gt;top = res; return (wanted - LUA_MULTRET); /* 0 iff wanted == LUA_MULTRET */&#125; 虚拟机执行流程： 在f_parser函数中，对代码文件的分析返回了Proto指针。这个指针会保存在Closure指针中，留待后续继续使用。 在luaD_precall函数中，将lua_state的savedpc指针指向第一步中Proto结构体的code指针，同时准备好函数调用时的栈信息。 在luaV_execute函数中，pc指针指向第二步的savedpc指针（Lua5.3中似乎直接使用的savedpc指针），紧跟着就是一个大的循环体，依次取出其中的OpCode执行。 执行完毕后，调用luaD_poscall函数恢复到上一个函数的环境。 虚拟机指令执行的两大入口如下： 词法、语法分析阶段的luaY_parser，Lua一次遍历脚本文件完成了词法分析和语法分析，生成的OpCode存放在Proto结构体的code数组中。 luaV_execute：虚拟机执行指令阶段的入口函数，取出第一步生成的Proto结构体中的指令执行。 Proto结构体中的数据： 函数的常量数组 编译生成的字节码信息 函数的局部变量信息 保存upvalue名字的数组 1234567891011121314151617181920212223242526/*** Function Prototypes*/typedef struct Proto &#123; CommonHeader; lu_byte numparams; /* number of fixed parameters */ lu_byte is_vararg; lu_byte maxstacksize; /* maximum stack used by this function */ int sizeupvalues; /* size of 'upvalues' */ int sizek; /* size of 'k' */ int sizecode; int sizelineinfo; int sizep; /* size of 'p' */ int sizelocvars; int linedefined; int lastlinedefined; TValue *k; /* constants used by the function */ Instruction *code; struct Proto **p; /* functions defined inside the function */ int *lineinfo; /* map from opcodes to source lines (debug information) */ LocVar *locvars; /* information about local variables (debug information) */ Upvaldesc *upvalues; /* upvalue information */ struct LClosure *cache; /* last created closure with this prototype */ TString *source; /* used for debug information */ GCObject *gclist;&#125; Proto; 该程序最终会调用 luaV_execute() 函数执行，开始会初始化 global_State、lua_State 两个结构体，用来保存上下文的相关信息。 12345678910111213main() |-luaL_newstate() # 创建global_State+lua_State，并初始化 |-lua_pcall() # 实际会调用pmain()函数 | # 根据不同的参数调用不同的函数 |-runargs() # 执行命令行通过-e指定的命令 |-doREPL() # 执行交互模式，也即read-eval-print loop |-handle_script() # 执行lua脚本 |-luaL_loadfile() # 加载lua文件，后面详细介绍 | |-lua_load() | |-docall() # 调用执行 |-lua_pcall() |-luaD_pcall() # 实际会调用f_call()函数 在调用函数执行过程中，最终会调用 luaV_execute() 函数。其中，主要处理字节码的是 for(;;){} 循环，也即进入到解释器的主循环，处理很简单，取得当前指令，pc 递增，初始化 ra，然后根据指令的操作码进行选择；然后接下来是一大串的 switch … case … 处理。 接下来对其中有主要的几类指令进行说明。 关于define部分符号用法详见：https://www.jianshu.com/p/e9f00097904a，先转一个，有时间了再写。 另一个参考：https://gcc.gnu.org/onlinedocs/cpp/Macros.html#Macros]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua与C交互相关]]></title>
    <url>%2F2019%2F08%2F16%2FLua%2FLua%E4%B8%8EC%E4%BA%A4%E4%BA%92%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[C语言API总览。 C语言和Lua语言的两种交互形式： C语言拥有控制权，而Lua语言被用作库，这种交互形式中的C代码被称为应用代码。 Lua语言拥有控制权，而C语言被用作库，此时的C代码被称为库代码。 应用代码和库代码都适用相同的API和Lua语言通信，这些API称为C API。 一个简单的独立解释器：1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include "lua.h"#include "lauxlib.h"#include "lualib.h"int main(void)&#123; char buff[256]; int error; lua_State *L = luaL_newstate(); /* 打开Lua */ luaL_openlibs(L); /* 打开标准库 */ while(fgets(buuff,sizeof(buff),stdin) != NULL) &#123; error = luaL_loadstring(L,buff) || lua_pcall(L,0,0,0); if(error) &#123; fprintf(stderr,"%s\n",lua_tostring(L,-1)); lua_pop(L,1); /* 从栈中弹出错误信息 */ &#125; &#125; lua_close(L); return 0;&#125; 头文件lua.h声明了Lua提供的基础函数，其中包括创建新Lua环境的函数、调用Lua函数的函数、读写环境中的全局变量的函数，以及注册供Lua语言调用的新函数的函数，等等。其中声明的所有内容都有一个前缀lua_。 头文件lauxlib.h声明了辅助库所提供的函数，其中所有的声明均以luaL_开头。 头文件lualib.h中声明了用于打开这些库的函数。 栈：Lua和C之间通信的主要组件是虚拟栈，几乎所有的API的调用都是在操作这个栈中的值，Lua和C之间所有的数据交换都是通过这个栈完成的，此外，还可以利用栈保存中间结果。 为了解决动态类型和静态类型体系之间不匹配，以及自动内存管理和手动内存管理之间不匹配：Lua API中没有定义任何类似于lua_Value的类型，而是使用栈在Lua和C之间交换数据。栈中的每个元素都能保存Lua中任意类型的值。当我们想要从Lua中获取一个值时，只需调用Lua，Lua就会将指定的值压入栈中。当想要将一个值传给Lua时，首先要将这个值压入栈，然后调用Lua将其从栈中弹出即可。这需要每个C语言类型都有一个函数将其压入栈，还需要每个类型都有一个弹出的函数，但是避免了过多的组合，另外由于这个栈是Lua状态的一部分，因此垃圾收集器知道C语言正在使用哪些值。 压入元素：针对每一种能用C语言直接表示的Lua数据类型，C API中都有一个对应的压栈函数。 对栈空间的检查可以使用int lua_checkstack(lua_State *L,int sz);这里，sz是我们所需的额外栈位置的数量，如果可能，函数 lua_checkstack 会增加栈的大小，以容纳所需的额外空间；否则该函数返回0。 查询元素：第一个被压入栈的元素索引为1，第二个被压入的元素索引为2，依此类推。也可以使用负数索引来访问栈中的元素，栈顶的元素为-1，-2表示在它之前被压入栈中的元素。 与Lua栈相关的函数游一系列，在此不做赘述。 使用C API进行错误处理：处理应用程序中的错误：Lua语言通常通过长跳转来提示错误，但是如果没有相应的setjmp，解释器就无法进行长跳转。此时，API中的任何错误都会导致Lua调用紧急函数。当这个函数返回后，应用就会退出。 要正确的处理应用代码中的错误，就必须通过Lua语言调用我们自己的代码，即在setjmp的上下文中运行代码。 我们可以把C代码封装到一个函数F中，然后使用lua_pcall调用这个函数F，通过这种方式，我们的C代码会在保护模式下运行。即便发生内存分配失败，函数lua_pcall也会返回一个对应的错误码，使解释器能够保持一致的状态： 1234567891011static int foo(lua_State *L)&#123; //code to run in protected mode return 0;&#125;int secure_foo(lua_State *L)&#123; lua_pushcfunction(L,foo); return (lua_pcall(L,0,0,0) == 0)&#125; 无论发生什么，调用secure_foo时都会返回一个布尔值，来表示foo执行是否成功。 处理库代码中的错误：当C语言库中的函数检测到错误时，只需简单的调用lua_error即可。 内存分配：Lua语言核心对内存分配不进行任何假设，只会通过一个分配函数来分配和释放内存，当用户创建lua状态时必须提供该函数。 luaL_newstate是一个用默认分配函数来创建Lua状态的辅助函数。该默认分配函数使用了来自C语言标准函数库的标准函数malloc-realloc-free，对于大多数应用程序来说已经够了，但是，要完全控制Lua的内存分配也很容易，使用原始的lua_newstate来创建我们自己的Lua状态即可： 1lua_State *lua_newstate(lua_Alloc f,void *ud) 该函数有两个参数：一个是分配函数，另一个是用户数据。用这种方式创建的Lua状态会通过调用f完成所有的内存分配和释放，甚至结构lua_State也是由f分配的。 分配函数f必须满足lua_Alloc的类型声明： 1234typedef void *(*lua_Alloc)(void *ud, // 为lua_newstate所提供的用户数据 void *ptr, // 正要被分配或者释放的块的地址 size_t osize, // 原始块的大小 size_t nsize); // 请求的块大小 如果ptr不是NULL，则lua会保证其之前被分配的大小就是osize。 当nsize为0时，分配函数必须释放ptr指向的块并返回NULL，对应于所要求的大小为零的块。当ptr时NULL时，该函数必须分配并返回一个指定大小的块；如果无法分配指定的块，则必须返回NULL。 pcall：在调用函数lua_pcall时，第二个参数表示传递的参数数量，第三个参数是期望的结果数量，第四个参数代表错误处理函数。就像Lua语言的赋值一样，函数lua_pcall会根据所要求的数量来调整返回值的个数，即压入nil或丢弃多余的结果。在压入结果前，lua_pcall会把函数和其参数从栈中移除。当一个函数返回多个结果时，那么第一个结果最后被压入。 在Lua中调用C语言：当Lua调用C函数时，我们必须注册该函数，即必须以一种恰当的方式为Lua提供该C函数的地址。Lua调用C函数时，也使用了一个与C语言调用Lua函数时相同类型的栈，C函数从栈中获取参数，并将结果压入栈中。 这个栈不是一个全局结构；每个函数都有其私有的局部栈。当Lua调用一个C函数时，第一个参数总是位于这个局部栈中索引为1的位置。即使一个C函数调用了Lua代码，而且Lua代码又再次调用了同一个的C函数，这些调用每一个都只会看到本次调用自己的私有栈，其中索引为1的位置上就是第一个参数。 所有在Lua中注册的函数都必须使用一个相同的原型，该原型就是定义在lua.h中的lua_CFunction： 1typedef int (*lua_CFunction)(lua_State *L) 在Lua中，调用这个函数前，还必须通过lua_pushcfunction注册该函数。函数lua_pushcfunction会获取一个指向C函数的指针，然后在Lua中创建一个“function”类型，代表待注册的函数。一旦完成注册，C函数就可以像其他Lua函数一样行事了。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua源码阅读：基本数据类型Table]]></title>
    <url>%2F2019%2F08%2F12%2FLua%2FLua%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8BTable%2F</url>
    <content type="text"><![CDATA[Lua中Table数据结构的定义、初始化、查找等。 Table数据结构的定义：123456789101112131415161718192021222324typedef union TKey &#123; struct &#123; TValuefields; int next; /* for chaining (offset for next node) */ &#125; nk; TValue tvk;&#125; TKey;typedef struct Node &#123; TValue i_val; TKey i_key;&#125; Node;typedef struct Table &#123; CommonHeader; lu_byte flags; /* 1&lt;&lt;p means tagmethod(p) is not present */ lu_byte lsizenode; /* log2 of size of 'node' array */ unsigned int sizearray; /* size of 'array' array */ TValue *array; /* array part */ Node *node; Node *lastfree; /* any free position is before this position */ struct Table *metatable; GCObject *gclist;&#125; Table; Table的结构中有CommonHeader成员，这是一个在lObject.h中定义的宏，包含了一些成员，所有受gc管理的对象均含有CommonHeader，其继承自GObject对象。CommonHeader 相当于来自父类的数据，在整个结构的最前面，其他成员相当于子类数据。通过这种方式可以让GCObject 指针指向所有受gc管理的lua的对象，并且CommonHeader 结构中还有当前对象的类型，可以转换成具体类型的对象。 12345/*** Common Header for all collectable objects (in macro form, to be** included in other objects)*/#define CommonHeader GCObject *next; lu_byte tt; lu_byte marked TValue是所有lua数据类型的集合，其包含一个类型_tt和一个value，Value类型是一个union，可以是lua的任意类型： 12345678910111213141516171819202122/*** Tagged Values. This is the basic representation of values in Lua,** an actual value plus a tag with its type.*/#define TValuefields Value value_; int tt_typedef struct lua_TValue TValue;union Value &#123; GCObject *gc; /* collectable objects */ void *p; /* light userdata */ int b; /* booleans */ lua_CFunction f; /* light C functions */ lua_Integer i; /* integer numbers */ lua_Number n; /* float numbers */&#125;;struct lua_TValue &#123; TValuefields;&#125;; Table主要有两部分，数组和哈希： array和node是两个一维数组，array是普通的数组，成员为TValue，node是一个hash表存放key,value键值对。node的key为TKey类型，Tkey是一个union，当没有hash冲突的时候是一个TValue，当有hash冲突的时候TKey是一个struct，多一个next值，指向下一个有冲突的节点。 1234567891011121314151617181920typedef union TKey &#123; struct &#123; TValuefields; int next; /* for chaining (offset for next node) */ &#125; nk; TValue tvk;&#125; TKey;/* copy a value into a key without messing up field 'next' */#define setnodekey(L,key,obj) \ &#123; TKey *k_=(key); const TValue *io_=(obj); \ k_-&gt;nk.value_ = io_-&gt;value_; k_-&gt;nk.tt_ = io_-&gt;tt_; \ (void)L; checkliveness(G(L),io_); &#125;typedef struct Node &#123; TValue i_val; TKey i_key;&#125; Node; sizearray：是数组array的大小 lsizenode：2^lsizenode 的值为node 的大小 lastfree：lastfree 指针的右边均由非空的或者不能访问的node (即不属于自己的空间，访问会越界)组成 metatable ：元表 gclist：与gc 有关，将table加入到gray表中时，gclist指向gray表中的下一个元素或者NULL flags : 这是一个byte类型的数据，用于表示这个表中提供了哪些元方法，最开始的flag为1，当查找了一次之后，如果该表中存在某个元方法，那么将该元方法对应的flag bit置为0，这样下一次查找时只需要比较这个bit就行了。每个元方法对应的bit定义在ltm.h中 。 Table的初始化：12345678910Table *luaH_new (lua_State *L) &#123; GCObject *o = luaC_newobj(L, LUA_TTABLE, sizeof(Table)); Table *t = gco2t(o); t-&gt;metatable = NULL; t-&gt;flags = cast_byte(~0); t-&gt;array = NULL; t-&gt;sizearray = 0; setnodevector(L, t, 0); return t;&#125; 首先，为Table开辟空间，然后将其加到allgc链表上通过gc进行管理，之后初始化Table的内容。 1234567891011121314151617181920212223242526272829303132static void setnodevector (lua_State *L, Table *t, unsigned int size) &#123; int lsize; if (size == 0) &#123; /* no elements to hash part? */ t-&gt;node = cast(Node *, dummynode); /* use common 'dummynode' */ lsize = 0; &#125; else &#123; int i; lsize = luaO_ceillog2(size); if (lsize &gt; MAXHBITS) luaG_runerror(L, "table overflow"); size = twoto(lsize); t-&gt;node = luaM_newvector(L, size, Node); for (i = 0; i &lt; (int)size; i++) &#123; Node *n = gnode(t, i); gnext(n) = 0; setnilvalue(wgkey(n)); setnilvalue(gval(n)); &#125; &#125; t-&gt;lsizenode = cast_byte(lsize); t-&gt;lastfree = gnode(t, size); /* all positions are free */&#125;#define dummynode (&amp;dummynode_)#define isdummy(n) ((n) == dummynode)static const Node dummynode_ = &#123; &#123;NILCONSTANT&#125;, /* value */ &#123;&#123;NILCONSTANT, 0&#125;&#125; /* key */&#125;; flag设置为全1表示没有元方法，node指向的不是NULL而是dummynode，dummynode是一个全局共享的对象（key和value均为nil），这样做可以减少NULL的判断：例如，刚初始化完table，需要查找一个key为“test”的对象，因为lsizenode为0，所以经过运算确定的位置肯定为node[0]，然后读取node[0].i_key和“test”的TKey进行比较，判断是否相同，node[0]是dummynode，所以比较结果肯定不相同，所以返回nil；如果node[0]为NULL，访问node[0]的时候必须先判断node[0]是否为NULL，否则直接访问会越界，dummynode的设计省去了NULL的判断。 Table的查找：因为table有两部分，数组和hash表，所以查找也分为两部分来进行： 在数组中查找，如果传入的key是integer类型，而且其值-1小于sizearray的话，在数组中查找。 其他情况在hash表中查找：计算出该key的散列值，根据此散列值访问Node数组得到散列桶所在的位置，遍历该散列桶下的所有链表元素，直到找到该key为止。 在Lua中除了nil，其他类型均可以作为表的key，那么table的key是如何与其array数组与hash表的下标对应的呢？ 对于array数组，如果是上述的第一种情况，则直接将key-1即得到了下标，对于hash表则需要将key转换成uint类型，然后通过计算得到下标。 通过运算将各类型转换为uint 类型的值，如将LUA_TNUMFLT 类型二进制数值转成以uint 型类 型表示，将LUA_TTABLE 的gc 指针转换为uint 类型， LUA_TSHRSTR 类型直接取其hash值，因为短字符串在构造时会计算其hash值，LUA_TLNGSTR 类型则需要通过hash函数计算其hash值。在 完成了对key 的hash运算以后，需要根据key 的hash值计算该key对应hash表中的哪个下标，计算的公式是: 1index = hash_value &amp; ((2^lsizenode) - 1) 其中2^lsizenode - 1 为一个二进制低位全为1 的值，和hash_value 相与可以保证hash_value超过2^lsizenode - 1 的部分为0，则得到的值一定在[0，(2^lsizenode) - 1] 区间内，此时key和hash 表的下标就对应了起来，并且不会越界。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/*** main search function*/const TValue *luaH_get (Table *t, const TValue *key) &#123; switch (ttype(key)) &#123; case LUA_TSHRSTR: return luaH_getstr(t, tsvalue(key)); case LUA_TNUMINT: return luaH_getint(t, ivalue(key)); case LUA_TNIL: return luaO_nilobject; case LUA_TNUMFLT: &#123; lua_Integer k; if (numisinteger(fltvalue(key), &amp;k)) /* index is int? */ return luaH_getint(t, k); /* use specialized version */ /* else go through */ &#125; default: &#123; Node *n = mainposition(t, key); for (;;) &#123; /* check whether 'key' is somewhere in the chain */ if (luaV_rawequalobj(gkey(n), key)) return gval(n); /* that's it */ else &#123; int nx = gnext(n); if (nx == 0) break; n += nx; &#125; &#125;; return luaO_nilobject; &#125; &#125;&#125;/*** search function for integers*/const TValue *luaH_getint (Table *t, lua_Integer key) &#123; /* (1 &lt;= key &amp;&amp; key &lt;= t-&gt;sizearray) */ if (l_castS2U(key - 1) &lt; t-&gt;sizearray) return &amp;t-&gt;array[key - 1]; else &#123; Node *n = hashint(t, key); for (;;) &#123; /* check whether 'key' is somewhere in the chain */ if (ttisinteger(gkey(n)) &amp;&amp; ivalue(gkey(n)) == key) return gval(n); /* that's it */ else &#123; int nx = gnext(n); if (nx == 0) break; n += nx; &#125; &#125;; return luaO_nilobject; &#125;&#125; Table的更新：table 更新也分两种情况: 通过上述查找的 value 如果不是 luaO_nilobject ，直接将 value 更改即可，即table的修改和删除(将值置为nil) 查找返回的是 luaO_nilobject ，即 key 在 table 中不存在时( table 的插入操作)需要先找一个空的槽，然后完成插入操作，如果找不到空槽则需要扩容。 散列表部分的数据组织是，首先计算数据的key所在的桶数组位置，这个位置称为mainposition。相同mainposition的数据以链表形式组织： 这部分的API包括luaH_set、luaH_setnum、luaH_setstr 这三个函数，它们的实际行为并不在其函数内部对 key 所对应的数据进行添加或者修改，而是返回根据该 key 查找到的 TValue 指针，由外部的使用者来进行实际的替换操作。 当找不到对应的 key 时，这几个 API 最终都会调用内部的 newkey 函数分配一个新的 key 来返回。 具体的更新操作如下： 如果查找一个空槽： 在lua Table中有一个lastfree指针，在更新时通过该指针寻找一个空槽，lastfree 指针在最开始的时候指向NULL ，当空间不够rehash 时，lastfree 指针指向 node 数组中最后不可用的空间，如node 数组size为4 其指向的就是4 的位置(从0开始)。当需要找一个空槽时，lastfree指针向左移，判断当前位置有没有被占用，即key 是否为nil ，如果被占用则继续左移，直到找到一个空槽，或者地址大于node 的地址，即移动到了node 的前一个，表示没有找到。这种方式可以保证lastfree的右边和当前指向的位置均不可用或者被占用，可以减少在查找空槽时对非nil元素的遍历。 冲突时谁移动： 记冲突位置为index ，找到的空槽位置为freeindex ，发生冲突位置的key 为oldkey ， 新的key 为newkey 。发生冲突时计算oldkey 的下标，如果值为index ，则将newkey 建立 到freeindex 位置处，如果oldkey 计算后不是index ，而是因为冲突被移动到index 位置的，则移动oldkey 的node到新的槽。 Tkey的Next如何设置： lua 中的Tkey 中添加了一个next 成员，通过next 可以查找冲突位置的所有元素。比如两个元素冲突了，冲突位置为index (下标，后面的freeindex 也是下标)，这两个元素分别 为node1 、node2 ，假设将node1 移动到了另一个位置freeindex ，那么node2 则在index位置，node2 的next 为freeindex 减去index ，当需要查找node1 时，通过hash 运算找到是node2 ，比较发现不是要找的元素，此时可以通过index + next 找到freeindex 的位置，继续比较判断发现是node1 则返回结果。这种方式可以减少查找时对非冲突元素的遍 历，加快查找效率，不过也有弊端就是每个节点占用的空间会增减四个字节。 Table的扩容：rehash操作是hash 表不可避免的，当空间不够时就需要进行扩容，而扩容后每个元素的下标就需要重新计算。对于一般的开放地址法会有一个负载因子 ，当负载因子大于某个值的时候就需要扩容，这个是为了考虑效率问题，当负载因子越来越大的时候，元素之间冲突的可能性会越来越大，导致插入和查找的时间复杂度会增大所以需要扩容降低负载因子。lua 的table没有负载因子，而是当node 的所有空间都用完的时候才会扩容(被置为nil 也算，lastfree指针不会向右移动，而判断满的条件就是lastfree 已经到了第一个元素的位置)。 1234567891011121314151617181920/*** nums[i] = number of keys 'k' where 2^(i - 1) &lt; k &lt;= 2^i*/static void rehash (lua_State *L, Table *t, const TValue *ek) &#123; unsigned int nasize, na; unsigned int nums[MAXABITS + 1]; int i; int totaluse; for (i = 0; i &lt;= MAXABITS; i++) nums[i] = 0; /* reset counts */ nasize = numusearray(t, nums); /* count keys in array part */ totaluse = nasize; /* all those keys are integer keys */ totaluse += numusehash(t, nums, &amp;nasize); /* count keys in hash part */ /* count extra key */ nasize += countint(ek, nums); totaluse++; /* compute new size for array part */ na = computesizes(nums, &amp;nasize); /* resize the table to new computed sizes */ luaH_resize(L, t, nasize, totaluse - na);&#125; 扩容前会先统计table中的数量，将其存至nasize中；建立了一个大小为32的数组并且初始化为0，然后统计array数组中不为nil的元素个数，统计时通过分段的方式进行统计，将所有的元素按(2\^(i-1),2\^i]分段，分为32 个区间段：(0.5, 1]、(1, 2]、(2, 4]、 (4, 8] ……，统计步骤如下： 分配一个位图 nums，将其中的所有位置 0。这个位图的意义在于：nums 数组中第 i 个元素存放的是 key 在 2^(i-1)和 2^i 之间的元素数量。 遍历 Lua 表中的数组部分，计算其中的元素数量，更新对应的 nums 数组中的元素数量（numusearray函数）。 遍历 Lua 表中的散列桶部分，因为其中也可能存放了正整数，需要根据这里的正整数数量更新对应的 nums 数组元素数量（numusehash 函数）。 此时nums 数组已经拥有了当前这个 Table 中所有正整数的分配统计，逐个遍历 nums 数组，获得其范围区间内所包含的整数数量大于 50%的最大索引，作为重新散列之后的数组大小，超过这个范围的正整数，就分配到散列桶部分了（computesizes 函数） 根据上面计算得到的调整后的数组和散列桶大小调整表（resize 函数）。 调整标准：希望在调整过后，数组在每一个二次方位置容纳的元素数量都超过该范围的 50%。能达到这个目标的话，我们就认为这个数组范围发挥了最大的效率。 重新散列的代价与解决：1234local a = &#123;&#125;for i = 1,3 do a[i] = trueend 最开始，Lua 创建了一个空表 在第一次迭代中，a[1]为 true 触发了一次重新散列操作，将数组部分长度设置为 2^0，即 1，散列表部分仍为空。 在第二次迭代中，a[2]为 true 触发了一次重新散列操作，将数组部分长度设置为 2^1，即 2。 最后一次迭代中，a[3]又触发了一次重新散列操作，将数组部分长度设置为 2^2，即 4。 如果有很多很小的表要进行创建，则会对开销造成巨大的影响——可以预先填充以避免重新散列操作。 Table 的迭代：12345678910111213141516171819202122232425int luaH_next (lua_State *L, Table *t, StkId key) &#123; unsigned int i = findindex(L, t, key); /* find original element */ for (; i &lt; t-&gt;sizearray; i++) &#123; /* try first array part */ if (!ttisnil(&amp;t-&gt;array[i])) &#123; /* a non-nil value? */ setivalue(key, i + 1); setobj2s(L, key+1, &amp;t-&gt;array[i]); return 1; &#125; &#125; for (i -= t-&gt;sizearray; cast_int(i) &lt; sizenode(t); i++) &#123; /* hash part */ if (!ttisnil(gval(gnode(t, i)))) &#123; /* a non-nil value? */ setobj2s(L, key, gkey(gnode(t, i))); setobj2s(L, key+1, gval(gnode(t, i))); return 1; &#125; &#125; return 0; /* no more elements */&#125;/* 在数组部分查找数据： 查找成功，则返回该 key 的下一个数据 否则在散列桶部分查找数据： 查找成功，则返回该 key 的下一个数据*/ 一开始进入 findindex 函数，返回一个整数索引，如果这个索引在表的 sizearray 之内，则说明落入到数组部分，否则就落入到散列桶部分。 Table 取长度操作：对Lua 中的表进行取长度的操作时，如果没有提供该表的原方法 _len，那么该操作只针对该表的序列部分进行——序列指的是该表的一个子集{1…n}，n是一个正整数，其中每个键对应的数据都不为 nil。 123456789101112131415161718192021/*** Try to find a boundary in table 't'. A 'boundary' is an integer index** such that t[i] is non-nil and t[i+1] is nil (and 0 if t[1] is nil).*/int luaH_getn (Table *t) &#123; unsigned int j = t-&gt;sizearray; if (j &gt; 0 &amp;&amp; ttisnil(&amp;t-&gt;array[j - 1])) &#123; /* there is a boundary in the array part: (binary) search for it */ unsigned int i = 0; while (j - i &gt; 1) &#123; unsigned int m = (i+j)/2; if (ttisnil(&amp;t-&gt;array[m - 1])) j = m; else i = m; &#125; return i; &#125; /* else must find a boundary in hash part */ else if (isdummy(t-&gt;node)) /* hash part is empty? */ return j; /* that is easy... */ else return unbound_search(t, j);&#125; Table的元表：注意事项： 尽量不要在一个表中混用数组和散列桶部分，即一个表最好只存放一类数据。Lua 的实现上确实提供了两者统一表示的遍历，但这并不意味着使用者就应该混用这两种方式。 尽量不要在表中存放 nil 值，这会让取长度操作的行为不稳定。 尽量避免重新散列操作，因为这个操作的代价极大，通过预分配、只使用数组部分等策略规避这个 Lua 解释器背后的动作，能提升不少效率。 参考： 《lua 设计与实现》codedump 著]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua源码阅读：基本数据类型String]]></title>
    <url>%2F2019%2F08%2F08%2FLua%2FLua%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8BString%2F</url>
    <content type="text"><![CDATA[Lua中对于String的实现。 Lua使用TString结构体代表一个字符串对象。 12345678910111213141516171819/*** Header for string value; string bytes follow the end of this structure** (aligned according to 'UTString'; see next).*/typedef struct TString &#123; CommonHeader; lu_byte extra; /* reserved words for short strings; "has hash" for longs */ unsigned int hash; size_t len; /* number of characters in string */ struct TString *hnext; /* linked list for hash table */&#125; TString;/*** Ensures that address after this type is always fully aligned.*/typedef union UTString &#123; L_Umaxalign dummy; /* ensures maximum alignment for strings 用于最大字节对齐 */ TString tsv;&#125; UTString; hash用来记录字符串对应的哈希值，len用来记录字符串的长度。 在Lua中，分为长字符串和短字符串，长度大于40的是长字符串，小于40的是短字符串，这部分在luaconf.h中定义： 1234567/*@@ LUAI_MAXSHORTLEN is the maximum length for short strings, that is,** strings that are internalized. (Cannot be smaller than reserved words** or tags for metamethods, as these strings must be internalized;** #("function") = 8, #("__newindex") = 10.)*/#define LUAI_MAXSHORTLEN 40 对于短字符串，在实际使用中一般用来作为索引或需要进行字符串比较，存放在global_State-&gt;strt中，这个字符串表（strt）是一个stringtable类型的全局唯一的哈希表，当需要创建一个短字符串对象时，会首先在这个表中查找已有对象。所有的短字符串都是全局唯一的，不会存在两个相同的短字符串对象，如果短字符串对象的extra&gt;0，表示这是一个系统保留的字符串；长字符串一般用来存放文本数据，很少需要比较或者索引，所以长字符串被挂接到allgc链表上当作普通的对象来处理。 12345678910111213141516171819/*** new string (with explicit length) 生成新字符串的函数*/TString *luaS_newlstr (lua_State *L, const char *str, size_t l) &#123; if (l &lt;= LUAI_MAXSHORTLEN) /* short string? */ return internshrstr(L, str, l); else &#123; if (l + 1 &gt; (MAX_SIZE - sizeof(TString))/sizeof(char)) luaM_toobig(L); return createstrobj(L, str, l, LUA_TLNGSTR, G(L)-&gt;seed); &#125;&#125;/* 在global_State中存储的哈希表结构体 */typedef struct stringtable &#123; TString **hash; int nuse; /* number of elements 已装元素的个数 */ int size; /* 实际hash桶的大小 */&#125; stringtable; 对于短字符串，在创建的时候，首先计算str的哈希值。计算时会得到一个随机种子，这个种子就是global_State-&gt;seed，然后通过LUAI_HASHLIMIT控制步长，每一个步长范围内取字符串中的一个字符，和上次hash的结果相加，得到新的hash结果，计算出hash后，开始找是否存在这个字符串，方法是遍历global_State-&gt;strt-&gt;hash，短字符串表申请内存的大小和实际使用大小由后两个字段表示。 1234567891011121314151617181920212223242526272829303132333435363738/*** checks whether short string exists and reuses it or creates a new one** 检查短字符串的存在性，根据结果重用已存在的字符串或创建一个新的字符串*/static TString *internshrstr (lua_State *L, const char *str, size_t l) &#123; TString *ts; global_State *g = G(L); unsigned int h = luaS_hash(str, l, g-&gt;seed); TString **list = &amp;g-&gt;strt.hash[lmod(h, g-&gt;strt.size)]; for (ts = *list; ts != NULL; ts = ts-&gt;hnext) &#123; if (l == ts-&gt;len &amp;&amp; (memcmp(str, getstr(ts), l * sizeof(char)) == 0)) &#123; /* found! */ if (isdead(g, ts)) /* dead (but not collected yet)? */ changewhite(ts); /* resurrect it */ return ts; &#125; &#125; if (g-&gt;strt.nuse &gt;= g-&gt;strt.size &amp;&amp; g-&gt;strt.size &lt;= MAX_INT/2) &#123; luaS_resize(L, g-&gt;strt.size * 2); list = &amp;g-&gt;strt.hash[lmod(h, g-&gt;strt.size)]; /* recompute with new size */ &#125; ts = createstrobj(L, str, l, LUA_TSHRSTR, h); ts-&gt;hnext = *list; *list = ts; g-&gt;strt.nuse++; return ts;&#125;/* 对字符串按步长hash的函数 */unsigned int luaS_hash (const char *str, size_t l, unsigned int seed) &#123; unsigned int h = seed ^ cast(unsigned int, l); size_t l1; size_t step = (l &gt;&gt; LUAI_HASHLIMIT) + 1; for (l1 = l; l1 &gt;= step; l1 -= step) h = h ^ ((h&lt;&lt;5) + (h&gt;&gt;2) + cast_byte(str[l1 - 1])); return h;&#125;]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua中的垃圾回收机制]]></title>
    <url>%2F2019%2F08%2F07%2FLua%2FLua%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Lua中的垃圾回收机制：弱引用表，析构器和函数collectgarbage 垃圾收集：Lua语言使用自动内存管理，程序可以创建对象（表，闭包等），但却没有函数来删除对象。Lua语言通过垃圾收集自动的删除成为垃圾的对象。 弱引用表，析构器和函数collectgarbage是在Lua语言中用来辅助垃圾收集器的主要机制。弱引用表允许收集Lua语言中还可以被程序访问的对象；析构器允许收集不在垃圾收集器直接控制下的外部对象；函数collectgarbage则允许我们控制垃圾收集器的步长。 弱引用表：垃圾收集器不能猜测我们认为哪些是垃圾，程序不会再用到的、存储在全局变量中的对象，对于Lua语言来说不是垃圾，需要我们的代码将这些对象所在的位置赋为nil，以便这些位置不会锁定可释放的对象。 简单的清除引用并不够，有些情况下，还需要程序和垃圾收集器之间的协作——当我们要保存某种类型的活跃对象的列表时，只需要将新对象插入数组即可；但是，一旦一个对象成为了数组的一部分，即使没有其他任何地方在引用它，但数组依然在引用它，无法被回收。 弱引用表就是这样一种用来告知Lua语言一个引用不应阻止对一个对象回收的的机制。 所谓弱引用是一种不在垃圾收集器考虑范围内的对象引用。如果对一个对象的所有引用都是弱引用，那么垃圾收集器将会回收这个对象并删除这些弱引用。Lua通过弱引用表来实现弱引用，弱引用表就是元素均为弱引用的表，这意味着如果一个对象只被一个弱引用表持有，那么Lua语言最终会回收这个对象。 表由键值对组成，其两者都可以容纳任意类型的对象。在正常情况下，垃圾收集器不会回收一个在可访问表中作为键和值的对象。也就是说，键和值都是强引用，他们会阻止对其所指向对象的回收。在一个弱引用表中，键和值都可以是弱引用的。这就意味着有三种类型的弱引用表：具有弱引用键的表、具有弱引用值的表及同时具有弱引用键和值的表。不论是哪种类型的弱引用表，只要有一个键或值被回收了，那么对应的整个键值对都会被从表中删除。 一个表是否为弱引用表是由其元表中的__mode字段所决定的。当这个字段存在时，其值应为一个字符串：如果这个字符串是”k”，则说明这个表的键（key）是弱引用的，如果这个字符串是”v”，那么这个表的值是弱引用的；如果这个字符串是“kv”，那么这个表的键和值都是弱引用的。 只有对象可以从弱引用表中被移除，而像数字和布尔这样的“值”是不可回收的。 析构器：析构器是一个与对象关联的函数，当该对象即将被回收时该函数会被调用。 Lua语言通过元方法__gc实现析构器： 1234o = &#123;x = "hi"&#125;setmetatable(o,&#123;__gc = function(o) print(o.x) end&#125;)o = nilcollectgarbage() --&gt; hi 通过给对象设置一个具有非空__gc元方法的元表，就可以将一个对象标记为需要进行析构处理，如果不标记对象，那么对象就不会被析构。 当垃圾收集器在同一个周期中析构多个对象时，它会按照对象被标记为需要析构处理的顺序逆序调用这些对象的析构器。 析构器的另一个特点是复苏：当一个析构器被调用时，它的参数是正在被析构的对象。因此，这个对象会至少在析构期间重新变成活跃的，这叫做“临时复苏”；在析构器执行期间，我们无法阻止析构器把该对象存储在全局变量中，使得该对象在析构器返回后仍然可访问，这称为“永久复苏”。 由于复苏的存在，Lua语言会在两个阶段中回收具有析构器的对象。当垃圾收集器首次发现某个具有析构器的对象不可达的时候，垃圾收集器就把这个对象复苏，并将其放入等待被析构的队列中。一旦析构器开始执行，Lua语言就将该对象标记为已被析构，当下一次垃圾收集器又发现这个对象不可达时，它就将这个对象删除。 如果想保证我们程序中的所有垃圾都被真正的释放了的话，那么必须调用collectgarbage两次，第二次调用才会删除第一次调用中被析构的对象。 由于Lua语言在被析构对象上设置的标记，每一个对象的析构器都会精确的运行一次，如果一个对象直到程序运行结束还没有被回收，那么Lua语言就会在整个Lua虚拟机关闭后调用它的析构器。 另一个有趣的技巧会允许程序在每次完成垃圾回收后调用指定的函数。由于析构器只运行一次，所以这种技巧是让每个析构器创建一个用来运行下一个析构器的新对象。 具有析构器的对象和弱引用表之间的交互也有些微妙：在每个垃圾收集周期内，垃圾收集器会在调用析构器前清理弱引用表的值，在调用析构器之后再清理键。这种行为的原理在于我们经常使用带有弱引用键来保存对象的属性，因此，析构器可能需要访问那些属性。不过，我们也会使用具有弱引用值的表来重用活跃的对象，在这种情况下，正在被析构的对象就不再有用了。 垃圾收集器：一直到Lua5.0，Lua语言使用的都是一个简单的标记-清除式垃圾收集器，这种收集器又被称为全局暂停式的收集器，意味着Lua语言会时不时地停止主程序的运行来执行一次完整的垃圾收集周期。每一个垃圾收集周期由四个阶段组成：标记、清理、清除和析构。 标记阶段：把根结点集合（由Lua语言可以直接访问的对象组成）标记为活跃。在Lua语言中，这个集合只包括C注册表。保存在一个活跃对象中的对象是程序可达的，因此也会被标记为活跃（弱引用表中的内容除外），当所有可达对象都被标记为活跃后，标记阶段完成。 清理阶段：首先，Lua语言遍历所有被标记为需要进行析构、但又没有被标记为活跃状态的对象。这些没有被标记为活跃状态的对象会被标记为活跃（复苏），并被放在一个单独的列表中，这个列表会在析构阶段用到。然后，Lua语言遍历弱引用表并从中移除键或值未被标记的元素。 清除阶段：遍历所有对象（Lua 语言把所有创建的对象放在一个链表中），如果一个对象没有被标记为活跃，Lua语言就将其回收。否则，Lua语言清理标记，然后准备进行下一个清理周期。 析构阶段：Lua语言调用清理阶段被分离出的对象的析构器。 Lua5.1使用了增量式垃圾收集器。这种垃圾收集器像老版的垃圾收集器一样执行相同的步骤，但是不需要在垃圾收集期间停止主程序的运行：它与解释器一起交替运行，每当解释器分配了一定数量的内存时，垃圾收集器也执行一小步。 Lua5.2引入了紧急垃圾收集，当内存分配失败时，Lua语言会强制进行一次完整的垃圾收集，然后再次尝试分配。这些紧急情况可以发生在Lua语言进行内存分配的任意时刻，包括Lua语言处于不一致的代码执行状态时，因此，这些收集动作不能运行析构器。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua程序设计（6）]]></title>
    <url>%2F2019%2F08%2F07%2FLua%2FLua%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%886%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Lua中的数据结构：数组、链表、队列等 数组：在Lua语言中使用整数来索引表就可以实现数组，因此数组的大小不用非得是固定的，而是可以按需增长的。 在Lua语言中一般以1作为数组的起始索引。 矩阵及多维数组：使用一个不规则数组：即数组的数组，一个所有元素均是另一个表的表。 这种矩阵在创建时必须显式的创建每一行，一方面更加具体，另一方面增加了更多的灵活性。 将两个索引合并为一个：我们通过将第一个索引乘以一个合适的常量再加上第二个索引来实现这种效果，在这种方式下，我们可以使用以下的代码来创建一个全0元素的N*M矩阵： 1234567local mt = &#123;&#125;for i = 1,N do local aux = (i - 1) * M for j = 1,M do mt[aux + j] = 0 endend 链表：我们可以把每个节点用一个表来表示，链接则为一个包含指向其他表的引用的简单表字段： 根结点：list = nil 在表头插入一个值为v的元素： 1list = &#123;next = list,value = v&#125; 遍历链表： 12345local l = listwhile l do visit l.value l = l.nextend 队列及双端队列：一种简单的方法是使用table标准库中的函数insert和remove，不过这种移动对于较大的结构来说开销很大。 一种更高效的实现是使用两个索引，一个指向第一个元素，另一个指向最后一个元素，这样就可以以O(1)时间复杂度同时在首尾两端插入或删除元素了。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua源码阅读：C API]]></title>
    <url>%2F2019%2F08%2F06%2FLua%2FLua%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%9AC-API%2F</url>
    <content type="text"><![CDATA[Lua中关于C API的内容。 Iapi.cindex2addr：12345678910111213141516171819202122232425static TValue *index2addr (lua_State *L, int idx) &#123; CallInfo *ci = L-&gt;ci; if (idx &gt; 0) &#123; TValue *o = ci-&gt;func + idx; api_check(idx &lt;= ci-&gt;top - (ci-&gt;func + 1), "unacceptable index"); if (o &gt;= L-&gt;top) return NONVALIDVALUE; else return o; &#125; else if (!ispseudo(idx)) &#123; /* negative index */ api_check(idx != 0 &amp;&amp; -idx &lt;= L-&gt;top - (ci-&gt;func + 1), "invalid index"); return L-&gt;top + idx; &#125; else if (idx == LUA_REGISTRYINDEX) return &amp;G(L)-&gt;l_registry; else &#123; /* upvalues */ idx = LUA_REGISTRYINDEX - idx; api_check(idx &lt;= MAXUPVAL + 1, "upvalue index too large"); if (ttislcf(ci-&gt;func)) /* light C function? */ return NONVALIDVALUE; /* it has no upvalues */ else &#123; CClosure *func = clCvalue(ci-&gt;func); return (idx &lt;= func-&gt;nupvalues) ? &amp;func-&gt;upvalue[idx-1] : NONVALIDVALUE; &#125; &#125;&#125; 这个index2addr函数的作用就是通过给定的 index 参数取出对应的TValue类型的对象指针。 情况 执行 当 index &gt; 0 时 在当前function的栈空间找对应的TValue 当 LUA_REGISTRYINDEX &lt; index &lt;= 0 时 在当前function的栈空间逆向找对应的TValue 当LUA_REGISTRYINDEX == index 时 返回registry（注册表） 否则当 LUA_REGISTRYINDEX &gt; index 时 查找upvalues]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua源码阅读：基本数据类型]]></title>
    <url>%2F2019%2F08%2F06%2FLua%2FLua%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[关于Lua中基本数据类型的底层实现方式，本篇是IState。 lStatelua_State在lState.h中定义了lua_State的结构体，这是每个 Lua 函数都会接受的表示当前状态的结构，最主要的成员包括运行栈 stack, 栈用于表示函数调用、传递参数及返回值： 12345678910111213141516171819202122232425262728293031323334353637/*** 'per thread' state*/struct lua_State &#123; CommonHeader; /* */ lu_byte status; /* 解析容器的，用于记录中间状态 */ global_State *l_G; /* 全局状态机 */ /*调用栈：调用栈的信息管理*/ CallInfo *ci; /* call info for current function 当前函数的运行信息 */ CallInfo base_ci; /* CallInfo for first level (C calling Lua) 调用栈的头部指针 */ /* 数据栈：栈指针地址管理 */ StkId top; /* first free slot in the stack 指向线程栈的栈顶 */ StkId stack_last; /* last free slot in the stack 线程栈的最后一个位置 */ StkId stack; /* stack base 栈的指针，当前运行的位置 */ GCObject *gclist; /* GC列表 */ const Instruction *oldpc; /* last pc traced 在当前thread 的解释执行指令的过程中，指向最后一次执行的指令的指针 */ struct lua_State *twups; /* list of threads with open upvalues */ struct lua_longjmp *errorJmp; /* current error recover point */ UpVal *openupval; /* list of open upvalues in this stack */ /* Hook 相关管理 - 服务于debug模块 */ lua_Hook hook; ptrdiff_t errfunc; /* current error handling function (stack index) */ int stacksize; int basehookcount; int hookcount; lu_byte hookmask; lu_byte allowhook; /* 跟C语言通信 管理 */ unsigned short nny; /* number of non-yieldable calls in stack */ unsigned short nCcalls; /* number of nested C calls */&#125;; GCUnion123456789101112/*** Union of all collectable objects (only for conversions)*/union GCUnion &#123; GCObject gc; /* common header */ struct TString ts; struct Udata u; union Closure cl; struct Table h; struct Proto p; struct lua_State th; /* thread */&#125;; global_state12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/*** 'global state', shared by all threads of this state** lua全局状态机** 作用：管理全局数据、全局字符串表、内存管理函数*/typedef struct global_State &#123; const lua_Number *version; /* pointer to version number 版本号 */ /* 内存管理 */ lua_Alloc frealloc; /* function to reallocate memory Lua的全局内存分配器 */ void *ud; /* auxiliary data to 'frealloc' 分配器的userdata */ lu_mem totalbytes; /* number of bytes currently allocated - GCdebt */ l_mem GCdebt; /* bytes allocated not yet compensated by the collector */ lu_mem GCmemtrav; /* memory traversed by the GC */ lu_mem GCestimate; /* an estimate of the non-garbage memory in use */ TValue l_registry; unsigned int seed; /* randomized seed for hashes */ lu_byte currentwhite; lu_byte gcstate; /* state of garbage collector */ lu_byte gckind; /* kind of GC running */ lu_byte gcrunning; /* true if GC is running */ GCObject *allgc; /* list of all collectable objects */ GCObject **sweepgc; /* current position of sweep in list */ GCObject *finobj; /* list of collectable objects with finalizers */ GCObject *gray; /* list of gray objects */ GCObject *grayagain; /* list of objects to be traversed atomically */ GCObject *weak; /* list of tables with weak values */ GCObject *ephemeron; /* list of ephemeron tables (weak keys) */ GCObject *allweak; /* list of all-weak tables */ GCObject *tobefnz; /* list of userdata to be GC */ GCObject *fixedgc; /* list of objects not to be collected */ Mbuffer buff; /* temporary buffer for string concatenation */ /* 字符串管理 */ stringtable strt; /* hash table for strings */ /* GC管理 */ unsigned int gcfinnum; /* number of finalizers to call in each GC step */ int gcpause; /* size of pause between successive GCs */ int gcstepmul; /* GC 'granularity' */ /* 线程管理 */ struct lua_State *mainthread; /* 主线程 */ struct lua_State *twups; /* list of threads with open upvalues 闭包了当前线程变量的其他线程列表 */ /* 错误处理 */ lua_CFunction panic; /* to be called in unprotected errors */ TString *memerrmsg; /* memory-error message */ /* 虚函数表 */ TString *tmname[TM_N]; /* array with tag-method names 预定义方法名字数组 */ struct Table *mt[LUA_NUMTAGS]; /* metatables for basic types 每个基本类型一个metatable */&#125; global_State; 创建栈结构：lua_newstate主要用于创建一个主线程栈结构，分配lua_State和global_State。 对外通过lua_State结构暴露给用户，而global_State挂载在lua_State上。 通过这种结构，每个线程会独立维护自己的线程栈和函数栈。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071LUA_API lua_State *lua_newstate (lua_Alloc f, void *ud) &#123; int i; lua_State *L; global_State *g; /* 分配一个lua_State结构的内容块 */ LG *l = cast(LG *, (*f)(ud, NULL, LUA_TTHREAD, sizeof(LG))); if (l == NULL) return NULL; L = &amp;l-&gt;l.l; g = &amp;l-&gt;g; L-&gt;next = NULL; L-&gt;tt = LUA_TTHREAD; g-&gt;currentwhite = bitmask(WHITE0BIT); L-&gt;marked = luaC_white(g); /* 初始化一个线程的栈结构数据 */ preinit_thread(L, g); g-&gt;frealloc = f; g-&gt;ud = ud; g-&gt;mainthread = L; g-&gt;seed = makeseed(L); g-&gt;gcrunning = 0; /* no GC while building state */ g-&gt;GCestimate = 0; g-&gt;strt.size = g-&gt;strt.nuse = 0; g-&gt;strt.hash = NULL; setnilvalue(&amp;g-&gt;l_registry); luaZ_initbuffer(L, &amp;g-&gt;buff); g-&gt;panic = NULL; g-&gt;version = NULL; g-&gt;gcstate = GCSpause; g-&gt;gckind = KGC_NORMAL; g-&gt;allgc = g-&gt;finobj = g-&gt;tobefnz = g-&gt;fixedgc = NULL; g-&gt;sweepgc = NULL; g-&gt;gray = g-&gt;grayagain = NULL; g-&gt;weak = g-&gt;ephemeron = g-&gt;allweak = NULL; g-&gt;twups = NULL; g-&gt;totalbytes = sizeof(LG); g-&gt;GCdebt = 0; g-&gt;gcfinnum = 0; g-&gt;gcpause = LUAI_GCPAUSE; g-&gt;gcstepmul = LUAI_GCMUL; for (i=0; i &lt; LUA_NUMTAGS; i++) g-&gt;mt[i] = NULL; if (luaD_rawrunprotected(L, f_luaopen, NULL) != LUA_OK) &#123; /* memory allocation error: free partial state */ close_state(L); L = NULL; &#125; return L;&#125;/*** preinitialize a thread with consistent values without allocating** any memory (to avoid errors)*/static void preinit_thread (lua_State *L, global_State *g) &#123; G(L) = g; /* 将global_State结构挂载在lua_State上 #define G(L) (L-&gt;l_G) */ L-&gt;stack = NULL; L-&gt;ci = NULL; L-&gt;stacksize = 0; L-&gt;twups = L; /* thread has no upvalues */ L-&gt;errorJmp = NULL; L-&gt;nCcalls = 0; L-&gt;hook = NULL; L-&gt;hookmask = 0; L-&gt;basehookcount = 0; L-&gt;allowhook = 1; resethookcount(L); L-&gt;openupval = NULL; L-&gt;nny = 1; L-&gt;status = LUA_OK; L-&gt;errfunc = 0;&#125; 销毁栈结构：1234567891011121314151617181920/* 关闭lua栈 */LUA_API void lua_close (lua_State *L) &#123; L = G(L)-&gt;mainthread; /* only the main thread can be closed */ lua_lock(L); close_state(L);&#125;/* 释放lua栈结构 */static void close_state (lua_State *L) &#123; global_State *g = G(L); luaF_close(L, L-&gt;stack); /* close all upvalues for this thread 释放栈结构的upvalues */ luaC_freeallobjects(L); /* collect all objects 释放全部对象 */ if (g-&gt;version) /* closing a fully built state? */ luai_userstateclose(L); luaM_freearray(L, G(L)-&gt;strt.hash, G(L)-&gt;strt.size); luaZ_freebuffer(L, &amp;g-&gt;buff); freestack(L); lua_assert(gettotalbytes(g) == sizeof(LG)); (*g-&gt;frealloc)(g-&gt;ud, fromstate(L), sizeof(LG), 0); /* free main block */&#125; 数据栈与调用栈：数据栈结构由一个StkID结构存储。lua中的数据分为值类型和引用类型。引用类型需要GC机制管理。 12345678910111213141516union Value &#123; GCObject *gc; /* collectable objects 存放所有需要垃圾回收的类型的对象 */ void *p; /* light userdata 存放轻量用户数据 */ int b; /* booleans */ lua_CFunction f; /* light C functions 存放一个方法 */ lua_Integer i; /* integer numbers 存放int数字 */ lua_Number n; /* float numbers 存放float数字 */&#125;;struct lua_TValue &#123; TValuefields;&#125;;// #define TValuefields Value value_; int tt_typedef TValue *StkId; /* index to stack elements */ 调用栈存放在CallInfo中，以数组的形式存放在虚拟机的对象里。其中CallInfo中的ci-&gt;func指向正在执行的函数在数据栈上的位置l-&gt;top（正在调用的函数一定位于数据栈上。） 12345678910111213141516171819202122232425262728/*** Information about a call.** When a thread yields, 'func' is adjusted to pretend that the** top function has only the yielded values in its stack; in that** case, the actual 'func' value is saved in field 'extra'. ** When a function calls another with a continuation, 'extra' keeps** the function index so that, in case of errors, the continuation** function can be called with the correct top.*/typedef struct CallInfo &#123; StkId func; /* function index in the stack func 指向正在执行的函数在数据栈上的位置 */ StkId top; /* top for this function */ struct CallInfo *previous, *next; /* dynamic call link */ union &#123; struct &#123; /* only for Lua functions */ StkId base; /* base for this function */ const Instruction *savedpc; &#125; l; struct &#123; /* only for C functions */ lua_KFunction k; /* continuation in case of yields */ ptrdiff_t old_errfunc; lua_KContext ctx; /* context info. in case of yields */ &#125; c; &#125; u; ptrdiff_t extra; short nresults; /* expected number of results from this function */ lu_byte callstatus;&#125; CallInfo; 栈初始化和释放：1234567891011121314151617181920212223242526272829static void stack_init (lua_State *L1, lua_State *L) &#123; /* 栈初始化，分为数据栈与调用栈 */ int i; CallInfo *ci; /* initialize stack array */ L1-&gt;stack = luaM_newvector(L, BASIC_STACK_SIZE, TValue); // 默认栈的大小为40 L1-&gt;stacksize = BASIC_STACK_SIZE; for (i = 0; i &lt; BASIC_STACK_SIZE; i++) setnilvalue(L1-&gt;stack + i); /* erase new stack */ L1-&gt;top = L1-&gt;stack; L1-&gt;stack_last = L1-&gt;stack + L1-&gt;stacksize - EXTRA_STACK; // 栈顶默认到35 /* initialize first ci */ ci = &amp;L1-&gt;base_ci; ci-&gt;next = ci-&gt;previous = NULL; ci-&gt;callstatus = 0; ci-&gt;func = L1-&gt;top; // 指向当前栈顶 setnilvalue(L1-&gt;top++); /* 'function' entry for this 'ci' */ ci-&gt;top = L1-&gt;top + LUA_MINSTACK; // 指向L1-&gt;top + 20的位置 L1-&gt;ci = ci;&#125;/* 释放栈内存结构 */static void freestack (lua_State *L) &#123; if (L-&gt;stack == NULL) return; /* stack not completely built yet */ L-&gt;ci = &amp;L-&gt;base_ci; /* free the entire 'ci' list */ luaE_freeCI(L); /* 一个释放循环链表的过程 */ luaM_freearray(L, L-&gt;stack, L-&gt;stacksize); /* free stack array */&#125; 栈初始化由f_luaopen函数调用，对它的调用出现在lua_newstate中： 12345if (luaD_rawrunprotected(L, f_luaopen, NULL) != LUA_OK) &#123; /* memory allocation error: free partial state */ close_state(L); L = NULL;&#125; 栈扩容操作：Lua会通过lua_checkstack函数去检查栈空间的大小。初始化分配栈大小的时候是分配了40个StkId，栈顶留5个buf空间，所以栈顶是35个，这部分函数在lapi.c中实现： 1234567891011121314151617181920212223242526272829/*** to be called by 'lua_checkstack' in protected mode, to grow stack** capturing memory errors*//* 针对lua_state进行扩容 */static void growstack (lua_State *L, void *ud) &#123; int size = *(int *)ud; luaD_growstack(L, size);&#125;LUA_API int lua_checkstack (lua_State *L, int n) &#123; int res; CallInfo *ci = L-&gt;ci; lua_lock(L); api_check(n &gt;= 0, "negative 'n'"); if (L-&gt;stack_last - L-&gt;top &gt; n) /* stack large enough? */ res = 1; /* yes; check is OK */ else &#123; /* no; need to grow stack */ int inuse = cast_int(L-&gt;top - L-&gt;stack) + EXTRA_STACK; if (inuse &gt; LUAI_MAXSTACK - n) /* can grow without overflow? */ res = 0; /* no */ else /* try to grow stack */ res = (luaD_rawrunprotected(L, &amp;growstack, &amp;n) == LUA_OK); &#125; if (res &amp;&amp; ci-&gt;top &lt; L-&gt;top + n) ci-&gt;top = L-&gt;top + n; /* adjust frame top */ lua_unlock(L); return res;&#125; 对lua_state进行扩容的growstack函数内部调用了ldo.c中的luaD_growstack函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546void luaD_growstack (lua_State *L, int n) &#123; int size = L-&gt;stacksize; if (size &gt; LUAI_MAXSTACK) /* error after extra size? */ luaD_throw(L, LUA_ERRERR); else &#123; int needed = cast_int(L-&gt;top - L-&gt;stack) + n + EXTRA_STACK; int newsize = 2 * size; /* 栈空间扩充到目前size的2倍 */ if (newsize &gt; LUAI_MAXSTACK) newsize = LUAI_MAXSTACK; /* 如果扩充后的size大于最大size则将其设置为最大size */ if (newsize &lt; needed) newsize = needed; /* 如果2倍不够直接设置为目标大小 */ if (newsize &gt; LUAI_MAXSTACK) &#123; /* stack overflow? */ luaD_reallocstack(L, ERRORSTACKSIZE); luaG_runerror(L, "stack overflow"); &#125; else luaD_reallocstack(L, newsize); &#125;&#125;/* 重新分配一块statck内容，并且进行拷贝 */void luaD_reallocstack (lua_State *L, int newsize) &#123; TValue *oldstack = L-&gt;stack; int lim = L-&gt;stacksize; lua_assert(newsize &lt;= LUAI_MAXSTACK || newsize == ERRORSTACKSIZE); lua_assert(L-&gt;stack_last - L-&gt;stack == L-&gt;stacksize - EXTRA_STACK); luaM_reallocvector(L, L-&gt;stack, L-&gt;stacksize, newsize, TValue); for (; lim &lt; newsize; lim++) setnilvalue(L-&gt;stack + lim); /* erase new segment */ L-&gt;stacksize = newsize; L-&gt;stack_last = L-&gt;stack + newsize - EXTRA_STACK; correctstack(L, oldstack);&#125;/* 拷贝到新的栈结构上 */static void correctstack (lua_State *L, TValue *oldstack) &#123; CallInfo *ci; UpVal *up; L-&gt;top = (L-&gt;top - oldstack) + L-&gt;stack; for (up = L-&gt;openupval; up != NULL; up = up-&gt;u.open.next) up-&gt;v = (up-&gt;v - oldstack) + L-&gt;stack; for (ci = L-&gt;ci; ci != NULL; ci = ci-&gt;previous) &#123; ci-&gt;top = (ci-&gt;top - oldstack) + L-&gt;stack; ci-&gt;func = (ci-&gt;func - oldstack) + L-&gt;stack; if (isLua(ci)) ci-&gt;u.l.base = (ci-&gt;u.l.base - oldstack) + L-&gt;stack; &#125;&#125;]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua源码阅读：标准库]]></title>
    <url>%2F2019%2F08%2F06%2FLua%2FLua%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%9A%E6%A0%87%E5%87%86%E5%BA%93%2F</url>
    <content type="text"><![CDATA[Lua标准库中定义的一些函数及其实现方式。 lmathlib.c从一个简单的math.Abs()函数开始： 12345678910static int math_abs (lua_State *L) &#123; if (lua_isinteger(L, 1)) &#123; lua_Integer n = lua_tointeger(L, 1); if (n &lt; 0) n = (lua_Integer)(0u - n); lua_pushinteger(L, n); &#125; else lua_pushnumber(L, l_mathop(fabs)(luaL_checknumber(L, 1))); return 1;&#125; 首先，先检查传入的值是否是int类型，这里调用了lapi.c中的lua_isinteger函数，检查传入值的TValue原始类型标签是否是LUA_TNUMINT，这部分的检查在lObject.h中定义的函数完成，同时数据类型LUA_TNUMINT也在lObject.h中定义： 12345/* Variant tags for numbers */#define LUA_TNUMFLT (LUA_TNUMBER | (0 &lt;&lt; 4)) /* float numbers */#define LUA_TNUMINT (LUA_TNUMBER | (1 &lt;&lt; 4)) /* integer numbers */// lObject.h 如果传入的值的TValue是int类型的（传入的值是lua_state类型的），调用lua_tointeger将传入的值转换为int类型（实际上是lua_Integer类型，其最根源是longlong类型的，在luaconf.h中定义），将其赋给n，如果n小于零，则用一个unsigned 0减去它，将其置为正数，最后将n存入到TValue中，将其存放在lua_state的栈顶。 如果不是int类型的，则检查其是否是一个number类型的值，如果是一个number则调用fabs，将其push栈，否则返回一个错误提示。 lstrlib.cstrlib中一部分是关于字符串的操作函数，一部分是关于模式匹配的函数，先挑选一个Reverse函数进行分析： 12345678910static int str_reverse (lua_State *L) &#123; size_t l, i; luaL_Buffer b; const char *s = luaL_checklstring(L, 1, &amp;l); char *p = luaL_buffinitsize(L, &amp;b, l); for (i = 0; i &lt; l; i++) p[i] = s[l - i - 1]; luaL_pushresultsize(&amp;b, l); return 1;&#125; 简单来说就是利用一个指针（index）来对字符数组进行逆序的赋值，从数组s中获取赋值给数组p。]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua源码阅读：目录及模块结构]]></title>
    <url>%2F2019%2F08%2F05%2FLua%2FLua%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%9A%E7%9B%AE%E5%BD%95%E5%8F%8A%E6%A8%A1%E5%9D%97%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[Lua源码阅读的第一期，主要内容：系列内容计划以及目录。 Lua源码阅读：本篇转载于LuaSource 目录 第一篇：目录及模块结构 第二篇：基本数据类型 第三篇：实用函数 第四篇：标准库 第五篇：C API lua.c12345678910111213141516int main (int argc, char **argv) &#123; int status, result; lua_State *L = luaL_newstate(); /* create state */ if (L == NULL) &#123; l_message(argv[0], "cannot create state: not enough memory"); return EXIT_FAILURE; &#125; lua_pushcfunction(L, &amp;pmain); /* to call 'pmain' in protected mode */ lua_pushinteger(L, argc); /* 1st argument */ lua_pushlightuserdata(L, argv); /* 2nd argument */ status = lua_pcall(L, 2, 1, 0); /* do the call */ result = lua_toboolean(L, -1); /* get result */ report(L, status); lua_close(L); return (result &amp;&amp; status == LUA_OK) ? EXIT_SUCCESS : EXIT_FAILURE;&#125; 模块结构Lua代码的模块概要介绍如下： 以下模块实现了一些实用函数： ldebug.c - 调试接口，包含功能有：访问调试钩子（lua_sethook、lua_gethook、lua_gethookcount）；访问运行时栈（lua_getstack、lua_getlocal、lua_setlocal）；检测字节码（luaG_checkopenop、luaG_checkcode）；抛出错误（luaG_typeerror、luaG_concaterror、luaG_aritherror、luaG_ordererror、luaG_errormsg、luaG_runerror） lzio.c - 通用的输入流接口 lmem.c - 内存管理接口。实现了luaM_realloc / luaM_growaux_ 两个函数，其中封装了内存分配函数 lgc.c - 增量的垃圾回收器 以下模块实现了基本的数据类型： lstate.c - 全局状态。包括打开、关闭Lua状态机（lua_newstate / lua_close）和线程（luaE_newthread / luaE_freethread）。 lobject.c - 一些操作Lua Object的通用函数。包括一些数据类型到字符串的互转函数，原生类型的相等性测试（luaO_rawequalObj），和以2为底的对数函数（luaO_log2） lstring.c - 字符串哈希表（管理了所有被Lua用到的字符串） lfunc.c - 一些用于操作函数原型(Proto）和闭包（Closure）的辅助函数 ltable.c - Lua的table实现 以下模块做语法解析和代码生成： lcode.c - 代码生成器，被lparser.c用到 llex.c - 词法分析器，被lparser.c用到 lparser.c - Lua语法解析器 lundump.c - 加载预编译的Lua代码块。实现了luaU_undump函数，此函数加载预编译的代码块。还提供了另外一个函数lua_header（被luaU_undump内部使用），用于加载代码块中的函数头信息。 ldump.c - 保存预编译的Lua代码块。实现了luaU_dump函数，些函数导出Lua函数为二进制形式的字符串 以下模块处理Lua字节码的执行： lopcodes.c - 定义Lua虚拟机的操作码。定义了所有操作码的名字和操作模式等信息（通过列表luaP_opnames、luaP_opmodes定义的） lvm.c - Lua虚拟机（luaV_execute），可执行Lua字节码。另外还暴露了一些被lapi.c用到的函数，比如：luaV_concat ldo.c - 函数调用栈。处理函数调用（luaD_call、luaD_pcall），栈空间增长，协程等 ltm.c - 元方法。实现从对象访问元方法的一些函数 以下模块实现标准库： lbaselib.c - 基础函数 lstrlib.c - 字符串函数 ltablib.c - 表函数 lmathlib.c - 数学函数 loslib.c - 系统函数 liolib.c - 输入输出、文件读写 loadlib.c - 包、模块 ldblib.c - 调试函数 以下模块定义了C API： lapi.c - Lua API。实现了大部分Lua C API（lua_* 系列函数） lauxlib.c - 定义了luaL_*系列函数 linit.c - 实现luaL_openlibs，这个函数中加载了所有的标准库函数 以下模块实现Lua和Luac两个程序： lua.c - Lua的独立解释器 print.c - 定义了“PrintFunction”函数，它可以打印出一个函数的字节码（可在Luac中使用 -l 选项） luac.c - Lua编译器（可保存字节码到文件中，也可在控制台列出字节码） 命名约定一个函数的前缀表明了它来自哪个模块 luaA_ - lapi.c luaB_ - lbaselib.c luaC_ - lgc.c luaD_ - ldo.c luaE_ - lstate.c luaF_ - lfunc.c luaG_ - ldebug.c luaH_ - ltable.c luaI_ - lauxlib.c luaK_ - lcode.c luaL_ - llauxlib.c/h linit.c luaM_ - lmem.c luaO_ - lobject.c luaP_ - lopcodes.c luaS_ - lstring.c luaT_ - ltm.c luaU_ - lundump.c luaV_ - lvm.c luaX_ - llex.c luaY_ - lparser.c luaZ_ - lzio.c lua_ - lapi.c/h + luaconfig.h, ldebug.c luai_ - luaconf.h luaopen_ - luaconf.h + libraries (lbaselib.c, ldblib.c, liolib.c, lmathlib.c, loadlib.c, loslib.c, lstrlib.c, ltablib.c) 参考： Lua源码阅读笔记 Lua有关的论文和The Lua Architecture从各个方面论述了Lua的实现 Lua VM指令在文档A No-Frills Introduction to Lua 5.1 VM Instructions中 Yueliang项目（用Lua实现Lua VM），其中的大量的源码注释，可以帮助理解相关的C代码 LuaAnnotate - C代码注释，注释单独存放在外部文件中，用某些文本工具可以将注释嵌入显示在代码中 stevedonovan.github.com/lua-5.1.4 包含LuaAnnotate注释的源码 可在http://www.lua.org/source/网站上浏览Lua源码]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[First Person Shooter (FPS) With Unreal Engine 4 开发笔记（0）]]></title>
    <url>%2F2019%2F07%2F29%2F%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%2FFirst-Person-Shooter-FPS-With-Unreal-Engine-4-%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%880%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一个Unreal实现的FPS游戏开发笔记。 项目地址及教程地址：项目地址：UnrealLifeFromZero 教程地址：Creating A First Person Shooter - Unreal Engine 4 Course 目前实现的内容有： 玩家的基本动画状态切换（蹲、走、跑、射击、装弹、腰射与精确射击）以及它们的平滑过渡。 简单的敌人AI（目前可以跟随视野中的玩家；被玩家命中后跟随玩家、受伤。） 简单的UMG内容：包括玩家的护甲、生命值以及动态准星。 一些简单的粒子效果。]]></content>
      <categories>
        <category>开发笔记</category>
      </categories>
      <tags>
        <tag>FPS</tag>
        <tag>Unreal4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记]]></title>
    <url>%2F2019%2F07%2F29%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%2FRayTracing-In-Weekend-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[关于RayTracing In A Weekend一书的实现细节。 Chapter1：Output an Image下载一个ppm软件，我下载的是XnView。 第一章里面给出的代码并不完整，如果想得到PPM格式的文件的话，需要在代码里加入写入txt文件的代码： 1234567891011121314151617181920212223242526272829#include "pch.h"#include &lt;iostream&gt;#include &lt;fstream&gt;using namespace std;int main()&#123; int nx = 200; int ny = 100; ofstream outfile(".\\result\\FirstPicture.txt", ios_base::out); outfile &lt;&lt; "P3\n" &lt;&lt; nx &lt;&lt; " " &lt;&lt; ny &lt;&lt; "\n255\n"; for (int j = ny - 1; j &gt;= 0; j--) &#123; for (int i = 0; i &lt; nx; i++) &#123; float r = float(i) / float(nx); float g = float(j) / float(ny); float b = 0.2; int ir = int(255.99*r); int ig = int(255.99*g); int ib = int(255.99*b); outfile &lt;&lt; ir &lt;&lt; " " &lt;&lt; ig &lt;&lt; " " &lt;&lt; ib &lt;&lt; "\n"; std::cout &lt;&lt; ir &lt;&lt; " " &lt;&lt; ig &lt;&lt; " " &lt;&lt; ib &lt;&lt; "\n"; &#125; &#125; return 0;&#125; 在VmView中可以看到对应的图片： Chapter2：The vec3 class重载了一组关于vec3的运算符。 包括向量间的加减乘除、向量与标量的加减乘除、向量的叉积点积等。 1234567891011inline float dot(const vec3 &amp;v1, const vec3 &amp;v2)&#123; return v1.e[0] * v2.e[0] + v1.e[1] * v2.e[1] + v1.e[2] * v2.e[2];&#125;inline vec3 cross(const vec3 &amp;v1, const vec3 &amp;v2)&#123; return vec3((v1.e[1] * v2.e[2] - v1.e[2] * v2.e[1]), (-(v1.e[0] * v2.e[2] - v1.e[2] * v2.e[0])), (v1.e[0] * v2.e[1] - v1.e[1] * v2.e[0]));&#125; Chapter3：Rays,a simple camera, and background定义了射线类，并定义了三个函数，分别返回原点、方向以及射线本身。射线本身由一个Vec3表示。 Chapter4:在运行的代码中加入了一个检测与球体相交的函数，这个函数可以从2D中射线与圆的相交检测函数出发去理解。 后面会将其抽离到单独的头文件中。 1234567891011121314151617181920212223242526272829bool sphere :: hit(const ray&amp; r, float t_min, float t_max, hit_record&amp; rec)const &#123; vec3 oc = r.origin() - center; float a = dot(r.direction(), r.direction()); float b = dot(oc, r.direction()); float c = dot(oc, oc) - radius * radius; float discriminant = b * b - a * c; if (discriminant &gt; 0) &#123; float temp = (-b - sqrt(b*b - a * c)) / a; if (temp &lt; t_max &amp;&amp; temp &gt; t_min) &#123; rec.t = temp; rec.p = r.point_at_parameter(rec.t); rec.normal = (rec.p - center) / radius; return true; &#125; temp = (-b + sqrt(b*b - a * c)) / a; if (temp&lt;t_max &amp;&amp; temp&gt;t_min) &#123; rec.t = temp; rec.p = r.point_at_parameter(rec.t); rec.normal = (rec.p - center) / radius; return true; &#125; &#125; return false;&#125; Chapter5：Surface normals and multiple objects.加入了对法线方向的运算，并将对应的射线检测函数抽离到了对应的头文件中。 从球心到球上某点的向量即为该点的法线方向。 另外定义了一个类，用来计算并存储距离射线命中物体的一组点中距离射线原点最近的一个点。 Chapter6：Antialasing题目意为抗锯齿。 这里的做法是在每个以像素点为中心，向外距离为1的范围内采样n次，将n个采样的值进行平均即为该点最终的像素值。 在数字图像处理中类似的方式被称为均值滤波。 1234567891011vec3 col(0, 0, 0);for (int s = 0; s &lt; ns; s++)&#123; float random = rand() % (100) / (float)(100); float u = float(i + random) / float(nx); float v = float(j + random) / float(ny); ray r = cam.get_ray(u, v); vec3 p = r.point_at_parameter(2.0); col += color(r, world);&#125;col /= float(ns); Chapter7：Diffuse Materials题目名为漫反射材质。 Pick a random point s from the unit radius sphere that is tangent to the hitpoint, and send a ray from the hitpoint p to the random point s. That sphere has center (p+N): 从与命中点相切的单位半径球中选择一个随机点s，并将一条射线从命中点射向随机点s。球心为（p+N） 这里的做法是将反射方向加上一个随机的方向作为漫反射的方向。 12345678910111213141516171819202122232425262728vec3 random_in_unit_sphere()&#123; vec3 p; do &#123; float random0 = rand() % (100) / (float)(100); float random1 = rand() % (100) / (float)(100); float random2 = rand() % (100) / (float)(100); p = 2.0*vec3(random0, random1, random2) - vec3(1, 1, 1); &#125; while (p.squared_length() &gt;= 1.0); return p;&#125;vec3 color(const ray&amp; r, hitable *world)&#123; hit_record rec; if (world-&gt;hit(r, 0.001, (numeric_limits&lt;float&gt;::max)(), rec)) &#123; vec3 target = rec.p + rec.normal + random_in_unit_sphere(); return 0.5*color(ray(rec.p,target - rec.p), world); &#125; else &#123; vec3 unit_direction = unit_vector(r.direction()); float t = 0.5*(unit_direction.y() + 1.0); return (1.0 - t)*vec3(1.0, 1.0, 1.0) + t * vec3(0.5, 0.7, 1.0); &#125;&#125; Chapter8：Metal第八章加上了简单的材质。 我们定义了一个简单的朗伯反射的类用来描述这一材质：理想的“遮罩”或漫反射表面的属性。无论观察者的视角如何，朗伯表面对观察者的表观亮度都是相同的。 12345678910111213141516171819202122232425262728293031#ifndef LANBERTIANH#define LANBERTIANH#include "material.h"class lambertian :public material&#123;public: lambertian(const vec3&amp; a):albedo(a)&#123;&#125; virtual bool scatter(const ray&amp; r_in, const hit_record&amp; rec, vec3&amp; attenuation, ray&amp; scattered)const; vec3 albedo;&#125;;vec3 random_in_unit_sphere() &#123; vec3 p; do &#123; float random0 = rand() % (100) / (float)(100); float random1 = rand() % (100) / (float)(100); float random2 = rand() % (100) / (float)(100); p = 2.0*vec3(random0, random1, random2) - vec3(1, 1, 1); &#125; while (p.squared_length() &gt;= 1.0); return p;&#125;bool lambertian::scatter(const ray&amp; r_in, const hit_record&amp; rec, vec3&amp; attenuation, ray&amp; scattered) const &#123; vec3 target = rec.p + rec.normal + random_in_unit_sphere(); scattered = ray(rec.p, target - rec.p); attenuation = albedo; return true;&#125;#endif // !LANBERTIANH 注意原书给出的随机函数没有找到对应的引用，所以在这份代码中用rand()代替。 另外原书还定义了一个镜面反射类，这个类的反射函数参考初中物理。 1234vec3 reflect(const vec3&amp; v, const vec3&amp; n)&#123; return v - 2 * dot(v, n)*n;&#125; 在本章的最后我们添加了一个模糊的参数，这个模糊的参数使得反射光线的方向有着一定量的偏移。 Chapter9：Dielectrics这一章的标题为电解质，实际上想说明的内容包括玻璃、水这种透明的可以折射光线的材质： 123456789101112bool refract(const vec3&amp; v, const vec3&amp; n, float ni_over_nt, vec3&amp; refracted)&#123; vec3 uv = unit_vector(v); float dt = dot(uv, n); float discriminant = 1.0 - ni_over_nt * ni_over_nt*(1 - dt * dt); if (discriminant &gt; 0) &#123; refracted = ni_over_nt * (uv - n * dt) - n * sqrt(discriminant); return true; &#125; else return false;&#125; 注意，这里的情况判断包括一种全反射的情况。 关于折射的公式请参考：斯涅尔定律) Chapter10：Positionable camera在第十章，我们定义了一个具有透视功能的相机用于观察场景。 参数包括位置，观察方向，fov等。 Chapter11：Defocus Blur题目的翻译为散焦模糊，在相机的头文件中加入了一个因光圈与焦距导致成像模糊的功能。 Chapter12：第十二章算是一个总结与引导，描述了接下来要处理的一些细节： You now have a cool ray tracer! What next? Lights. You can do this explicitly, by sending shadow rays to lights. Or it can be done implicitly by making some objects emit light, biasing scattered rays toward them, and then downweighting those rays to cancel out the bias. Both work. I am in the minority in favoring the latter approach. Triangles. Most cool models are in triangle form. The model I/O is the worst and almost everybody tries to get somebody else’s code to do this. Surface textures. This lets you paste images on like wall paper. Pretty easy and a good thing to do. Solid textures. Ken Perlin has his code online. Andrew Kensler has some very cool info at his blog. Volumes and media. Cool stuff and will challenge your software architecture. I favor making volumes have the hitable interface and probabilistically have intersections based on density. Your rendering code doesn’t even have to know it has volumes with that method. Parallelism. Run N copies of your code on N cores with different random seeds. Average the N runs. This averaging can also be done hierarchically where N/2 pairs can be averaged to get N/4 images, and pairs of those can be averaged. That method of parallelism should extend well into the thousands of cores with very little coding. Have fun, and please send me your cool images! 你现在是一个很酷的Ray Tracer了，那么接下来呢？ 灯：您可以通过向灯光发送阴影光线来明确地执行此操作。或者它可以通过使一些物体发光来隐式地完成。 将散射光线偏向它们，然后减轻这些光线以抵消偏差。两者都有效。我是为数不多的喜欢后一种做法的人。 三角形：最酷的模型是三角形的。模型I/O是最糟糕的，几乎每个人都试图复制别人的代码来做到这一点（I/O）。 表面纹理。这样可以将纹理像墙纸一样贴到物体上。非常简单，也是一件值得去做的好事。 坚固的纹理。 Ken Perlin在线提供他的代码。 Andrew Kensler在他的博客上有一些非常酷的信息。 卷和媒体。很酷的东西，将挑战您的软件架构。我赞成使卷具有可调整的界面，并且概率上具有基于密度的交叉点。您的呈现代码甚至不必知道它具有该方法的卷。（这里我猜是卷积？存疑。） 并行。使用不同的随机种子在N个核心上运行N个代码副本。平均N次运行。这种平均也可以分层次地完成，其中N / 2对可以被平均以获得N / 4个图像，并且可以对这些图像的对进行平均。这种并行方法应该可以很好地扩展到数千个内核中。 享受你的乐趣，请将你很酷的图像发送给我吧～]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua中的深拷贝与浅拷贝]]></title>
    <url>%2F2019%2F07%2F23%2FLua%2FLua%E4%B8%AD%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[有关深拷贝、浅拷贝在Lua中的一系列事情。 为什么要写深拷贝：在《Lua程序设计（第四版）》第五章开头，作者描述了表的性质： 可以认为，表是一种动态分配的对象，程序只能操作指向表的引用（或指针）。除此之外，Lua语言不会进行隐藏的拷贝（hidden copies）或创建新的表。 已经描述的很清楚了，对于表的操作，Lua语言不会进行深拷贝（即Lua语言拷贝的是对象的引用而非整个对象本身。） 先看一下Lua的源码： 12345678910Table *luaH_new (lua_State *L) &#123; GCObject *o = luaC_newobj(L, LUA_TTABLE, sizeof(Table)); Table *t = gco2t(o); t-&gt;metatable = NULL; t-&gt;flags = cast_byte(~0); t-&gt;array = NULL; t-&gt;sizearray = 0; setnodevector(L, t, 0); return t;&#125; 当生成一个Table时，会返回一个Table类型的指针（t），可以看出，如果在Lua中进行表的赋值的话，实际上是将一个表的指针赋给了另一个变量，而这两个量指向的是同一个地址，也就是说，这次赋值并没有创造出一个新的副本出来，而只是给原来的变量起了一个别名。 123456789101112table1 = &#123;1,2,3&#125;table2 = table1table.insert(table1,4)for i,v in ipairs(table2) do print(v)end&gt;&gt; 1 2 3 4 如果要复制出一份独立的表，该怎么写呢？ 深拷贝与浅拷贝：深拷贝（DeepCopy）：拷贝整个对象本身，在上例的Lua代码中，如果table2对table1进行深拷贝，则改变table1不会同时改变table2，即table2是table1完全独立的一份复制。 深拷贝的实现方式：具体讲解可以参考wiki上的这一篇：CopyTable 一种快速但不怎么好的实现：这个版本的clone使用到了标准库中的unpack函数，这个函数会返回列表中的元素。 12345678function table.clone（org） return &#123; table.unpack（org）&#125;endlocal abc = &#123;5,12,1&#125;local def = table.clone（abc）table.sort（def）print（abc [2]，def [2]）- 12 5 Shallow Copy：这个实现很简单，但是有一些缺陷：它只复制了顶层的值，没有对更加深层的元素、元表和特殊类型（如userdata或coroutines）进行处理，它也容易受到__pairs元方法的影响。 12345678910111213function shallowcopy(orig) local orig_type = type(orig) local copy if orig_type == 'table' then copy = &#123;&#125; for orig_key, orig_value in pairs(orig) do copy[orig_key] = orig_value end else -- number, string, boolean, etc copy = orig end return copyend Deep Copy：这个版本的实现可以复制所有层级的元素，是一个简单的递归实现，并且会将原表的元表复制一份到新表的元表中。 1234567891011121314function deepcopy(orig) local orig_type = type(orig) local copy if orig_type == 'table' then copy = &#123;&#125; for orig_key, orig_value in next, orig, nil do copy[deepcopy(orig_key)] = deepcopy(orig_value) end setmetatable(copy, deepcopy(getmetatable(orig))) else -- number, string, boolean, etc copy = orig end return copyend 将表的拷贝存储在copies中，由原始的表索引，这是通过创建已复制的表的哈希表并将其作为第二个参数提供给deepcopy函数来完成的。 123456789101112131415161718192021-- Save copied tables in `copies`, indexed by original table.function deepcopy(orig, copies) copies = copies or &#123;&#125; local orig_type = type(orig) local copy if orig_type == 'table' then if copies[orig] then copy = copies[orig] else copy = &#123;&#125; for orig_key, orig_value in next, orig, nil do copy[deepcopy(orig_key, copies)] = deepcopy(orig_value, copies) end copies[orig] = copy setmetatable(copy, deepcopy(getmetatable(orig), copies)) end else -- number, string, boolean, etc copy = orig end return copyend]]></content>
      <categories>
        <category>开发笔记</category>
      </categories>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua迭代器和范型for]]></title>
    <url>%2F2019%2F07%2F05%2FLua%2FLua%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E8%8C%83%E5%9E%8Bfor%2F</url>
    <content type="text"><![CDATA[关于Lua中的迭代器：ipairs与pairs。 迭代器和泛型for：迭代器和闭包：所有的迭代器都需要在连续的调用之间保存一些状态，这样才能知道当前迭代所处的位置及如何从当前位置步进到下一位置。对于我们自己的迭代器而言，闭包为保存状态提供了一种良好的机制。一个闭包就是一个可以访问其自身的环境中一个或多个局部变量的函数。这些变量将连续调用过程中的值并将其保存在闭包中，从而使得闭包能够记住迭代所处的位置。当然，要创建一个新的闭包，我们还需要创建非局部变量。因此，一个闭包结构通常涉及两个函数：闭包本身和一个用于创建该闭包及其封装变量的工厂。 泛型for：泛型for在循环过程中在其内部保存了迭代函数，泛型for保存了三个值：一个迭代函数、一个不可变状态和一个控制变量。 语法如下： 123for var-list in exp-list do bodyend 其中，var-list是由一个或多个变量名组成的列表，以逗号分隔；exp-list是一个或多个表达式组成的列表，同样以逗号分隔。通常，表达式列表只有一个元素，即一句对迭代器工厂的调用。 1for k,v in pairs(t) do print(k,v) end 我们把变量列表的第一个变量称为控制变量，其值在循环过程中永远不会为nil，因为当其值为nil时循环就结束了。 for做的第一件事情是对in后面的表达式求值。这些表达式应该返回三个值供for保存：迭代函数、不可变状态和控制变量的初始值。类似于多重赋值，只有最后一个白哦大事能够产生不止一个值；表达式列表的结果只会保留三个，多余的值会被丢弃，不足三个则以nil补齐。 在上述的初始化步骤完成后，for使用不可变状态和控制变量为参数来调用迭代函数，从for代码结构的立足点来看，不可变状态根本没有意义，for只是把从初始化步骤得到的状态值传递给所有迭代函数，然后，for将迭代函数的返回值赋给变量列表中声明的变量。如果第一个返回值为nil，那么循环终止；否则，for执行它的循环体并再次调用迭代函数，再不断的重复这个过程。 两种语法等价： 1for var_1,...,var_n in explist do block end 等价于： 123456789do local _f,_s,_var = explist while true do local var_1,...,var_n = _f(_s,_var) _var = var_1 if _var == nil then break end block endend 假设迭代函数是f，不可变状态为s，控制变量的初始值为a0，那么在循环中控制变量的值依次为a1=f(s,a0),a2=f(s,a1)，直到ai为nil。如果for还有其他变量，那么这些变量只是简单的在每次调用f后得到额外的返回值。 无状态迭代器：无状态迭代器就是一种自身不保存任何状态的迭代器，因此，可以在多个循环中使用同一个无状态迭代器，从而避免创建新闭包的开销。 for循环会以不可变状态和控制变量为参数调用迭代函数，一个无状态迭代器之需要这两个值来为迭代生成下一个元素： 1234a = &#123;"One","Two","Three"&#125;for i,v in ipairs(a) do print(i,v)end ipairs和迭代器都非常简单： 1234567891011local function iter(t,i) i = i + 1 local v = t[i] if v then return i,v endendfunction ipairs(t) return iter,t,0end 当调用for循环中的ipairs(t)时，ipairs(t)会返回三个值，即迭代函数iter，不可变状态表t和控制变量的初始值0。 然后Lua语言调用iter(t,0)，得到1，t[1]（除非t[1]已经变成了nil）。在第二次迭代中，Lua语言调用iter(t,1)，得到2，t[2]，依次类推，直至得到第一个为nil的元素。 函数pairs和函数ipairs类似，也用于遍历一个表中的所有元素，不同的是，函数pairs的迭代函数是Lua语言中的一个基本函数next： 123function pairs(t) return next,t,nilend 在调用next(t,k)时，k是表t的一个键，该函数会以随机次序返回表中的下一个键以及k对应的值，调用next(t,nil)时，返回表中的第一个键值对。当所有的元素遍历完时，函数next返回nil。 区别： pairs：用于迭代table，可以遍历表中所有的key，可以返回nil ipairs: 迭代数组，不能返回 nil,如果遇到 nil 则退出]]></content>
      <categories>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua模块与包]]></title>
    <url>%2F2019%2F07%2F04%2FLua%2FLua%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85%2F</url>
    <content type="text"><![CDATA[Lua中的模块和包。 一个模块就是一些代码，这些代码可以通过函数require加载，然后创建和返回一个表。这个表就像是某种命名空间，其中定义的内容是模块中导出的东西，比如函数和常量。 函数require：函数require尝试对模块的定义做最小的假设。对于该函数来说，一个模块可以是定义了一些变量的（比如函数或者包含函数的表）的代码。 require的加载机制首先，函数require在表package.loaded中检查模块是否已被加载，如果模块已经被加载，函数require就返回相应的值，因此，一旦一个模块被加载过，后续的对于同一模块的所有require调用都将返回同一个值，而不会再运行任何代码。 如果模块尚未加载，那么函数require则搜索具有指定模块名的Lua文件（搜索路径由变量package.path指定）。如果函数require找到了相应的文件，那么就用函数loadfile将其进行加载，结果是一个我们称之为加载器的函数。 如果函数require找不到指定模块名的Lua文件，那么它就搜索相应名称的C标准库。如果找到了一个C标准库，则使用底层函数package.loadlib进行加载，这个底层函数会查找名为luaopen_modname的函数。在这种情况下，加载函数就是loadlib的执行结果，也就是一个被表示为Lua函数的C语言函数。 为了最终加载模块，函数require带着两个参数调用加载函数：模块名和加载函数所在的文件的名称。如果加载函数有返回值，那么函数require会返回这个值，然后将其保存在表package.loaded中，以便于将来在加载统一模块时返回相同的值。如果加载函数没有返回值且表中的package.loaded[@rep{modname}]为空，函数require就假设模块的返回值为true。如果没有这种补偿，那么后续调用函数require时将会重复加载模块。 编写模块的基本方法在Lua语言中创建一个表，并将所有需要导出的函数放入其中，最后返回这个表。 另一种编写模块的方法是把所有的函数定义为局部变量，然后在最后构造返回的表。 字模块和包Lua支持具有层次结构的模块名，通过点来分隔名称中的层次，例如一个名为mod.sub的模块是模块mod的一个子模块。一个包（package）是一棵由模块组成的完整的树，它是Lua语言用于发行程序的单位。]]></content>
      <categories>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua面向对象编程]]></title>
    <url>%2F2019%2F07%2F03%2FLua%2FLua%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[开发笔记] Chernobog:Rebirth（0）]]></title>
    <url>%2F2019%2F05%2F22%2F%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%2F%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0-Chernobog-Rebirth%EF%BC%880%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一款新的预研项目Chernobog:Rebirth的开发笔记——数据持久化。 这个新项目在我的理解看来就是类似于文明一样的那种六边形地块策略游戏。 由于策划同学在沟通的时候有讲到一种比较公式化的数值体系，比如：感染率与效率的关系，人口与效率的关系，所以打算确定一个辅助脚本来方便策划用数据表的形式对游戏进行配置。 有几种选择可以选： Excel转database（例如MySQL这种数据库），然后在Unity内读取数据库 Excel/CSV读取，读取为一个数据类的实例，在运行时对实例进行操作 Excel/CSV转Json/XML，存储为一个对应格式的文本文件，在运行时对文本文件进行解析。 搜了一下，感觉Unity连接数据库的过程有些麻烦，而且也不清楚是否在目标运行的机器上也需要连接数据库，所以没有选择这种方案；其次是使用Excel的一个拓展——Epplus，这个过程宣雨松老师的那本《Unity3D开发》有写；最后决定的是使用CSV格式的文件来进行操作。 总体思路我定义了两个类，一个是CSVObject，用来表示单行数据；一个是CSVTable，用来储存整表数据，其主要字段如下： 12345678910111213141516171819202122232425262728// CSVObject表示单行数据public class CSVObject&#123; // 主键 public string _ID; // 一条数据包含的所有键名 public string[] _AllKeys; // 除主键之外的所有键值对 private Dictionary&lt;string,string&gt; _attributeDic;&#125;// CSVTable表示整表，用于实例化public class CSVTable&#123; // 表名 public string Name &#123; get&#123;return _name;&#125; &#125; private string _name; // 获取表中的所有属性键 public List&lt;string&gt; AttributeKeys &#123;get&#123;return _attributeKeys;&#125;&#125; private List&lt;string&gt; _attributeKeys; // 存储表中的所有数据对象 private Dictionary&lt;string,CSVObject&gt; _dataObjDic;&#125; 多张.csv格式的表存放在StreamingAssets目录下，所经历的过程是这样的： 在对应目录下有一个名为filePath.txt的文本文件，里面按行存储着所有数据文件（.csv）格式的具体路径 DataManager读取filePath.txt文件，逐行检查描述的路径中是否存在对应文件，如不存在则报错 检查无误后，DataManager遍历上述路径中的文件，调用CSVTable中的CreateTable方法，将其数据转换成CSVTable格式 CreateTable中逐行对数据进行拆解，生成CSVObject，即单行数据 CSVObject唯一的标识符为主键（ID），根据主键来获取单行数据，再根据具体的键名来获取对应的值 filePath.txt的更新借助UnityEditor的一个脚本写入]]></content>
      <categories>
        <category>开发笔记</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>Excel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua程序设计（5）]]></title>
    <url>%2F2019%2F05%2F22%2FLua%2FLua%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%885%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Lua中的闭包。 闭包在Lua语言中，函数是严格遵循词法定界的第一类值。 “第一类值”意味着Lua语言中的函数与与其他常见类型的值具有同等权限（函数也是值）： 一个程序可以将某个函数保存到变量中或表中 可以将某个函数作为参数传递给其他函数 还可以将某个函数作为其他函数的返回值返回。 “词法定界”意味着Lua语言中的函数可以访问包含其自身的外部函数中的变量。 函数是第一类值：Lua中常见的函数定义方式如下： 123function foo(x) return 2*x end -- 语法糖-- 等同于foo = function(x) return 2*x end 赋值语句右边的表达式就是函数构造器。 在Lua语言中，所有的函数都是匿名的，像其他所有的值一样，函数并没有名字，在讨论函数名时，实际上指的是保存该函数的变量名。 以另一个函数为参数的函数，称为高阶函数（例如函数sort）。高阶函数是一种强大的编程机制，而利用匿名函数作为参数正是其灵活性的来源。 非全局函数函数不仅可以被存储在全局变量中，还可以被存储在表字段和局部变量中。 123456789101112131415-- 几种存储在表字段中的写法Lib = &#123;&#125;Lib.foo = function (x,y) return x + y endLib.goo = function (x,y) return x - y end-- 表构造器Lib = &#123; foo = function (x,y) return x + y end goo = function (x,y) return x - y end&#125;-- 一种特殊的语法Lib = &#123;&#125;function Lib.foo (x,y) return x + y endfunction Lib.goo (x,y) return x - y end 当把一个函数存储到局部变量中，就得到了一个局部函数，即一个被限定在指定作用域中使用的函数。由于Lua语言将每个程序段作为一个函数处理，所以在一段程序中声明的函数就是局部函数，这些局部函数只在该程序段中可见。 词法定界当编写一个被其他函数B包含的函数A时，被包含的函数A可以访问包含其的函数B的所有全局变量。 假入想建立一个函数来对学生姓名排序，可以： 12345function sortbygrade(names,grades) table.sort(names,function(n1,n2) return grades[n1] &gt; grades[n2] end)end 注意：传给函数sort的匿名函数可以访问grades，而grades是包含匿名函数的外层函数sortbygrades的形参，在该匿名函数中，grades既不是全局变量，也不是局部变量，而是非全局变量，也称上值（upvalue）。 函数作为第一类值，能够逃逸出它们变量的原始定界范围。 简单的说，一个闭包就是一个函数外加能够使该函数正确访问非局部变量所需的其他机制。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua程序设计（4）]]></title>
    <url>%2F2019%2F05%2F21%2FLua%2FLua%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%884%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Lua的输入输出、补充知识 输入输出单就Lua语言而言，只提供了ISO C语言标准支持的功能，即基本的文件操作等。 简单I/O模型简单模型虚拟了一个当前输入流和一个当前输出流。函数io.input和函数io.output可以用于改变当前的输入输出流，调用io.input会以只读模式打开指定文件，并将文件设置为当前输入流。之后所有的输入都将来自该文件，除非再次调用io.input。 io.write函数io.write可以读取任意数量的字符串并将其写入当前输入流。由于调用函数时可以使用多个参数，因此应尽量避免使用连接操作符以节省资源。 作为原则，应该只在”用后即弃”的代码中使用函数print，当需要完全控制输出时，应该使用函数io.write。 io.read 参数 操作 “a” 读取整个文件 “l” 读取下一行（丢弃换行符） “L” 读取下一行（保留换行符） “n” 读取一个数值 Num 以字符串读取num个字符 调用io.read(&quot;a&quot;)可从当前位置开始读取当前输入文件的全部内容，如果当前处于文件末尾或者文件为空，那么该函数返回一个空字符串。 完整I/O模型可以使用函数io.open来打开一个文件，这个函数有两个参数，一个参数是待打开文件的文件名，另一个参数是一个模式字符串，包括表示只读的r，表示只写的w，表示追加的a，以及一个可选的表示打开二进制文件的b。 补充知识局部变量和代码块Lua中的变量在默认情况下是全局变量，所有的局部变量在使用前必须声明。 局部变量可以避免由于不必要的命名而造成全局变量的混乱。 局部变量还能避免同一程序中不同代码部分的命名冲突 访问局部变量比访问全局变量更快 局部变量会随着其作用域的结束而消失，使得垃圾收集器能够将其释放 控制结构 if then else elseif while repeat-until：类似于do-while 数值型for： 123for var = exp1,exp2,exp3 do somethingend var值从exp1变化到exp2之前的每次循环会执行something，并在每次循环结束后将步长exp3增加到var上，如果exp3不存在则默认为1，不想设置循环上限，可以使用math.huge。 泛型for： 泛型for遍历迭代函数返回的所有值，例如pairs、ipairs、io.lines等。 break、return、goto：标签形如::name::]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua程序设计（3）]]></title>
    <url>%2F2019%2F05%2F20%2FLua%2FLua%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%883%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Lua中的函数。 函数在Lua语言中，函数是对语句和表达式进行抽象的主要方式。函数调用时都需要使用一对圆括号把参数列表扩起来，无论函数需不需要参数。当函数只有一个参数，且该参数是字符串常量或表构造器的时候，括号是可选的。 一例： 1234567function add (a) local sum = 0 for i = 1,#a do sum = sum + a[i] end return sumend 调用函数时使用的参数个数可以与定义函数时使用的参数个数不一致。Lua语言会通过抛弃多余参数和将不足的参数设为nil的方式来调整参数的个数。 多返回值Lua编写的函数可以返回多个结果，只需要在return关键字后列出所有要返回的值即可。 当函数被作为一条单独语句调用时，其所有返回值都会被丢弃 当函数被作为表达式调用时，将只保留函数的第一个返回值 当函数调用是一系列表达式中的最后一个表达式（或者是唯一一个表达式）时，其所有的返回值才能被获取到 如果一个函数没有返回值或者返回值不够多，那么Lua语言会用nil来补充缺失的值 可变长参数函数Lua语言中的函数可以是可变长参数函数，即可以支持数量可变的参数。 1234567function add (...) local s = 0 for _, v in ipairs&#123;...&#125; do s = s + v end return send 参数列表中的三个点(…)表示该函数的参数是可变长的。当这个函数被调用时，Lua内部会把它的所有参数收集起来，我们把这些被收集起来的参数称为函数的额外参数。当函数要访问这些参数时仍需用到三个点，但不同的是此时这三个点时作为一个表达式来使用的。在上例中，表达式{…}的结果是一个由所有可变长参数组成的列表，该函数会遍历该列表来累加其中的元素。 我们将三个点组成的表达式称为可变长参数表达式，其行为类似于一个具有多个返回值的函数，返回的是当前函数的所有可变长参数。 遍历可变长参数要遍历可变长参数，函数可以使用表达式{...}将可变长参数放在一个表中，就像add示例中所做的那样。不过在某些情况下，如果可变长参数重包含无效的nil，那么{...}获得的表可能不再是一个有效的序列，此时可以使用table.pack将表达式中的所有参数放在一个表中返回，这个表还有一个保存了参数个数的额外字段”n”。 另一种遍历函数的可变长参数的方法是使用函数select，函数select总是具有一个固定的参数selector，以及数量可变的参数，如果selector是数值n，那么函数select返回第n个参数后的所有参数（包括第n个）；否则，selector应该是字符串#，以便函数select返回额外参数的总数。 函数table.unpack多重返回值还涉及一个特殊的函数table.unpack，该函数的参数是一个数组，返回值为数组内的所有元素。 unpack函数的重要用途之一体现在泛型调用机制中，泛型调用机制允许我们动态的调用具有任意参数的任意函数。如果我们想通过数组a传入可变的参数来调用函数f： 1f(table.unpack(a)) unpack会返回a中所有的元素，而这些元素又被用作f的参数： 1print(string.find("hello","ll")) 可以使用以下的代码动态地构造一个等价的调用： 1234f = string.finda = &#123;"hello","ll"&#125;print(f(table.unpack(a))) unpack可以显式的限制返回元素的范围： 12print(table.unpack(&#123;"Sun","Mon","Tue","Wed"&#125;,2,3))&gt; Mon Tue 正确的尾调用为调用是被当作函数调用使用的跳转。当一个函数的最后一个动作是调用另一个函数而没有再进行其他工作时，就形成了尾调用。 当被调用的函数执行结束后，程序就不再需要返回最初的调用者，因此，在尾调用之后，程序也就不需要在调用栈中保存有关调用函数的任何信息，当g返回时，程序的执行路径会直接返回到调用f的位置。由于尾调用不会使用栈空间，所以一个程序中能够嵌套的尾调用的数量是无限的。 在Lua语言中，只有形如return func(args)的调用才是尾调用。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua程序设计（2）]]></title>
    <url>%2F2019%2F05%2F16%2FLua%2FLua%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%882%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Lua中的数据结构——表 表表是Lua语言中最主要（事实上也是唯一的）和强大的数据结构。 Lua语言中的表本质上是一种辅助数组，这种数组不仅可以使用数值作为索引，也可以使用字符串或其他任意类型的值作为索引（nil除外）。 Lua语言的表要么是值要么是变量，它们都是对象，表是一种动态分配的对象，程序只能操作指向表的引用。除此之外，Lua语言不会进行隐藏的拷贝（深拷贝：拷贝对象的引用而非整个对象本身）或创建新的表。 表永远是匿名的，表本身和保存表的变量之间没有固定的关系。 对于一个表而言，当程序中不再有指向它的引用时，垃圾收集器会最终删除这个表并重用其占用的内存。 表索引同一个表中存储的值可以具有不同的类型索引，并可以按需增长容纳新的元素。 把表当作结构体使用时，可以把索引当作成员名称使用（a.name等价于a[“name”]），但一般点分形式说明了表时被当作结构体使用的，此时表实际上是由固定的、预先定义的键组成的集合。 注意：a.x表示的是a.[“x”]，而不是a[x]，a[x]是指由变量x对应的值索引的表。 当被用作表索引是，任何能够被转换为整型的浮点数都会被转换成整型数；相反，不能被转换为整型数的浮点数则不会发生上述的类型转换。（这里的”能够被转换“指的是2.0这种数值本身就是整数的值） 表构造器表构造器用来创建和初始化表的表达式。 列表式写法：days = {1,2,3,4,5,6,7} 记录式写法：a = {x = 10, y = 20} 不能使用负数索引初始化列表（索引必须从1开始），也不能使用不符合规范的标识符作为索引。可以使用另一种更加通用的构造器，即通过方括号扩起来的表达式显示的指定每一个索引：opnames = {[&quot;+&quot;] = &quot;add&quot;,[&quot;-&quot;] = &quot;sub&quot;,[&quot;*&quot;] = &quot;mul&quot;,[&quot;/&quot;] = &quot;div&quot;} 数组、列表和序列只需要使用整型作为索引即可表示常见的数组或列表，Lua中数组索引依照惯例是从1开始的。 我们把所有元素都不为nil的数组称为序列。Lua语言提供了操作符#来获取序列的长度。 对于中间存在空洞（nil值）的列表而言，序列长度操作符是不可靠的，它只能用于序列。 不包含数值类型键的表就是长度为零的序列。 对于Lua语言来说，一个nil的字段和一个不存在的元素没有区别，因此a = {10,20,30,nil,nil}的长度为3，而非5。 遍历表 可以使用pairs迭代器遍历表中的键值对，但它遍历过程中元素的出现顺序可能是随机的，相同的程序在每次运行时也可能产生不同的顺序，但在遍历的过程中，每个元素会且仅会出现一次。 对于列表而言，可以使用ipairs迭代器，这会是顺序进行遍历的。 可以使用数值型for循环来遍历序列。 安全访问对于表达式a or {}，当a为nil时，其结果是一个空表，因此对于表达式(a or {}).b，当a为 nil时其结果也同样是nil，这样就可以写成：zip = (((company or {}).director or {}).address or {}).zipcode 表标准库：]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua程序设计（1）]]></title>
    <url>%2F2019%2F05%2F15%2FLua%2FLua%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Lua中的字符串。 字符串Lua语言中的字符串是一串字节组成的序列，Lua核心并不关心这些字节究竟以何种方式编码文本。 在Lua语言中，字符使用8个比特位来存储。 Lua语言中的字符串是不可变值。 像Lua语言中的其他对象（表、函数等）一样，Lua语言中的字符串也是自动内存管理的对象之一，Lua会负责字符串的分配和释放。 可以使用长度操作符#获取字符串的长度，该操作符返回字符串占用的字节数，在某些编码中，这个值可能与字符串中字符的个数不同。 我们可以使用连接操作符..来进行字符串连接，如果操作数存在数值，那么Lua语言会先把数值转换成字符串。 字符串连接总是创建一个新字符串，而不会改变原来作为操作数的字符串。 字符串常量我们可以使用一对双引号或单引号来声明字符串常量，使用双引号和单引号声明字符串是等价的，它们唯一的区别在于，使用双引号声明的字符串中出现单引号的时候，单引号可以不用转义（反过来亦然）。 Lua语言的字符串支持一些C语言风格的转义字符： 在字符串中，还可以使用转义序列\ddd和\xhh来声明字符，见上表叙述。 长字符串/多行字符串可以使用一对双方括号来表明长字符串/多行字符串常量，被方括号扩起来的内容可以包括很多行，并且内容中的转义序列不会被转义。此外，如果多行字符串的第一个字符是换行符，那么这个换行符将会被忽略。 为了应对a=b[c[i]]这样的内容，或者字符串中可能有被注释掉的代码，可以在两个左方括号之间加上任意数量的等号，这样字符串常只有在遇到了包含相同数量等号的两个右方括号时才会结束。 当代码中需要使用常量文本时，使用长字符串是一种理想的选择，但是对于非文本的常量我们不应该滥用长字符串。虽然Lua语言中的字符串常量可以包含任意字节，但是最好不要滥用长字符串。同时，像\r\n一样的EOF序列在被读取的时候可能会被归一化为\n，作为替代方案，最好就是把这些可能引起歧义的二进制数据用十进制或十六进制的数值转义序列进行表示。 Lua5.2开始引入了转义序列\z，该转义符会跳过其后的所有空白字符，直到遇到第一个非空白字符。 强制类型转换Lua语言在运行时提供了数值与字符串之间的自动转换。针对字符串的所有算术操作会尝试将字符串转换为数值（不仅是算术操作，还会在任何需要数值的情况下进行）。 Lua5.3没有实现强制类型转换与整形的集成——算数运算的规则就是只有在两个操作数都是整型值时结果才是整型。 可以使用函数tonumber来显式的将字符串转换为数值，当这个字符串的内容不能表示为有效数字的时候该函数返回nil，否则就返回对应的数值。默认情况下，函数tonumber使用的是十进制，也可以指明使用二进制到三十六进制之间的任意进制。 字符串标准库：用到再说……找就完了。 http://www.lua.org/manual/5.3/ Unicode编码遇到再说……]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Unity] U3D网络开发实战（1）]]></title>
    <url>%2F2019%2F05%2F11%2FUnity%E7%AC%94%E8%AE%B0%2FUnity-U3D%E7%BD%91%E7%BB%9C%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[第二章：分身有术：异步和多路复用 什么样的代码算是异步代码如果想实现一个5秒后响铃的方法，可以： 暂停当前线程5秒，然后响铃： System.Threading.Thread.Sleep(5000); 使用多线程技术，异步回调执行响铃函数： Timer timer = new Timer(TimeOut,null,5000,0); 异步客户端异步Connect每一个同步API对应着两个异步API，分别是在原名称前面加上Begin和End。客户端发起连接时，如果网络不好或者服务端没有回应，可会断会被卡住一段时间（指同步Connect）。若使用异步程序，则可以防止程序卡住，其核心的API BeginConnect的函数原型如下： 1public IAsyncResult BeginConnect(string host,int port,AsyncCallback requestCallback,object state) 参数 说明 host 远程主机的名称（IP），如”127.0.0.1” port 远程主机的端口号，如”8888” requestCallback 一个AsyncCallback委托，即回调函数，回调函数的参数必须是这样的形式：void ConnectCallback(IAsyncResult ar) state 一个用户定义对象，可包含连接操纵的相关信息。此对象会被传递给回调函数 EndConnect的函数原型如下。在BeginConnect的回调函数中调用EndConnect，可完成连接。 public void EndConnect(IAsyncResult asyncResult) 实例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758using System.Collections;using System.Collections.Generic;using UnityEngine;using System.Net.Sockets;using UnityEngine.UI;using System;public class Chap2_Echo : MonoBehaviour &#123; // 定义套接字 Socket socket; // UGUI public InputField inputField; public Text text; // 点击连接按钮 public void Connection() &#123; // Socket socket = new Socket(AddressFamily.InterNetwork,SocketType.Stream,ProtocolType.Tcp); // Connect socket.BeginConnect("127.0.0.1",8888,ConnectCallback,socket); &#125; // 点击发送按钮 public void Send() &#123; // Send string sendStr = inputField.text; byte[] sendBytes = System.Text.Encoding.Default.GetBytes(sendStr); socket.Send(sendBytes); // Reveice byte[] readBuff = new byte[1024]; int count = socket.Receive(readBuff); string recvStr = System.Text.Encoding.Default.GetString(readBuff,0,count); text.text = recvStr; // Close socket.Close(); &#125; public void ConnectCallback(IAsyncResult ar) &#123; try &#123; Socket socket = (Socket) ar.AsyncState; socket.EndConnect(ar); Debug.Log("Socket Connect Succ"); &#125; catch (SocketException ex) &#123; Debug.Log("Socket Connect fail" + ex.ToString()); &#125; &#125;&#125; 异步Receive与BeginConnect相似，BeginReceive用于实现异步数据的接收。 public IAsyncResult BeginReceive(byte[] buffer,int offset,int size,SocketFlags socketFlags,AsyncCallback callback,object state) 参数 说明 buffer Byte类型的数组，它存储接收到的数据 offset buffer中存储的数据的位置，该位置从0开始计数 size 最多接收的字节数 socketFlags SocketFlags值的按位组合，这里设置为0 callback 回调函数，一个AsyncCallback委托 state 一个用户定义对象，其中包含接收操作的相关信息。当操作完成时，此对象会被传递给EndReceive委托 对应的EndReceive的原型如下，它的返回值代表了接收到的字节数。 public int EndReceive(IAsyncResult asyncResult) 异步SendTCP是可靠连接，当接收方没有收到数据时，发送方会重新发送数据，直至确认接收方收到数据为止。 在操作系统内部，每个Socket都会有一个发送缓冲区，用于保存那些接收方还没有确认的数据。 发送缓冲区的长度是有限的，如果缓冲区满，那么Send就会被阻塞，知道缓冲区的数据被确认腾出空间。 Send过程只是把书记放到发送缓冲区中，然后由操作系统负责重传、确认等步骤。Send方法返回只代表成功将数据放到发送缓冲区中，对方可能还没有收到数据。 异步Send方法BeginSend的原型如下： public IAsyncResult BeginSend(byte[] buffer,int offset,int size,SocketFlags socketFlags,AsyncCallback callback,object state) 参数 说明 buffer byte类型的数组，包含要发送的数据 offset 从buffer中的offset位置开始发送 size 要发送的字节数 SocketFlags SocketFlags值的按位组合，这里设置为0 callback 回调函数，一个AsyncCallback索引 state 一个用户定义对象，其中包含发送操作的相关信息。当操作完成时，此对象会被传递给EndSend委托 异步服务端第一章的同步服务端程序同一时间只能处理一个客户端的请求，因为它会一直阻塞，等待某一个客户端的数据，无暇顾及其他客户端。 管理客户端可以定义一个名为ClientState的类，用于保存一个客户端信息。ClientState类包含TCP连接所需Socket，以及应用于BeginReceive参数的读缓冲区readBuff。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100using System;using System.Net;using System.Net.Sockets;using System.Collections.Generic;namespace EchoSever&#123; class ClientState &#123; public Socket socket; public byte[] readBuff = new byte[1024]; &#125; class MainClass &#123; // 监听 Socket static Socket listenfd; // 客户端Socket及状态信息 static Dictionary&lt;Socket, ClientState&gt; clients = new Dictionary&lt;Socket, ClientState&gt;(); public static void Main(string[] args) &#123; Console.WriteLine("Hello World!"); // Socket Socket listenfd = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); // Bind IPAddress ipAdr = IPAddress.Parse("127.0.0.1"); IPEndPoint iPEp = new IPEndPoint(ipAdr, 8888); listenfd.Bind(iPEp); // Listen listenfd.Listen(0); Console.WriteLine("[服务器]启动成功"); // Accept listenfd.BeginAccept(AcceptCallback, listenfd); // 等待 Console.ReadLine(); &#125; // Accept回调 public static void AcceptCallback(IAsyncResult ar) &#123; try &#123; Console.WriteLine("[服务器]Accept"); Socket listenfd = (Socket)ar.AsyncState; Socket clientfd = listenfd.EndAccept(ar); // clients列表 ClientState state = new ClientState(); state.socket = clientfd; clients.Add(clientfd, state); // 接收数据BeginReceive clientfd.BeginReceive(state.readBuff, 0, 1024, 0, ReceiveCallback, state); // 继续Accept listenfd.BeginAccept(AcceptCallback, listenfd); &#125; catch(SocketException ex) &#123; Console.WriteLine("Socket Accept fail" + ex.ToString()); &#125; &#125; // Receive 回调 public static void ReceiveCallback(IAsyncResult ar) &#123; try &#123; ClientState state = (ClientState)ar.AsyncState; Socket clientfd = state.socket; int count = clientfd.EndReceive(ar); // 客户端关闭 if(count == 0) &#123; clientfd.Close(); clients.Remove(clientfd); Console.WriteLine("Socket Close"); return; &#125; string recvStr = System.Text.Encoding.Default.GetString(state.readBuff, 0, count); byte[] sendBytes = System.Text.Encoding.Default.GetBytes("echo" + recvStr); clientfd.Send(sendBytes); // 减少代码量，不用异步 clientfd.BeginReceive(state.readBuff, 0, 1024, 0, ReceiveCallback, state); &#125; catch(SocketException ex) &#123; Console.WriteLine("Socket Receive fail" + ex.ToString()); &#125; &#125; &#125;&#125; 代码解释 AcceptCallback是BeginAccept的回调函数： 给新的连接分配ClientState，并把它添加到client列表中 异步接收客户端数据 再次调用BeginAccept实现循环 ReceiveCallback是BeginReceive的回调函数： 服务端收到消息后，回应客户端 如果收到客户端关闭连接的信号if(Count == 0)，断开连接（当Receive返回值小于等于零时，表示Socket连接断开，可以关闭Socket） 继续调用BeginReceive接收下一个数据 做个聊天室状态检测Poll本节的目的是引入Poll来讲述单线程下的响应优化问题。 什么是Poll比起异步程序，同步程序更加简单明了，而且不会引发线程问题。只要在阻塞方法前加上一层判断，有数据可读才调用Receive，有数据可写才调用Send，这样就既能实现功能，又不会卡住程序了。 Socket类提供的Poll方法原型如下： 1public bool Poll(int microSeconds,SelectMode mode) MicroSeconds为等待回应的时间，以微秒为单位，如果该参数为-1，则一直等待，如果为0表示非阻塞。 mode对应三种可选的模式，与Socket的可读写性以及连接成功与否有关。 Poll客户端多路复用Select什么是多路复用多路复用，就是同时处理多路信号，比如同时检测多个Socket的状态。 解决Poll服务端CPU占用率过高的方法：同时检测多个Socket的状态，在设置要监听的Socket列表后，如果有一个Socket可读（或可写，或发生错误信息），那就返回这些可读的Socket，如果没有可读的，那就阻塞。 Select方法是实现多路复用的关键，它的原型如下： 1public static void Select(IList checkRead,IList checkWrite,IList checkError,int microSeconds) 参数 说明 checkRead 检测是否有可读的Socket列表 checkWrite 检测是否有可写的Socket列表 checkError 检测是否有出错的Socket列表 microSeconds 等待回应的时间，以微秒为单位，如果该参数为-1，则一直等待，如果为0表示非阻塞 原理： Select可以确定一个或多个Socket对象的状态，使用它时，需先将一个或多个套接字放入IList中。通过调用Select可检查Socket是否具有可读性、可写性或错误条件。在调用Select之后，Select将修改IList列表，仅保留那些满足条件的套接字。当没有任何满足条件的Socket时，程序将会阻塞，不占用CPU资源。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Unity] U3D网络开发实战（0）]]></title>
    <url>%2F2019%2F05%2F09%2FUnity%E7%AC%94%E8%AE%B0%2FUnity-U3D%E7%BD%91%E7%BB%9C%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%EF%BC%880%EF%BC%89%2F</url>
    <content type="text"><![CDATA[第一章：网络游戏的开端：Echo 藏在幕后的服务端网络连接的端点：SocketSocket网络上的两个程序通过一个双向的通信连接实现数据交换，这个连接的一段称为一个Socket。一个Socket包含了进行网络通信必需的五种信息：连接使用的协议、本地主机的IP地址、本地的协议端口、远程主机的IP地址和远程协议端口。 IP地址网络上的计算机都是通过IP地址识别的，应用程序通过通信端口彼此通信。 端口端口是个逻辑概念，随着多任务系统的发展，人们定义了”端口”的概念，把不同的网络消息分发给不同的任务。 每一个进程可以用哟多个Socket，每个Socket通过不同端口与其他计算机连接。每一条Socket连接代表着本地Socket——本地端口——网络介质——远程端口——远程Socket的链路。 和打电话一样，Socket通信也分为”连接方”和”监听方”，连接方使用不同的端口连接，监听方只使用一个端口监听。 Socket通信的流程 开启一个连接之前，需要创建一个Socket对象（使用API Socket），然后绑定本地对应的端口（使用API Bind）。对服务端而言，绑定的步骤相当于给手机插上SIM卡，确定了”手机号”。对客户端而言，连接时（使用API Connect）会由系统分配端口，可以省去绑定步骤。 服务端开启监听（使用API Listen），等待客户端接入。相当于电话开机，等待别人呼叫。 客户端连接服务器（使用API Connect），相当于手机拨号。 服务器接受连接（使用API Accept），相当于接听电话并说出”喂”。 通过这四个步骤，成功建立连接，可以收发数据。 客户端和服务端通过Send和Receive等API收发数据，操作系统会自动完成数据的确认、重传等步骤，确保传输的数据准确无误。 某一方关闭连接（使用API Close），操作系统会执行”四次挥手”的步骤，关闭双方连接，相当于挂断电话。 【图】 TCP 和 UDP协议TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议，与TCP相对应的UDP协议是无连接的、不可靠的、但传输效率较高的协议。在本系列的语义中，”Socket通信”特指TCP协议的Socket通信。 开始网络编程：Echo什么是Echo程序Echo程序是网络编程中最基础的案例。建立网络连接后，客户端向服务端发送一行文本，服务端收到后将文本发送回客户端。 编写客户端程序12345678910111213141516171819202122232425262728293031323334353637383940414243using System.Collections;using System.Collections.Generic;using UnityEngine;using System.Net.Sockets;using UnityEngine.UI;public class Chap1_Echo : MonoBehaviour &#123; // 定义套接字 Socket socket; // UGUI public InputField inputField; public Text text; // 点击连接按钮 public void Connection() &#123; // Socket socket = new Socket(AddressFamily.InterNetwork,SocketType.Stream,ProtocolType.Tcp); // Connect socket.Connect("127.0.0.1",8888); &#125; // 点击发送按钮 public void Send() &#123; // Send string sendStr = inputField.text; byte[] sendBytes = System.Text.Encoding.Default.GetBytes(sendStr); socket.Send(sendBytes); // Reveice byte[] readBuff = new byte[1024]; int count = socket.Receive(readBuff); string recvStr = System.Text.Encoding.Default.GetString(readBuff,0,count); text.text = recvStr; // Close socket.Close(); &#125;&#125; 客户端代码知识点 using System.Net.Sockets;Socket编程的API位于这个命名空间下。 创建Socket对象：Socket(AddressFamily.InterNetwork,SocketType.Stream,ProtocolType.Tcp) 地址族：指明使用IPv4还是IPv6 SocketType：套接字类型，类型参考SocketType Enum ProtocolType：指明协议，本例使用的是TCP协议，部分协议类型参考ProtocolType Enum 连接Connect 客户端通过socket.Connect(远程IP地址，远程端口)连接服务端。Connect是一个阻塞方法，程序会卡住直到服务端回应(接受、拒绝或超时)。 发送信息Send 客户端通过socket.Send发送数据，这也是一个阻塞方法。该方法接受一个byte[]类型的参数指明要发送的内容。Send的返回值指明发送数据的长度。 接收消息Receive 客户端通过socket.Receive接收服务端数据，这也是一个阻塞方法，没有收到服务端数据时，程序将卡在Receive不会向下执行。该方法接受一个byte[]类型的参数，存储接收到的数据，Receive的返回值指明接收数据的长度。 关闭连接Close 编写服务端程序12345678910111213141516171819202122232425262728293031323334353637383940using System;using System.Net;using System.Net.Sockets;namespace EchoSever&#123; class MainClass &#123; public static void Main(string[] args) &#123; Console.WriteLine("Hello World!"); // Socket Socket listenfd = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); // Bind IPAddress ipAdr = IPAddress.Parse("127.0.0.1"); IPEndPoint iPEp = new IPEndPoint(ipAdr, 8888); listenfd.Bind(iPEp); // Listen listenfd.Listen(0); Console.WriteLine("[服务器]启动成功"); while(true) &#123; // Accept Socket connfd = listenfd.Accept(); Console.WriteLine("[服务器]Accept"); // Receive byte[] readBuff = new byte[1024]; int count = connfd.Receive(readBuff); string readStr = System.Text.Encoding.Default.GetString(readBuff, 0, count); Console.WriteLine("[服务器接收]" + readStr); // Send byte[] sendBytes = System.Text.Encoding.Default.GetBytes(readStr); connfd.Send(sendBytes); &#125; &#125; &#125;&#125; 服务端知识点： 绑定Bind listenfd.Bind(ipEp)将给listenfd套接字绑定IP和端口，程序中绑定本地地址”127.0.0.1”和8888号端口。127.0.0.1是回送地址，指本地机，一般用于测试。 监听Listen 服务端通过listenfd.Listen(backlog)开启监听，等待客户端连接。参数backlog指定队列中最多可容纳等待接受的连接数，0表示不限制。 应答Accept 开启监听之后，服务器调用listenfd.Accept()接收客户端连接。本例使用的所有Socket方法都是阻塞方法，也就是说当没有客户端连接的时候，服务端程序会卡在listenfd.Accept()不会向下执行，直到收到了客户端的连接。Accept返回一个新客户端的Socket对象，对于服务器来说，它有一个监听Socket（listenfd）用来监听和应答客户端的连接，对每个客户端还有一个专门的Socket（connfd）用来处理客户端的数据。 IPAddress和IPEndPoint 用IPAddress指定IP地址，用IPEndPoint指定IP和端口。 System.Text.Encoding.Default.GetString Receive方法将接收到的字节流保存在readBuff上，readBuff是byte型数组。 公网和局域网]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Unity] 不同设备屏幕适配问题]]></title>
    <url>%2F2019%2F04%2F24%2FUnity%E7%AC%94%E8%AE%B0%2FUnity-%E4%B8%8D%E5%90%8C%E8%AE%BE%E5%A4%87%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[面试问到了，不同设备屏幕适配问题。]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[转] AssetBundle 使用模式]]></title>
    <url>%2F2019%2F04%2F20%2FUnity%E7%AC%94%E8%AE%B0%2F%E8%BD%AC-AssetBundle-%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[AssetBundle 使用模式 原文地址：https://zhuanlan.zhihu.com/p/33268074 原文：https://unity3d.com/cn/learn/tutorials/temas/best-practices/assetbundle-usage-patterns译文参考： http://blog.shuiguzi.com/2017/04/18/AssetBundle_usage_pattern_1/ 这是 Unity 5 资源、Resources目录和资源管理 系列文章的第五篇。 上一篇文章涵盖了 AssetBundle 基础知识，特别是各种加载资源 API 的底层行为。这篇会讨论实际使用 AssetBundle 碰到的问题和可能的解决方案。 4.1 管理已加载的资源在高性能要求的环境中，要特别严格地，小心翼翼地控制加载的对象的数量和大小。当对象从当前场景中移除时，Unity 不会自动的卸载他们。资源的清理在特殊的时间触发，当然它也可以手动来触发。 AssetBundle 必须要被仔细地管理，来自本地存储文件的 AssetBundle（不管是从缓存或者是通过 AssetBundle.LoadFromFile加载的) 一般来说很少会超过10-40 kb的额外内存开销，所以它的开销是 最小 的。然而当存在大量 AssetBundle 时，这种开销仍然可能成为问题。 对大部分项目来说，一般允许用户对游戏内容重新体验（例如重玩关卡），那么考虑在什么时候加载和卸载AssetBundle就显得很重要了。如果一个 AssetBundle 没有被正确卸载，可能会引起内存中对象重复。 不正确的卸载资源也在某些情况下也可能引起不希望的结果，比如引起纹理丢失。要理解这其中的缘由，可以参考 “资源、对象与序列化（Assets, Objects and serialization）- 1.2 对象之间的引用(Inter-Object references)” 章节。 要了解AssetBundle管理资源的关键，是要了解在调用 AssetBundle.Unload 函数时参数 true 或是 false 时的不同行为。 这个 API 会卸载调用的 AssetBundle 的信息头，参数意思是是否也卸载从这个 AssetBundle 加载的对象实例。如果是 true, 所有从这个 AssetBundle 实例化的对象会立即被卸载，即便是它们被当前场景正在被使用。 例如，假设材质 M 是从 AssetBundle AB 中加载的，并且当前场景正使用着材质 M： 如果调用了 AB.Unload(true)，那么 M 会从当前场景中删除，同时销毁和卸载。如果调用了 AB.Unload(false)，那么 AB 的信息头会被卸载，但是材质 M 依然在当前场景中并且可用。调用 AssetBundle.Unload(false) 会打破 M 和 AB 直接的关联关系，如果稍后再次加载 AB，则 AB 中包含的对象的新副本将被加载到内存中： 如果稍后再次加载 AB, 将会加载一个新的 AB 信息头的副本，但是 M 不是从 AB 新副本中加载的，所以Unity 不会为 M 和新的 AB 拷贝间建立新的关联关系： 如果调用了 AB.LoadAsset() 来重新加载 M,Unity 不会把 M 的旧副本解析为 AB 的数据的实例，所以，Unity 会重新加载一个 M 的副本，这时场景中就会有 两个 完全一摸一样的 M 的副本。 对大多数项目而言，这种行为是不可取的，大多数项目应该使用 AssetBundle.Unload(true) 并且使用额外方法来确保对象不会有重复副本，一般常用的方法有： 在应用生命周期中，在明确定义的时间点对临时的AssetBundle 卸载，比如两个关卡之间或者加载场景的时候。这个比较简单，也是使用最多的情况。 维护单个物体的引用计数，并当组成 AssetBundle 的对象都未被使用时卸载 AssetBundle。这允许应用卸载和重新加载对象而不会复制多余的内存。如果应用必须使用 AssetBundle.Unload(false)来卸载资源, 则单个对象只能通过下面两种方式卸载： 在场景和代码中清除不需要对象的所有引用，在完成之后调用 Resources.UnloadUnusedAssets 排他性方式加载场景，这个操作会卸载当前场景中的所有对象，然后自动的调用 Resources.UnloadUnusedAssets 如果一个项目中有明确定义的时间点，那它可以用来等待对象的加载和卸载，比如游戏模式和关卡之间，那么在这些点应该尽可能多的卸载对象和加载新的对象。 最简单的方法是将项目中离散块打包到场景中，然后把场景和所有依赖打包到 AssetBundle 中。这个应用可以进入一个 “加载” 场景，在这个场景中完全卸载包含旧场景的 AssetBundle ， 然后加载包含新场景的 AssetBundle。 然而这只是一个简单的流程，有些项目需要更复杂的 AssetBundle 管理，并没有放之四海皆准的AssetBundle设计模式，每个项目的具体情况都不同。当考虑如何对资源进行AssetBundle分组时，如果一些资源通常需要被一块加载或者更新的时候，那么把它们打包到一个AssetBundle中会是一个不错的选择。 例如，考虑一个角色扮演游戏，单个地图和过场动画可以按场景分组到 AssetBundle 中，但是有一些对象在大多数场景中都要被用到，例如AssetBundle 可以用于加载肖像，游戏中 UI, 不同的角色模型和纹理。这些用到的对象和资源可以被分组到另一套AssetBundle里，这样可以在游戏启动的时候加载，并且运行时一直保留在内存里。 如果 Unity 必须重新从已经卸载的 AssetBundle 中加载对象，那么这时对象加载会失败，对象在 Unity 编辑器的 Hierarchy 中显示为（Missing）。 这种情况通常发生在Unity丢失了图形上下文(graphics context)然后又重新获得控制权的时候，例如一个移动应用被挂起或者用户 PC 端锁屏。在这种情况下，Unity 必须向 GPU 重新上传纹理和 shader。如果上传的资源的 AssetBundle 不可用，那么应用的场景中的对象就会 “丢失Shader” 而显示成的洋红色。 4.2 部署有两种基本的方式可以将项目的 AssetBundle 部署到客户端上：跟项目一起安装或者项目安装之后下载。是一起安装还是安装之后下载的决定依赖于项目目标平台的能力和限制：移动端项目通常采用安装后下载来达到减少初始安装大小, 并且大小不超过无线网络下载限制。主机和 PC 项目一般是采用 AssetBundle 跟初始安装一起分发。 优良架构可以在不管AssetBundle最开始如何分发的情况下，进行内容的更新和修正。更多的信息请参照这章中的 “4.4 为Assetbunlde 打补丁” 章节。 4.2.1 随工程分发AssetBundle 跟随项目一起分发是部署他们的最简单的方式，因为不需要额外的下载管理代码。将AssetBundle在安装的时候就包含进去最主要有两点原因： 减少项目构建时间和允许更快的迭代开发。如果 AssetBundle 不需要独立于程序本身独立更新，程序可以将 AssetBundle 放置于 StreamingAssets 中。参考下面的 “4.2.1.1 Streaming Assets 目录” 小结。 为可以更新的内容提供一个初始版本。这通常是为最终用户初始安装之后节省时间或者作为一个后期更新的基础版本。Streaming Assets 在这种情况下不是好的选择。如果不想写一个定制的下载器和缓存系统的话，那么可以更新内容的基础版本可以从 “4.2.3.1 初始缓存(Cache Priming)” 中加载。 4.2.1.1 Streaming Assets目录在构建项目之前将内容放到 /Assets/StreamingAssets/ 文件夹里，是 Unity 程序安装时就包含各种各样的内容的最简便的方法。所有在 StreamingAssets 文件夹内的文件都会在项目构建的时候被拷贝到最终程序包里，StreamingAssets 文件夹可以用来存储最终程序包内的各种内容，而不仅仅是 AssetBundle。 在运行时要想取得StreamingAssets 文件夹在本地存储中的全路径，可以通过属性 Application.streamingAssetsPath 得到，AssetBundle 在大多数平台上都可以通过 AssetBundle.LoadFromFile来加载。 致Android开发者： 在安卓平台上， Application.streamingAssetsPath 指向的是一个压缩的 .jar 文件，即便 AssetBundle 已经被压缩过了。在这种情况下，必须使用 WWW.LoadFromCacheOrDownload 加载每个 AssetBundle。当然可以写代码去解压 .jar file，然后将 AssetBundle 提取到一个可以读的本地存储上。[ 译注： 这里文档有误，Android平台上通过AssetBundle.LoadFromFile(Async)加载StreammingAssets目录里的AssetBundle可行的，可以参考 这里] 注意： StreamingAssets目录 在一些平台上是不可写的。如果一个项目的 AssetBundle 需要在安装之后更新，可以使用 WWW.LoadFromCacheOrDownload 或者写一个定制的下载器，更多详情请参照 “4.2.3.2 存储” 小结。 4.2.2 安装之后下载将 AssetBundle 交付到移动设备上的首选方式是在应用安装完之后下载，内容可以再在应用安装后，用户不需要重新下载整个应用的情况下新加或者修改。在移动平台上，应用文件需要进昂贵并且长时间的认证审核过程，所以一个安装后下载的系统是必不可少的。 最简单地分发 AssetBundle 是将它们放到一个网络服务器上，然后通过 WWW.LoadFromCacheOrDownload或者 UnityWebRequest 来下载它们。Unity 会在本地存储上自动的缓存已下载的 AssetBundle。如果下载的 AssetBundle 是 LZMA 压缩格式，为了之后更快的加载，它会以未压缩格式存储在缓存中。如果下载的 AssetBundle 是 LZ4 压缩格式，则会保持压缩格式存储在缓存中。 如果缓存满了，Unity 会将最近未使用的 AssetBundle 从缓存中移除。更多详情请参考 “4.2.3 内置缓存” 小节。 注意 WWW.LoadFromCacheOrDownload 是有瑕疵的。就如在“3.4 加载AssetBundle” 小节中所说，WWW 对象下载的时候会消耗跟 AssetBundle 数据的大小一样的内存，这会导致意想不到的内存峰值。有三种方法可以避免这种情况： 使用小尺寸 AssetBundle，AssetBundle 下载过程中，项目内存预算值决定了下载的 AssetBundle 的最大值。有 “加载” 界面的应用可分配用来下载 AssetBundle 的内存通常会比在后台读写 AssetBundle 的多。 如果是 Unity 5.3 或者更新版本，使用新的 UnityWebRequest API 的 DownloadHandlerAssetBundle，这个不会引起内存峰值。 定制一个下载器。更多的信息，可以参考“4.2.3 自定义下载器”章节。 通常推荐尽可能使用 UnityWebRequest 或者在 Unity 5.2及之前版本中使用 WWW.LoadFromCacheOrDownload。只有当内置的 API 在内存消耗，缓存行为或者性能上不满足项目需求，或者项目必须跑平台相关代码来满足其需求时才需要定制下载器。 不适用 UnityWebRequest 或者 WWW.LoadFromCacheOrDownload 的情况有： 需要对 AssetBundle 缓存做细微地控制 项目需要实现定制的压缩策略 项目希望使用平台相关的 API 去满足特定需求，比如需要在程序非激活状态下保持数据流(stream data)，例如：使用 iOS 的 Background Tasks API 去后台下载数据。 AssetBundle 需要通过在 Unity 不完全支持平台上使用 SSL，比如 PC。 4.2.3 内置缓存Unity 中有一个可以用来缓存通过 WWW.LoadFormCacheOrDownload 或者 UnityWebRequest API下载的 AssetBundle 的内置缓存系统。 这两个 API 都有接收 AssetBundle 版本号为参数的函数重载，这个版本号既不是保存在 AssetBundle 里面，也不是由 AssetBundle 系统生成。 缓存系统会一直记录传递给 WWW.LoadFromCacheOrDownload 和 UnityWebRequest 的版本号。当带版本号任一API被调用时，缓存系统会检查是否有缓存过的 AssetBundle。缓存系统会比较首次缓存时被传递的版本号和当前传递的版本号。如果两个版本号不匹配，或者没有 AssetBundle没有被缓存过，Unity 会下载一个新的副本，然后将其与新的版本号关联。 缓存系统中的 AssetBundle 只靠他们的文件名来区分的，而不是靠下载他们的地址。这就意味着拥有相同名字的 AssetBundle 可以存储在不同路径中。比如，一个 AssetBundle 可以放到内容分发网络（CDN）中的多台服务器上。只要他们的文件名一样，缓存系统会认为它们是同一个 AssetBundle。 分配版本号给 AssetBundls 和传递这些版本号给 WWW.LoadFromCacheOrDownload 的策略完全由各个应用自己决定。大部分应用可以用 Unity 5 的 AssetBundleManifest API。这个 API 会根据 AssetBundle 的内容为其生成一个 MD5 哈希值。当 AssetBundle 改变时，这个哈希值会跟着改变，这表明这个 AssetBundle 需要被下载。 注意： Unity 内置缓存系统的实现方式的特殊，旧的 AssetBundle 直到缓存被填满之后才会被删除。Unity 有意向在未来的发行版中解决这个问题。 更多信息请参考 “4.4 给AssetBundle打补丁” 小节。 我们可以调用缓存对象上的 API 来控制 Unity 内置的缓存。Unity 缓存行为可以通过 Caching.expirationDeplay 和 Caching.maximumAvailableDiskSpace 来控制： Caching.expirationDelay是 AssetBundle 被自动删除前所需要达到的秒数。如果 AssetBundle 没有在设置的时间内访问，它将被自动删除。 Caching.maximumAvailableDiskSpace决定了缓存在使用本地存储时，删除最少使用的 AssetBundle 时能达到的最大空间，它通过字节来计数。当达到最大限制时，Unity 会删除最近最少打开的或者通过 Caching.MarkAsUsed 标识已使用的 AssetBundle。直到空间满足新下载的 AssetBundle 时 Unity 才会停止删除已缓存的 AssetBundle。 注意： Unity 5.3 版本中控制内置缓存的功能很不完善。不支持主动地从缓存中移除指定的 AssetBundle, 而只能当 AssetBundle 超过了时限，或者超过了磁盘空间限制，或者调用 Caching.CleanCache API。Cache.CleanCache 将会清除缓存中的所有 AssetBundle。这会给开发过程或者线上操作带来问题，比如 Unity 不会移除不再被应用使用的 AssetBundle。 4.2.3.1 初始缓存(Cache Priming)因为 AssetBundle 是通过他们的名字来区别的，所以应用程序时可以“初始化(prime)”缓存的。通过将基础版本的 AssetBundle 放置到 /Assets/StreamingAssets/ 文件夹下可以达到这种目的。这个过程跟 “4.2.1 随工程分发”提到的一种方式是一样的。 应用第一次运行的时候，可以从 Application.streamingAssetsPath 加载一次 AssetBundle，这样就放置到缓存中。然后以后可以调用 WWW.LoadFromCacheOrDownload 或者 UnityWebRequest 加载。 4.2.3 自定义下载器定制一个下载器可以让应用全权控制 AssetBundle 如何下载，解压和存储。只有当大团队需要些一些精益的应用时才推荐写下载器。写一个下载器时有四个主要的问题需要考虑： 怎么样下载 AssetBundle 将 AssetBundle 存储到哪里 是否需要和如何压缩 AssetBundle 如果给 AssetBundle 打补丁 关于如何打补丁，可以参照 给 “4.4 AssetBundle 打补丁” 小节。 4.2.3.1 下载对于大多数应用来说，HTTP 是下载 AssetBundle 最简单的方式。但是，实现一个基于 HTTP 的下载器并不是一个简单的任务。定制的下载器需要避免过高的内存开销，过高的线程使用率和过多的线程唤醒。Unity 的 WWW 类根据 “AssetBundle基础 - 3.4.3 WWW.LoadFromCacheOrDownload”章节里的描述，是特别不适合这项任务的。因为 WWW 会消耗比较高的内存，即使不使用 WWW.LoadFromCacheOrDownload 的情况下也不要使用 WWW 类。 当要写一个定制的下载器时，有 3 个选择： C# 的 HttpWebRequest 和 Web Client 类 定制原生插件 AssetStore 插件 4.2.3.1.1 C#类如果应用不需要支持 HTTPS/SSL，C# 的 WebClient 类提供了最简单的机制用来下载 AssetBundle。它能将任何文件异步的下载到本地存储中，不需要过多的内存分配。 使用 WebClient 下载 AssetBundle, 只要创建一个 WebClient 实例，将 AssetBundle 的下载地址和存储地址传给实例就可以。如果需要更多的控制请求的参数，可以使用 C# 的 HttpWebRequest 类去写下载器: 从 HttpWebResponse.GetResponseStream 获取一个字节流(byte stream)。 从堆内存上分配一个固定长度的字节buffer。 将字节从流中读到 buffer 里。 将 Buffer 里的数据写到硬盘中，可以使用 C# http://File.IO API或者其它流式IO系统。 平台相关注意： Unity C# 运行时支持 HTTPS/SSL 的平台仅有 iOS, Android 和 Windows Phone。在 PC 平台上，试图用 C# 类去访问 HTTPS 服务器的话会得到证书验证失败的错误提示。 4.2.3.1.2 AssetStore 插件有好几个 Asset Store 插件通过原生代码(native-code)提供了实现的可以通过 HTTP, HTTPS 和其他协议下载文件的功能。在为 Unity 写定制的原生代码插件前，推荐先评估一下 Asset Store插件。 4.2.3.1.3 定制原生插件写一个定制原生插件是在 Unity 下载数据方式中最耗时但又最灵活的。由于需要比较多的编程时间和技术要求，这个方式只推荐在其他方式不能满足应用需求的时候使用。比如，当应用必须要在 Unity 不支持的平台上使用 SSL 通讯时。这些平台有 Windows, OSX (mac OS) 和 Linux。 定制原生插件一般会封装目标平台上的原生下载 API. 比如 iOS 上的 NSURLConnection 和安卓平台上的 java.net.HttpURLConnection。关于这些 API 的更详细使用，请查看对于平台的原生文档。 4.2.3.2 存储在所有平台上，Application.persistentDataPath 都指向了一个可以写的路径，这个路径用来保存可以程序多次运行持久化的数据。当写一个定制下载器时，强烈推荐使用 Application.persistentDataPath 的子目录去存储已下载的数据。 Application.streamingAssetPath 是只读的，是用来做 AssetBundle 缓存的一个糟糕的选择。streamingAssetPath 其中： OSX: 在 .app 包内，不可以写 Windows： 在安装目录内（一般是 Promgram Files），通常不可写 iOS： 在 .ipa 包内，不可写 Android： 在压缩的 .jar 文件内，不可写 4.3 资源分配策略决定如何将项目内的资源分配到 AssetBundle 是不容易的。简单的规则都很有诱惑性，比如将所有对象都放置到他们自己的 AssetBundle 中或者将所有对象都放到一个 AssetBundle 中，但是这些方案都有明显的缺点： AssetBundle 数量太少: 会增加运行时内存使用 会增加加载时间 需要下载大量数据 有太多的 AssetBundle: 会增加构建的时间 会加大开发的复杂性 会增加总的下载时间 关键之处在于如何将对象分组到 AssetBundle 中。主要的策略有： 逻辑实体 对象类型 内容不相干(Concurrent content) 注意一个项目对于不同的内容分类可以将这些并且应该将这些策略混合地使用。比如一个项目可能需要将 UI 元素分组到不同平台的 AssetBundle 中，但是靠关卡或者场景来分组他们项目相关的内容。关于使用的策略，可以遵循下面这些指导： 相比不经常更新的内容，将经常更新的对象拆分到不同的 AssetBundle 中 将可能同时加载的对象分组到一起。比如模型和他的动画与纹理 如果一个对象被多个 AssetBundle 中的多个对象依赖，将它分配到单独的 AssetBundle 中 如果两个对象不太可能同时加载，比如一个纹理的高清和标清版本，可以将他们分配到不同的 AssetBundle 中 如果是同一个对象的不同导入设置或者数据的不同版本，考虑使用 AssetBundle 变体（AssetBundle Variants）来替代 一旦遵循上面的指导，考虑将任意时刻内小于 50% 能被加载的 AssetBundle 拆分。也可以考虑将一些小的(资产数量小于 5 - 10 个)、会同时加载的 AssetBundle 合并。 4.3.1 逻辑实体分组逻辑实体分组是一个通过项目功能来分组对象的策略。当采用这种策略时，应用中的不同部分会单独分组进不同的 AssetBundle 中。 例如： 一个 UI 屏幕中的所有纹理和布局数据打包在一起 一个角色的纹理、模型和动画打包在一起 被多个关卡共享的场景碎片的纹理和模型打包在一起 逻辑实体分组是最常用的 AssetBundle 策略，特别适用于： DLC （Downloadable Content） 实体（Entity）在应用生命周期内多处被用到例如： 通用的角色或者基本 UI 元素 实体（Entity）仅仅是平台或者性能不同而有差异 逻辑实体分组的优点是不需要从新下载不变内容的情况下轻松的更新实体。这就是它为什么特别适合 DLC （Downloadable Content）的原因。这个策略也是内存效率最高的，因为应用只需要加载当前使用的实体的 AssetBundle。 尽管如此，这也是最难实现的策略，因为分配对象给 AssetBundle 的开发者必须精确地熟悉单个对象是怎样被项目使用的。 4.3.2 类型分组类型分组是最简单的策略。在这个策略中，相似或者相同类型的对象被放置到同一个 AssetBundle 中。比如，将不同的音轨放置到同一个 AssetBundle 或者不同的语言文件放置到同一个 AssetBundle。 这个策略简单的同时，它却经常是在编译时，加载时和升级时最低效的。它常常被用作小文件对象的同时升级，比如本地化文件。 4.3.3 不相干(concurrent)内容分组不相干内容分组是将需要同时加载和使用内容分组到同一个 AssetBundle 的策略。这种策略最常用在强本地相关属性的内容上，也就是说内容很少或者基本不可能在应用特定的位置或者时间之外出现。举个例子，关卡游戏中每一关卡都独一无二的艺术效果，角色和声效。 实现不相干内容分组的最常用的方法是通过场景来构建 AssetBundle，每个 AssetBundle 包括了场景中的几乎所有的依赖。对没有强本地属性的项目，和在应用生命周期内很少出现的内容，应该通过逻辑实体策略来分组。这两种都是最优化使用 AssetBundle 内容的大体策略。 一个例子就是，一个角色在世界中随机生成的开发世界游戏。这种情况中，很难预测几个角色会同时出现，所以它们一般需要使用不同的策略。 4.4 为Assetbunlde 打补丁给 AssetBundle 打补丁就如简单地下载一个新的 AssetBundle 然后替换已存在的。如果 WWW.LoadFromCacheOrDownload 或者 UnityWebRequest 被用来管理应用已缓存的 AssetBundle，这个过程就是给所选的 API 传递不同的版本号一样简单。（可以参考上面的脚本参考链接来查看更多详情。） 更困难的问题是解决补丁系统检测哪个 AssetBundle 需要被替换。一个补丁系统需要两个信息列表： 当前已下载的 AssetBundle 和它们的版本信息列表 远程服务器上的 AssetBundle 和它们的版本信息列表 修补程序需要下载服务器端的 AssetBundle 列表和然后比较这个列表。AssetBundle 丢失或者 AssetBundle 的版本信息改变了，都需要重新下载。 Unity 5 的 AssetBundle 系统会在构建完成后创建一个额外的 AssetBundle。这个额外的 AssetBundle 包括一个 AssetBundleManifest 对象。这个清单对象包含 AssetBundle 和它们的哈希值，可以用来给客户端传递有效的 AssetBundle 下载列表和版本信息。关于 AssetBundle manifest bundle，请参照 Unity手册。 我们也可以写一个定制的系统来检测 AssetBundle 的改变。大部分写开发者写的系统都选择使用行业标准的数据结构作为他们的 AssetBundle 文件列表，比如 JSON，还有用来计算 checksum 的标准 C# 类，比如 MD5。 4.4.1 差异更新在 Unity 5 中，Unity 可以将数据按确定的顺序编译出 AssetBundle。这就允许定制下载器实现差异更新。要让 AssetBunle 按确定的布局构建，需要将 BuildAssetBundleOptions.DeterministicAssetBundle 标签传递给 BuildAssetBundles 函数。（更多详情请参照脚本参考的链接。） Unity 没有提供内置的差异更新的机制，WWW.LoadFromCacheOrDownload 和 UnityWebRequest 使用内置的缓存系统也没有实现差异更新。如果一个系统中，差异更新是必须的，那么必须要写一个定制的下载器。 4.4.2 iOS 中的按需加载资源按需加载资源 是 Apple 为 iOS 和 TVOS 设备提供内容的 API，在iOS 9以上的系统中可用。它在 App Store 发布 iOS app 不是必须的需求，但是在 TVOS app 中是必须的。 关于 Apple 的按需加载资源系统的资料可以从 Apple 开发者 找到。 Unity 5.2.1 中对 Apple 的应用分割和按需资源支持都是在 Apple 的另外一个叫Asset Catalogs系统上构建的。在 Unity 编辑器中注册回调函数之后，iOS 的构建管道会给出被自动放到 Asset Catalogs 中并分配了按需资源标签的文件集合。 新的 API UnityEngine.iOS.OnDemandResources 提供了运行时获取和缓存按需资源文件的支持。一旦资源通过按需资源系统加载，它就可以通过标准的 API AssetBundle.LoadFromFile 加载进 Unity。示例和更多的细节可以参照 这篇帖子。 4.5 常见的坑这小节讲述了使用 AssetBundle 的项目常出现的几个问题。 4.5.1 资源重复通过AssetDatabase，Unity 5 的 AssetBundle 系统可以找出打包进 AssetBundle 的对象的所有依赖。依赖信息决定了打包进 AssetBundle 的对象集合。 对象被显式的分配到某个 AssetBundle 后它们只会被打包到那个 AssetBundle 中。对象被 “显式分配” 是对象的 AssetImpoter 的 assetBundleName 属性被设置为了非空字符串。这个行为可以在对象 Inspector 中选择 AssetBundle 或者通过编辑器脚本完成。 没有被显式分配到 AssetBundle 的对象会被打包到拥有一个或者多个没有标签的对象的 AssetBundle 中。如果两个不同的对象被分配到不同的 AssetBundle ，而它们都引用了共同依赖对象，然后这个共同的对象会被拷贝到每个 AssetBundle 中。重复的依赖对象会被实例化，这意味着这些依赖对象的拷贝会被认为是拥有不同标识不同对象。这会增加应用的 AssetBundle 的总大小。这也让加载这两个不同对象所在的 AssetBundle 时，它们会被加载进内存中。 有几种方式来应付这种问题： 确保被打包进 AssetBundle 中的不同对象不会有同样的依赖。任何跟其他对象没有共同依赖的对象都会打包到 AssetBundle 中，而不同重复拷贝依赖。 这种方法对有很多共享依赖的项目不太合适。它会产生的巨大的 AssetBunle，而且这个 AssetBunle 必须频繁地重建和下载，既不方便又很低效。 AssetBundle 分片，这样就不会同时有两个有共同依赖的 AssetBundle 会被加载 这个方法可能只对某些项目管用，比如基于关卡的游戏。但是它会给项目增加不必要的 AssetBundle 大小和增加编译与加载时间。 把所有的依赖都打包到依赖他们的 AssetBundle 中。这完全地排除了冗余资产的风险，但是它也引入了复杂性。应用程序必须 AssetBundle 间的依赖，来确保在调用 AssetBundle.LoadAsset API 前加载了正确的 AssetBundle。 Unity 5 中，对象的依赖是通过 AssetDatabase API 来记录的，这些 API 位于 UnityEditor 命名空间。就行命名空间名字所表明意思一样，这些 API 只有在 Unity 编辑器中可用，在运行时不可用。AssetDatabase.GetDependencies 可用来得到特定对象或者资源当前的依赖。注意得到的依赖可能还有它们自己的依赖。另外的，AssetImporter API 可用来查询 AssetBundle 被指派到了那些指定的对象上。 通过 AssetDatabase 和 AssetImporter API 的组合使用，用脚本用来确保一个 AssetBundle 的所有直接或者间接的依赖都指派到了同一个 AssetBundle 上，或者不存在没有指派到 AssetBundle 的依赖被两个 AssetBundle 共享是可行的。出于对重复资源内存消耗考虑，建议所有的项目都有这样的编辑器脚本。 4.5.2 图集的冗余下面小结介绍了 Unity 5 的资源依赖计算代码中，用于自动生成的图集的一种缺陷。Unity 5.2.4p4 和 Unity 5.3 已经对这个行为打了补丁。 Unity 5.2.2p4，5.3 和之后的版本所有自动生成的精灵图集所有对象都会指派到包含它们的 AssetBundle 中。如果这些精灵对象被指派到多个 AssetBunle,那么图集就不会指派给一个AssetBundle，这就会导致重复。如果这些精灵对象没有指派给AssetBundle，那么图集也不会指派给一个AssetBundle。 为了确保精灵图集不会冗余，确保所有标在同一个图集中的精灵都指派到了同一个 AssetBundle 中。 Unity5.2.2p3 以及老的版本在这些版本中，自动生成的精灵图集永远不会指派到 AssetBundle 中。因为这样，包含有组成这个图集的精灵对象的 AssetBundle 和引用了组成这个图集的精灵对象的 AssetBundle 都会包含这个图集。 因为这个问题，建议所有使用 Unity 的 Sprite Packer 的版本都生升级到 Uinty 5.2.2p4，5.4 或者更新的 Unity 版本。 对于不能升级的项目，有两种临时解决方案： 简单的方案：避免使用 Unity 的内置 Sprite Packer. 外部的打包工具生成的精灵图集是造正常的资源，可以正确的指派到 AssetBundle 中。 难的方案：将所有使用了自动打图集的精灵的对象都指派到和精灵同一个 AssetBundle 中 这可以确保生成的精灵图集对于非直接的依赖的 AssetBundle 不可见，也不会有冗余 这个方案解决了使用 Unity Sprite Packer 的简单流程，但是它让开发者不能将分配资源到不同的 AssetBundle 中，并且引用了这个图集的组件上的任何数据变动都要强制重新下载整个精灵图集，即使图集自己没有任何变动。 4.5.3 安卓纹理由于安卓生态中设备的碎片化特别严重，常常我们需要将纹理压缩成好几种格式。所有的安卓设备都支持 ETC1, 而 ETC1 不支持 alpha 通道。在不是必须要求使用 OpenGL ES 2 支持的设备上，最彻底简便的解决这个问题方法就是使用 ETC2 格式，这个格式被所有使用 OpenGL ES 3 的安卓设备支持。 如果很多应用程序需要在不支持 ETC2 的老设备支持。一个解决这个问题的方法就是使用 Unity 5 的 AssetBundle 变体（Variants）。（更多设置详情请查看 Unity 的安卓优化指导。） 为了使用 AssetBundle 变体（Variants），所有不能使用 ETC1 的纹理多要被隔离到只包含纹理的 AssetBundle 中。然后为非 ETC2 设备创建主变体，并使用第三方纹理压缩格式，比如 DXT5, PVRTC 和 ATITC。对于每个 AssetBundle 变体，改变包含的纹理的 TextureImporter 设置来改变为变体对应的格式。 在运行时，不同纹理压缩格式可以用 SystemInfo.SupportsTextureFormat API 来检测。这个信息应该用来选择和加载其所支持纹理格式的AssetBundle 变体。 更多Android图片压缩格式的信息可以参考 这里。 4.5.4 过度使用iOS文件句柄下面描述的问题已经在 Unity 5.3.2p2 中修复，当前版本的 Unity 并不受其影响。 在 Unity 5.3.2p2 之前，Unity 会在整个周期内保持对已加载过的 AssetBundle 的文件句柄的占用。这个对大多数平台不算大问题。但是 iOS 限制了并行的文件句柄数量最大为 255。 如果超过这个数量时加载 AssetBundle, 加载的调用会失败，并抛出 “打开文件句柄太多” 错误。 这对那些把内容拆分到上百甚至上千个 AssetBundle 的项目算是比较常见的问题。 对于没法升级 Unty 补丁版本的 Unity, 有两个临时解决方案可以用： 合并相关的 AssetBundle 来减少 AssetBundle 的数量 使用 AssetBundle.Unload(false) 关闭文件句柄，并手动的管理加载的对象的生命周期 4.6 AssetBunle 变体Unity 5 AssetBundle 系统的一个关键功能就是引入了 AssetBundle 变体(Variants)。变体的目的是允许应用根据运行环境来调整它们的内容。它可以让不同 AssetBundle 中的不同 UnityEngine.Objects 对象在加载和引用处理的时候表现的像 “同一个” 对象一样。从概念上来讲，它允许两个不同的 UnityEngine.Objects 对象表现为共享了相同的文件 GUID 和 本地 ID，然后通过变体 ID 来断定实际要加载的 UnityEngine.Object 对象。 这个系统有两个主要的用途： 变体简化了平台对应 AssetBundle 的加载。 例子：构建系统可能创建了一个适用于 DirectX11 Windows 独立运行程序 的AssetBundle， 它包含高分辨率纹理和复杂的 Shader，然后另外一个给 Android 平台的低质量的 AssetBundle。在运行期，项目资源加载代码可以根据运行的平台加载对应的 AssetBundle 变体，而不用改变传递给 AssetBundle.Load API 的县官代码。 变体可以让应用在相同平台上为不同的硬件加载不同的内容。 这是支持大范围移动设备的关键。在真实世界中应用 iPhone4 显示 iPhone6 质量的内容会比较吃力 在 Android 上，AssetBundle 变体可以用来处理不同设备间屏幕分辨率和 DPI 碎片化严重的问题 [译注： AssetBunle 变体这功能一般不常用] 4.6.1 AssetBundle 变体限制AssetBunble 变体系统的主要限制是要求变体需要从不同的资源中编译出来。即使只有导入设置的改变也受这个限制影响。如果一个纹理需要打包进变体 A 和变体 B 中，两个变体中这个纹理的唯一差别是导入设置中的压缩算法不同，这种情况下，变体 A 和变体 B 必须要求是完全不同的资产，意味着必须是磁盘上独立分开的文件。这个限制会导致在版本管理中同一个资产可能会有多份拷贝，增加了大项目的管理复杂度。而且如果开发者要更新资源的内容时，所有这些拷贝也要更新。针对这个问题，现在还没有内置的临时解决方案。大部分团队会有他们自己的 AssetBundle 变种方式。通常靠将定义好的后缀加入到编译的 AssetBundle 文件名中，用来区分不同的变体。然后用代码在打包这些 AssetBundle 时修改资源的导入设置。也有些开发会扩展他们定制的系统，让其能修改预设上的组件的参数。 4.7 压缩还是不压缩是否要压缩 AssetBundle 需要仔细的考虑，重点有下面几个方面： 加载时间 是不是这个 AssetBundle 的主要因数？从磁盘或缓存中加载没有压缩的 AssetBundle 会比压缩的 AssetBundle 快很多。但是通常从服务器上下载一个压缩的文件会比一个未压缩的 AssetBundle 快。 编译时间 是不是这个 AssetBundle 的主要因数？LZMA 和 LZ4 在压缩式很慢，并且 Unity 编辑器会序列化 AssetBundle。有很多 AssetBundle 的项目会在压缩上花费很长的时间。 程序大小 是不是主要因数？如果 AssetBundle 是跟程序一起发布，压缩他们会减少包体的大小。另外 AssetBundle 可以在程序安装后下载。 内存使用 是不是主要因数？在 Unity 5.3 之前，所有 Unity 的解压机制都要求解压前将整个 AssetBundle 都加载到内存中。如果内存使用率比较重要，请使用 LZ4 压缩 AssetBundles 或者不压缩 AssetBundle。 下载时间 是不是主要因数？压缩仅在 AssetBundle 比较大或者用户在带宽有限的环境中才需要，比如移动端通过 3G 下载或者在低速连接中。如果只有几十 M 的数据需要传输到 PC 或者在高速连接中，可以把压缩去掉。 4.8 AssetBundle 和 WebGLUnity 强烈推荐开发者在 WebGL 项目上不压缩 AssetBundle。 Unity 5.3 中所有的 AssetBundle 解压和加载在 WebGL 项目中都发生在主线程之上。这是因为 Unity 5.3 的 WebGL 导出选项不支持工作线程。（AssetBundle 的下载通过 Javascript 的 XMLHttpRequest API 代理给了浏览器，不是在主线程中。）这意味着在 WebGL 中加载压缩的 AssetBundle 开销比较昂贵。 知道了这些之后，你能会想到使用解压很高效的 LZ4 压缩来避免 LZMA 压缩格式。如果你需要传输比 LZ4 更小的压缩大小，你可以通过配置 Web 服务器在 Http 协议层中使用 gzip 压缩文件（在 LZ4 压缩之上使用）。]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[转] AssetBundle 基本知识]]></title>
    <url>%2F2019%2F04%2F20%2FUnity%E7%AC%94%E8%AE%B0%2F%E8%BD%AC-AssetBundle-%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[AssetBundle 基本知识。 原文地址：http://blog.shuiguzi.com/2017/01/08/AssetBundle_Fundamentals/ 这是 Unity 5 [资产, 资源和资源管理系列文章] 的第四篇。 这篇将会探讨 AssetBundle，并介绍构建 AssetBundle 的基本系统和与它交互的核心 API。这篇文章也会特别地介绍 AssetBundle 和 AssetBundle 内的资产与对象的加载和卸载。 更多关于 AssetBundle 的使用模式和最佳实践，请看本系列文章中的下一篇。 概况AssetBundle 系统提供了一种可以把一个或者多个文件存储到一个能被 Unity 识别的存档的方法。这个系统的目的是提供一个可以和 Unity 的序列化系统兼容的数据推送方法。AssetBundle 是 Unity 用来在应用安装后推送或者更新非代码内容的主力工具。开发者能够用它来减少资产的体积，缩短运行时内存压力，以及在不同的用户终端有选择的加载内容。 理解 AssetBundle 的工作原理是开发一个成功的移动设备项目必不可少的。 什么是 AssetBundle一个 AssetBundle 有两部分组成：一个 Header 和一个数据段。 Header 是 Unity 构建 AssetBundle 时创建的。它包含了一些 AssetBundle 的信息，比如 AssetBundle 的识别符，AssetBundle 是否压缩和一个清单。 清单是一个由对象名称当做关键词的查找表格。每个条目都提供了用来标识对应对象在 AssetBundle 数据段中位置的字节索引。在大部分平台上，这个操作表是通过 C++ STL 中的 std:multimap 来实现的。虽然这个算法在不同的平台上有实现有差异，但是大部分都是平衡搜索树的变种。比如 Windows 和 OSX 衍生的平台（包括 iOS）使用的是红黑树。随着 AssetBundles 内资产数量的增长，构建清单的时间将大于会线性的增长。 AssetBundle 数据段包含了 AssetBundle 中资产序列化后的源数据。如果数据被压缩，则 LZMA 算法已被应用于串行化字节的集合序列 - 也就是说，所有资产被串行化，然后完整的字节阵列被压缩。 在 Unity 5.3 之前，对象不能被单独的压缩到 AssetBundle 内。所以在 5.3 之前的版本的 Unity 如果想从一个压缩过之后的 AssetBundle 内读取一个或者多个对象，Unity 必须解压整个 AssetBundle。平常，Unity 会缓存解压后的 AssetBundle 来提高之后有加载请求时性能。 Unity 5.3 加入了一个 LZ4 压缩选项。选择了 LZ4 压缩后，AssetBundle 内对象会被单独压缩，这样 Unity 就可以把压缩后的 AssetBundle 存储到硬盘上, 并且解压单个对象而不需要解压整个 AssetBundle。 AssetBundle ManagerUnity 开发并维护了一个 AssetBundle Manager 的参考实现，并把放到了 Bitbucket 网站上。这个 Manager 用到了这篇文章中的很多概念和 API 的细节，并且为任何一个必须集成 AssetBundle 作为它的资产管理流程的项目提供给了一个好的起点。 这个 Manager 值得注意的功能是引入了 “模拟模式”。当这个模式开起的时候，这个模式会透明地把对 AssetBundle 内资产的请求重定向到对 Project Assets 文件夹下中的原资产。这可以让开发者开发过程中不需要重新打包 AssetBundle。 AssetBundle Manager 是开源项目，可以在 这里 找到。 加载 AssetBundle在 Unity 5 中，AssetBundle 可以被 4 中不同 API 加载。这 4 个的行为基于下面两个条件： AssetBundle 是否开启 LZMA 或者 LZ4 压缩 加载 AssetBundle 的平台 这 4 个 API 分别是： AssetBundle.LoadFromMemoryAsync AssetBundle.LoadFromFile WWW.LoadFromCacheOrDownload UnityWebRequest 的 DownloadHandlerAssetBundle (在大于 5.3 的 Unity 中) AssetBundle.LoadFromMemoryAsyncUnity 不推荐使用这个 API。 Unity 5.3.3 更新： 这个 API 在 5.3.3 被重命名，在之前的版本中叫 AssetBundle.CreateFromMemory, 但是功能并没有改变。 AssetBundle.LoadFromMemoryAsync 从托管代码字节数组（C# 中的 Btye[]）中加载 AssetBundle。它总是会从本地内存中开辟一段连续内存，然后从托管代码的字节数组中拷贝源数据到这段新分配的内存中。如果 AssetBundle 是 LZMA 压缩格式的，拷贝过程中 AssetBundle 会被解压。而 LZ4 压缩格式的 AssetBundle 会原原本本的拷贝过去。 这个 API 消耗内存的峰值最少是 AssetBundle 大小的两倍：一个是 API 创建的本地内存，一个是传递给 API 的托管代码数组。 利用这个 API 加载资产之后，这个加载资产将会在内存中出现 3 份拷贝：一个是托管代码字节数组，一个是 AssetBundle 的本地内存，第三个是在 GPU 或者系统内存中的资产本身。 AssetBundle.LoadFromFileUnity 5.3 更新： 这个 API 在 Unity 5.3.3 被重命名。在之前的版本中叫做 AssetBundle.CreateFromFile。它的功能并没有改变。 AssetBundle.LoadFromFile 能从本地存储中（如硬盘和 SDK 卡）高效的加载未压缩的 AssetBundle。如果 AssetBundle 未压缩或者使用 LZ4 压缩，这个 API 有如下表现。 移动设备： API 只会加载 AssetBundle 的 Header, 其他的数据保留在磁盘中。当调用加载的方法（也就是 AssetBundle.Load）或者他们的实例 Id 被间接引用时对象会被按需加载。在这种情况下没有额外的内存开销。 Unity 编辑器： 这个 API 会讲整个 AssetBundle 加载进内存，而不像从磁盘上读取所有字节，使用 AssetBundle.LoadFromMemoryAsync。如果在 Unity Editor 中监视内存，当 AssetBundle 加载时，监视器上内存会出现一个尖峰。这些尖峰并不影响设备上性能，而且在做调整措施之前必须要在设备上重新测试。 注意： 在 Unity 5.3 或者之前的安卓设备上，从 StreamingAssets 目录下加载 AssetBundle 会失败。这是因为 StreamingAssets 下的内容会被打包到一个压缩的 .jar 文件中。更详细的内容，请参照 AssetBundle 使用模式 的 项目部署 小结。这个问题在 Unity 5.4 中已经修复。Unity 5.4 或者以后版本编译的游戏可以使用这个 API 来从 StreamingAssets 里面加载 AssetBundle。 注意： 对 LZMA 压缩的 AssetBundle 调用 AssetBundle.LoadFromFile 会永远不成功。 WWW.LoadFromCacheOrDownloadWWW.LoadFromCacheOrDownload 对于从远端服务器和本地存储中加载对象很有用。可以使用 file:// 链接地址从本地加载文件。如果 AssetBundle 已经在 Unity 的缓存中存在，则它会表现的跟 AssetBundle.LoadFromFile 一样。 如果 AssetBundle 没有被缓存，WWW.LoadFromCacheOrDownload 会从 AssetBundle 的源地址读取它。如果 AssetBundle 是压缩格式，它会使用一个 worker 线程来解压 AssetBundle 并且写入到缓存当中。如果不是压缩格式，worker 线程会直接将它写入缓存中。 一旦 AssetBundle 被缓存了，WWW.LoadFromCacheOrDownload 会从缓存中加载 Header 信息和未压缩的 AssetBundle。之后这个 API 表现就跟 AssetBundle.LoadFromFile 一样了。 注意： 当数据被解压并写到缓存的同时，WWW 对象会在本地内存中保留一份 AssetBundle 字节的完整拷贝。这个 AssetBundle 的额外的拷贝是用来支持 WWW.bytes 属性的。 由于 WWW 对象会缓存 AssetBundle 的数据，这里推荐开发者使用 WWW.LoadFromCacheOrDownload 来确保 AssetBundle 保持最小（最多几 M 大小。也推荐开发在内存有限平台上，如移动设备，确保他们的代码在运行时只下载一个 AssetBundle 来避免内存尖峰现象。关于 AssetBundle 的大小，请参照 AssetBundle 使用模式 章节中的 资产分配策略 小结。 注意： 每调用一次这个 API 都会产生出一个新的 worker 线程。要当心多次调用这个 API 的时候多产生多个线程。如果有 5 到 10 个 AssetBundle 需要下载，建议代码只让少数几个 AssetBundle 同时下载。 AssetBundleDownloadHandler在 Unity 5.3 的移动平台上，Unity 引入了 UnityWebRequest API，它比 Unity 的 WWW API 更灵活。UnityWebRequest 可以让开发者指定 Unity 怎么样处理数据和排除不需要的内存开销。使用 UnityWebRequest 去下载一个 AssetBundle 的最简单的方式就是调用 UnityWebRequest.GetAssetBundle API。 这篇文章中，我们感兴趣的类是 DownloadHandlerAssetBundle。使用时，这里的行为跟 WWW.LoadFromCacheOrDownload 类似。它使用 worker 线程去下载数据到固定大小 Buffer 中，然后把 Buffer 中的数据写到临时存储或者 AssetBundle 缓存中，存储在哪这依赖于 Doanload Hanlder 怎么设置。LZMA 格式压缩的 AssetBudnle 会在下载和缓存过程中被解压。 为了不增加托管堆大小，所有的操作都是发生在 Native code 中。这个 Download Handler 也没有下载数据的的本地拷贝，进一步的减少了下载 AssetBundle 过程中的内存开支。 当下载完成之后，Doanload Handler 的 assetBundle 属性提供给了对下载的 AssetBundle 的访问，就像对下载后的 AssetBundle 执行了 AssetBundle.LoadFromFile 一样。 UnityWebRequeset 也支持像 WWW.LoadFromCacheOrDownload 一样缓存机制。如果给 UnityWebRequest 对象提供给了缓存信息，并且请求的 AssetBundle 已经在 Unity 的缓存中，AssetBundle 会马上有效并这个 API 会像 AssetBundle.LoadFromFile 一样操作它。 注意： Unity AssetBundle 缓存在 WWW.LoadFromCacheOrDownload 和 UnityWebReuqest 见是共享的，任何下载过的 AssetBundle 都对这两个 API 管用。 注意: 不像 WWW, UnityWebRequest 系统拥有一个内部的 worker 线程池，和内部的人物系统去确保开发者不会开始多个线程去同步下载。当前这个池的大小是不可控制的。 推荐一般的，应该尽可能的使用 AssetBundle.LoadFromFile。这个 API 在速度，磁盘使用率和运行期内存方面都最高效。 对于需要下载 AssetBundle 或者给 AssetBundle 打补丁的项目，强烈推荐在 Unity 5.3 或更新版本中使用 UnityWebRequest ，在 Unity 5.2 或者更老版本中使用 WWW.LoadFromCacheOrDownload。就像在下一章的 部署 小结中提到，可以在项目安装器将 AssetBundle 缓存先准备好。 当使用 WWW.LoadFromCacheOrDownload 时，强烈推荐确保 AssetBundle 保持在项目最大内存使用的 2-3%，为了避免内存尖峰引起的程序终止。对于大多数项目，AssetBundle 最好不要大于 5M 的文件大小，并且不大于 2 个 AssetBundle 同时下载。 当使用 WWW.LoadFromCacheOrDownload 或者 UnityWebRequest 是，确保下载的代码在加载完 AssetBundle 后正确的调用 Dispose。C# 的 using 是确保 WWW 或者 UnityWebRequest 被安全 Dispose 的最方便的做法。 对于一个有持续交互的工程师团队和有唯一缓存和下载需求的项目，自定义的下载器是有必要的。写一个自定义的下载器不是一个非凡的任务，而这个这个下载器不需要要和 AssetBundle.LoadFromFile 兼容。更多详情，查看下章节中的 部署 小结。 在 AssetBundle 中加载资产可以使用 3 种不同 AssetBundle 的 API 来从 AssetBundle 中加载 UnityEngine.Objects：LoadAsset，LoadAllAssets 和 LoadAssetWithSubAssets。这些 API 都有带有 -Async 后缀的异步方法：LoadAssetAsync，LoadAllAssetsAsync 和 LoadAssetWithSubAssetsAsync。 同步类型的 API 总是比异步 API 快，至少在一帧中是这样。在 Unity 5.1 及其更老版本中尤其是这样。在 Unity 5.2 之前，所有的异步在每帧中最多加载一个对象，这就意味着 LoadAllAssetsAsync 和 LoadAssetWithSubAssetAsync 会明显比其同步的 API 慢。这个行为在 Unity 5.2 之后被纠正 了。现在异步 API 可以在每帧中加载多个对象，这依赖于时间片的限制。关于这种行为的底层技术原因和时间片的详细描述，请参照 Low-level loading details。 当加载多个独立的 UnityEngine.Objects 时，应该要使用 LoadAllAssets。它应该用在需要加载的主要对象（或者多个对象）是在同一个 AssetBundle 时。相比其他两个 API, LoadAllAssets 比多次调用 LoadAssets 更快一些。如果需要再加的对象数目比较多，并且在同一时间需要加载的数量小于 AssetBundle 内数量的 2/3，可以考虑将这个 AssetBundle 切分为跟小的 AssetBundle, 然后使用 LoadAllAssets。 LoadAssetWithSubAssets 应该用于需要加载一个包含多个嵌入对象资产，比如包含动画的 FBX 模型或者包含多个精灵的精灵图集。如果需要再加的对象都来自同一个资产，但是他们存储在一个拥有很多其他不相关的对象的 AssetBundle 中，可以使用这个 API。 其他情况，请使用 LoadAsset 或者 LoadAsstsAsync。 底层加载细节UnityEngine.Object 的加载不是在主线程中执行：一个对象的数据是 worker 从存储中读取的。其他一切 Unity 系统中不涉及线程的部分（脚本，图形）将会在 worker 线程中被转换。比如，从网格中创建 VBO（Vertex Buffer Object），解压纹理等。 在 Unity 5.3 之前的版本中，对象加载是串行的，并且对象的加载过程的某些部分只能在主线程中执行。这个部分这叫做 “integration”。当 workter 线程完成对象数据的加载，这部分就会暂停，并把新加载的对象集成进主线程，并且保持（而不是加载下一个对象）到主线程集成完成。 从 Unity 5.3 开始，对象加载可以是并行的。worker 线程中可以反序列化，处理和集成多个对象。当一个对象的加载完成后，它的 Awake 回调函数会被调用，并且从下帧开始，这个对象会在 Unity 引擎中变成可用。 同步类型的方法 AssetBundle.Load 方法会暂停主线程，直到对象加载结束为止。在 Unity 5.3 之前，异步方法 AssetBundle.LoadAsync 在它需要将对象集成到主线程之前，它不会暂停主线程。它们会将对象加载按时间分片，使对象集成不会超过一定毫秒数量的帧时间。这个毫秒的数量是靠下面这个属性来设置的。 Application.backgroundLoadingPriority ThreadPriority.High： 每帧最多 50 毫秒 ThreadPriority.Normal： 每帧最多 10 毫秒 ThreadPriority.BelowNormal： 每帧最多 4 毫秒 ThreadPriority.Low： 每帧组多 2 毫秒 在 Unity 5.1 之前，异步 API 在每一帧中只集成一个对象。这个可以说是个 Bug, 其已经在 Unity 5.2 中被修复了。从 Unity 5.2 开始，可以加载多个对象直到超过了帧中加载时间的最大上限。假设其他条件都一样的情况下，AssetBundle.LoadAsync 总是比比的同步 API 需要更多的时间，因为从调用 LoadAsync 到对象在引擎中可用期间有最小帧延迟。 可以现实中对资产和对象的测试来演示他们的不同。Unity 5.2 之前，在一个低端设备上加载一个大纹理，同步方式会消耗 7ms, 异步会消耗 70ms. 在 Unity 5.2 之后，两种方式之间差别几乎为零。 AssetBundle 依赖Unity 5 的 AssetBundle 系统中，AssetBunle 间的依赖是靠两种不同的 API 来自动跟踪的，这依赖于运行时环境。在 Unity 编辑器中，AssetBundle 依赖是通过 AssetDatabase API 查询的。AssetBundle 的分配和依赖可以通过 AssetImporter 访问和改变。在运行时，Unity 提供了可以选择的 API 去 加载基于 ScriptableObject 的 AssetBundleManifest API 构建 AssetBundle 过程中生成的 AssetBundle 依赖信息。 一个 AssetBundle 是否是依赖的取决于另外一个 AssetBundle，当父 AssetBundle 的一个或者多个 UnityEngine.Objects 引用其他 AssetBundle 中的一个或者多个 UnityEngine.Objects。更多关于信息可以参考 资产，对象和序列化 文章中的 内部引用 小结。 就像在那片文章中的 序列化和实例 小结中提到，AssetBundle 提供 AssetBundle 内每个靠文件 GUID 和 本地 ID 来鉴别的对象的源数据。 因为当对象的实例 ID 第一次被间接引用时加载，并且对象在 AssetBundle 加载后被分配了一个有效的实例 ID，所以对象在 AssetBundle 中的顺序并不是很重要。反而重要的是加载对象之前，加载这个对象所有依赖的 AssetBundle。Unity 不会在加载完父 AssetBundle 只有去自动加载子 AssetBundle。 例子：假设材质 A 引用了纹理 B。材质 A 被打包进 AssetBundle 1, 而纹理 B 被打包进 AssetBundle 2 在这种情况下，AssetBundle 2 必须在加载来自 AssetBundle 1 的材质 A 之前加载。 这不是在暗示 AssetBundle 2 必须要在 AssetBundle 1 之前加载，或者或者纹理 B 必须在 AssetBundle 2 中显式的加载。在加载来自 AssetBundle 1 中的材质 A 之前加载 AssetBundle 2 就够了。 Unity 不会在加载完 AssetBundle 1 之后自动的加载 AssetBundle 2。它必须手动的通过脚本加载。加载 AssetBundle 1 和 AssetBundle 2 时使用的 API并不重要。 使用 WWW.LoadFromCacheOrDownload 加载的 AssetBundle 可以和被 AssetBundle.LoadFromFile 或者 AssetBundle.LoadFromMemoryAsync 加载的 AssetBundle 混合使用。 AssetBundle 清单当通过 BuildPipeline.BuildAssetBundles API 来构建 AssetBundle 时，Unity 会序列化一个包含 AssetBundle 依赖信息的对象。这个对象的数据被存储在一个单独的，包含一个 AssetBundleManifest 类型的对象的 AssetBundle 中。 这个资产会存储在一个 AssetBundle 中，这个 AssetBundle 的名字跟 AssetBundle 所在的目录的名字一样。如果一个项目编译它的 AssetBundle 到 (Projectroot)/build/Client/ 中，这个 AssetBundle 的清单文件会被保存为 (projectroot)/build/Client/Client.mainifest。 AssetBundle 包含的清单可以被加载，缓存和卸载，就像其他的 AssetBundle 一样。 AssetBundleManifest 对象提供了 GetAllAssetBundles API 来列出所有跟清单一起编译出来的 AssetBundle 和两个查询 AssetBundle 依赖的方法。 AssetBundleManifest.GetAllDependencies 返回一个 AssetBundle 的所有依赖，包括 AssetBundle 所有依赖以及依赖的依赖等等。 AssetBundleManifest.GetDirectDependencies 只返回一个 AssetBundle 的直接依赖。 需要注意的一点，这两个 API 都会产生字符串数组。要尽量少使用它们，不要用在应用运行期中对性能敏感的部分。 推荐在用户进入应用的性能要求高的部分前尽可能多的加载所需的对象被认为是一个好的方案，比如用户进入主要的游戏关卡或者场景。这对移动平台特别关键，移动平台对存储的访问慢并且在运行时加载和卸载对象对内存的消耗会触发垃圾回收器。 对于在应用程序交互时必须加载和卸载对象的项目，请参照 AssetBundle usage patterns 章节的 Managing loaded assets 小结关于卸载对象和 AssetBundle 的信息。 英文原文地址：https://unity3d.com/learn/tutorials/topics/best-practices/asset-bundle-fundamentals]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[转] Resources 文件夹]]></title>
    <url>%2F2019%2F04%2F20%2FUnity%E7%AC%94%E8%AE%B0%2F%E8%BD%AC-Resources-%E6%96%87%E4%BB%B6%E5%A4%B9%2F</url>
    <content type="text"><![CDATA[Resources 文件夹 原文地址：http://blog.shuiguzi.com/2016/12/28/resources_folder/ 这是 Unity 5 [资产, 资源和资源管理系列文章]的第三篇。 这个章节将讨论 Resources 系统。这个系统可以让开发者通过 Resources API 加载或卸载存储在在一个或多个以 Resources 命名的文件夹中的资产。 Resources 系统的最佳实践下面情况不要使用它 这个强烈建议有下面几点原因： 使用 Resources 文件夹会让内存颗粒度管理变得更困难 不正确的使用 Resources 文件夹会增加应用启动时间和包的大小 随着在 Resources 文件中的文件增加，管理这些文件会变得很困难 Resources 系统自定义的平台特殊文件推送变得恶化并且不能增量更新 AssetBundle 变体是 Unity 用来不同平台内容调整的主要工具 Resources 系统正确使用：下面两种情况 Resources 系统很有用处： 因为 Resources 系统很容易使用，它很适合是在快速原型制作和试验。但是当项目要转成产品时，强烈建议不要使用 Resources 文件夹 Resources 文件夹对一些满足如下条件的案例很有用： 存储在 Resources 文件夹下的内容不要很大的内存 存储在 Resources 文件夹下的内容在整个项目周期都有用 内容基本不用升级 内容在各平台都一样的 上面第二种情况（存储在 Resources 文件夹下的内容在整个项目周期都有用）例子包括在全局使用的 MonoBehaviour 单例的预设或者第三方配置数据中的资产，比如 Facebook 应用的 ID。 当项目构建完成之后，所有名为 Resources 的文件夹内的资产和对象都会被合并到然后序列化到同一个文件中。这个文件跟 AssetBundle 类似，包括包含了源数据和索引信息。就像在 AssetBundle 基本原理章节中的 什么是 AssetBundle 小节中提到的，索引信息里面包括了处理对象名字到对应的文件 GUID 和本地ID 的查找树。它也用来定位对象在序列化文件中的偏移位置。 用于查找的数据结构是平衡搜索树[1]（在大多数平台上），它的构建时间增长到了 O(nLog(N)), 其中 N 是在查找树内的对象的个数。这个增长也使 Resources 文件夹内的对象增加时，索引的加载时间会比线性增长时间长。 这个操作是在程序启动，不可交互的闪屏页显示时发生，是不能去除的。一个包含 10000 个资产的 Resouces 系统，即使其中大部分资产都不需要在第一个场景中加载，在低端移动设备上初始化也需要好几秒的时间。 脚注[1] 在大部分平台上是 C++ STL（Standard Template Library）中的 std:multimap 英文原文链接: https://unity3d.com/learn/tutorials/topics/best-practices/asset-bundle-fundamentals]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[转] 资产, 对象和序列化]]></title>
    <url>%2F2019%2F04%2F20%2FUnity%E7%AC%94%E8%AE%B0%2F%E8%BD%AC-%E8%B5%84%E4%BA%A7-%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[资产, 对象和序列化。 原文地址：http://blog.shuiguzi.com/2016/12/15/Assets_Objects_serialization/ 这是 Unity 5 [资产, 资源和资源管理系列文章]的第二篇。 这篇文章涵盖了 Unity 序列化系统的底层知识和 Unity 怎么在它的编辑器及运行时维持不同对象的稳定的引用，理解怎么样在 Unity 中高效的加载和卸载资产。正确的资产管理是保持低内存和快速加载的关键。 资产和对象的内部要理解怎么样正确的管理数据，Unity 怎么鉴别和序列化数据很重要。其中首先的关键点是理解 资产 和 对象（UnityEngine.Objects） 的区别。 一个资产是存储在 Unity Project 中资产文件夹下的文件。比如纹理文件，材质文件和 FBX 文件都是资产。有些资产包含 Unity 原生数据格式，比如材质。而有些资产需要转换成 Unity 原生数据格式，比如 FBX 文件。 一个 UnityEngine.Object 或者大写字母 O 的 Object，是个序列化数据集合，用来表述某个资源的具体实例。它可以是任何 Unity 引擎使用的资源，比如一个网格，一个精灵，一个音频剪辑和一个动画片段。所有的对象都是 UnityEngine.Object 的子类。 在 Unity 中基本所有的对象类型都是内置的，除了两种特殊的类型。 ScriptableObject 给开发者提供了一个便捷的，可以定义自己数据类型的系统。这些类型能被 Unity 序列化和反序列化和在 Unity 编辑器的 Inspector Window 中使用。 A MonoBehaviour 提供了一个链接到 MonoScript 的封装。MonoScript 是一个内置的数据类型，在 Unity 中用来保持程序集或者命名空间中一个脚本的引用。MonoSript 不包含任何可以执行的代码。 内置对象的引用所有的 UnityEngine.Objects 都能拥有其他 UnityEngine.Objects 的引用。而这些其他的 UnityEngine.Objects 可能同一个资产文件，或者从其他资产文件中导入。比如，一个材质对象通常拥有一个或者多个纹理对象的引用。这些纹理对象一般都是从一个或者多个纹理资产文件中导入的（比如 PNG 和 JPG 文件）。 当被序列化之后，由两部分数据组成了这些引用：一个是 文件 GUID 另外一个是 本地 ID。文件 GUID 用来 标识目标资源存储位置下的资产文件。本地ID（唯一的 [1]）用来标识一个资产文件中的每个对象，因为一个资产文件可能包含多个对象。 文件 GUID 存储在 .meta 文件中。这些 .meata 文件在 Unity 导入资产的时候创建，存储在和资产文件同一个目录中。 上面提到的鉴别和引用系统可以在文本编辑器中看到：创建一个新 Unity 项目，然后将 编辑器 设置为 Visible Meta Files 和 序列化为文本。然后创建一个材质和导入一个纹理到项目中。将新创建的材质指定到场景中的一个立方体上面，然后保存场景。 我们用文本编辑器打开和材质关联的 .meta 文件。在文件头部会有标识了 “guid” 的行。这行定义了材质的文件 GUID。查找本地 ID, 我们可以在文本编辑器中打开材质文件。我们会看到类似于如下所示的材质对象的定义： — !u!21 &amp;2100000Material:serializedVersion: 3… more data … 在上面的例子中，前面带 &amp; 符号的数字就是材质的本地 ID。如果一个材质对象在一个文件 GUID 为 abcdefg 的资产里面，这个材质对象就可以用文件 GUID abcdefg 和本地 ID 2100000 组合唯一地标识。 为什么要文件 GUID 和本地 ID为什么需要 Unity 的文件 GUID 和本地 ID 系统？答案是为了健壮性和提供一个灵活和平台独立的工作流。 文件 GUID 提供了文件位置的抽象。只要文件 GUID 和一个文件关联上，那文件在磁盘上的位置就变得无关紧要了。这个文件可以随意移动，而不必更新所有引用了该文件的对象。 一个资产文件可能包含多个 UnityEngine.Object，为了清楚的区分它们，需要本地 ID。 如果和资产文件相关的文件 GUID 丢失了，所有对象对这个文件的引用就会丢失。这就是为什么 .meta 文件必须和它们相关联的资产文件存储在同一个位置，并且拥有相同的文件名很重要。注意 Unity 会重新生成被删除的或者被乱放的 .meta 文件。 Unity 编辑器拥有已知文件 GUID 到文件路径的映射。这个映射实体会把资产的文件路径和文件 GUID 关联起来。如果 Unity 编辑器打开时，一个 .meta 文件丢失而资产的路径并没有改变的资产，编辑器会确保这个资产得到相同的文件 GUID。 如果 .meta 文件在 Unity Editor 关闭时丢失，或者资产的路径变化时没有把 .meta 文件一起跟资产文件移动，所有对资产内对象的引用都会丢失。 组合资产和 Importers在 资产和对象的内部 章节中提到，非原生的资产类型需要导入到 Unity 中。这是靠 Assets Importer 完成的。这些 Importers 都是自动调用的，他们靠 AssetImporter API 和它的子类来暴露给脚本。比如，TextureImporter API 提供了导入 PNG 和 JPG 等纹理资产时的设置访问。 导入过程的结果是一个或者多个 UnityEngine.Objects。这些对象在 Unity 编辑器中显示为一个资产的子资产。比如设置成精灵图集方式导入纹理资产，会有多个精灵嵌套在这个资产下。这些精灵对象会共享一个文件 UIID 作为他们的源资产文件。而在导入的纹理资产中靠本地 ID 来区分他们。 导入过程会将源资产文件转换成在 Unity 编辑器中选中的目标平台合适的格式。导入过程也可能会带有比较重的操作，比如纹理压缩。如果每次 Unity 编辑器打开的时候都要执行导入过程的话会是 Unity 编辑器变得特别没有效率。 作为解决方案，Unity 会讲资产导入后的结果缓存到 Libraray 文件夹。导入后的结果会缓存到以资产的文件 GUID 前两个字母命名的文件夹中。这个文件夹在 Library/metadat/ 文件夹内。每个独立的对象都会被序列化为单独的以它们资产文件 GUID 命名的二进制文件。 这对所有的资产都适用，而不仅仅是非原生的资产。但是原生的资产不需要做长时间的转换或者重新序列化。 序列化和实例文件 GUID 和本地 ID 系统健壮的同时，GUID 的比较是比较慢的，这就需要一个在运行期时更高效的系统。Unity 内部维持了一个能把文件 GUID 和本地 ID 换成在独立会话内唯一的，简单的数字的缓存[2]。这个数字叫做实例 ID。当新的对象注册到缓存时，会给它分配一个严格递增的值。 这个缓存维护了给定的实例 ID、对象源文件中定义的文件 GUID 和本地 ID 和内存中对象（如果有的话）的映射关系。它让 UnityEngine.Objects 稳定的维护各个对象间的引用成为可能。通过一个实例 ID 的引用可以快速的返回这个 ID 对应的对象。如果这个对象没有加载，Unity 就可以根据 FileID 和本地 ID 来实时的加载对象。 在启动的时候，实例 ID 缓存会初始化所有被场景引用的的对象和 Resources 文件夹下的所有对象数据。运行时导入的新资产[3]和从 AssetBundles 里面加载的对象会被额外的添加到缓存中。当实例 ID 不在有用的时候他们会从缓存中移除。当一个 AssetBunld 访问未加载的文件 GUID 和本地 ID 时会生这种情况。 卸载 AssetBundle 时引起实例 ID 无效时，为了节省内存，实例 ID 和文件 GUID 及 本地 ID 间的映射将会被移除。当 AssetBundle 重新被加载时，将会给从 AssetBundle 中重新加载的对象分配一个新的实例 ID。 更深入的探讨卸载 AssetBundles 带来的问题，可以参照 AssetBundle 使用模式 中的 管理加载的资产 这一节。 注意，在某些平台上的特定的事件会强制从内存中删除对象。比如，在 iOS平台，当程序挂起的时候，可以从图形内存里面卸载图形资产。如果这些对象是从已卸载的 AssetBundle 里加载的，Unity 将会无法从对象的源数据重新加载对象了。所有对这些对象的引用也会变成无效。在这个例子中可能会出现看不见的网格或者模型带有洋红色的纹理和材质的现象。 提示： 在运行时，上述控制流程不是特别精确。对于重度加载操作，比较文件 GUID 和本地 ID 是非常不高效的。当构建一个 Unity 项目时，文件 GUID 和本地 ID 都被映射到了一个简单的格式上。但是概念依然一样，运行时考虑使用文件 GUID 和本地 ID 来做对比依然很有用。 这也是为什么资产的文件 GUID 不能再运行时查询的一个原因。（因为被转换成了其他简单格式。） MonoScripts理解 MonoBehaviour 拥有一个 MonoScript 的引用和 MonoScript 仅包含简单的用来定位特定脚本的信息是比较重要的。MonoScript 并不包括脚本的执行代码。 MonoScript 包含 3 个字符串：程序集的名字， 一个类名和一个命名空间。 当构建项目的时候，Unity 收集所有 Assets 文件下零散放置的脚本，然后将他们编译成 Mono 程序集。Unity 会为 Assets 文件夹下的不同语言和 Assets/Plugins 文件夹下的脚本构建单独的程序集。在 Plugins 子文件夹外的 C# 脚本会编译到 Assembly-CSharp.dll 中，而 Plugins 子文件夹内的脚本会编译到 Assembly-CSharp-firstpass.dll 中。 这些程序集（包括预先编译好的程序集的 DLL）会被包含到 Unity 应用的最终构建里面。他么也是 MonoScript 引用的程序集。与其他资源不同，所有 Unity 程序内的程序集会在程序第一次启动时加载。 因为有 MonoScript 对象，AssetBundle（或者是场景文件，或者是预设）中 MonoBehaviour 组件可以不包含实际运行代码。这使得不同的 MonoBehaviour 可以指向特定的共享的类，即使这些不同的 MonoBehaviour 在不同的 AssetBundle 中。 Resouce 的生命周期UnityEingine.Objects 会在具体或者特定的时间从内存中加载/卸载。为了减少加载时间和管理应用的内存，理解 UnityEngine.Objects 的生命周期是比较重要的。 有两种方式可以加载 UnityEngine.Objects: 自动的和显式的。当一个实例 ID 映射到一个源数据存在，但是没有加载进内存并被间接引用的对象时，对象会被自动创建。对象可以在脚本中显式的加载。显式加载方式要可以是直接创建他们，也可以是通过资源加载的 API, 例如 AssetBundle.LoadAsset。 当一个对象被加载，Unity 会尝试将所有引用从文件 GUID 和本地 ID 转换成实例 ID。 当满足下面两个条件时，一个对象在它的实例 ID 被第一次引用时按需加载： 实例 ID 引用了没有加载的对象 实例 ID 在缓存中有有效的、对应文件 GUID 和本地 ID 这通常发生在引用被加载和处理后的非常短的时间里。 如果一个文件 GUID 和本地 ID 不包含实例 ID, 或者一个实例 ID 关联一个引用无效的文件 GUID 和本地 ID 的未加载的对象，实例 ID 引用将会保留但是实际对象缺不能加载。这个在 Unity 编辑器里面显示为 (Missing)。在程序运行时或者场景视图里， 基于 (Missing) 对象的类型，会有下面几种显示：比如网格不可见，纹理显示成洋红色。 对象会在下面 3 种情况下被卸载： 对象会在未使用的资产被清理时卸载。这个过程当场景破坏性的改变时（例如使用非增量的 Application.LoadLevel API）或者在代码里面调用 Resources.UnloadUnusedAssets API 时自动发生。这个过程只能卸载未被引用的对象：一个对象仅当没有 Mono 变量引用它，和没有其他对象保持其引用时才会卸载。 从 Resources 文件夹内加载的对象可以用 Resources.UnloadAsset API 来卸载。它们的实例 ID 会保持有效，依然对应着有效的文件 GUID 和本地 ID。如果任何 Mono 变量或者对象保留着被 Resources.UnloadAsset 卸载的对象的引用，这些对象则会被重新加载。 当我们调用 AssetBundle.Unload(true) API 时，从 AssetBundle 加载的对象会被立即自动的卸载。这会使对象的实例 ID 的文件 GUID 和本地 ID 引用无效，并且任何引用的已卸载的对象的引用将会变成 (Missing)。从 C# 脚本中尝试访问已卸载的对象的方法和属性会抛出 NullReferenceException 异常。 如果调用 AssetBundle.Unload(false)，从已卸载的 AssetBundle 中得到的活动的对象将不会被销毁，但是 Unity 会使这些对象的实例 ID 对其文件 GUID 和本地 ID 引用无效。如果这些对象从内存中卸载并且对这些已卸载的对象的引用依然保持着，Unity 将无法重新加载对象。 加载大层次结构当序列化有大层次结构的 Unity 游戏对象（比如序列化预设）时，重要的是要记住整个层次结构都会被序列化。也就是说层次结构中的每个游戏对象和组件都会被单独的序列化到序列化后的数据里面。这对加载和实例化对象层次需索的时间有影响。 当创建游戏对象层次结构时，CPU 时间会花费在下面几种方面上 从存储，别的游戏对象等读取源数据的时间 构建新 Transform 间父-子关系的时间 实例化新游戏对象和组件的时间 激活新游戏对象和组件的时间 后面三种时间花费一般是不变的，无论是从现成的层次结构中拷贝或者从存储中加载（比如 AssetBundle)。但是读取源数据的时间与层次结构中的组件和游戏对象成线性增加的关系，当然还要乘以读取源数据的速度。 在当前支持的所有平台中，从内存中读取数据会比从设备存储中读取明显快不少。而且不同平台上的存储媒介在性能上有很大差别–比如从 PC 上加载数据的数据会比移动设备快很多。 所以在低速存储设备的平台上加载预设，读取从存储上读取预设的实际会快速的超过实例化预设所花费的实际。也就是说，设备 I/O 的时间主导了加载操作所消耗的时间。 前面提到过，序列化大预设的时候，每个游戏对象和组件的数据都会单独的被序列化，即使这些数据是重复的。一个拥有 30 个一样的元素的 UI，这 30 一样的元素都会被序列化。这将会产生大量的数据。当在加载时期，这些重复数据元素必须从磁盘中读取，然后传递给新实例化的对象。文件读取时间主导了大预设实例化花费的时间。 直到 Unity 支持可嵌套预设之前，对于加载大层次游戏对象预设的项目，可以通过将冗余的元素拆分出来，然后在运行时加载它们的，而不依赖于 Unity 的序列化和预设系统来加载整个大对象的方式来大幅减少加载时间 一旦预设或者对象已经构建了，从拷贝已存在的对象会比从存储中加载快一个新拷贝快很多。 Unity 5.4: Unity 5.4 修改了内存中 tranform 的呈现方式。每个根 tranform 的所有子物体都存在内存中一段紧凑的，连续的区域中。实例化会重指定父级的新游戏对象时，考虑用 GameObject.Instantiate 的接受父物体为参数的新重载。 使用这个重载可以避免给新物体新分配根 tranform 层次。测试结果中，这个可以提高 5 - 10 % 的实例化时间。 脚记 [1] 本地 ID 在包含它文件中是唯一的。也就是说在同一个资产文件中一个本地 ID 会区别于其他本地 ID。 [2] 在 Unity 内部，这个缓存叫做 PresistenManager。这个转换过程在 Unity 的 C++ Remapper 类中发生。Remapper 类当前不能被任何 C# API 访问。 [3] 一个在运行时创建资产的例子就是在脚本中创建 Texture2D 对象，例如 1var myTexture = new Texture2D(1024, 768); [4] 最常见的是，当 Unity 丢失了对已在运行时从内存中移除的对象的 图形上下文的控制的时候，对象不会被 Unity 卸载。例如，这会发生在一个移动端应用被强制切到后台并挂起的时候，移动端系统通常会将从 GPU 显存中删除所有图形资源。当应用切回到前台，Unity 在恢复渲染当前场景之前， 必须重新上次所有需要的纹理，着色器和网格到 GPU 中。 英文原文地址：https://unity3d.com/learn/tutorials/topics/best-practices/assets-objects-and-serialization]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[转] 资源和 AssetBundle 指导]]></title>
    <url>%2F2019%2F04%2F20%2FUnity%E7%AC%94%E8%AE%B0%2F%E8%BD%AC-%E8%B5%84%E6%BA%90%E5%92%8C-AssetBundle-%E6%8C%87%E5%AF%BC%2F</url>
    <content type="text"><![CDATA[资源和 AssetBundle 指导。 原文地址：http://blog.shuiguzi.com/2016/12/15/GuideToABAndRes/ 这是深度探讨 Unity 引擎中资源（Resource）和资产（Asset） 管理的系列文章。文章试图给高级开发者提供 Unity 资产和序列化系统的底层、代码级的知识，并且审视 Unity 的 AssetBundle 系统技术基础和当前使用它们的最佳实践。 系列文章将会拆分为四个章节： [资产，对象和序列化] 章节探讨 Unity 如何序列化资产和处理它们之间的引用的底层细节。强烈推荐从读者从这章开始阅读，因为它定义了贯穿这系列文章的术语。 [Resources 文件夹] 探讨内置的 Resources API. [AssetBundle 基本知识] 在第一章的基础上描述 AssetBundles 怎么运转和加载 AssetBundles 及从 AssetBundles 加载资产。 AssetBundle 使用模式 是一篇探讨很多 AssetBundle 的实际用途。它包括了给 AssetBundles 添加资产 和管理加载后的资产并描述了开发者使用 AssetBundles 时经常碰到的陷阱。 注意：这系列文章中的对象和资产有别与 Unity API 命名约定中的对象和资产。 本指导中所指的对象是数据，在很多 Unity API 中叫做资产，比如 AssetBundle.LoadAsset and Resources.UnloadUnusedAssets。 本指导中的资产很少在公开的 API 中出现。当他们出现时，一般仅在和构建相关的代码中，比如 AssetDatabase and BuildPipeline。这种情况下，公开的 API 中都叫它们为文件。 英文原文链接: https://unity3d.com/cn/learn/tutorials/topics/best-practices/guide-assetbundles-and-resources]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Unity3D 游戏开发] 第九章-静态对象]]></title>
    <url>%2F2019%2F04%2F18%2FUnity%E7%AC%94%E8%AE%B0%2FUnity3D-%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E9%9D%99%E6%80%81%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[LightMap、遮挡剔除、Batching、寻路网格、反射探头等。 静态对象静态对象是Unity提供的一个属性，它可以附加在游戏对象或者Prefab上。它的原理是限制物体在运行中不能发生位移变化，预先生成一些辅助的数据，从而达成一种用内存换时间的优化方式。静态元素的种类很多，如图所示： Lightmap Static : 用来表示接受烘焙光照计算，可烘焙光照贴图。 Occluder Static : 表示自身可以被遮挡剔除掉。 Batching Static : 表示支持静态合批。 Navigation Static : 表示可烘焙寻路网格。 Occludee Static :表示自身是否可以遮挡其他元素。 Off Mesh Link Generation : 寻路连接不同区域的点，就像角色从山顶跳下来。 Reflection Probe Static : 反射探头，就像玻璃反射一样的镜面效果。 Lightmap：Lightmap技术的原理是将场景中的灯光和物体产生的光照与阴影信息烘焙在一张或者多张Lightmap贴图中，这些物体将不再参与实时光照计算，从而减少了大量的性能开销。它的缺点就是参与烘焙计算的对象在游戏过程中不能发生移动，所以游戏中通常会将物体分为两类，一类是可发生位移变化的，它们使用实时光照计算；另一类是不可发生位移变化的，它们采取预先烘焙Lightmap。 遮挡剔除：Batching（静态合批）：设置静态合批：首先需要在Player Settings页面中勾选Static Batching和Dynamic Batching(表示动态合批)；接着，在游戏场景中选择需要合批的游戏对象，并选中Batching Static标记，然后运行游戏。Mesh Filter会自动生成一个新的Mesh，这样如果有相同的材质、Shader并且参数一致的话，就会合并DrawCall。 脚本静态合批：自动的静态合批用起来很方便，但是也有隐患。加入场景非常庞大，那么合并出来的Mesh会非常大，运行游戏之后，只要其中有一小部分出现在摄像机内，那么整个Mesh都需要参与渲染。另外，静态合批的最大顶点数是65535，如果顶点数超过了它，Unity就会自动合并出多个Mesh。我们可以利用脚本来动态设置需要合批在一起的游戏对象。如果使用脚本合并，游戏对象不需要选中Static标记。 1234567891011using UnityEngine;public class Script_09_05 : MonoBehavior&#123; public GameObject[] datas; void Start() &#123; StaticBatchingUtility.Combine(datas,gameObject); &#125;&#125; 这段代码的含义就是将数组中的游戏对象合并到同一个Root节点下，也就是第二个参数指定的。另外，运行游戏之后，合并过的Mesh对象时不可以发生位移的，但是可以移动它指定的Root节点。 动态合批：动态合批是全自动的，我们不需要做任何事情，但是它有要求： Mesh的顶点数量需要小于300 如果Shader中使用了顶点位置、法线、UV0、UV1和切线，Mesh的顶点数必须小于180 静态合批的隐患：静态合批的原理就是自动生成Mesh，但是不同Mesh保存的信息可能是不同的。例如Mesh中可能会保存color和tangent，但是大部分Mesh都是不需要这个信息的，如果静态合批中有一个Mesh包含了这个信息，那么合并以后整个mesh都会带上它，这样无疑会增加一些额外的开销。 寻路网格：反射探头：]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>Unity3D 游戏开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Unity] 在Unity中纹理图该是什么格式？]]></title>
    <url>%2F2019%2F04%2F17%2FUnity%E7%AC%94%E8%AE%B0%2FUnity-%E5%9C%A8Unity%E4%B8%AD%E7%BA%B9%E7%90%86%E5%9B%BE%E8%AF%A5%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%BC%E5%BC%8F%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[一个在Windows下的png格式图，在Unity中存储为什么格式？ Unity下的资源导入问题：Unity会把我们放进去的外部资源转换成一种Unity内部格式的资源，这个过程就是资源导入。 比如说在Windows下显示为png格式的图片，在Unity内部会根据平台的不同而设置成不同的压缩格式。 可以使用AssetPostProcessor来对导入的资源进行规定化。 AssetPostProcessor是一个编辑器类，用来管理资源导入，当资源导入之前和之后都会发送通知，可以根据不同的资源类型，在导入之前和之后做不同的处理，来修改Unity内部资源格式。 由于这是一个编辑器类，在UnityEditor命名空间下，所以在使用C#脚本时，需要在脚本前加上using UnityEditor引用，且放在工程目录下的Asset/Editor文件夹下。一般我们通过修改这个类中OnPreprocessxxx和OnPostprocessxxx函数来修改资源数据和设置。这两者的区别可以简单理解为：前者用来Inspector视图可见的选项，后者为不可见的。 下面的脚本可以自动设置不同文件夹下贴图的压缩格式以及大小： 1234567891011121314151617181920212223242526272829303132using UnityEditor;using UnityEngine;public class Script_12_02 : AssetPostprocessor&#123; void OnPreprocessTexture() &#123; TextureImporter textureImporter = (TextureImporter)assetImporter; if(textureImporter.assetPath.Contains("UI")) &#123; textureImporter.textureType = TextureImporterType.Sprite; textureImporter.mipmapEnabled = false; // 设置UI贴图在三个平台下的压缩格式以及大小 textureImporter.SetPlatformTextureSettings("Standalone",2048,TextureImporterFormat.RGBA32); textureImporter.SetPlatformTextureSettings("iPhone",2048,TextureImporterFormat.RGBA32,100,true); textureImporter.SetPlatformTextureSettings("Android",2048,TextureImporterFormat.RGBA32,true); &#125; else if(textureImporter.assetPath.Contains("Texture")) &#123; textureImporter.textureType = TextureImporterType.Default; textureImporter.mipmapEnabled = true; // 设置模型贴图在三个平台下的压缩格式以及大小 textureImporter.SetPlatformTextureSettings("Standalone",2048,TextureImporterFormat.DXT5); textureImporter.SetPlatformTextureSettings("iPhone",2048,TextureImporterFormat.ASTC_RGBA_4x4,100,true); textureImporter.SetPlatformTextureSettings("Android",2048,TextureImporterFormat.ETC_RGB4,true); &#125; &#125;&#125; 拓展阅读：为什么要进行纹理压缩：http://www.newhappy.com.cn/?p=907 那么纹理有哪些压缩格式呢？桌面平台： RGB Compressed DXT1 压缩的RGB纹理。这是最常见的漫反射纹理格式。4位/像素（32 KB 256x256） RGBA Compressed DXT5 压缩的RGBA纹理。这是漫反射和高光控制纹理的主要格式。1 字节/像素（64 KB 256x256） RGB 16 bit 65万颜色不带alpha。压缩的DXT格式使用较少的内存，通常会更好看。（128 KB 256x256） RGB 24 bit 真彩色不带alpha。（192 KB 256x256） Alpha 8 bit 高质量alpha通道，不带颜色。（64 KB 256x256） RGBA 16 bit 低质量真彩色。有16级红，绿，蓝和alpha。压缩的DXT5格式使用较少的内存，通常会更好看。（128 KB 256x256） RGBA 32 bit 高质量真彩色带alpha（256 KB 256x256），这个文件很大。大多数情况下 DXT5提供足够的质量，文件大小要小得多。这个主要用于法线贴图，DXT压缩往往带有一个可见的质量损失。 Android： RGB Compressed DXT1 压缩的RGB纹理。支持Nvidia Tegra。4位/像素（32 KB 256x256） RGBA Compressed DXT5 压缩的RGBA纹理。支持Nvidia Tegra。6位/像素（64 KB 256x256） RGB Compressed ETC 4 bits 压缩的RGB纹理。这是Android工程默认的纹理格式。 ETC1是OpenGL ES 2.0标准的一部分，并且支持所有的OpenGL ES 2.0 GPU，但它不支持Alpha。4位/像素（32 KB 256x256） RGB Compressed PVRTC 2 bits 压缩的RGB纹理。 支持Imagination PowerVR GPU。2位/像素（16 KB 256x256） RGBA Compressed PVRTC 2 bits 压缩的RGBA纹理。支持Imagination PowerVR GPU。2位/像素（16 KB 256x256） RGB Compressed PVRTC 4 bits 压缩的RGB纹理。 支持Imagination PowerVR GPU。4位/像素（32 KB 256x256） RGBA Compressed PVRTC 4 bits 压缩的RGBA纹理。 支持Imagination PowerVR GPU。4位/像素（32 KB 256x256） RGB Compressed ATC 4 bits 压缩的RGB纹理。 支持Qualcomm Snapdragon。4位/像素（32 KB 256x256） RGBA Compressed ATC 8 bits 压缩的RGB纹理。 支持Qualcomm Snapdragon。6位/像素（64 KB 256x256） RGB 16 bit 65万颜色不带alpha。比压缩的格式使用更多的内存，但更适用于UI或不带渐变的明快的纹理。128 KB 256x256 RGB 24 bit 真彩色不带alpha。（192 KB 256x256） Alpha 8 bit 高质量alpha通道，不带颜色。（64 KB 256x256） RGBA 16 bit 低质量真彩色。默认压缩的纹理带有alpha通道（128 KB 256x256） RGBA 32 bit 真彩色带alpha - 这是高质量压缩的纹理带有alpha通道。（256 KB 256x256） IOS： RGB Compressed PVRTC 4 bits PVRTC 4位，压缩的RGB纹理。这是最常见的漫反射纹理格式。4位/像素（32 KB 256x256） RGBA Compressed PVRTC 4 bits 压缩的RGBA纹理。这是漫反射和高光控制纹理的主要格式。4 位/像素（32 KB 256x256） RGB Compressed PVRTC 2 bits压缩的RGB纹理。 低质量格式，适用于漫反射纹理。2 位/像素（16 KB 256x256） RGBA Compressed PVRTC 2 bits 压缩的RGBA纹理。 低质量格式，适用于漫反射纹理和高光控制纹理。2 位/像素（16 KB 256x256） RGB Compressed DXT1 压缩的RGB纹理。 在iOS不支持此格式，但为桌面项目保持向后兼容性。 RGBA Compressed DXT5 压缩的RGBA纹理。在iOS不支持此格式，但为桌面项目保持向后兼容性。 RGB 16 bit 65万颜色不带alpha。比PVRTC格式使用更多的内存，但更适用于UI或不带渐变的明快的纹理。128 KB 256x256 RGB 24 bit 真彩色不带alpha。（192 KB 256x256） Alpha 8 bit 高质量alpha通道，不带颜色。（64 KB 256x256） RGBA 16 bit 低质量真彩色。具有16级的红、绿、蓝和alpha。比PVRTC格式使用更多的内存，但如果需要精确的alpha通道，会更方便。（128 KB 256x256） RGBA 32 bit 真彩色带alpha - 这是最高质量。256KB 256x256，这个是很消耗性能的。大多数情况下，PVRTC格式提供足够的质量，但有更小的文件大小。 (图片来自：喵小逗@UWA问答社区) 几种主要的压缩格式介绍：高清晰无压缩 - RGBA32RGBA32等同于原图了，优点是清晰、与原图一致，缺点是内存占用十分大；对于一些美术要求最好清晰度的图片，是首选。 要注意一些png图片，在硬盘中占用几KB，怎么在Unity中显示却变大？因为Unity显示的是Texture大小，是实际运行时占用内存的大小，而png却是一种压缩显示格式；可以这样理解，png类似于zip格式，是一个压缩文件，只不过在运行时会自动解压解析罢了。 中清晰中压缩 - RGBA16 + DitheringUnity RGBA16，不抖动处理的渐变图片惨不忍睹 既然叫RGBA16，自然就是RGBA32的阉割版。对于一些采用渐变的图片，从RGBA32转换成RGBA16，能明显的看出颜色的层叠变化。 采用Floyd Steinberg抖动处理后，除非放大，否则肉眼基本看不出区别 RGBA16的优点，内存占用是RGBA32的1/2；搭配上Dithering抖动，在原尺寸下看清晰度一模一样； 缺点，Unity原生不支持Dithering抖动，需要自己做工具对图片做处理；对于需要放大、拉伸的图片，Dithering抖动的支持不好，会有非常明显的颗粒感。 RGB16而RGB16，是主要针对一些，不带透明通道，同时长宽又不是2的次方的图片；对于这些图片，使用RGB16可以降低一半的内存，但是效果会略逊于RGB32。 当然了，RGB16其实也是可以搭配抖动，也能提升显示效果；但同样的Dithering抖动对拉伸放大是不友好的。 低清晰高压缩 - ETC1+Alpha/PVRTC4很多初学者都会疑惑，为什么游戏开发中经常看到一些图片，需要设置成2的次方？因为像ETC1、PVRTC4等这类在内存中无需解压、直接被GPU支持的格式，占用内存极低，而且性能效率也是最好的。 但是，相对RGBA32，还是能肉眼看出质量有所下降的。 ETC1 ETC1+Alpha一般应用在Android版的UI图集中，ETC1不带透明通道，所以需要外挂一张同样是ETC1格式的Alpha通道图。方法是，在原RGBA32的原图中，提取RGB生成第一张ETC1，再提取A通道，填充另一张ETC1的R通道；游戏运行时，Shader将两张ETC1图片进行混合。 PVRTC4 PVRTC4在Unity中是直接支持的，不过要注意的细节是，它必须是二次方正方形；也就是说，长宽在二次方的同时，还必须要相等。 在项目中，尽可能是使用ETC1和PVRTV4等GPU直接支持的图片格式，不仅内存占用低、性能也更好；当出现质量不及格时，再逐步的提升压缩格式，来满足需要。 参考： Unity运用导入器规范资源格式和设置 Unity3D 图片纹理格式(作者：JumboWu) 干货：Unity游戏开发图片纹理压缩方案]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Unity] 生命周期相关]]></title>
    <url>%2F2019%2F04%2F17%2FUnity%E7%AC%94%E8%AE%B0%2FUnity-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[生命周期相关。 脚本的生命周期：Unity脚本有一套完整的生命周期，脚本需要挂在任意游戏对象上，并且同一个游戏对象可以挂不同的脚本，各脚本执行自己的生命周期，它们可以互相组合并且互不干预。生命周期中的所有方法都是Unity系统自己回调的，不需要手动调用，主要有编辑脚本、初始化、物理碰撞事件、更新回调、渲染和销毁等。学习脚本的生命周期之前，我们不得不引用文档中非常经典的一张图，它完整的描述了脚本的生命周期： 第一个场景加载：这些函数将在场景开始加载时调用。(场景中的每个物体仅调用一次) Awake：这个方法总是在在任何开始方法之前调用(可以理解成最先调用吧？)，并且在一个prefab刚被实例化后就调用。(如果一个游戏物体在开始时是不活跃的(inactive)则将不会调用awake函数，直到其变为活跃。) OnEnable：(仅在物体为活跃(active)状态调用)：这个函数仅在一个物体变为有效(enabled)后调用。这通常发生在一个MonoBehavior实例创建时，例如在一个场景加载时或者一个持有脚本组件的游戏物体被实例化时。 OnLevelWasLoaded：这个函数用来通知游戏逻辑一个新的场景已经被加载完。 注意：对于加到场景中的物体来说，Awake和OnEnable方法将在所有脚本的任何类似于Start、Update等方法被调用之前调用。自然的，这些方法也不能在游戏进行中强制调用。 编辑器： Reset：Reset被调用于第一次将脚本绑定到物体上时初始化脚本属性，或者在Reset指令被触发时调用。 在帧之间： OnApplicationPause:：这个方法在检测到暂停的帧的末尾调用，在正常帧更新间有效？之后将会发出一个额外的帧。调用OnApplicationPause以允许游戏显示指示暂停状态的图形。 更新顺序：当你追踪游戏逻辑和交互、动画、相机位置等，你可以使用几个不同的事件。常见的模式是在Update函数中执行大多数任务，但也可以使用其他功能。 FixedUpdate：FixedUpdate函数通常要比Update函数调用的更为频繁，会按照设置的时间固定频率来循环更新。如果帧速率低，则可以每帧调用多次，如果帧速率高，则可以不在帧之间调用。所有物理计算和更新在FixedUpdate之后立即发生。在FixedUpdate中应用移动计算时，不需要乘以Time.deltaTime。这是因为FixedUpdate在可靠的定时器上调用，与帧速率无关。 Update：Update每帧调用一次。它是帧更新的主要功能。 LateUpdate：LateUpdate每帧调用一次，但在Update执行结束之后。在LateUpdate开始时，在Update中执行的任何计算都应该已经完成。LateUpdate的一个常见用途是实现跟随的第三人称相机。如果你将角色移动放在Update中执行，那么你可以将所有的相机移动和旋转计算放在LateUpdate中执行。这将确保角色在摄像机跟踪其位置之前完全移动。 总体来说，Update()和LateUpdate()属于立即更新，更新之间的频率是不固定的，比如某一帧有一个耗时操作的时候，就会影响到下一帧更新的时间，所以对更新频率要求比较稳定的物理系统就不太适合在这里处理更新。 FixedUpdate()虽然是固定更新，但是其实也是相对固定的，比如某一帧耗了好几秒，它依然会卡住。不过正常的程序要优化耗时操作，小范围的帧率波动是正常的，可以让它更新的时间间隔稍微长一点，这样它的更新是比较平滑的。在实际的开发中，例如以秒为单位的倒计时，并不需要每一帧去判断时间，所以用FixedUpdate()就再合适不过了。 动画更新循环：这些方法和Profiler Markers在Unity评估(？)动画系统时会调用。 (暂略) 有用的profile markers：(暂略) 渲染： OnPreCull：在相机剔除场景之前调用。剔除确定相机可以看到哪些对象。在剔除之前调用OnPreCull。 OnBecameVisible/OnBecameInvisible：当对象变得对任何相机可见/不可见时调用。 OnWillRenderObject：如果对象可见，则为每个摄像机调用一次。 OnPreRender：在相机开始渲染场景之前调用一次。 OnRenderObject：在完成所有常规场景渲染后调用。您可以使用GL类或Graphics.DrawMeshNow来绘制自定义几何体。 OnPostRender：在相机完成渲染场景后调用。 OnRenderImage：在场景渲染完成后调用以允许对图像进行后处理，请参阅后处理效果。 OnGUI：响应GUI事件，每帧调用多次。首先处理Layout和Repaint事件，然后为每个输入事件处理Layout和keyboard / mouse事件。 OnDrawGizmos：用于在场景视图中绘制Gizmo以进行可视化。 协程：正常的协程在Update函数返回后更新。协程是一个可以暂停执行(yield)直到给定的YieldInstruction完成的函数。以下是协程的不同用处： yield：在下一帧调用所有Update函数后，协程将继续。 yield WaitForSeconds：在为帧调用了所有的Update函数后，协程在指定的延迟时间后继续。 yield WaitForFixedUpdate：在所有脚本中的的所有FixedUpdate执行后继续协程。 yield WWW：在一个WWW类的下载完成之后执行协程。 yield StartCoroutine：链接协程，并将等待MyFunc协程首先完成。 当物体被销毁时： OnDestroy：在对象存在的最后一帧的所有帧更新之后调用这个函数。(该对象可能在相应Object.Destory或者场景闭合时被销毁)。 当退出时：在场景中的所有活动对象上调用这些函数： OnApplicationQuit：在退出应用程序之前，将在所有游戏对象上调用此函数。在编辑器中，当用户停止播放模式时调用它。 OnDisable：当行为被禁用或处于非活动状态时，将调用此函数。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Demo] 一个可视化寻路Project]]></title>
    <url>%2F2019%2F04%2F12%2F%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%2FDemo-%E4%B8%80%E4%B8%AA%E5%8F%AF%E8%A7%86%E5%8C%96%E5%AF%BB%E8%B7%AFProject%2F</url>
    <content type="text"><![CDATA[一个可视化寻路Project。 项目地址：https://github.com/bitzhangmo/PathFindingInVisual]]></content>
      <categories>
        <category>开发笔记</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>算法</tag>
        <tag>Astar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Unity] Unity中的内存泄漏]]></title>
    <url>%2F2019%2F04%2F11%2FUnity%E7%AC%94%E8%AE%B0%2FUnity-Unity%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%2F</url>
    <content type="text"><![CDATA[Unity中的内存泄漏。 参考： 内存是手游的硬伤——Unity游戏Mono内存管理及泄漏 深入浅出再谈Unity内存泄漏]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[游戏AI] 状态机]]></title>
    <url>%2F2019%2F04%2F01%2F%E6%B8%B8%E6%88%8FAI%2F%E6%B8%B8%E6%88%8FAI-%E7%8A%B6%E6%80%81%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[状态机的利与弊。 参考： 漫谈游戏中的人工智能 《游戏人工智能编程案例精粹》 状态机状态机是什么：为什么选择状态机：状态机的演进：最简单的状态机：首先很容易抽象出IUnit： 123456789101112public interface IUnit&#123; void ChangeState(UnitStateEnum state); void Patrol(); IUnit GetNearestTarget(); void LockTarget(IUnit unit); float GetFleeBloodRate(); bool CanMove(); bool HpRateLessThan(float rate); void Flee(); void Speak();&#125; 要注意的是，原作者的实现方式是定义一个单位接口，每个智能体要实现这个单位接口中定义的方法。(这样写会使每个单位类中有着一套自己所有行为的方法。我之前的实现方式是状态机来控制单位进行相应的行为，这样可以使每个状态仅有这个状态下自身的方法，但是耦合性较高。原作者这种接口是不是可以改写成虚方法的形式，在基类中实现基本行为，具体单位子类中再override出特定的行为？) 一个最简单的状态机定义： 12345678public interface IState&lt;TState,TUnit&gt; where TState : IConvertible&#123; TState Enum &#123;get;&#125; TUnit Self &#123;get;&#125; void OnEnter(); void Drive(); void OnExit();&#125; 这样写有着一个明显的性能问题：状态机本质是描述状态迁移的，并不需要保存实体的上下文，如果实体的上下文都保存在State中(上文中的TUnit类型的Self)，那么这个状态机的每个状态迁移逻辑需要每个状态都保存一个实体的实例，这样浪费内存，应该将决策逻辑与实体的上下文分离。 决策逻辑和上下文分离：剥离后： 1234567public interface IState&lt;TState,TUnit&gt; where TState : IConvertible&#123; TState Enum &#123;get;&#125; void OnEnter(TUnit self); void Drive(TUnit self); void OnExit(TUnit self);&#125; 可以使用单例模式保持静态的状态内容实例只有一个，此时状态之间的迁移逻辑变成了静态，动态的是状态迁移过程中的上下文。 分层有限状态机：如果想要让状态机框架描述层级结构的概念，需要对其进行拓展： 例如一个怪物需要在巡逻一段时间后进行休息，在休息一段时间后再次进行巡逻，而巡逻与休息状态均保持着对于战斗的检查。这时如果按照之前的框架(我之前就是最初级的那种)，就需要手动进行装配，在每个状态中都写入一个关于是否进入战斗状态的检查。可以看出战斗状态的优先级较高，并且相对来说算是一种”全局检查”，可以将其抽离出来作为上层状态。 父状态需要关注子状态的运行结果，所以状态的Drive接口需要一个运行结果的返回值。 子状态一定是由父状态驱动的。 考虑这样一个组合状态情景：巡逻时，需要依次得先走到一个点，然后怠工一会儿，再走到下一个点，然后再怠工一会儿，循环往复。这样就需要父状态（巡逻状态）注记当前激活的子状态，并且根据子状态执行结果的不同来修改激活的子状态集合。这样不仅是Unit自身有上下文，连组合状态也有了自己的上下文。 状态定义： 123456public interface IState&lt;TState, TCleverUnit, TResult&gt; where TState : IConvertible&#123; // ... TResult Drive(); // ...&#125; 组合状态的定义： 123456789101112131415161718192021222324public abstract class UnitCompositeStateBase : UnitStateBase&#123; protected readonly LinkedList&lt;UnitStateBase&gt; subStates = new LinkedList&lt;UnitStateBase&gt;(); // ... protected Result ProcessSubStates() &#123; if (subStates.Count == 0) &#123; return Result.Success; &#125; var front = subStates.First; var res = front.Value.Drive(); if (res != Result.Continue) &#123; subStates.RemoveFirst(); &#125; return Result.Continue; &#125; // ...&#125; 巡逻状态： 1234567891011121314151617181920212223242526272829303132333435363738394041public class PatrolState : UnitCompositeStateBase&#123; // ... public override void OnEnter() &#123; base.OnEnter(); AddSubState(new MoveToState(Self)); &#125; public override Result Drive() &#123; if (subStates.Count == 0) &#123; return Result.Success; &#125; var unit = Self.GetNearestTarget(); if (unit != null) &#123; Self.LockTarget(unit); return Result.Success; &#125; var front = subStates.First; var ret = front.Value.Drive(); if (ret != Result.Continue) &#123; if (front.Value.Enum == CleverUnitStateEnum.MoveTo) &#123; AddSubState(new IdleState(Self)); &#125; else &#123; AddSubState(new MoveToState(Self)); &#125; &#125; return Result.Continue; &#125;&#125; 分层有限状态机的上下文分离： 我们对之前重构出来的层次状态机框架再进行一次Context分离优化。 要优化的点有这样几个： 首先是继续之前的，unit不应该作为一个state自己的内部status。 组合状态的实例内部不应该包括自身执行的status。目前的组合状态，可以动态增删子状态，也就是根据status决定了结构的状态，理应分离静态与动态。巡逻状态组合了两个子状态——A和B，逻辑中是一个完成了就添加另一个，这样一想的话，其实巡逻状态应该重新描述——先进行A，再进行B，循环往复。 由于有了父状态的概念，其实状态接口的设计也可以再迭代，理论上只需要一个drive即可。因为状态内部的上下文要全部分离出来，所以也没必要对外提供OnEnter、OnExit，提供这两个接口的意义只是做一层内部信息的隐藏，但是现在内部的status没了，也就没必要隐藏了。 具体分析一下需要拆出的status： 一部分是entity本身的status，这里可以简单的认为是unit。 另一部分是state本身的status。 对于组合状态，这个status描述的是我当前执行到哪个substate。 对于原子状态，这个status描述的种类可能有所区别。 例如MoveTo/Flee，OnEnter的时候，修改了unit的status，然后Drive的时候去check。 例如Idle，OnEnter时改了自己的status，然后Drive的时候去check。 经过总结，我们可以发现，每个状态的status本质上都可以通过一个变量来描述。一个State作为一个最小粒度的单元，具有这样的Concept： 输入一个Context，输出一个Result。 Context暂时只需要包括这个Unit，和之前所说的status。同时，考虑这样一个问题： 父状态A，子状态B。 子状态B向上返回Continue的同时，status记录下来为b。 父状态ADrive子状态的结果为Continue，自身也需要向上抛出Continue，同时自己也有status为a。 这样，再还原现场时，就需要即给A一个a，还需要让A有能力从Context中拿到需要给B的b。因此上下文的结构理应是递归定义的，是一个层级结构。 Context如下定义： 123456789101112public class Continuation &#123; public Continuation SubContinuation &#123; get; set; &#125; public int NextStep &#123; get; set; &#125; public object Param &#123; get; set; &#125; &#125;public class Context&lt;T&gt;&#123; public Continuation Continuation &#123; get; set; &#125; public T Self &#123; get; set; &#125;&#125; 修改State的接口定义为： 1234public interface IState&lt;TCleverUnit, TResult&gt; &#123; TResult Drive(Context&lt;TCleverUnit&gt; ctx); &#125; 已经相当简洁了。 这样，我们对之前的巡逻状态也做下修改，达到一个ContextFree的效果。利用Context中的Continuation来确定当前结点应该从什么状态继续： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class PatrolState : IState&lt;ICleverUnit, Result&gt; &#123; private readonly List&lt;IState&lt;ICleverUnit, Result&gt;&gt; subStates; public PatrolState() &#123; subStates = new List&lt;IState&lt;ICleverUnit, Result&gt;&gt;() &#123; new MoveToState(), new IdleState(), &#125;; &#125; public Result Drive(Context&lt;ICleverUnit&gt; ctx) &#123; var unit = ctx.Self.GetNearestTarget(); if (unit != null) &#123; ctx.Self.LockTarget(unit); return Result.Success; &#125; var nextStep = 0; if (ctx.Continuation != null) &#123; // Continuation var thisContinuation = ctx.Continuation; ctx.Continuation = thisContinuation.SubContinuation; var ret = subStates[nextStep].Drive(ctx); if (ret == Result.Continue) &#123; thisContinuation.SubContinuation = ctx.Continuation; ctx.Continuation = thisContinuation; return Result.Continue; &#125; else if (ret == Result.Failure) &#123; ctx.Continuation = null; return Result.Failure; &#125; ctx.Continuation = null; nextStep = thisContinuation.NextStep + 1; &#125; for (; nextStep &lt; subStates.Count; nextStep++) &#123; var ret = subStates[nextStep].Drive(ctx); if (ret == Result.Continue) &#123; ctx.Continuation = new Continuation() &#123; SubContinuation = ctx.Continuation, NextStep = nextStep, &#125;; return Result.Continue; &#125; else if (ret == Result.Failure) &#123; ctx.Continuation = null; return Result.Failure; &#125; &#125; ctx.Continuation = null; return Result.Success; &#125; &#125; subStates是readonly的，在组合状态构造的一开始就确定了值。这样结构本身就是静态的，而上下文是动态的。不同的entity instance共用同一个树的instance。 ​ (最后这个理解起来比较吃力了)]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>游戏AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[转] Unity 3D中的内存管理]]></title>
    <url>%2F2019%2F03%2F26%2FUnity%E7%AC%94%E8%AE%B0%2F%E8%BD%AC-Unity-3D%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[Unity 3D中的内存管理 本文欢迎转载，但烦请保留此行出处信息：http://www.onevcat.com/2012/11/memory-in-unity3d/ Unity3D在内存占用上一直被人诟病，特别是对于面向移动设备的游戏开发，动辄内存占用飙上一两百兆，导致内存资源耗尽，从而被系统强退造成极差的体验。类似这种情况并不少见，但是绝大部分都是可以避免的。虽然理论上Unity的内存管理系统应当为开发者分忧解难，让大家投身到更有意义的事情中去，但是对于Unity对内存的管理方式，官方文档中并没有太多的说明，基本需要依靠自己摸索。最近在接手的项目中存在严重的内存问题，在参照文档和Unity Answer众多猜测和证实之后，稍微总结了下Unity中的内存的分配和管理的基本方式，在此共享。 虽然Unity标榜自己的内存使用全都是“Managed Memory”，但是事实上你必须正确地使用内存，以保证回收机制正确运行。如果没有做应当做的事情，那么场景和代码很有可能造成很多非必要内存的占用，这也是很多Unity开发者抱怨内存占用太大的原因。接下来我会介绍Unity使用内存的种类，以及相应每个种类的优化和使用的技巧。遵循使用原则，可以让非必要资源尽快得到释放，从而降低内存占用。 Unity中的内存种类实际上Unity游戏使用的内存一共有三种：程序代码、托管堆（Managed Heap）以及本机堆（Native Heap）。 程序代码包括了所有的Unity引擎，使用的库，以及你所写的所有的游戏代码。在编译后，得到的运行文件将会被加载到设备中执行，并占用一定内存。这部分内存实际上是没有办法去“管理”的，它们将在内存中从一开始到最后一直存在。一个空的Unity默认场景，什么代码都不放，在iOS设备上占用内存应该在17MB左右，而加上一些自己的代码很容易就飙到20MB左右。想要减少这部分内存的使用，能做的就是减少使用的库，稍后再说。 托管堆是被Mono使用的一部分内存。Mono项目一个开源的.net框架的一种实现，对于Unity开发，其实充当了基本类库的角色。托管堆用来存放类的实例（比如用new生成的列表，实例中的各种声明的变量等）。“托管”的意思是Mono“应该”自动地改变堆的大小来适应你所需要的内存，并且定时地使用垃圾回收（Garbage Collect）来释放已经不需要的内存。关键在于，有时候你会忘记清除对已经不需要再使用的内存的引用，从而导致Mono认为这块内存一直有用，而无法回收。 最后，本机堆是Unity引擎进行申请和操作的地方，比如贴图，音效，关卡数据等。Unity使用了自己的一套内存管理机制来使这块内存具有和托管堆类似的功能。基本理念是，如果在这个关卡里需要某个资源，那么在需要时就加载，之后在没有任何引用时进行卸载。听起来很美好也和托管堆一样，但是由于Unity有一套自动加载和卸载资源的机制，让两者变得差别很大。自动加载资源可以为开发者省不少事儿，但是同时也意味着开发者失去了手动管理所有加载资源的权力，这非常容易导致大量的内存占用（贴图什么的你懂的），也是Unity给人留下“吃内存”印象的罪魁祸首。 优化程序代码的内存占用这部分的优化相对简单，因为能做的事情并不多：主要就是减少打包时的引用库，改一改build设置即可。对于一个新项目来说不会有太大问题，但是如果是已经存在的项目，可能改变会导致原来所需要的库的缺失（虽说一般来说这种可能性不大），因此有可能无法做到最优。 当使用Unity开发时，默认的Mono包含库可以说大部分用不上，在Player Setting（Edit-&gt;Project Setting-&gt;;Player或者Shift+Ctrl(Command)+B里的Player Setting按钮）面板里，将最下方的Optimization栏目中“Api Compatibility Level”选为.NET 2.0 Subset，表示你只会使用到部分的.NET 2.0 Subset，不需要Unity将全部.NET的Api包含进去。接下来的“Stripping Level”表示从build的库中剥离的力度，每一个剥离选项都将从打包好的库中去掉一部分内容。你需要保证你的代码没有用到这部分被剥离的功能，选为“Use micro mscorlib”的话将使用最小的库（一般来说也没啥问题，不行的话可以试试之前的两个）。库剥离可以极大地降低打包后的程序的尺寸以及程序代码的内存占用，唯一的缺点是这个功能只支持Pro版的Unity。 这部分优化的力度需要根据代码所用到的.NET的功能来进行调整，有可能不能使用Subset或者最大的剥离力度。如果超出了限度，很可能会在需要该功能时因为找不到相应的库而crash掉（iOS的话很可能在Xcode编译时就报错了）。比较好地解决方案是仍然用最强的剥离，并辅以较小的第三方的类库来完成所需功能。一个最常见问题是最大剥离时Sysytem.Xml是不被Subset和micro支持的，如果只是为了xml，完全可以导入一个轻量级的xml库来解决依赖（Unity官方推荐这个）。 关于每个设定对应支持的库的详细列表，可以在这里找到。关于每个剥离级别到底做了什么，Unity的文档也有说明。实际上，在游戏开发中绝大多数被剥离的功能使用不上的，因此不管如何，库剥离的优化方法都值得一试。 托管堆优化Unity有一篇不错的关于托管堆代码如何写比较好的说明，在此基础上我个人有一些补充。 首先需要明确，托管堆中存储的是你在你的代码中申请的内存（不论是用js，C#还是Boo写的）。一般来说，无非是new或者Instantiate两种生成object的方法（事实上Instantiate中也是调用了new）。在接收到alloc请求后，托管堆在其上为要新生成的对象实例以及其实例变量分配内存，如果可用空间不足，则向系统申请更多空间。 当你使用完一个实例对象之后，通常来说在脚本中就不会再有对该对象的引用了（这包括将变量设置为null或其他引用，超出了变量的作用域，或者对Unity对象发送Destory()）。在每隔一段时间，Mono的垃圾回收机制将检测内存，将没有再被引用的内存释放回收。总的来说，你要做的就是在尽可能早的时间将不需要的引用去除掉，这样回收机制才能正确地把不需要的内存清理出来。但是需要注意在内存清理时有可能造成游戏的短时间卡顿，这将会很影响游戏体验，因此如果有大量的内存回收工作要进行的话，需要尽量选择合适的时间。 如果在你的游戏里，有特别多的类似实例，并需要对它们经常发送Destroy()的话，游戏性能上会相当难看。比如小熊推金币中的金币实例，按理说每枚金币落下台子后都需要对其Destory()，然后新的金币进入台子时又需要Instantiate，这对性能是极大的浪费。一种通常的做法是在不需要时，不摧毁这个GameObject，而只是隐藏它，并将其放入一个重用数组中。之后需要时，再从重用数组中找到可用的实例并显示。这将极大地改善游戏的性能，相应的代价是消耗部分内存，一般来说这是可以接受的。关于对象重用，可以参考Unity关于内存方面的文档中Reusable Object Pools部分，或者Prime31有一个是用Linq来建立重用池的视频教程（Youtube，需要翻墙，上半部分，下半部分）。 如果不是必要，应该在游戏进行的过程中尽量减少对GameObject的Instantiate()和Destroy()调用，因为对计算资源会有很大消耗。在便携设备上短时间大量生成和摧毁物体的话，很容易造成瞬时卡顿。如果内存没有问题的话，尽量选择先将他们收集起来，然后在合适的时候（比如按暂停键或者是关卡切换），将它们批量地销毁并且回收内存。Mono的内存回收会在后台自动进行，系统会选择合适的时间进行垃圾回收。在合适的时候，也可以手动地调用System.GC.Collect()来建议系统进行一次垃圾回收。要注意的是这里的调用真的仅仅只是建议，可能系统会在一段时间后在进行回收，也可能完全不理会这条请求，不过在大部分时间里，这个调用还是靠谱的。 本机堆的优化当你加载完成一个Unity的scene的时候，scene中的所有用到的asset（包括Hierarchy中所有GameObject上以及脚本中赋值了的的材质，贴图，动画，声音等素材），都会被自动加载（这正是Unity的智能之处）。也就是说，当关卡呈现在用户面前的时候，所有Unity编辑器能认识的本关卡的资源都已经被预先加入内存了，这样在本关卡中，用户将有良好的体验，不论是更换贴图，声音，还是播放动画时，都不会有额外的加载，这样的代价是内存占用将变多。Unity最初的设计目的还是面向台式机，几乎无限的内存和虚拟内存使得这样的占用似乎不是问题，但是这样的内存策略在之后移动平台的兴起和大量移动设备游戏的制作中出现了弊端，因为移动设备能使用的资源始终非常有限。因此在面向移动设备游戏的制作时，尽量减少在Hierarchy对资源的直接引用，而是使用Resource.Load的方法，在需要的时候从硬盘中读取资源，在使用后用Resource.UnloadAsset()和Resources.UnloadUnusedAssets()尽快将其卸载掉。总之，这里是一个处理时间和占用内存空间的trade off，如何达到最好的效果没有标准答案，需要自己权衡。 在关卡结束的时候，这个关卡中所使用的所有资源将会被卸载掉（除非被标记了DontDestroyOnLoad）的资源。注意不仅是DontDestroyOnLoad的资源本身，其相关的所有资源在关卡切换时都不会被卸载。DontDestroyOnLoad一般被用来在关卡之间保存一些玩家的状态，比如分数，级别等偏向文本的信息。如果DontDestroyOnLoad了一个包含很多资源（比如大量贴图或者声音等大内存占用的东西）的话，这部分资源在场景切换时无法卸载，将一直占用内存，这种情况应该尽量避免。 另外一种需要注意的情况是脚本中对资源的引用。大部分脚本将在场景转换时随之失效并被回收，但是，在场景之间被保持的脚本不在此列（通常情况是被附着在DontDestroyOnLoad的GameObject上了）。而这些脚本很可能含有对其他物体的Component或者资源的引用，这样相关的资源就都得不到释放，这绝对是不想要的情况。另外，static的单例（singleton）在场景切换时也不会被摧毁，同样地，如果这种单例含有大量的对资源的引用，也会成为大问题。因此，尽量减少代码的耦合和对其他脚本的依赖是十分有必要的。如果确实无法避免这种情况，那应当手动地对这些不再使用的引用对象调用Destroy()或者将其设置为null。这样在垃圾回收的时候，这些内存将被认为已经无用而被回收。 需要注意的是，Unity在一个场景开始时，根据场景构成和引用关系所自动读取的资源，只有在读取一个新的场景或者reset当前场景时，才会得到清理。因此这部分内存占用是不可避免的。在小内存环境中，这部分初始内存的占用十分重要，因为它决定了你的关卡是否能够被正常加载。因此在计算资源充足或是关卡开始之后还有机会进行加载时，尽量减少Hierarchy中的引用，变为手动用Resource.Load，将大大减少内存占用。在Resource.UnloadAsset()和Resources.UnloadUnusedAssets()时，只有那些真正没有任何引用指向的资源会被回收，因此请确保在资源不再使用时，将所有对该资源的引用设置为null或者Destroy。同样需要注意，这两个Unload方法仅仅对Resource.Load拿到的资源有效，而不能回收任何场景开始时自动加载的资源。与此类似的还有AssetBundle的Load和Unload方法，灵活使用这些手动资源加载和卸载的方法，是优化Unity内存占用的不二法则～]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[游戏引擎架构] 第十章：渲染引擎]]></title>
    <url>%2F2019%2F03%2F26%2F%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%2F%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84-%E7%AC%AC%E5%8D%81%E7%AB%A0%EF%BC%9A%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[「占位」 渲染引擎采用深度缓冲的三角形光栅化基础三维场景渲染的本质涉及以下基本步骤： 描述一个虚拟场景。这些场景一般是以某数学形式表示的三维表面。 定位及定向一个虚拟摄像机，为场景取景。 设置光源。 描述场景中物体表面的视觉特性。 对于每个位于影像矩形内的像素，渲染引擎会找出经过该像素而聚焦于虚拟摄像机焦点的光线，并计算其颜色和强度。此过程为求解渲染方程，也叫做着色方程。 场景描述：高端渲染软件所用的表示法三角形网格游戏开发者会使用三角形网格来为表面建模。三角形是表面的分段线性逼近。 为什么选取三角形？ 三角形是最简单的多边形 三角形必然是平坦的 三角形经过多种转换之后仍然维持是三角形，对于仿射转换与透视转换也成立 几乎所有的商用图形加速软件都是为三角形光栅化而设计的。 镶嵌： 镶嵌是指把表面分割为一组离散多边形的过程。 构造三角形网格 缠绕顺序 三角形由三个顶点的位置矢量定义，此三个矢量设为p1，p2，p3。每条棱的相邻顶点的位置矢量相减，就能求得三条棱的矢量。 任何两棱的叉积，归一化后就能定义为三角形的单位面法线N，若要知道面法线的方向，需要定义哪一面才是三角形的正面，哪一面是背面，这个可以简单用缠绕顺序(winding order)定义，缠绕顺序用来定义表面方向有两种方式，分别是顺时针方向和逆时针方向。 模型空间世界空间及网格实例化描述表面的视觉性质光和颜色的概论顶点属性顶点格式属性插值纹理材质光照基础局部及全局光照模型Phong氏光照模型光源模型虚拟摄像机观察空间投影观察体积及平截头体投影及齐次裁剪空间屏幕空间及长宽比帧缓冲三角形光栅化及片段遮挡及深度缓冲渲染管道高级光照及全局光照视觉效果和覆盖层]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>游戏引擎</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Unity] 托管堆与垃圾回收]]></title>
    <url>%2F2019%2F03%2F25%2FUnity%E7%AC%94%E8%AE%B0%2FUnity-%E6%89%98%E7%AE%A1%E5%A0%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%2F</url>
    <content type="text"><![CDATA[有关Unity中的托管堆与垃圾回收。 托管堆与垃圾回收托管堆：“托管堆”是一段内存，由项目脚本运行时（Mono或IL2CPP）的内存管理器自动管理。托管代码中创建的所有对象必须在托管堆上分配（注意：严格地说，必须在托管堆上分配所有非空引用类型对象和所有盒装值类型对象）。 在上图中，白框表示分配给托管堆的内存量，其中的彩色框表示存储在托管堆内存空间中的数据值。当需要其他值时，将从托管堆中分配更多空间。 垃圾收集器定期运行（注意：确切的时间与平台有关）。这会扫描堆上的所有对象，标记删除任何不再引用的对象。然后删除未引用的对象，释放内存。 至关重要的是，Unity的垃圾收集 - 使用Boehm GC算法 - 是非代数和非压缩的。“非世代”意味着GC在执行收集传递时必须扫描整个堆，因此其性能因堆扩展而降低。“非压缩”意味着内存中的对象不会被重新定位以便关闭对象之间的间隙。 上图显示了内存碎片的示例。释放对象时，将释放其内存。但是，释放的空间也不会成为“空闲内存”一家独大池的一部分。释放对象两侧的对象可能仍在使用中。因此，释放的空间是存储器的其他部分之间的“间隙”（该间隙由图中的红色圆圈表示）。因此，新释放的空间仅可用于存储与释放的对象相同或更小的数据。 分配对象时，请记住该对象必须始终占用内存中的连续空间块。 这导致了内存碎片的核心问题：虽然堆中可用的总空间量可能很大，但是该空间中的一些或全部可能在分配的对象之间存在小的“间隙”。在这种情况下，即使可能有足够的总空间来容纳某个分配，托管堆也找不到足够大的连续内存块来适应分配。 但是，如果分配了大对象并且没有足够的连续可用空间来容纳对象，则如上所述，Unity内存管理器执行两个操作。 首先，如果还没有这样做，垃圾收集器就会运行。这会尝试释放足够的空间来完成分配请求。 如果在GC运行后，仍然没有足够的连续空间来满足请求的内存量，则堆必须扩展。堆扩展的具体数量取决于平台; 但是，大多数Unity平台的大小都是托管堆的两倍。 堆的关键问题托管堆扩展的核心问题有两个： Unity在扩展时不会经常释放分配给托管堆的内存页; 它乐观地保留了扩展堆，即使它的大部分是空的。这是为了防止在进一步发生大量分配时需要重新扩展堆。 在大多数平台上，Unity最终将托管堆空部分使用的页面释放回操作系统。发生这种情况的间隔不能保证，不应该依赖。 托管堆使用的地址空间永远不会返回给操作系统。 对于32位程序，如果托管堆多次扩展和收缩，则可能导致地址空间耗尽。如果程序的可用内存地址空间已用尽，操作系统将终止该程序。 对于64位程序，地址空间足够大，对于运行时间不超过人类平均寿命的程序来说，这种情况极不可能发生。 了解自动内存管理：创建对象，字符串或数组时，存储它所需的内存是从称为堆的中央池分配的。当项目不再使用时，它曾经占用的内存可以被回收并用于其他内容。在过去，通常由程序员通过适当的函数调用显式地分配和释放这些堆内存块。如今，Unity的Mono引擎等运行时系统会自动为您管理内存。自动内存管理比显式分配/释放需要更少的编码工作，并且大大降低了内存泄漏的可能性（分配内存但从未随后释放的情况）。 分配和垃圾收集内存管理器跟踪它知道未使用的堆中的区域。当请求新的存储器块时（例如，当实例化对象时），管理器选择一个未使用的区域，从该区域分配块，然后从已知的未使用空间中移除分配的存储器。后续请求以相同的方式处理，直到没有足够大的空闲区域来分配所需的块大小。此时极不可能从堆中分配的所有内存仍在使用中。只有存在可以找到它的引用变量时，才能访问堆上的引用项。如果对内存块的所有引用都消失了（即，引用变量已被重新分配，或者它们是现在超出范围的局部变量），则可以安全地重新分配它占用的内存。 为了确定哪些堆块不再使用，内存管理器搜索所有当前活动的引用变量，并将它们称为“实时”的块标记。在搜索结束时，内存管理器认为实时块之间的任何空格都是空的，并且可以用于后续分配。由于显而易见的原因，定位和释放未使用的内存的过程称为垃圾收集（或简称GC）。 优化垃圾收集是自动的，对于程序员不可见，但在采集过程中实际需要的背后显著CPU时间的场景。如果使用正确，自动内存管理通常会等于或超过手动分配以获得整体性能。但是，程序员必须避免错误，这些错误会比必要时更频繁地触发收集器并在执行时引入暂停。 Unity中的垃圾回收：堆分配期间会发生什么？堆分配比堆栈分配复杂得多。这是因为堆可用于存储长期和短期数据，以及许多不同类型和大小的数据。分配和解除分配并不总是以可预测的顺序发生，并且可能需要非常不同大小的存储器块。 创建堆变量时，将执行以下步骤： 首先，Unity必须检查堆中是否有足够的可用内存。如果堆中有足够的可用内存，则分配变量的内存。 如果堆中没有足够的可用内存，Unity会尝试释放垃圾收集器，以释放未使用的堆内存。这可能是一个缓慢的操作。如果堆中现在有足够的可用内存，则会分配变量的内存。 如果垃圾回收后堆中没有足够的可用内存，Unity会增加堆中的内存量。这可能是一个缓慢的操作。然后分配变量的内存。 堆分配可能很慢，特别是如果垃圾收集器必须运行并且必须扩展堆。 垃圾收集期间会发生什么？当堆变量超出范围时，用于存储它的内存不会立即释放。只有在垃圾收集器运行时才会释放未使用的堆内存。 每次垃圾收集器运行时，都会发生以下步骤： 垃圾收集器检查堆上的每个对象。 垃圾收集器搜索所有当前对象引用以确定堆上的对象是否仍在范围内。 任何不再在范围内的对象都被标记为删除。 将删除标记的对象，并将分配给它们的内存返回到堆中。 垃圾收集可能是一项昂贵的操作。堆上的对象越多，它必须做的工作越多，代码中的对象引用越多，它必须做的工作就越多。 垃圾收集什么时候发生？有三件事可能导致垃圾收集器运行： 无论何时请求堆分配都无法使用堆中的可用内存来执行垃圾收集器。 垃圾收集器会不时自动运行（尽管频率因平台而异）。 垃圾收集器可以强制手动运行。 垃圾收集可能是一个频繁的操作。每当无法从可用堆内存中实现堆分配时，就会触发垃圾收集器，这意味着频繁的堆分配和解除分配会导致频繁的垃圾回收。 参考： Understanding the managed heap（理解托管堆） Understanding Automatic Memory Management(理解自动内存管理) Optimizing garbage collection in Unity games(在Unity游戏中优化垃圾回收) Boehm garbage collector]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[转] 骨骼蒙皮动画(Skinned Mesh)的原理解析]]></title>
    <url>%2F2019%2F03%2F25%2FUnity%E7%AC%94%E8%AE%B0%2F%E8%BD%AC-%E9%AA%A8%E9%AA%BC%E8%92%99%E7%9A%AE%E5%8A%A8%E7%94%BB-Skinned-Mesh-%E7%9A%84%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[骨骼蒙皮动画(Skinned Mesh)的原理解析。 原文地址（已经404）：http://blog.csdn.net/ccx1234/article/details/6641944 骨骼蒙皮动画(Skinned Mesh)的原理解析（一）3D模型动画基本原理和分类 3D模型动画的基本原理是让模型中各顶点的位置随时间变化。主要种类有Morph动画，关节动画和骨骼蒙皮动画(Skinned Mesh)。从动画数据的角度来说，三者一般都采用关键帧技术，即只给出关键帧的数据，其他帧的数据使用插值得到。但由于这三种技术的不同，关键帧的数据 是不一样的。 Morph（渐变，变形）动画是直接指定动画每一帧的顶点位置，其动画关键中存储的是Mesh所有顶点在关键帧对应时刻的位置。 关节动画的模型不是一个整体的Mesh,而是分成很多部分(Mesh)，通过一个父子层次结构将这些分散的Mesh组织在一起，父Mesh带动其下子 Mesh的运动，各Mesh中的顶点坐标定义在自己的坐标系中，这样各个Mesh是作为一个整体参与运动的。动画帧中设置各子Mesh相对于其父Mesh 的变换（主要是旋转，当然也可包括移动和缩放），通过子到父，一级级的变换累加（当然从技术上，如果是矩阵操作是累乘）得到该Mesh在整个动画模型所在 的坐标空间中的变换（从本文的视角来说就是世界坐标系了，下同），从而确定每个Mesh在世界坐标系中的位置和方向，然后以Mesh为单位渲染即可。关节 动画的问题是，各部分Mesh中的顶点是固定在其Mesh坐标系中的，这样在两个Mesh结合处就可能产生裂缝。 第三类就是骨骼蒙皮动画即Skinned Mesh了，骨骼蒙皮动画的出现解决了关节动画的裂缝问题，而且效果非常酷，发明这个算法的人一定是个天才，因为Skinned Mesh的原理简单的难以置信，而效果却那么好。骨骼动画的基本原理可概括为：在骨骼控制下，通过顶点混合动态计算蒙皮网格的顶点，而骨骼的运动相对于其 父骨骼，并由动画关键帧数据驱动。一个骨骼动画通常包括骨骼层次结构数据，网格(Mesh)数据，网格蒙皮数据(skin info)和骨骼的动画(关键帧)数据。下面将具体分析。 Skinned Mesh原理和结构分析Skinned Mesh中文一般称作骨骼蒙皮动画，正如其名，这种动画中包含骨骼（Bone）和蒙皮(Skinned Mesh)两个部分，Bone的层次结构和关节动画类似，Mesh则和关节动画不同：关节动画中是使用多个分散的Mesh，而Skinned Mesh中Mesh是一个整体，也就是说只有一个Mesh,实际上如果没有骨骼让Mesh运动变形，Mesh就和静态模型一样了。Skinned Mesh技术的精华在于蒙皮，所谓的皮并不是模型的贴图（也许会有人这么想过吧），而是Mesh本身，蒙皮是指将Mesh中的顶点附着（绑定）在骨骼之上，而且每个顶点可以被多个骨骼所控制，这样在关节处的顶点由于同时受到父子骨骼的拉扯而改变位置就消除了裂缝。Skinned Mesh这个词从字面上理解似乎是有皮的模型，哦，如果贴图是皮，那么普通静态模型不也都有吗？所以我觉得应该理解为具有蒙皮信息的Mesh或可当做皮肤用的Mesh，这个皮肤就是Mesh。而为了有皮肤功能，Mesh还需要蒙皮信息，即Skin数据，没有Skin数据就是一个普通的静态Mesh了。 Skin数据决定顶点如何绑定到骨骼上。顶点的Skin数据包括顶点受哪些骨骼影响以及这些骨骼影响该顶点时的权重(weight)，另外对于每块骨骼还需要骨骼偏移矩阵(BoneOffsetMatrix)用来将顶点从Mesh空间变换到骨骼空间。在本文中，提到骨骼动画中的Mesh特指这个皮肤 Mesh，提到模型是指骨骼动画模型整体。骨骼控制蒙皮运动，而骨骼本身的运动呢？当然是动画数据了。每个关键帧中包含时间和骨骼运动信息，运动信息可以 用一个矩阵直接表示骨骼新的变换，也可用四元数表示骨骼的旋转，也可以随便自己定义什么只要能让骨骼动就行。除了使用编辑设定好的动画帧数据，也可以使用 物理计算对骨骼进行实时控制。 下面分别具体分析骨骼蒙皮动画中的结构部件。 理解骨骼和骨骼层次结构（Bone Hierarchy）首先要明确一个观念：骨骼决定了模型整体在世界坐标系中的位置和朝向。 先看看静态模型吧，静态模型没有骨骼，我们在世界坐标系中放置静态模型时，只要指定模型自身坐标系在世界坐标系中的位置和朝向。在骨骼动画中，不是把 Mesh直接放到世界坐标系中，Mesh只是作为Skin使用的，是依附于骨骼的，真正决定模型在世界坐标系中的位置和朝向的是骨骼。在渲染静态模型时， 由于模型的顶点都是定义在模型坐标系中的，所以各顶点只要经过模型坐标系到世界坐标系的变换后就可进行渲染。而对于骨骼动画，我们设置模型的位置和朝向， 实际是在设置根骨骼的位置和朝向，然后根据骨骼层次结构中父子骨骼之间的变换关系计算出各个骨骼的位置和朝向，然后根据骨骼对Mesh中顶点的绑定计算出 顶点在世界坐标系中的坐标，从而对顶点进行渲染。要记住，在骨骼动画中，骨骼才是模型主体，Mesh不过是一层皮，一件衣服。 如何理解骨骼？请看第二个观念：骨骼可理解为一个坐标空间。 在一些文章中往往会提到关节和骨骼，那么关节是什么?骨骼又是什么？下图是一个手臂的骨骼层次的示例。 骨骼只是一个形象的说法，实际上骨骼可理解为一个坐标空间，关节可理解为骨骼坐标空间的原点。关节的位置由它在父骨骼坐标空间中的位置描述。上图中有三块 骨骼，分别是上臂，前臂和两个手指。Clavicle(锁骨)是一个关节，它是上臂的原点，同样肘关节(elbow joint)是前臂的原点，腕关节(wrist)是手指骨骼的原点。关节既决定了骨骼空间的位置，又是骨骼空间的旋转和缩放中心。为什么用一个4X4矩阵 就可以表达一个骨骼，因为4X4矩阵中含有的平移分量决定了关节的位置，旋转和缩放分量决定了骨骼空间的旋转和缩放。我们来看前臂这个骨骼，其原点位置是 位于上臂上某处的，对于上臂来说，它知道自己的坐标空间某处（即肘关节所在的位置）有一个子空间，那就是前臂，至于前臂里面是啥就不考虑了。当前臂绕肘关 节旋转时，实际是前臂坐标空间在旋转，从而其中包含的子空间也在绕肘关节旋转，在这个例子中是finger骨骼。和实际生物骨骼不同的是，我们这里的骨骼 并没有实质的骨头，所以前臂旋转时，他自己没啥可转的，改变的只是坐标空间的朝向。你可以说上图的蓝线在转，但实际蓝线并不存在，蓝线只是画上去表示骨骼 之间关系的，真正转的是骨骼空间，我们能看到在转的是wrist joint，也就是两个finger骨骼的坐标空间，因为他们是子空间，会跟随父空间运动，就好比人跟着地球转一样。 骨骼就是坐标空间，骨骼层次就是嵌套的坐标空间。关节只是描述骨骼的位置即骨骼自己的坐标空间原点在其父空间中的位置，绕关节旋转是指骨骼坐标空间（包括 所有子空间）自身的旋转，如此理解足矣。但还有两个可能的疑问，一是骨骼的长度问题，由于骨骼是坐标空间，没有所谓的长度和宽度的限制，我们看到的长度一 方面是蒙皮后的结果，另一方面子骨骼的原点（也就是关节）的位置往往决定了视觉上父骨骼的长度，比如这里upper arm线段的长度实际是由elbow joint的位置决定的。第二个问题，手指的那个端点是啥啊？实际上在我们的例子中手指没有子骨骼，所以那个端点并不存在：）那是为了方便演示画上去的。 实际问题中总有最下层的骨骼，他们不能决定其他骨骼了，他们的作用只剩下控制Mesh顶点。对了，那么手指的长度如何确定？我们看到的长度应该是由蒙皮决定的，也就是由Mesh中属于手指的那些点离腕关节的距离决定。 经过一段长篇大论，我们终于清楚骨骼和骨骼层次是啥了，但是为什么要将骨骼组织成层次结构呢？答案是为了做动画方便，设想如果只有一块骨骼，那么让他动起 来就太简单了，动画每一帧直接指定他的位置即可。如果是n块呢？通过组成一个层次结构，就可以通过父骨骼控制子骨骼的运动，牵一发而动全身，改变某骨骼时并不需要设置其下子骨骼的位置，子骨骼的位置会通过计算自动得到。上文已经说过，父子骨骼之间的关系可以理解为，子骨骼位于父骨骼的坐标系中。我们知道物 体在坐标系中可以做平移变换，以及自身的旋转和缩放变换。子骨骼在父骨骼的坐标系中也可以做这些变换来改变自己在其父骨骼坐标系中的位置和朝向等。那么如 何表示呢？由于4X4矩阵可以同时表示上述三种变换，所以一般描述骨骼在其父骨骼坐标系中的变换时使用一个矩阵，也就是DirectX SkinnedMesh中的FrameTransformMatrix。实际上这不是唯一的方法，但应该是公认的方法，因为矩阵不光可以同时表示多种变换 还可以方便的通过连乘进行变换的组合，这在层次结构中非常方便。在本文的例子-最简单的skinned mesh实例中，我只演示了平移变换，所以只用一个3d坐标就可以表示子骨骼在父骨骼中的位置。下面是Bone Class最初的定义： 12345class Bone&#123; public: float m_x, m_y, m_z;//这个坐标是定义在父骨骼坐标系中的&#125;; OK,除了使用矩阵，坐标或某东西描述子骨骼的位置，我们的Bone Class定义中还需要一些指针来建立层次结构，也就是说我们要能通过父骨骼找到子骨骼或反之。问题是我们需要什么指针呢？从父指向子还是反之？结论是看 你需要怎么用了。如果使用矩阵，需要将父子骨骼矩阵级联相乘，无论你的矩阵是左乘列向量还是右乘行向量，从哪边开始乘不重要，只要乘法中父子矩阵的左右位置正确，所以可以在骨骼中只存放指向父的指针，从子到父每次得到父矩阵循环相乘。也可以像DX中那样从根开始相乘并递归。在文本的DEMO中由于没用矩阵，直接使用坐标相加计算坐标，所以要指定父的位置，然后计算出子的位置，那么需要在Bone Class中加入子骨骼的指针，因为子骨骼有n个，所以需要n个指针吗？不一定，看看DirectX的做法，只需要两个就搞定了，指向第一子的和指向兄弟骨骼的。这样事先就不需要知道有多少子了。下面是修改后的Bone Class： 12345678class Bone&#123; Bone* m_pSibling; Bone* m_pFirstChild; float m_x, m_y, m_z;//pos in its parent's space float m_wx, m_wy, m_wz; //pos in world space&#125;; 同时增加了一组坐标，存放计算好的世界坐标系坐标。 将各个骨骼相对于其父骨骼摆放好，就行成了一个骨骼层次结构的初始位置，所谓初始是指定义骨骼层次时，那后来呢？后来动画改变了骨骼的相对位置，准确的说 一般是改变了骨骼自身的旋转而位置保持不变（特殊情况总是存在，比如雷曼，可以把拳头扔出去的那个家伙），总之骨骼动了，位置变化了。初始位置很重要，因为通过初始位置骨骼层次间的变换，我们确定了骨骼之间的关系，然后在动画中你可以只用旋转。 假设我们通过某种方法建立了骨骼层次结构，那么每一块骨骼的位置都依赖于其父骨骼的位置，而根骨骼没有父，他的位置就是整个骨骼体系在世界坐标系中的位 置。可以认为root的父就是世界坐标系。但是初始位置时，根骨骼一般不是在世界原点的，比如使用3d max character studio创建的biped骨架时，一般两脚之间是世界原点，而根骨骼-骨盆位于原点上方（+z轴上）。这有什么关系呢？其实也没什么大不了的，只是我 们在指定骨骼动画模型整体坐标时，比如设定坐标为（0，0，0），则根骨骼-骨盆被置于世界原点，假如xy平面是地面，那么人下半个身子到地面下了。我们 想让两脚之间算作人的原点，这样设定（0，0，0）的坐标时人就站在地面上了，所以可以在两脚之间设定一个额外的根骨骼放在世界原点上，或者这个骨骼并不 需要真实存在，只是在你的骨骼模型结构中保存骨盆骨骼到世界原点的变换矩阵。在微软X文件中，一般有一个Scene_Root节点，这算一个额外的骨骼 吧，他的变换矩阵为单位阵，表示他初始位于世界原点，而真正骨骼的根Bip01，作为Scene_root的子骨骼，其变换矩阵表示相对于root的位 置。说这么多其实我只是想解释下，为什么要存在Scene_Root这种额外的骨骼，以及加深理解骨骼定位骨骼动画模型整体的世界坐标的作用。 有了骨骼类，现在让我们看一下建立骨骼层次的代码，在bone class中增加一个构造函数和两个成员函数： 123456789101112131415class Bone&#123; public: Bone(float x, float y, float z):m_pSibling(NULL),m_pFirstChild(NULL),m_pFather(NULL),m_x(x),m_y(y),m_z(z)&#123;&#125; void SetFirstChild(Bone* pChild) &#123; m_pFirstChild = pChild; m_pFirstChild-&gt;m_pFather = this; &#125; void SetSibling(Bone* pSibling) &#123; m_pSibling = pSibling; m_pSibling-&gt;m_pFather = m_pFather; &#125;&#125;; 注意我增加了一个成员变量，Bone* m_pFather，这是指向父骨骼的指针，在这个例子中计算骨骼动画时本不需要这个指针，但我为了画一条从父骨骼关节到子骨骼关节的连线，增加了它，因 为每个骨骼只有第一子骨骼的指针，绘制父骨骼时从父到子画线就只能画一条，所以记录每个骨骼的父，在绘制子骨骼时画这根线。 有了这个函数，就可以创建骨骼层次了，例如： 1234567891011121314Bone* g_boneRoot;Bone* g_bone1, *g_bone21, *g_bone22;void buildBones()&#123; g_boneRoot = new Bone(0, 0, 0); g_bone1 = new Bone(0.1, 0, 0); g_bone21 = new Bone(0.0, 0.1, 0); g_bone22 = new Bone(0.1, 0.0, 0); g_boneRoot-&gt;SetFirstChild(g_bone1); g_bone1-&gt;SetFirstChild(g_bone21); g_bone21-&gt;SetSibling(g_bone22);&#125; 接下来是骨骼层次中最核心的部分，更新骨骼！由于动画的作用，某个骨骼的变换（TransformMatrix）变了，这时就要根据新的变换来计算，所以 这个过程一般称作UpdateBoneMatrix。因为骨骼的变换都是相对父的，要变换顶点必须使用世界变换矩阵，所以这个过程是根据更新了的某些骨骼 的骨骼变换矩阵（TransformMatrix）计算出所有骨骼的世界变换矩阵（也即CombinedMatrix）。在本文的例子中，骨骼只能平移， 甚至我们没有用矩阵，所以当有骨骼变动时要做的只是直接计算骨骼的世界坐标，因此函数命名为ComputeWorldPos，相当于 UpdateBoneMatrix后再用顶点乘以CombinedMatrix。 1234567891011121314class Bone&#123; //give father's world pos, compute the bone's world pos void ComputeWorldPos(float fatherWX, float fatherWY, float fatherWZ) &#123; m_wx = fatherWX+m_x; m_wy = fatherWY+m_y; m_wz = fatherWZ+m_z; if(m_pSibling!=NULL) m_pSibling-&gt;ComputeWorldPos(fatherWX, fatherWY, fatherWZ); if(m_pFirstChild!=NULL) m_pFirstChild-&gt;ComputeWorldPos(m_wx, m_wy, m_wz); &#125;&#125;; 其中的递归调用使用了微软例子的思想。 有了上述函数，当某骨骼运动时就可以让其子骨骼跟随运动了，但是怎么让骨骼运动呢？这就是动画问题了。我不打算在这个简单的例子中使用关键帧动画，而只是 通过程序每帧改变某些骨骼的位置，DEMO中animateBones就是做这个的，你可以在里面改变不同的骨骼看看效果。在本文下面会对骨骼的关键帧动 画做简单的讨论。 至此，我们定义了骨骼类的结构，手工创建了骨骼层次（实际引擎应该从文件读入），并且可以根据新位置更新骨骼了（实际引擎应该从动画数据读入新的变换或使 用物理计算），这样假如我们用连线将骨骼画出来，并且让某个骨骼动起来，我们就会看见他下面的子骨骼跟着动了。当然只有骨骼是不够的，我们要让Mesh跟 随骨骼运动，下面就是蒙皮了。 骨骼蒙皮动画(Skinned Mesh)的原理解析（二）蒙皮信息和蒙皮过程Skin info的定义上文曾讨论过，Skinned Mesh中Mesh是作为皮肤使用，蒙在骨骼之上的。为了让普通的Mesh具有蒙皮的功能，必须添加蒙皮信息，即Skin info。我们知道Mesh是由顶点构成的，建模时顶点是定义在模型自身坐标系的，即相对于Mesh原点的，而骨骼动画中决定模型顶点最终世界坐标的是骨 骼，所以要让骨骼决定顶点的世界坐标，这就要将顶点和骨骼联系起来，Skin info正是起了这个作用。下面是DEMO中顶点类的定义的代码片段： 1234567891011#define MAX_BONE_PER_VERTEX 4class Vertex&#123; float m_x, m_y, m_z; //local pos in mesh space float m_wX, m_wY, m_wZ;//blended vertex pos, in world space //skin info int m_boneNum; Bone* m_bones[MAX_BONE_PER_VERTEX]; float m_boneWeights[MAX_BONE_PER_VERTEX];&#125;; 顶点的Skin info包含影响该顶点的骨骼数目，指向这些骨骼的指针，这些骨骼作用于该顶点的权重(Skin weight)。由于只是一个简单的例子，这儿没有考虑优化，所以用静态数组存放骨骼指针和权重，且实际引擎中Skin info的定义方式不一定是这样的，但基本原理一致。 MAX_BONE_PER_VERTEX在这儿用来设置可同时影响顶点的最大骨骼数，实际上由于这个DEMO是手工进行Vertex Blending并且也没用硬件加速，可影响顶点的骨骼数量并没有限制，只是恰好需要一个常量来定义数组，所以定义了一下。在实际引擎中由于要使用硬件加 速，以及为了确保速度，一般会定义最大骨骼数。另外在本DEMO中，Skin info是手工设定的，而在实际项目中，一般是在建模软件中生成这些信息并导出。 Skin info的作用是使用各个骨骼的变换矩阵对顶点进行变换并乘以权重，这样某块骨骼只能对该顶点产生部分影响。各骨骼权重之和应该为1。 Skin info是针对顶点的，然而在使用Skin info前我们必须要使用Bone Offset Matrix对顶点进行变换，下面具体讨论Bone offset Matrix。（写下这句话的时候我感觉有些不妥，因为实际是先将所有的矩阵相乘最后再作用于顶点，这儿是按照理论上的顺序进行讲述吧，请不要与实际情况 混淆，其实他们也并不矛盾。而且在我们的DEMO中由于没有使用矩阵，所以变换的顺序和理论顺序是一致的） Bone Offset Matrix的含义和计算方法上文已经说过：“骨骼动画中决定模型顶点最终世界坐标的是骨骼，所以要让骨骼决定顶点的世界坐标”，现在让我们看下顶点受一块骨骼的作用时的坐标变换过程： mesh vertex (defined in mesh space)—-BoneOffsetMatrix—-&gt;Bone space—-BoneCombinedTransformMatrix—-&gt;World 从这个过程中可看出，需要首先将模型顶点从模型空间变换到某块骨骼自身的骨骼空间，然后才能利用骨骼的世界变换计算顶点的世界坐标。Bone Offset Matrix的作用正是将模型从顶点空间变换到骨骼空间。那么Bone Offset Matrix如何得到呢？下面具体分析： Mesh space是建模时使用的空间，mesh中顶点的位置相对于这个空间的原点定义。比如在3d max中建模时（视xy平面为地面，+z朝上），可将模型两脚之间的中点作为Mesh空间的原点，并将其放置在世界原点，这样左脚上某一顶点坐标是 （10，10，2），右脚上对称的一点坐标是（-10，10，2），头顶上某一顶点的坐标是（0，0，170）。由于此时Mesh空间和世界空间重合，上 述坐标既在Mesh空间也在世界空间，换句话说，此时实际是以世界空间作为Mesh空间了。在骨骼动画中，在世界中放置的是骨骼而不是Mesh，所以这个 区别并不重要。在3d max中添加骨骼的时候，也是将骨骼放入世界空间中，并调整骨骼的相对位置使得和mesh相吻合（即设置骨骼的TransformMatrix），得到骨 架的初始姿势以及相应的Transform Matrix(按惯例模型做成两臂侧平举直立，骨骼也要适合这个姿态)。由于骨骼的Transform Matrix（作用是将顶点从骨骼空间变换到上层空间）是基于其父骨骼空间的，只有根骨骼的Transform是基于世界空间的，所以要通过自下而上一层 层Transform变换（如果使用行向量右乘矩阵，这个Transform的累积过程就是 C=Mbone*Mfather*Mgrandpar*…*Mroot）,得到该骨骼在世界空间上的变换矩阵 - Combined Transform Matrix，即通过这个矩阵可将顶点从骨骼空间变换到世界空间。那么这个矩阵的逆矩阵就可以将世界空间中的顶点变换到某块骨骼的骨骼空间。由于Mesh 实际上就是定义在世界空间了，所以这个逆矩阵就是Offset Matrix。即OffsetMatrix就是骨骼在初始位置（没有经过任何动画改变）时将bone变换到世界空间的矩阵 （CombinedTransformMatrix）的逆矩阵，有一些资料称之为InverseMatrix。在几何流水线中，是通过变换矩阵将顶点变换 到上层空间，最终得到世界坐标，逆矩阵则做相反的事，所以Inverse这种提法也符合惯例。那么Offset这种提法从字面上怎么理解呢？Offset 即骨骼相对于世界原点的偏移，世界原点加上这个偏移就变成骨骼空间的原点，同样定义在世界空间中的点经过这个偏移矩阵的作用也被变换到骨骼空间了。从另一 角度理解，在动画中模型中顶点的位置是根据骨骼位置动态计算的，也就是说顶点跟着骨骼动，但首先必须确定顶点和骨骼之间的相对位置（即顶点在该骨骼坐标系 中的位置），一个骨骼可能对应很多顶点，如果要保存这个相对位置每个顶点对于每块受控制的骨骼都要保存，这样就要保存太多的矩阵了。。。所以只保存 mesh空间到骨骼空间的变换（即OffsetMatrix），然后通过这个变换计算每个顶点在该骨骼空间中的坐标，所以OffsetMatrix也反应 了mesh和每块骨骼的相对位置，只是这个位置是间接的通过和世界坐标空间的关系表达的，在初始位置将骨骼按照模型的形状摆好是关键之处。 以上的分析是通过将mesh space和world space重合得到Offset Matrix的计算方法。那么如果他们不重合呢？那就要先计算顶点从mesh space变换到world space的变换矩阵，并乘上（还是右乘为例）Combined Matrix的Inverse Matrix从而得到Offset Matrix。但是这不是找麻烦吗？因为Mesh的原点在哪儿并不重要，为啥不让他们重合呢？ 还有一个问题是，既然Offset Matrix可以计算出来，为啥还要在骨骼动画文件中同时提供TransformMatrix和OffsetMatrix呢？实际上文件中确实可以不提供 OffsetMatrix，而只在载入时计算。但TransformMatrix不可缺少，动画关键帧数据一般只存储骨骼的旋转和根骨骼的位置，骨骼间的 相对位置还是要靠TransformMatrix提供。在微软的X文件结构中提供了OffsetMatrix，原因是什么呢？我不知道。我猜想一个可能的 原因是为了兼容性和灵活性，比如mesh并没有定义在世界坐标系，而是作为一个object放置在3d max中，在导出骨骼动画时不能简单的认为mesh的顶点坐标是相对于世界原点的，还要把这个object的位置考虑进去，于是导出插件要计算出 OffsetMatrix并保存在x文件中以避免兼容性问题。 关于OffsetMatrix和TransformMatrix含有平移，旋转和缩放的讨论： 首先，OffsetMatrix取决于骨骼的初始位置(即TransformMatrix)，由于骨骼动画中我们使用的是动画中的位置，初始位置是什么样 并不重要，所以可以在初始位置中只包含平移，而旋转和缩放在动画中设置（一般也仅仅使用旋转，这也是为啥动画通常中可以用一个四元数表示骨骼的关键帧）。 在这种情况下，OffsetMatrix只包含平移即可。因此一些引擎的Bone中不存放Transform矩阵，而只存放骨骼在父骨骼空间中的坐标，然 后旋转只在动画帧中设置，最基本的骨骼动画即可实现。但也可在Transform和Offset Matrix中包括旋转和缩放，这样可以提高创建动画时的容错性。 在本文DEMO中，我们也没有使用矩阵保存Bone Offset，而只用了一个坐标保存偏移位置。 1234567891011121314151617181920212223class BoneOffset&#123;public: float m_offx, m_offy, m_offz;&#125;;//在Bone class中，有一个方法用来计算Bone Offsetclass Bone&#123;public: BoneOffset m_boneOffset; //called after ComputeWorldPos() when bone loaded but not animated void ComputeBoneOffset() &#123; m_boneOffset.m_offx = -m_wx; m_boneOffset.m_offy = -m_wy; m_boneOffset.m_offz = -m_wz; if(m_pSibling!=NULL) m_pSibling-&gt;ComputeBoneOffset(); if(m_pFirstChild!=NULL) m_pFirstChild-&gt;ComputeBoneOffset(); &#125;&#125;; 在ComputeBoneOffset()中，使用计算好的骨骼的世界坐标来计算bone offset,这儿的计算只是取一个负数，在实际引擎中，如果bone offset是一个矩阵，这儿就应该是求逆矩阵，本文不做讨论了。注意由于我们计算Bone offset时是使用计算好的世界坐标，所以在这之前必须在初始位置时对根骨骼调用ComputeWorldPos()以计算出各个骨骼在初始位置时的世界坐标。 最终:顶点混合（vertex blending）现在我们有了Skin info,有了Bone offset，可谓万事具备，只欠东风了。现在就可以做顶点混合了，这是骨骼动画的精髓所在，正是这个技术消除了关节处的裂缝。顶点混合后得到了顶点新的 世界坐标，对所有的顶点执行vertex blending后，从Mesh的角度看，Mesh deform(变形)了，变成动画需要的形状了。 首先，让我们看看使用单块骨骼对顶点进行作用的过程，以下是DEMO中的相关代码： 12345678910111213141516class Vertex&#123; public: void ComputeWorldPosByBone(Bone* pBone, float&amp; outX, float&amp; outY, float&amp; outZ) &#123; //step1: transform vertex from mesh space to bone space outX = m_x+pBone-&gt;m_boneOffset.m_offx; outY = m_y+pBone-&gt;m_boneOffset.m_offy; outZ = m_z+pBone-&gt;m_boneOffset.m_offz; //step2: transform vertex from bone space to world sapce outX += pBone-&gt;m_wx; outY += pBone-&gt;m_wy; outZ += pBone-&gt;m_wz; &#125;&#125;; 这个函数使用一块骨骼对顶点进行变换，将顶点从Mesh坐标系变换到世界坐标系，这儿使用了骨骼的Bone Offset Matrix和 Combined Transform Matrix (嗯，我知道这儿没用矩阵，但意思是一样的对吗) 对于多块骨骼，对每块骨骼执行这个过程并将结果根据权重混合(即vertex blending)就得到顶点最终的世界坐标。进行vertex blending的代码如下： 1234567891011121314151617181920212223class Vertex&#123; void BlendVertex() &#123; //do the vertex blending,get the vertex's pos in world space m_wX = 0; m_wY = 0; m_wZ = 0; for(int i=0; i&lt;m_boneNum; ++i) &#123; float tx, ty, tz; ComputeWorldPosByBone(m_bones[i], tx, ty, tz); tx*= m_boneWeights[i]; ty*= m_boneWeights[i]; tz*= m_boneWeights[i]; m_wX += tx; m_wY += ty; m_wZ += tz; &#125; &#125;&#125;; 这些函数我都放在Vertex类中了，因为只是一个简单DEMO所以没有特别考虑引擎结构问题，在BlendVertex()中，遍历影响该顶点的所有骨 骼，用每块骨骼计算出顶点的世界坐标，然后使用Skin Weight对这些坐标进行加权平均。tx,ty,tz是某块骨骼作用后顶点的世界坐标乘以权重后的值，这些值相加后就是最终的世界坐标了。 现在让我们用一个公式回顾一下Vertex blending的整个过程(使用矩阵变换) Vworld = Vmesh BoneOffsetMatrix1 CombindMatrix1 * Weight1 + Vmesh BoneOffsetMatrix2 CombinedMatrix2 * Weight2 + … + Vmesh BoneOffsetMatrixN CombindMatrixN * WeightN （这个公式使用的是行向量左乘矩阵） 由于BoneOffsetMatrix和Combined Matrix都是矩阵，可以先相乘这样就减少很多计算了，在实际PC游戏中可以使用VS进行硬件加速计算。 动画数据和播放动画正如前面所说，本例子中并没有使用动画数据，但动画数据在骨骼动画中确实最重要的，因为我们的最终目的就是播放动画。所以作为DEMO的补充，这儿简要讨论一下动画数据相关问题。其实我觉得动画的处理在骨骼动画中是很灵活的，需要专门的一篇文章讨论。 本文的最开始说，3D模型动画的基本原理是让模型中各顶点的位置随时间变化。骨骼动画的情况是，骨骼的位置随时间变化，顶点位置随骨骼变化。所以动画数据 中必然包含的是骨骼的运动信息。可以在动画帧中包含某时刻骨骼的Transform Matrix，但骨骼一般只是做旋转，所以也可以用一个四元数表示。但有时候骨骼层次整体会在动画中进行平移，所以可能需要在动画帧中包含根骨骼的位置信 息。播放动画时，给出当前播放的时间值，对于每块需要动画的骨骼，根据这个值找出该骨骼前后两个关键帧，根据时间差进行插值，对于四元数要使用四元数球面 插值。然后将插值得到的四元数转换成Transform Matrix,再调用UpdateBoneMatrix（其含义上文已介绍）更新计算整个骨骼层次的CombinedMatrix。 总结从结构上看，SkinnedMesh包括：动画数据，骨骼数据，包含Skin info的Mesh数据，以及Bone Offset Matrix。 从过程上看，载入阶段：载入并建立骨骼层次结构，计算或载入Bone Offset Matrix，载入Mesh数据和Skin info（如果是DX的Skinned Mesh这个过程更复杂，因为还涉及到Matrix Palette等）。运行阶段：根据时间从动画数据中获取骨骼当前时刻的Transform Matrix，调用UpdateBoneMatrix计算出各骨骼的CombinedMatrix，对于每个顶点根据Skin info进行Vertex Blending计算出顶点的世界坐标，最终进行模型的渲染。]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>动画</tag>
        <tag>骨骼动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[转] 浅谈Unity3D骨骼动画]]></title>
    <url>%2F2019%2F03%2F25%2FUnity%E7%AC%94%E8%AE%B0%2F%E8%BD%AC-%E6%B5%85%E8%B0%88Unity3D%E9%AA%A8%E9%AA%BC%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[浅谈Unity3D骨骼动画。 转载请标明出处http://www.cnblogs.com/zblade/ 最近研究了一下游戏中模型的骨骼动画的原理，做一个学习笔记，便于大家共同学习探讨。 ps:最近改bug改的要死要活，博客写的吭哧吭哧的~ 首先列出学习参考的前人的文章，本文较多的参考了其中的表述： 1. 骨骼动画详解 2. OpenGL10-骨骼动画原理篇 骨骼动画、关节动画、关键帧动画在实际的游戏中，用的最多的是这三种基本的动画。 关键帧动画：模型在每个关键帧中都是一个固定的姿势，相当于一个“快照”，通过在不同的关键帧中进行插值平滑计算，可以得到一个较为流畅的动画表现。关键帧动画的一个优势是只需要做插值计算，相对于其他的动画计算量很小，但是劣势也比较明显，基于固定的“快照”进行插值计算，表现大大被限制，同时插值如果不够平滑容易出现尖刺等现象， 同时一个无法忽略的问题就是，对于每帧动画都需要进行内存占用，在帧数较多和顶点数较多的时候，这会带来极大的内存占用。当然帧动画也有其实际的应用场景，目前在一些模型的表情动画中会较多的应用到帧动画，因为其动画较少，同时可以用插值实现较为平滑的效果，不需要骨骼动画。 关节动画：早期出现的一种动画，在这种动画中，模型整体不是一个Mesh, 而是分为多个Mesh，通过父子的关系进行组织，这样父节点的Mesh就会带动子节点的Mesh进行变换，这样层层的变换关系，就可以得到各个子Mesh在不同关键帧中的位置。关节动画相比于关键帧动画，依赖于各个关键帧的动画数据，可以实时的计算出各个Mesh的位置，不再受限于固定的位置，但是由于是分散的各个Mesh，这样在不同Mesh的结合处容易出现裂缝。 骨骼动画：进一步的动画类型，原理构成极其简单，但是解决问题极其有优势。将模型分为骨骼Bone和蒙皮Mesh两个部分，其基本的原理可以阐述为：模型的骨骼可分为基本多层父子骨骼，在动画关键帧数据的驱动下，计算出各个父子骨骼的位置，基于骨骼的控制通过顶点混合动态计算出蒙皮网格的顶点。在骨骼动画中，通常包含的是骨骼层次数据，网格Mesh数据， 网格蒙皮数据Skin Info和骨骼的动画关键帧数据。本文重点讲解一下骨骼动画。 骨骼动画原理分析对于Skinned Mesh的理解关键是蒙皮的计算过程，这里的皮，并不是我们常见的在shader中用到的贴图texture，而是模型的mesh, 所以蒙皮其实就是计算mesh相对于骨骼的位置变换过程。如果我们的骨骼没有变化，那么我们的mesh就没有变化，此时的mesh就相当于一个静态的mesh。所以对于skinned的理解，就是指具有蒙皮数据skin info的mesh :D。 在实际的实例中，skin info主要包含当前mesh上的顶点受到哪些骨骼影响，各个骨骼的影响权重。借用文章1中的表述，整个mesh顶点的变换过程可以用矩阵的方式表述： Vworld = Vmesh BoneOffsetMatrix1 CombineMatrix1 W1 +Vmesh BoneOffsetMatrix2 CombineMatrix2 W2 +…+ Vmesh BoneOffsetMatrixn CombineMatrixn * Wn 其中BoneOffsetMatrix 和 CombineMatrix在下面的讲解中会详细讲解求解过程。 骨骼动画中的骨骼在我们常见的模型建模中，美术通常将模型设置成双手水平，双腿分立的类“大”字型。 为什么要用这样的方式？ 这与我们的模型的骨骼有一定的关系。通常模型骨骼数量都有一个限制（通常为30，下面会解释为什么受到限制），模型不可能为一根骨骼，如果为一根骨骼，那么模型的表现就会显得比较单一，想要表现出类似于人体的动画，一般都会有多个骨骼。对于每个骨骼，如何建立其组织关系，在建模的时候就进行了基本的设定。在完成建模后，在进行骨骼绑定的时候，通常美术会选择模型的盆骨做为模型的根骨骼。那么基于根骨骼，可以递推出各个骨骼相对于根骨的父子关系。通过骨骼所在的空间，其原点我们会选择两个脚之间的中点作为原点，这时候就会发现根骨骼并没有和原点重合，这时美术会构建一个Scene_Root做为额外的骨骼，其位置就为世界原点，而真正的根骨骼Bip01会作为Scene_Root的唯一子骨骼。 基于根骨骼，我们可以递推出各个骨骼相对于根骨骼的父子转换矩阵，通常这样的矩阵转换为旋转矩阵，不存在平移和缩放，当然比如你的一个模型动画是拉长模型的身体（比如海贼王这种动画:D），那么你可以添加平移和缩放到变换矩阵中。此时对于整个模型就有了一个基本的直观的感受了，模型的具体动画，取决于模型的根骨骼，牵一发而动全身（这儿的牵一发是指模型的动画数据驱动），整个模型的运动会带动外面的mesh一起运动，就可以表现出整个模型的骨骼动画，这样，我们对于骨骼动画就有一个基本的理解。 借用参考文1的说话，骨骼的本质，其实就是一个坐标空间，我们在做骨骼动画的时候，关键帧中包含的对骨骼的变换主要为旋转矩阵，所以对骨骼的变换就是对骨骼空间的旋转变换。说简单点，一个骨骼动画，带来的变换，首先作用在根骨骼上，影响根骨骼的坐标空间，然后递归的影响根骨的子骨骼，这样层层的递归影响，最后带来的就是整体骨骼变换。基于此，我们就可以理解关节的作用，关节就是骨骼自身空间的原点。而关节的位置由当前骨骼在其父节点骨骼空间中的位置来描述，围绕关节的旋转就是骨骼空间自身的旋转，这样变换就通过关节层层递归传递。用c++的表述，可以定义一个基本的骨骼类，主要包含自己的世界坐标中的位置，在父节点中的位置，其第一个子节点，其兄弟骨骼的指针，代码依据于文章1： 1234567891011121314151617181920212223class Bone&#123; Bone* m_pFirstChild; Bone* m_pSibling; float m_x, m_y, m_z; // pos in parents' space float m_wx, m_wy, m_wz; // pos in world space // public: Bone(float x, float y, float z): m_pSibling(NULL),m_pFirstChild(NULL),m_pFather(NULL),m_x(x), m_y(y), m_z(z)&#123;&#125; // void SetFirstChild(Bone* pChild) &#123; m_pFirstChild = pChild; m_pFirstChild-&gt;m_pFather = this; &#125; // void SetSibling(Bone* pSibling) &#123; m_pSibling = pSibling; m_pSibling-&gt;m_pFather = m_pFather; &#125;&#125; 这样，当父节点骨骼发生变换的时候，子节点的骨骼就会做相应的变换，这样的操作可以称为 UpdateBoneMatrix（更新骨骼矩阵），这样的操作可以用一个方法ComputeWorldPos来表示，这样可以用递归的方式在Bone中实现，代码依据于文章1： 123456789101112131415class Bone&#123; void ComputeWorldPos(float fatherX, float fatherY, float fatherZ) &#123; m_wx = fatherX + m_x; m_wy = fatherY + m_y; m_wz = fatherZ + m_z; // 兄弟节点用父节点传递的参数 if(m_pSibling ！=NULL) m_pSibling -&gt;ComputeWorldPos(fatherX, fatherY, fatherZ) // 递归到子节点计算其位置 if(m_pFirstChild!=NULL) m_pFirstChild -&gt;ComputeWorldPos(m_wx, m_wy, m_wz) &#125;&#125; 这样，当父节点骨骼发生变换的时候，子节点的骨骼都会做出相应的变换，从而得到最新的位置、朝向等信息，骨骼发生变化，从而会带动外在的mesh发生变化，所以整体的模型就表现出运动起来。基于此，可以理解为什么骨骼是骨骼动画的核心。 骨骼动画中的蒙皮关于蒙皮的一种理解在说完骨骼后，对于整体模型在动画中骨骼的变换，可以有一个大致的理解，当然模型只是内在的，动画的外在表现就是模型的蒙皮变化，所以骨骼动画中的第二部分就是蒙皮的计算。这里的皮，就是前面说过的Mesh。 首先，需要明确的是Mesh所在的空间。在建模的时候，模型的Mesh是和骨骼一样处于同样的空间中的，Mesh中的各个顶点是基于Mesh的原点来进行定位的。但是模型在运动表现的时候，是根据骨骼的变换来做相应的动作的，对应的Mesh上的顶点就需要做出对应的转换，所以Mesh的顶点需要转换到对应的骨骼所在的坐标空间中，进行相应的位置变换，因此对应的需要添加蒙皮信息，也就是skin info，主要是当前顶点受到哪些骨骼的影响，影响的权重等，借用文章1的表述，可以用C++表示一个顶点类，代码依据于文章1： 12345678910#define MAX_BONE_VERTEX 4class Vertex&#123; float m_x, m_y, m_z; // local pos in mesh space float m_wx, m_wy, m_wz; // pos in world space //skin info int m_boneNum; Bone* m_bones[MAX_BONE_VERTEX]; float m_boneWeights[MAX_BONE_VERTEX];&#125; 当然，这儿只是一个简单的表述，具体的在引擎中会有规范的设计。那么我们的顶点在跟随骨骼做运动的时候，是如何计算自己的位置的？我们就需要引入BoneOffsetMatrix 和 Transform Matrix的概念。 在前面，我们已经提到，顶点需要依附于骨骼进行位置计算，但是建模的时候，顶点的位置是基于Mesh原点进行建模的，通常情况下，Mesh的原点是和模型的骨骼的根骨骼处于同一个坐标空间中，那么 BoneOffsetMatrix就是用来将Mesh中顶点从Mesh空间转换到骨骼所在空间中。这就是很多文章中提及的Binding Pos的设置。 在建模的时候，对于每个骨骼，我们是可以得到其对应的Transform Matrix（用来层层计算到父节点所在空间中），其中根骨骼的Transform Matrix是基于世界空间的转换，所以对于每一个下面的子骨骼，要计算其Transform Matrix，需要进行一个矩阵的连乘操作。最后得到的最终矩阵连乘结果矩阵就是Combined Transform Matrix，基于这个矩阵，就可以将顶点从骨骼所在的空间转换到世界空间中。反过来，这个矩阵的逆矩阵（一般只考虑可以取逆的操作），就是从世界空间中转换到该骨骼的空间中，由于Mesh的定义基于Mesh原点，Mesh原点就在世界空间中，所以这个逆矩阵就是需要计算的的 Offset Matrix，也被称为Inverse Matrix，这个逆矩阵一般实在初始位置中求得，通过取逆即可获得。 在实际的计算中，每个骨骼可能会对应多个顶点，如果每个顶点都保存其对应的骨骼的变换矩阵，那么大量的顶点就会包含非常多的变换矩阵，带来内存数据的扩大。所以我们只需要保存当前该骨骼在初始位置，对应的从世界空间到其骨骼空间的变换矩阵，那么其对应的每个顶点在每次变换操作的时候，只需要对应的用offset Matrix来操作即可。（没懂） 对于上面的Transform Matrix和offset Matrix，是纳入了旋转、平移和缩放的。其实offset Matrix取决于骨骼的初始位置，此时一般只包含了平移（此时还没有动画，所以没有旋转和缩放），在动画中，一般也以旋转为主（所以大部分的动画的关键帧用四元数表示）。在矩阵中都包含三种矩阵，是处于兼容性考虑。 这儿就基于平移，做一个基本的蒙皮的计算过程，代码主要依据于文章1： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class BoneOffset&#123; public: float m_offx, m_offy, m_offz; //暂时只考虑平移&#125;class Bone&#123; public : BoneOffset* m_boneOffset; // void ComputeBoneOffset() &#123; m_boneOffset.m_offx -= m_wx; m_boneOffset.m_offy -= m_wy; m_boneOffset.m_offz -= m_wz; if(m_pSibling != NULL) m_pSibling-&gt;ComputeBoneOffset(); if(m_pFirstChild !=NULL) m_pFirstChild-&gt;ComputeBoneOffset(); &#125;&#125; //顶点类的计算class Vertex&#123; public: void ComputeWorldPosByBone(Bone* pBone, float &amp;outX, float&amp; outy, float&amp; outz) &#123; //从mesh空间转换到bone空间 outx = m_x + pBone-&gt;m_boneOffset.m_offx; outy = m_y + pBone-&gt;m_boneOffset.m_offy; outz = m_z + pBone-&gt;m_boneOffset.m_offz; //从bone空间转换到世界空间 outx += pBone-&gt;m_wx; outy += pBone-&gt;m_wy; outz += pBone-&gt;m_wz; &#125; //GPU中计算顶点的位置 void BlendVertex() ｛ float m_wx = 0; float m_wy = 0; float m_wz = 0; for(int i=0; i &lt; m_boneNum; i++) &#123; float tx, ty,tz; ComputeWorldPosByBone(m_bones[i], tx, ty,tz); tx *= m_boneWeights[i]; ty *= m_boneWeights[i]; tz *= m_boneWeights[i]; m_wx += tx; m_wy += ty; m_wz += tz; &#125; ｝&#125; 仔细捋一捋上面的代码，就可以理解整体的蒙皮变换的过程，当然，这儿只用了矩阵变换中的平移变换，如果考虑加上旋转和缩放，则回到最初的计算公式中了。至此，对于基本的骨骼动画中的骨骼变换和蒙皮变换，有了一个详细的解释。下面说说Unity中是如何处理骨骼变换的。 关于蒙皮的新的理解(重点理解)在我写完这篇文章后，给同事查看，同事觉得较为绕，有点迷糊，后来我想了一下，可以采用一种较为清晰的方式重新讲解一下蒙皮的过程： 首先给出蒙皮计算的过程： 顶点在模型坐标系中位置 -&gt; 骨骼空间中位置 -&gt; 变换后的骨骼空间中的位置-&gt;模型坐标系中的位置 -&gt; 世界空间中的位置 关于蒙皮的定义，其实质就是骨骼在动画数据的驱动下，变换位置，依附于该骨骼的mesh顶点会对应的变换到新的位置（在世界空间中）的整个过程。 确定最终结果： mesh上的顶点在世界空间中的位置变换到最新位置 那么怎么得到这样的一个结果？在前文中，我们已经知道，骨骼是和mesh分离的，骨骼依赖于根骨骼，层层递进得到各自的转换矩阵。而mesh是在模型建模中，基于模型空间得到的位置设定。在这儿，根骨骼的空间原点和mesh的空间原点重合，也就是mesh的坐标系和根骨骼的坐标系为同一个坐标系，也就是模型坐标系。 我们已经知道，骨骼本身就是一个坐标系空间，其原点就是关节点。那么在建模的时候，建模软件就会有一步计算操作，称为BindingPos操作。这步操作可以这样理解，mesh上分布了众多的顶点，对应于单独的一个骨骼，我们可以得到其骨骼空间的转换矩阵，以及那些顶点依附于其上。对于依附其上的顶点，建模的时候，以及基于模型空间给出了一个模型空间中的位置，那么其相对于当前该骨骼空间的位置，可以基于模型空间位置与骨骼的转换矩阵得到，这个位置就是其BindingPos， 这个变换矩阵，就是BindingPosMatrix，基于这个矩阵，可以将顶点位置从模型空间转换到骨骼空间。 到这儿，我们完成了： 顶点在模型坐标系中位置 -&gt; 骨骼空间中位置 接下来我们继续下面的计算，在骨骼动画中，每个动画数据中，会带来当前骨骼的新的变化(旋转为主)，那么在当前动画数据的驱动下，当前骨骼变换到新的位置，得到新的骨骼矩阵，那么依附其上的顶点的位置也会变换，首先是将顶点位置从模型空间中转换到当前该骨骼的空间中，然后基于骨骼的当前这次变换矩阵（比如旋转90度对应的矩阵），得到其在该骨骼空间中的新位置，这个新的位置再和当前骨骼在和根骨骼的变换矩阵相作用，变换回模型空间中。 到这儿，我们完成了： 骨骼空间中位置 -&gt; 变换后的骨骼空间中的位置-&gt;模型坐标系中的位置 接下来，就是模型坐标系到世界坐标系的变换，这个就不多说，就是一个MVP的转换矩阵。 这样，我们就完成了一次骨骼变换，依附其上的顶点的位置变换的整个过程，由点及面，整个蒙皮的过程就是一个大量该类变换的过程。当然，这儿还没有说一个顶点受多个骨骼影响的情况，其实质也很简单，就是一个顶点受到多个骨骼的影响，那么就各自分配一个对应的权重，那么在计算的时候，各自单独计算，然后乘上权重系数，进行累加，就可以得到mesh上各个顶点的最新位置信息。 Unity3D骨骼动画处理前面讲解的对于骨骼动画中的骨骼变换，蒙皮的计算，都是在CPU中进行的。在实际的游戏引擎中，这些都是分开处理的，较为通用的处理是将骨骼的动画数据驱动放在CPU中，计算出骨骼的变换矩阵，然后传递给GPU中进行蒙皮计算。在DX10的时候，一般的shader给出的寄存器的大小在128的大小，一个变换矩阵为4x4，如果去除最后一行(0,0,0,1)就可以用3个float表示，那么最多可以表示，嗯，42个左右，如果考虑进行性能优化，不完全占用寄存器的大小，那么一般会限制在30根骨骼的大小上。将这些骨骼的变换矩阵在CPU进行计算后，就可以封装成skin info传递到GPU中。 在GPU的计算中，就会取出这些mesh上的顶点进行对应的位置计算，基于骨骼的转换矩阵和骨骼的权重，得到最新的位置，从而进行一次顶点计算和描绘。之所以将骨骼动画的两个部分分开处理，一个原因就是CPU的处理能力相对而言没有GPU快捷，一般一个模型的骨骼数量是较小的，但是mesh上的顶点数量较大，利用GPU的并行处理能力优势，可以分担CPU的计算压力。 在DX11还是DX12之后（记不太清楚），骨骼变换矩阵的计算结果不再存储在寄存器中，而是存储在一个buffer中，这样的buffer大小基于骨骼数量的大小在第一次计算的时候设定，之后每次骨骼动画数据驱动得到新的变换矩阵，就依次更改对应的buffer中存储的变换矩阵，这样就不再受到寄存器的大小而限制骨骼的根数的大小。但是实际的优化中，都会尽量优化模型的骨骼的数量，毕竟数量越多，特别是影响顶点的骨骼数量越多，那么计算量就会越大，正常的思维是优化骨骼数量而不是去扩展buffer的大小：D 在文章2中，对于GPU的蒙皮计算做了较大的性能优化，主要的思维也是这样，在CPU中进行骨骼变换，将变换的结果传递到GPU中，从而进行蒙皮计算。基本的思维和前面说的变换思维一致，其基本的优化重点也是想利用一个buffer来缓存变换矩阵，从而优化性能。这儿我就重点分析一下shader部分的代码，其在cpu部分的代码处理基本和前面的代码思想一致： 如果采用CPU的计算骨骼变换，那么GPU的shader: 1234567891011121314151617181920212223242526272829303132333435uniform float4x4 _Matrices[24]; //设置的骨骼数量最大为24struct appdata&#123; float4 vertex:POSITION; float2 uv:TEXCOORD0; //存储的就是骨骼的变换矩阵，x/y为第一个骨骼的索引和权重，z/w为第二个的索引和权重 float4 tangent:TANGENT;&#125;；v2f vert(appdata v)&#123; v2f o; //蒙皮计算位置,注意看，其实就是矩阵变化加权重的表示 float4 pos = mul(_Matrices[v.tangent.x], v.vertex)* v.tangent.y + mul(_Matrices[v.tangent.z], v.vertex)* v.tangent.w //通用的mvp计算 o.vertex = mul(UNITY_MATRIX_MVP, pos); o.uv = TRANSFORM_TEX(v.uv, _MainTex); return o;&#125;//怎么计算index和权重,此处一个蒙皮顶点受到2根骨骼的影响Vector4[] tangents = new Vector4[mesh.vertexCount];for(int i=0; i &lt; mesh.vertexCount;++i)&#123; BoneWeight boneWeight = mesh.boneWeights[i]; tangents[i].x = boneWeight.boneIndex0; tangents[i].y = boneWeight.weight0; tangents[i].z = boneWeight.boneIndex1; tangents[i].w = boneWeight.weight1;&#125;newMesh.tangents = tangents; 其优化的策略，就是用贴图的方式来存储这个变换矩阵，参看一下代码吧： 123456789101112131415161718192021222324252627282930313233343536inline float4 indexToUV(int index)&#123; int row = (int) (index /_MatricesTexSize.x); int col = (index - row * _MatricesTexsize.x; return float4(col/_MatricesTexSize.x, row/_MatricesTexSize.y, 0 , 0);&#125;//算出当前的变换矩阵inline float4x4 getMatrix(int frameStartIndex, float boneIndex)&#123; int matStartIndex = frameStartIndex + boneIndex*3; float4 row0 = tex2Dlod(_MatricesTex, indexToUV(matStartIndx)); float4 row1 = tex2Dlod(_MatricesTex, indexToUV(matStartIndx + 1)); float4 row2 = tex2Dlod(_MatricesTex, indexToUV(matStartIndx + 2)); float4 row3 = float4(0,0,0,0); float4x4 mat = float4x4(row0, row1, row2, row3); return mat;&#125;v2f vert(appdata v)&#123; v2f o; float time = _Time.y; //算出当前时间对应的index int framIndex = (int)(((_Time.y + v.uv2.x)*_AnimFPS)%(_AnimLength * _AnimFPS)); int frameStartIndex = frameIndex * _MatricesTexFrameTexls; //去除对应的变换矩阵 float4 mat0 = getMatrix(frameStartIndex, v.tangent.x); float4 mat1 = getMatrix(frameStartIndex, v.tangent.z); float4 pos = mul(mat0, v.vertex) * v.tangent,y + mul(mat1, v.vertex) * v.tangent.w; o.vertex = mul(UNITY_MATRIX_MVP, pos); o.uv = TRANSFOR_TEX(v.uv, _MainTex); return o; 总结：综合整篇文章，对于骨骼动画有了一个较为详细的讲解，主要是参考两篇文章，我只是做了一个知识的搬运工，今儿就写到这儿，后面有更多的更新，会继续回来更改。]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>动画</tag>
        <tag>骨骼动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Unity] 动画系统]]></title>
    <url>%2F2019%2F03%2F25%2FUnity%E7%AC%94%E8%AE%B0%2FUnity-%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[Unity中的动画控制系统。 动画系统Unity的动画系统支持引擎内编辑动画，也支持外部导入FBX动画。由于引擎内置的的动画编辑器没有骨骼动画的概念，所以只能编辑每一帧模型的Transform、整体的旋转、缩放和平移。 模型：Unity显示模型必须给游戏对象提供Mesh Filter和Mesh Renderer组件，前者表示模型需要用的Mesh文件，后者通过材质的贴图和Shader最终将这个模型渲染出来。 Mesh Filter：Mesh Render：Prefab：动画编辑器：动画编辑器的原理就是通过时间线来修改组件的信息，比如修改Transform位置信息，修改Renderer组件或者修改颜色信息，控制模型显示隐藏；此外，还可以在时间线上添加动画事件，编辑后的动画需要配合Animator组件使用。 导入类动画：人形重定向动画：人形重定向动画就是多个身形不同的人物模型也可以共用一份骨骼动画，此技术应用在游戏中会大量减少内存和包体大小。重定向动画的原理就是将不同身形的骨骼信息套入相同的动画中来运算。 通用动画：老版动画：导入类动画事件：动画控制器：动画控制器的原理就是状态机：]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Unity] UI框架学习]]></title>
    <url>%2F2019%2F03%2F25%2FUnity%E7%AC%94%E8%AE%B0%2FUnity-UI%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[[Unity3D 游戏开发] 第十一章-资源加载与优化]]></title>
    <url>%2F2019%2F03%2F22%2FUnity%E7%AC%94%E8%AE%B0%2FUnity-%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E4%B8%8E%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[资源加载与优化：AssetBundle和优化工具。 资源加载与优化编辑模式：加载资源：编辑模式下的资源可分为两类：一类是引擎可识别的资源，例如Prefab、声音、视频、动画和UI等；另一类是引擎无法识别的资源，例如外部导入的资源，这类资源需要通过第三方将它的信息解析出来，最终组织成引擎内可识别资源才可以使用。 可以提供一个相对路径，使用AssetDatabase.LoadAssetAtPath()方法读取任意对象，如果使用GameObject.Instance()只能创建新对象，这会丢失Prefab的引用。 实例化Prefab在编辑模式下，实例化Prefab需要使用PrefabUtility.InstantiatePrefab()方法。 创建Prefab使用PrefabUtility.CreatePrefab()方法可以创建Prefab，此时需要提供保存的目录以及当前的游戏对象，其中ReplacePrefabOptions.ConnectToPrefab表示创建Prefab的同时自动关联到创建它的这个游戏对象。 更新Prefab：卸载资源：游戏对象和资源的关系游戏对象与资源是一种引用关系。例如一个模型是由贴图和Mesh组成，将它拖入场景中时，生成的游戏对象就会引用这两种资源。当程序调用GambObject.Destory()或者GameObject.DestoryImmediate()方法时，只会卸载掉它的对象，它身上引用的贴图和Mesh还在内存中。 Unity这样做的原因：很多游戏对象的加载和卸载是很频繁的，如果每次卸载都将引用的资源清理掉，无疑会造成IO的阻塞。但如果长时间不卸载这些资源，那么内存占用必将升高。所以Unity又提供了一个方法来自动卸载无用资源： 调用EditorUtility.UnloadUnusedAssetsImmediate()方法即可卸载编辑器下无用的资源了。 12345678public class Script_11_06&#123; [MenuItem("Assets/My Tools/UnloadUnusedAssetsImmediate",false,3)] static void UnloadUnusedAssetsImmediate() &#123; EditorUtility.UnloadUnusedAssetsImmediate(); &#125;&#125; 版本管理：资源在导入Unity的时候，会自动生成很多中间资源，这些资源都不需要上传，只需要将Asset、ProjectSettings文件夹下的所有文件以及.meta文件上传即可。 .meta文件：.meta文件是Unity自动生成的。每个游戏资源都会有一个对应的.meta文件，它会标记资源在引擎中的一些设置信息，我们可以在资源视图面板中重新设置这些资源的参数。此时.meta文件会保留这些参数，将资源拖入工程时，就会利用这些参数重新压缩资源。换句话说，资源在用户无感知的情况下被Unity优化了。 每个.meta文件都会记录guid这个重要信息。guid就是用来关联资源和游戏对象的引用的。 多工程：同步文件：svn外链：运行模式：编辑模式下可以放成千上万的资源，这些资源不需要打包在发布的游戏包中。打包时，Unity会自动删除掉没有引用的资源，只会保留Resources目录以及StreamingAssets目录下的资源。 引用资源：只有被引用到的资源Unity才会打包，那么如何分辨资源是否被引用呢： B贴图被New Material材质引用； New Material材质被Cube引用； Cube被Scene引用； 如果Scene被添加到Scenes In Build中，那么以上这几种资源都会被打入游戏包中。 Resources：Resources目录下的资源无论是否有引用关系，都会被强制打在游戏包中。Resources文件夹可以是顶层目录，也可以是某个文件夹的子目录，打包后，Unity会自动将它们合并在一起，接着在代码中动态读取这些资源，并且加载它。(Resources目录下的资源尽量不要直接引用在场景中，不然这个资源会被Resources和场景打成两份。) 删除对象：删除资源：GC：AssetBundle：在网络游戏中，可能需要运行时下载并更新资源，而Unity提供了AssetBundle组件，可以将指定的一部分资源构建成AssetBundle文件，如果需要下载，那么需要将这些AssetBundle文件上传到CDN上。 设置AssetBundle：代码： 1234567891011121314151617181920212223242526using UnityEditor;using UnityEngine;using System.IO;using UnityEngine.Events;public class Script_11_12&#123; [MenuItem("Tools/BuildAssetbundle")] static void BuildAssetbundle() &#123; string outPath = Path.Combine(Application.dataPath,"StreamingAssets"); // 如果目录已经存在，则删除它 if(Directory.Exists(outPath)) &#123; Directory.Delete(outPath,true); &#125; Directory.CreateDirectory(outPath); // 构建AssetBundle BuildPipeline.BuildAssetBundles(outPath,BuildAssetBundleOptions.ChunkBasedCompression, BuildTarget.StandaloneOSX); // 刷新 AssetDatabase.Refresh(); &#125;&#125; 依赖关系：如果两个Prefab都依赖了同一份材质和贴图文件，那么按照上面的打包方式，材质和贴图会生成两份。可以在有可能出现冗余的资源上输入它的AssetBundle名称，然后再构建AssetBundle，这样两个Prefab就会自动依赖材质和贴图了。构建AssetBundle后，会生成资源依赖关系文本(似乎是.manifest格式的) 通过脚本设置依赖关系：压缩格式：AssetBundle提供了如下三种可选的压缩格式： LZMA压缩：如果不做特殊指定，AssetBundle默认会以这种方式压缩，它的优点是Bundle会被压缩的特别小，缺点是每次使用都需解压，可能会带来卡顿。(不建议在项目中使用。) 不压缩：BuildAssetBundleOptions.UnCompressedAssetBundle它的缺点是构建出来的AssetBundle比较大，优点是加载的非常快。可以将不压缩的AssetBundle构建出来，用第三方压缩算法压缩它，再将它上传到CDN上，这样下载的时候还是压缩过的AssetBundle，所以不影响下载流量。接着，使用第三方解压算法将它写在硬盘上，这样用户在读取的时候就会非常快了。 LZ4压缩方式：BulidAssetBundleOptions.ChunkBasedCompression它是LZMA与不压缩之间的折中方案，构建出来的Bundle会比不压缩的小一点，加载速度会比LZMA压缩的快一点。(建议在项目中使用它。) 加载包体内的AssetBundle：包体内的AssetBundle只能放在StreamingAsset目录下，别的目录是无法读取的。可以使用AssetBundle.LoadFromFile()或者AssetBundle.LoadFromFileAsync()方法同步或者异步加载。这里需要注意的是，加载AssetBundle之前，需要使用AssetBundleManifest提取每个AssetBundle的相互依赖关系。 12345678910111213141516171819202122232425262728using System.Collections;using System.Collections.Generic;using UnityEngine;using System.IO;public class Script_11_14 : MonoBehaviour&#123; // Start is called before the first frame update void Start() &#123; AssetBundle assetbundle = AssetBundle.LoadFromFile(Path.Combine(Application.streamingAssetsPath,"StreamingAssets")); AssetBundleManifest manifest = assetbundle.LoadAsset&lt;AssetBundleManifest&gt;("AssetBundleManifest"); // 加载AssetBundle前，需要加载依赖的Bundle foreach(var item in manifest.GetAllDependencies("cube.unity3d")) &#123; AssetBundle.LoadFromFile(Path.Combine(Application.streamingAssetsPath,item)); &#125; // 读取Bundle assetbundle = AssetBundle.LoadFromFile(Path.Combine(Application.streamingAssetsPath,"cube.unity3d")); // 从Bundle中读取资源 GameObject prefab = assetbundle.LoadAsset&lt;GameObject&gt;("Cube"); // 实例化资源 GameObject.Instantiate&lt;GameObject&gt;(prefab); &#125;&#125; 下载AssetBundle：Unity提供了WWW类来进行下载。它可以下载包括AssetBundle在内的任意资源，此时只需要提供一个URL下载地址即可。如果下载本地任意资源，则在前面加上file://即可。 1// 此处应有代码： 使用WWW来下载AssetBundle，接着通过File.WritteAllBytes()将AssetBundle写在本地中，最后使用AssetBundle.LoadFromFile()从硬盘中加载它。 加载场景：卸载AssetBundle：在同一个AssetBundle文件中，可以同时构建多个资源文件。正确的从AssetBundle中实例化一个Prefab的步骤如下： 从硬盘中加载AssetBundle对象 从AssetBundle对象中加载需要的资源对象 从资源读取对象并且将其实例化到Hierarchy视图中，变成真正的游戏对象 由此可见，一次加载需要产生3种对象：AssetBundle对象、资源对象和游戏对象，接着开始卸载对象。 GambObject.Destroy()方法只能卸载游戏对象，资源对象还静静的在内存中。 Resources.UnloadUnusedAssets()方法也无法卸载资源对象，因为它被AssetBundle对象引用着。 AssetBundle.UnloadAllAssetBundles(true);方法可以全部卸载掉资源对象，其中参数true表示同时卸载AssetBundle对象以及资源对象。资源对象一旦卸载掉，下次再加载时又需要耗时处理，所以有时候只希望卸载AssetBundle对象而不卸载资源对象，这时候参数就可以填false了。 游戏对象：优化工具：资源管理实例： 参考： 《Unity3D游戏开发（第二版）》宣雨松 著]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>Unity3D 游戏开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity AssetBundle加载]]></title>
    <url>%2F2019%2F03%2F18%2FUnity%E7%AC%94%E8%AE%B0%2FUnity-AssetBundle%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[Unity AssetBundle加载。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity Shader中的测试]]></title>
    <url>%2F2019%2F03%2F18%2FUnity%E7%AC%94%E8%AE%B0%2FUnity-Shader%E4%B8%AD%E7%9A%84%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[Unity Shader中的测试：Alpha测试、模版测试、深度测试。 Alpha测试：Alpha Test和Alpha Blending是两种处理透明的方法。 Alpha Test：Alpha Test采用一种很霸道极端的机制，只要一个像素的alpha不满足条件，那么它就会被fragment shader舍弃。被舍弃的fragments不会对后面的各种Tests产生影响；否则，就会按正常方式写入到缓存中，并进行正常的深度检验等等，也就是说，Alpha Test是不需要关闭ZWrite的。Alpha Test产生的效果也很极端，要么完全透明，即看不到，要么完全不透明。 Alpha Blending：而Alpha Blending则是一种中庸的方式，它使用当前fragment的alpha作为混合因子，来混合之前写入到缓存中颜色值。但Alpha Blending麻烦的一点就是它需要关闭ZWrite，并且要十分小心物体的渲染顺序。如果不关闭ZWrite，那么在进行深度检测的时候，它背后的物体本来是可以透过它被我们看到的，但由于深度检测时大于它的深度就被剔除了，从而我们就看不到它后面的物体了。因此，我们需要保证物体的渲染顺序是从后往前，并且关闭该半透明对象的ZWrite。 注意：Alpha Blending只是关闭ZWrite，人家可没有关闭ZTest哦！这意味着，在输出一个Alpha Blending的fragment时，它还是会判断和当前Color Buffer中的fragment的深度关系，如果它比当前的fragment深度更远，那么它就不会再做后续的混合操作；否则，它就会和当前的fragment进行混合，但是不会把自己的深度信息写入Depth Buffer中。这是非常重要的，这一点决定了，即便一个不透明物体出现在一个透明物体的前面，不透明物体仍可以正常的遮挡住透明物体！也就是说，对于Alpha Blending来说，Depth Buffer是只读的。 尽可能使用Alpha Blending，而不要使用Alpha Test。 模板测试：模板测试stencil test是3d渲染管线中介于透明测试alpha test和深度测试depth test之间的测试，目的是根据条件来比较设置的参考值referenceValue和模板缓冲区stencil buff中对应的值stencilBuffValue的大小，如果条件满足就让片段fragment（候选的像素）进入下一测试，即深度测试，条件不满足就过滤掉片段，不把对应材质的片段输出到屏幕。 深度测试： 什么是深度？ 深度其实就是该像素点在3d世界中距离摄象机的距离，深度值Zbuffer（Z值）越大，则离摄像机越远。 什么是深度缓存？ 深度缓存中存储着每个像素点（绘制在屏幕上的）的深度值，如果启用了深度缓冲区，在绘制每个像素之前，OpenGL会把它的深度值和已经存储在这个像素的深度值进行比较。新像素深度值小于原先像素深度值，则新像素值会取代原先的；反之，新像素值被遮挡，其颜色值和深度将被丢弃，最终屏幕显示的就是深度缓存中深度对应的像素点的颜色！(深度主要起的是比较的作用) 什么是深度测试？ 在深度测试中，默认情况是将要绘制的新像素的z值与深度缓冲区中对应位置的z值进行比较，如果比深度缓存中的值小，那么用新像素的颜色值更新深度缓存中对应像素的颜色值。 为什么需要深度？ 在不使用深度测试的时候，如果我们先绘制一个距离较近的物体，再绘制距离较远的物体，则距离远的物体因为后绘制，会把距离近的物体覆盖掉，这样的效果并不是我们所希望的。而有了深度缓冲以后，绘制物体的顺序就不那么重要了，都能按照远近（Z值）正常显示，这很关键。(越后绘制的东西，距离相机就越近) ZWrite：ZWrite可以取的值为：On/Off，默认值为On，代表是否要将像素的深度写入深度缓存中。 ZTest：ZTest可以取的值为：Greater/GEqual/Less/LEqual/Equal/NotEqual/Always/Never/Off，默认值为LEqual，代表如何将像素的颜色写入深度缓存中，例如当取默认值的情况下，如果将要绘制的新像素的z值小于等于深度缓存中的值，则将用新像素的颜色值更新深度缓存中对应像素的颜色值。需要注意的是，当ZTest取值为Off时，表示的是关闭深度测试，等价于取值为Always，而不是Never！Always指的是直接将当前像素颜色(不是深度)写进颜色缓冲区中；而Never指的是不要将当前像素颜色写进颜色缓冲区中，相当于消失。 Early-Z技术：传统的渲染管线中，ZTest其实是在Blending阶段，这时候进行深度测试，所有对象的像素着色器都会计算一遍，没有什么性能提升，仅仅是为了得出正确的遮挡结果，会造成大量的无用计算，因为每个像素点上肯定重叠了很多计算。因此现代GPU中运用了Early-Z的技术，在Vertex阶段和Fragment阶段之间（光栅化之后，fragment之前）进行一次深度测试，如果深度测试失败，就不必进行fragment阶段的计算了，因此在性能上会有很大的提升。但是最终的ZTest仍然需要进行，以保证最终的遮挡关系结果正确。前面的一次主要是Z-Cull为了裁剪以达到优化的目的，后一次主要是Z-Check。 Early-Z的实现，主要是通过一个Z-pre-pass实现，简单来说，对于所有不透明的物体（透明的没有用，本身不会写深度），首先用一个超级简单的shader进行渲染，这个shader不写颜色缓冲区，只写深度缓冲区，第二个pass关闭深度写入，开启深度测试，用正常的shader进行渲染。其实这种技术，我们也可以借鉴，在渲染透明物体时，因为关闭了深度写入，有时候会有其他不透明的部分遮挡住透明的部分，而我们其实不希望他们被遮挡，仅仅希望被遮挡的物体半透，这时我们就可以用两个pass来渲染，第一个pass使用Color Mask屏蔽颜色写入，仅写入深度，第二个pass正常渲染半透，关闭深度写入。 Unity渲染顺序：如果我们先绘制后面的物体，再绘制前面的物体，就会造成over draw；而通过Early-Z技术，我们就可以先绘制较近的物体，再绘制较远的物体（仅限不透明物体），这样，通过先渲染前面的物体，让前面的物体先占坑，就可以让后面的物体深度测试失败，进而减少重复的fragment计算，达到优化的目的。Unity中默认应该就是按照最近距离的面进行绘制的。 参考： 【Unity Shaders】Alpha Test和Alpha Blending Unity Shader中的渲染队列、ZWrite和ZTest Unity Shader-渲染队列，ZTest，ZWrite，Early-Z]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[游戏编程模式：组件模式]]></title>
    <url>%2F2019%2F03%2F15%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F%EF%BC%9A%E7%BB%84%E4%BB%B6%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[组件模式。 模式动机：允许单一的实体跨越多个领域而不会导致这些领域彼此耦合。 单一实体跨越了多个领域。为了保持领域之间相互分离，将每部分代码放入各自的组件类中。 实体被简化为组件的容器。 使用场景：组件通常在定义游戏实体的核心部分中使用，但它们在其他地方也有用。 这个模式应用在在如下情况中： 有一个涉及了多个领域的类，而你想保持这些领域互相隔离。 一个类正在变大而且越来越难以使用。 想要能定义一系列分享不同能力的类，但是使用继承无法让你精确选取要重用的部分。 设计决策：对象如何获取组件： 如果对象创建组件： 这保证了对象总是能拿到需要的组件。 你永远不必担心某人忘记连接正确的组件然后破坏了整个游戏。容器类自己会处理这个问题。 重新设置对象比较困难。 这个模式的强力特性之一就是只需重新组合组件就可以创建新的对象。 如果对象总是用硬编码的组件组装自己，我们就无法利用这个特性。 如果外部代码提供组件： 对象更加灵活。 我们可以提供不同的组件，这样就能改变对象的行为。 通过共用组件，对象变成了组件容器，我们可以为不同目的一遍又一遍地重用它。 对象可以与具体的组件类型解耦。 组件之间如何通信： 通过修改容器对象的状态： 保持了组件解耦。 当我们的InputComponent设置了Bjorn的速度，而后PhysicsComponent使用它， 这两个组件都不知道对方的存在。在它们的理解中，Bjorn的速度是被黑魔法改变的。 需要将组件分享的任何数据存储在容器类中。 通常状态只在几个组件间共享。比如，动画组件和渲染组件需要共享图形专用的信息。 将信息存入容器类会让所有组件都获得这样的信息。 更糟的是，如果我们为不同组件配置使用相同的容器类，最终会浪费内存存储不被任何对象组件需要的状态。 如果我们将渲染专用的数据放入容器对象中，任何隐形对象都会无益地消耗内存。 这让组件的通信基于组件运行的顺序。 在同样的代码中，原先一整块的update()代码小心地排列这些操作。 玩家的输入修改了速度，速度被物理代码使用并修改位置，位置被渲染代码使用将Bjorn绘制到所在之处。 当我们将这些代码划入组件时，还是得小心翼翼地保持这种操作顺序。 如果我们不那么做，就引入了微妙而难以追踪的漏洞。 比如，我们先更新图形组件，就错误地将Bjorn渲染在他上一帧而不是这一帧所处的位置上。 如果你考虑更多的组件和更多的代码，那你可以想象要避免这样的错误有多么困难了。 通过它们之间相互引用： 简单快捷。 通信是一个对象到另一个的直接方法调用。组件可以调用任一引用对象的方法。做什么都可以。 两个组件紧绑在一起。 这是做什么都可以带来的坏处。我们向使用整块类又退回了一步。 这比只用单一类好一点，至少我们现在只是把需要通信的类绑在一起。 通过发送消息： 这是最复杂的选项。我们可以在容器类中建小小的消息系统，允许组件相互发送消息。 同级组件解耦。 通过父级容器对象，就像共享状态的方案一样，我们保证了组件之间仍然是解耦的。 使用了这套系统，组件之间唯一的耦合是它们发送的消息。 容器类很简单。 不像使用共享状态那样，容器类无需知道组件使用了什么数据，它只是将消息发送出去。 这可以让组件发送领域特有的数据而无需打扰容器对象。]]></content>
      <categories>
        <category>读书笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[游戏编程模式：工厂模式]]></title>
    <url>%2F2019%2F03%2F15%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[简单工厂模式、工厂方法模式、抽象工厂模式。 简单工厂模式模式动机考虑一个简单的软件应用场景，一个软件系统可以提供多个外观不同的按钮（如圆形按钮、矩形按钮、菱形按钮等）， 这些按钮都源自同一个基类，不过在继承基类后不同的子类修改了部分属性从而使得它们可以呈现不同的外观，如果我们希望在使用这些按钮时，不需要知道这些具体按钮类的名字，只需要知道表示该按钮类的一个参数，并提供一个调用方便的方法，把该参数传入方法即可返回一个相应的按钮对象，此时，就可以使用简单工厂模式。 模式定义简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。 模式结构简单工厂模式包含如下角色： Factory：工厂角色 工厂角色负责实现创建所有实例的内部逻辑 Product：抽象产品角色 抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口 ConcreteProduct：具体产品角色 具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。 模式分析 将对象的创建和对象本身业务分离可以降低系统的耦合度，使得两者修改起来相对容易。 在调用工厂类的工厂方法时，由于工厂方法时静态方法，使用起来很方便，可通过类名直接调用，而且只需要传入一个参数即可。在实际开发中，还可以在调用时将传入的参数保存在XML等格式的配置文件中，修改参数时无须修改任何源代码。 简单工厂模式的最大问题在于工厂类的职责相对过重，增加新的产品需要修改工厂类的判断逻辑，这一点与开闭原则是相违背的。 简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。 优缺点优点 工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，仅仅消费产品。简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象。 客户端无需知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可。对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。 缺点 由于工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。 使用简单工厂模式会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。 系统扩展困难，一旦增加新产品就不得不修改工厂逻辑，当产品类型较多时，有可能会造成工厂逻辑过于复杂，不利于系统的扩展和维护。 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。 适用环境 工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。 客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。 工厂方法模式模式动机现在对该系统进行修改，不再设计一个按钮工厂类来统一负责所有产品的创建，而是将具体按钮的创建过程交给专门的工厂子类去完成。我们先定义一个抽象的按钮工厂类，再定义具体的工厂类来生成圆形按钮、矩形按钮、菱形按钮等，它们实现在抽象按钮工厂类中定义的方法。这种抽象化的结果使这种结构可以在不修改具体工厂类的情况下引进新的产品，如果出现新的按钮类型，只需要为这种新类型的按钮创建一个具体的工厂类就可以获得该新按钮的实例。这一特点无疑使得工厂方法模式具有超越简单工厂模式的优越性，更加符合“开闭原则”。 模式定义工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。 模式结构 Product：抽象产品 ConcreteProduct：具体产品 Factory：抽象工厂 ConcreteFactory：具体工厂 模式分析工厂方法模式是简单工厂模式的进一步抽象和推广。由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责哪一个产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。 优缺点优点 在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。 基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。 使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。 缺点 在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。 适用环境 一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。 一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。 将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。 抽象工厂模式模式动机 在工厂方法模式中具体工厂负责生产具体的产品，每一个具体工厂对应一种具体产品，工厂方法也具有唯一性，一般情况下，一个具体工厂中只有一个工厂方法或者一组重载的工厂方法。但是有时候我们需要一个工厂可以提供多个产品对象，而不是单一的产品对象。 为了更清晰地理解工厂方法模式，需要先引入两个概念： 产品等级结构 ：产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。 产品族 ：在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。 当系统所提供的工厂所需生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构中属于不同类型的具体产品时需要使用抽象工厂模式。 抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形态。 抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建 。当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、有效率。 工厂模式就是去手机专卖店买手机，要什么手机生产什么手机，但是现在想去苹果专卖店，买一套——MBP，Ipad，Iphone，这个时候这三种产品（电脑，平板和手机）在原来的工厂模式下已经不适用了，就该使用抽象工厂模式了。 模式定义抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。 就是对一组具有相同主题的工厂进行封装（维基百科解释的很到位）； 例如：生产一台PC机，使用工厂方法模式的话，一般会有cpu工厂，内存工厂，显卡工厂…但是使用抽象工厂模式的话，只有一个工厂就是PC工厂，但是一个PC工厂涵盖了cpu工厂，内存工厂，显卡工厂等要做的所有事； 模式结构 AbstractFactory：抽象工厂 ConcreteFactory：具体工厂 AbstractProduct：抽象产品 Product：具体产品 优缺点优点 抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易。所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。另外，应用抽象工厂模式可以实现高内聚低耦合的设计目的，因此抽象工厂模式得到了广泛的应用。 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式。 增加新的具体工厂和产品族很方便，无须修改已有系统，符合“开闭原则”。 缺点 在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。 开闭原则的倾斜性（增加新的工厂和产品族容易，增加新的产品等级结构麻烦）。 适用环境 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。 系统中有多于一个的产品族，而每次只使用其中某一产品族。 属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。 系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。]]></content>
      <categories>
        <category>读书笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>创建型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试相关问题汇总]]></title>
    <url>%2F2019%2F03%2F11%2F%E9%9A%8F%E7%AC%94%2F%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[面试相关问题汇总 面经以及相关问题解释：Unity的垃圾回收机制：在最基本的层面上，Unity中的自动内存管理工作方式如下： Unity可以访问两个内存池：堆栈和堆（也称为托管堆。堆栈用于短期存储小块数据，堆用于长期存储和更大的数据。 创建变量时，Unity会从堆栈或堆中请求一块内存。 只要变量在范围内（仍然可以通过我们的代码访问），分配给它的内存仍然在使用中。我们说已经分配了这个内存。我们将堆栈内存中保存的变量描述为堆栈中的对象，将堆内存中的变量描述为堆上的对象。 当变量超出范围时，不再需要内存，可以将其返回到它来自的池中。当内存返回其池时，我们说内存已被释放。只要它引用的变量超出范围，就会释放堆栈中的内存。但是，堆中的内存此时不会被释放，并且即使它引用的变量超出范围，也会保持分配状态。 所述垃圾收集器标识，并释放未使用的堆内存。定期运行垃圾收集器以清理堆。 现在我们了解了事件的流程，让我们仔细看看堆栈分配和解除分配与堆分配和解除分配的不同之处。 堆栈分配和释放期间会发生什么？堆栈分配和解除分配快速而简单。这是因为堆栈仅用于在短时间内存储小数据。分配和解除分配总是以可预测的顺序发生，并且具有可预测的大小。 堆栈的工作方式类似于堆栈数据类型)：它是一个简单的元素集合，在这种情况下是内存块，其中元素只能按严格的顺序添加和删除。这种简单性和严格性使得它如此快速：当一个变量存储在堆栈中时，它的内存只是从堆栈的“末尾”分配。当堆栈变量超出范围时，用于存储该变量的内存会立即返回到堆栈以供重用。 堆分配期间会发生什么？堆分配比堆栈分配复杂得多。这是因为堆可用于存储长期和短期数据，以及许多不同类型和大小的数据。分配和解除分配并不总是以可预测的顺序发生，并且可能需要非常不同大小的存储器块。 创建堆变量时，将执行以下步骤： 首先，Unity必须检查堆中是否有足够的可用内存。如果堆中有足够的可用内存，则分配变量的内存。 如果堆中没有足够的可用内存，Unity会尝试释放垃圾收集器，以释放未使用的堆内存。这可能是一个缓慢的操作。如果堆中现在有足够的可用内存，则会分配变量的内存。 如果垃圾回收后堆中没有足够的可用内存，Unity会增加堆中的内存量。这可能是一个缓慢的操作。然后分配变量的内存。 堆分配可能很慢，特别是如果垃圾收集器必须运行并且必须扩展堆。 垃圾收集期间会发生什么？当堆变量超出范围时，用于存储它的内存不会立即释放。只有在垃圾收集器运行时才会释放未使用的堆内存。 每次垃圾收集器运行时，都会发生以下步骤： 垃圾收集器检查堆上的每个对象。 垃圾收集器搜索所有当前对象引用以确定堆上的对象是否仍在范围内。 任何不再在范围内的对象都被标记为删除。 将删除标记的对象，并将分配给它们的内存返回到堆中。 垃圾收集可能是一项昂贵的操作。堆上的对象越多，它必须做的工作越多，代码中的对象引用越多，它必须做的工作就越多。 垃圾收集什么时候发生？有三件事可能导致垃圾收集器运行： 无论何时请求堆分配都无法使用堆中的可用内存来执行垃圾收集器。 垃圾收集器会不时自动运行（尽管频率因平台而异）。 垃圾收集器可以强制手动运行。 垃圾收集可能是一个频繁的操作。每当无法从可用堆内存中实现堆分配时，就会触发垃圾收集器，这意味着频繁的堆分配和解除分配会导致频繁的垃圾回收。 降低GC的影响的方法 大体上来说，我们可以通过三种方法来降低GC的影响： 1）减少GC的运行次数； 2）减少单次GC的运行时间； 3）将GC的运行时间延迟，避免在关键时候触发，比如可以在场景加载的时候调用GC ​ 似乎看起来很简单，基于此，我们可以采用三种策略： 1）对游戏进行重构，减少堆内存的分配和引用的分配。更少的变量和引用会减少GC操作中的检测个数从而提高GC的运行效率。 2）降低堆内存分配和回收的频率，尤其是在关键时刻。也就是说更少的事件触发GC操作，同时也降低堆内存的碎片化。 3）我们可以试着测量GC和堆内存扩展的时间，使其按照可预测的顺序执行。当然这样操作的难度极大，但是这会大大降低GC的影响。 网络相关：状态同步与帧同步：状态同步：状态同步顾名思义，就是同步玩家的状态信息，比如位置，他的属性，还有其他跟玩法相关的数据。通常使用这种方案主逻辑基本上都在服务器运行，都在服务器进行计算，客户端只是作为一个显示。还有一个特点，就是我们通讯的网络流量大小是依赖于你的游戏里面，你的玩法里面，需要同步的一个实体数量。 一些RTS游戏，像星际争霸，就不太会使用这种状态同步的方案，他们可以操纵兵的个体的数量是非常多，可能有上百个单位，如果这样用状态同步的话，流量就会非常大。客户端会把他们的输入发给服务器，然后服务器会做一个处理，把状态信息发到客户端做一个显示。 帧同步：帧同步只同步玩家的指令，不同步状态。通常游戏的逻辑都是在客户端进行各自计算的。这肯定带来一个问题，就是说你要在各客户端各自计算，你怎么保证在各客户端算出来的结果是一样，这是帧同步的技术重点也是难点。然后就是网络流量是不依赖于同步实体的个数，只依赖于指令，这么一个大小，还有一个同步的频率。像星际争霸这种游戏，即使需要同步的单位从一百个加到两百个，加到三百个，对同步的网络流量也不会有特别明显的增加。 客户端会把它们的消息跟它们的输出发送给服务器，服务器会以一个统一的频率把各个客户端的输入转发给其他的客户端，然后其他各个客户端收到大家的输入之后，统一地进行运算。 确定性：要保证确定性，这是帧同步方案最难的地方。那么你要保证这个确定性，就是说各个客户端根据同样的输入，算出同样的结果，我们可以注意哪些问题呢，首先一定要把各客户端的核心逻辑的同步频率保持一致。如果你的频率不一样，比如用Unity的函数，每一帧运行时间间隔不一样，如果这个不一样的话会带来非常多的问题，基本上是不可能算出一样的结果，首先第一步就把这个频率调成一样的。 然后是随机数，我们很多游戏的话，肯定会使用到一些随机的东西，随机数在使用的时候，我们几乎不能使用Unity自带的随机数，因为我们知道我们通常使用的是伪随机数，我们为了保证在各客户端的随机数是一样的，需要做哪些工作。首先需要把初始化的种子要同步，它们是一样。然后还要保证在各个客户端上，随机数调用的次数是一样。 流畅性，讲流畅性之前，先了解一下，你不流畅的时候，到底是一个什么样的表现。通常玩家反馈给你，只会反馈给你，一个是卡，或者说一卡一卡，或者卡卡的。玩家不会告诉你说，我是看到这个东西网络是不是延迟了，或者说怎么样？不会这样，他会给你的是一些很感性的词。当玩家在说卡的时候，他在说什么？其实他在说输入和反馈之间存在延迟。输入和反馈之间存在延迟，这很可能就是我们的网络，可能存在说你丢包要重发，就是网络延迟。 还有一个是画面卡顿，画面卡顿的话，游戏存在性能问题，刚才我们《球球大作战》跟我们分享了优化的对大家也是挺有帮助的。然后还有一个就是游戏物件在来回抖动，可能不是因为你的网络延迟，也不是因为性能问题，可能单纯只是因为你的这个物体，由于你逻辑上有问题，导致它看起来在抖动，我们就遇到过这个问题。 http://www.360doc.com/content/17/0605/09/40005136_660108363.shtml 帧同步，一般而言是 P2P 架构。它的核心思路是：对同样的输入，每个客户端做出同样的操作，即可模拟视野内其他玩家的动作。这样的同步架构，一般而言只需要把少量的玩家输入分发给其他客户端，由其他客户端在本地进行模拟即可。例如一个 RTS 游戏，只需要把玩家的选兵、行动指令分发给其他客户端，由他们进行模拟即可。 状态同步则多采用 C2S 架构。它的核心思路则是：客户端将自己的操作或者局部状态交给服务器，由服务器来运算出游戏内的全局状态，最后由服务器把游戏内的状态分发给其他客户端（可能也包括自己），而客户端只是负责根据这些状态渲染出对应的画面而已。例如一个 MMORPG 游戏，每个玩家将自己所在的位置传递给服务端，服务端收集到各个玩家的位置之后，再分发给其他客户端。 两种网络同步算法各有千秋。总的来说，帧同步算法更适合于做 RTS / FPS / MOBA 类游戏：这类游戏输入简单、对实时性要求非常高，且有“局”和“房间”的概念，一局游戏所能持续的时间有限；而状态同步算法则更适合于 MMORPG 类游戏：这类游戏动作繁多，但对实时性要求可以容忍（甚至可以加入前摇、公 CD 等机制强行增加延迟），且游戏内部状态数据非常庞大、时间轴也会延续很长。 TCP与UDP：通常来说，我们认为对实时性要求比较高的MOBA游戏，我们还是选择UDP，有些游戏也是选择TCP，其实也是做的挺好，也可以根据自己的游戏需求，如果你觉得TCP还OK，那就选择TCP没有问题，很成熟，也很可靠。不需要做额外的工作。如果你觉得你的游戏对你的实时性要求比较强，还是推荐你用UDP，使用UDP带来什么问题，首先UDP是不可靠的传输协议，可能需要自己去处理一下丢包，还有顺序。通常常用的解决方案就是增加冗余数据，如果一次发包，可以一次带两帧的数据，如果丢包之后，丢了一个包，但是仍然可能还是有额外的一帧供你使用，继续去渲染。 TCP：TCP（Transmission Control Protocol，传输控制协议）是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。 UDP：UDP是一个非连接的协议，传输数据之前源端和终端不建立连接， 当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。 在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、 计算机的能力和传输带宽的限制； 在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。 修改本地属性的外挂（计算结果不一致）：多客户端数据仲裁。 LockStep同步机制：http://gameinstitute.qq.com/article/detail/16108 https://blog.codingnow.com/2018/08/lockstep.html 协程：我们在执行开启一个协程的时候，其本质就是返回一个迭代器的实例，然后在主线程中，每次update的时候，都会更新这个实例，判断其是否执行MoveNext的操作，如果可以执行(比如文件下载完成)，则执行一次MoveNext，将下一个对象赋值给Current(MoveNext需要返回为true， 如果为false表明迭代执行完成了)。 通过这儿，可以得到一个结论，协程并不是异步的，其本质还是在Unity的主线程中执行，每次update的时候都会触发是否执行MoveNext。 A*寻路：A*算法： 维护两个列表，Open列表和Closed列表，Open列表用于记录所有被考虑为最短路径的方块，Closed列表用于记录不会再被考虑的方块。 考虑与否取决于估值函数，我使用的估值函数为曼哈顿距离函数：当前方块到结束点的水平距离 + 当前方块到结束点的垂直距离。 从开始点出发，将开始点记录为当前点P，将其放在Closed表中，搜寻P周围的点，如果它既不在Open表中，也不在Closed表中，则计算它的移动代价F = G + H，并将其父节点设置为P，然后将其放入开放列表。 对开放列表进行排序，将F值最小的点拿出来作为下一步的P点 如果该点就是终点，则结束寻路，回溯所有的父节点到起点，完成寻路。 如果该点不是终点，则重复寻找步骤。 如果开放列表已经空了，则说明所有可以找的点已经找完了，寻路失败。 进程与线程的区别：进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。 1) 简而言之,一个程序至少有一个进程,一个进程至少有一个线程. 2) 线程的划分尺度小于进程，使得多线程程序的并发性高。 3) 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。 4) 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 5) 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。 协程：协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。 进程拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度。 线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(标准线程是这样的)。 协程和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度。 一个应用程序一般对应一个进程，一个进程一般有一个主线程，还有若干个辅助线程，线程之间是平行运行的，在线程里面可以开启协程，让程序在特定的时间内运行。 协程和线程的区别是：协程避免了无意义的调度，由此可以提高性能，但也因此，程序员必须自己承担调度的责任，同时，协程也失去了标准线程使用多CPU的能力。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>计算机网络</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity中的渲染优化技术]]></title>
    <url>%2F2019%2F03%2F11%2FUnity%E7%AC%94%E8%AE%B0%2FUnity%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[Unity中的渲染优化技术。 影响性能的因素：对于一个游戏来说，主要适用两种计算资源：CPU和GPU。它们会相互合作，来让我们的游戏可以在预期的帧率和分辨率下工作，其中CPU负责保证帧率，GPU负责分辨率相关的的一些处理。 性能瓶颈： CPU： 过多的draw call 复杂的脚本或者物理模拟 GPU： 顶点处理 过多的顶点 过多的逐顶点计算 片元处理 过多的片元（由分辨率造成或者由overdraw造成） 过多的逐片元计算 带宽 使用了尺寸很大且未压缩的纹理 分辨率过高的帧缓存 优化技术： CPU优化： 使用批处理减少draw call数目 GPU优化： 减少要处理的顶点数目： 优化几何体 使用模型的Level of Detail 技术 使用遮挡剔除（Occlusion Culling）技术 减少需要处理的片元数目： 控制绘制顺序 警惕透明物体 减少实时光照 减少计算复杂度 使用Shader的LOD技术 代码方面的优化 节省内存带宽： 减少纹理大小 使用分辨率缩放 CPU和GPU做了什么：在了解优化渲染前，我们需要了解在unity中，每一帧的渲染CPU和GPU都做了些什么： CPU检查场景中每个对象，决定他们是否应该被渲染。（这些对象只有满足一定的条件才会被渲染。） CPU收集即将被渲染的对象信息，并把这些信息分类为渲染指令（也就是draw calls，我们在之前的文章中也有提到，Draw Call实际上就是一个命令）。一个draw call包含网格数据以及网格如何被渲染。在某些场景，共享设置的一些对象可能会被合并为一个draw call。合并不同对象的数据到同一个draw call被称作batching。 CPU给每个draw call创建一个数据包，称为batch。每一个batch必须包含一个draw call。 CPU会发出指令，使GPU改变一些渲染状态。这个指令被称为SetPass call。SetPass call通知GPU，如何去渲染下一个网格。只有在渲染下一个网格时，其渲染状态相对于渲染上一个网格发生了变化时，才会调用SetPass call。 CPU把draw call发送给GPU。draw call通知GPU使用最近的SetPass call去渲染指定的网格。 有时，batch可能需要不止一个的pass。pass是shader代码的一部分，而新的pass需要改变渲染状态。对于batch中的每个pass，CPU必须发送一个新的SetPass call然后必须要再次发送draw call。 GPU按照CPU发送的指令顺序处理这些指令。 如果当前任务是SetPass call，那么GPU更新渲染状态。 如果当前任务是draw call，那么GPU渲染网格。渲染网格发生在很多阶段，不同阶段的shader代码可以定义渲染。其中：顶点着色器vertex shader告诉GPU怎么处理网格的顶点。片元着色器fragment shader告诉GPU怎么绘制单独的像素。 以上过程会重复执行，直到所有CPU发送的任务都被GPU完成。 CPU渲染优化：发送命令到GPU花费时间过长是引起CPU限制的最常见的原因，其最耗时的操作是SetPass call。如果CPU限制是由发送命令到GPU引起的，那么降低SetPass的数量通常是最好的改善性能的方式。 降低SetPass call和batches数量，我们通常可以从以下几个方面来进行： 减少要渲染的对象数量，通常可以同时降低SetPass call和batches的数量。 减少每个要渲染的对象的渲染次数，通常可以降低SetPass call 合并要渲染的对象的数据，可以降低batches数量不同的技术适用于不同的项目，我们在项目开发中因该从项目本身需求出发来选择最合适的方法。 减少要渲染的对象数量 手动减少场景中物体的数量 Occlusion Culling（遮挡剔除）： 遮挡剔除的原理就是当一个物体被其他物体遮挡住，不在摄像机的可视范围内时不对其进行渲染。 摄像机Clipping Planes： 我们可以通过摄像机的Clipping Planes 的Far裁剪远端，从而降低摄像机的绘制范围，为了降低性能损耗同时保证游戏质量，Far的值应该合理控制，不要造成不好的游戏体验，或者我们可以用雾来掩盖不被渲染的远端。 减少渲染对象的渲染次数 LightMap（光照贴图） Unity灯光默认是实时光照，也就是说物体在灯光下不同位置会产生不同灯光效果，由于动态光源在实时光照下会有大量的Setpass Calls，为了减小Setpass Calls，我们可以烘焙灯光效果，Unity会为我们生成光照贴图，这样大大减少了Setpass Calls。 阴影 阴影 (Shadows)：此项决定应该使用哪种阴影类型。 硬阴影和软阴影 (Hard and Soft Shadows)：硬阴影和软阴影都将得到渲染。 仅硬阴影 (Hard Shadows Only)：仅硬阴影 (hard shadows) 将得到渲染。 禁用阴影 (Disable Shadows)：没有阴影会被渲染。 阴影分辨率 (Shadow resolution)：阴影可以按以下几种不同分辨率进行渲染： 低 (Low) 、中 (Medium) 、高 (High) 和很高 (Very High)。分辨率越高，处理开销就越大。 阴影投射 (Shadow Projection)：从平行光源投射阴影有两种方法： 紧密配合 (Close Fit) 渲染分辨率更高的阴影，但是如果摄影机移动，这些阴影有时就会有些许摇晃。 稳定配合 (Stable Fit) 渲染分辨率更低的阴影，而阴影不会随摄影机的移动而摇晃。 阴影距离 (Shadow Distance)：从摄影机处可以看见阴影的最大距离。超出此距离的阴影将不会被渲染。 阴影层叠 (Shadow Cascades)：阴影层叠 (shadow cascades) 数可设置为零、二或四。层叠数越高质量越好，但这要以处理开销为代价。 反射探针： 反射探头没有很好的优化方法，在我们实际的项目中却常会用到，以创建更真实的反射，但却会增加batches， 所以我们应该在性能消耗较大的场合尽量最小化其使用率。 合并要渲染的对象的数据 静态批处理和动态批处理： 在Unity中如果动态物体共用相同的材质，那么Unity会自动对这些物体进行批处理。动态批处理操作是自动完成的。但同时我们注意CPU时间，同一材质的CPU时间明显更高，所以我们要注意增加的CPU时间是否会高于优化节省的时间。 我们进行静态批处理时，其网格会合并，这也是进行静态批处理的一个重要过程，我们需要他们使用同一个网格同一个材质。静态批处理没动态批处理的诸多限制，且不会造成CPU损耗，但会有更高的内存占用。使用静态批处理时，只需要同一个材质且批处理的物体处于静态，同时勾上Static。 纹理图集： 纹理图集是把大量的小纹理合并为一张大的纹理图的技术，当我们使用这个技术为游戏创建美术资源时，我们可以确保物体共享同一图集，因此适合合并。Unity内置了图集工具老版本为Sprite Packer，新版本为SpriteAtlas。 GPU渲染优化： 优化GPU渲染问题主要从三个方面来进行，分别是顶点，填充，带宽。我们需要明确这三个方面的概念。 顶点处理。顶点处理是指GPU需要渲染网格中每一个顶点的工作。顶点处理的消耗受两方面影响：必须渲染的顶点数量，以及在每个顶点上要进行的操作数量。 填充率。填充率是指GPU在屏幕上每秒可以渲染的像素数。如果我们的游戏受到填充率的限制，意味着我们的游戏每帧尝试绘制的像素数量超过了GPU的处理能力。 显存带宽。显存带宽是指GPU读写其专用内存的速度。如果我们的游戏速度受限于显存带宽，通常可能是我们使用的纹理太大，以至于GPU无法快速处理。 纹理压缩：纹理压缩技术可以同时极大的降低纹理在磁盘和内存中的大小。如果是显存带宽的问题，那么使用纹理压缩减小纹理在内存的大小可以帮助改善性能，Unity提供了很多纹理压缩的格式和设置，运用也十分简单，根据不同的需求、机器和场景我们使用的方式也有所不同，具体可以参照Unity 官方文档 Mipmap：如果我们的场景包含距离摄像机很远的物体，我们可以通过使用mipmap来缓解显存带宽的问题，mipmap的主要作用便是模型的贴图会根据摄像机距离模型的远近而调整不同质量的贴图显示，以达到优化目的。 LOD（Levels of Detail）：LOD与Mipmap类似，根据距离的远近使用不同精度模型，远处选择低精度的模型，近的时候选择高精度模型，这样就可以减少模型上面的顶点和面片数量从而提高性能。其和Mipmap的差异主要在一Mipmap针对贴图，而LOD针对模型。Mipmap可以自动生成八张精度不同的贴图，而LOD必须由我们自己提供三个不同精度的模型。 Unity 中的渲染分析工具：渲染统计窗口：Rendering Statistics Window性能分析器：Profiler帧调试器：Frame Debugger 参考： Unity3D性能优化——渲染篇]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity Shader 使用噪声]]></title>
    <url>%2F2019%2F03%2F10%2FUnity%E7%AC%94%E8%AE%B0%2FUnity-Shader-%E4%BD%BF%E7%94%A8%E5%99%AA%E5%A3%B0%2F</url>
    <content type="text"><![CDATA[消融效果、水波效果、全局雾效。 消融效果的实现：通过噪声纹理采样与设置好的消融属性相减，将算得结果小于0的像素剔除。对于剩下的像素进行正常的光照计算，然后在设定好的宽度范围内对两种溶解颜色进行插值，再将混合得到的颜色与环境光和漫反射光照混合输出。 后面还需要加一个用于处理阴影的Pass，否则已经消融的部分会投射影子。 定义属性： 定义消融需要的Pass：为了得到正确的光照，我们设置了Pass的LightMode和multi_compile_fwdbase的编译指令。 我们使用Cull off来关闭Shader的面片剔除，来使得其正面和背面都会被渲染。 定义顶点着色器： 通过片元着色器实现模拟消融效果： 首先对噪声纹理进行采样，并将结果和用于控制消融程度的属性相减，传递给clip函数，将结果小于0的像素剔除。 对于剩下的像素，进行正常的光照计算。我们根据漫反射纹理获得反射率albedo，并由此计算环境光照与漫反射光照。 计算烧焦颜色：在宽度为_LineWidth的范围内模拟一个烧焦的颜色变化，使用smoothstep来计算混合系数（当t为1时，表明该像素位于消融的边界处；当t为0时，表明该像素为正常的模型颜色），插值用来模拟一个烧焦效果：使用t来混合两种火焰颜色。同样使用step函数来保证剔除。 自定义投射阴影的Pass： 同样使用clip函数来剔除片元，然后使用内置宏SHADOW_CASTER_FRAGMENT()来完成阴影投射，将结果输出到深度图和阴影映射纹理中。 水波效果：全局雾效：生成噪声：噪声是怎么生成的：https://blog.csdn.net/candycat1992/article/details/50346469 基于晶格的方法（Lattice based） 基于点的方法（Point based） Perlin噪声： Perlin噪声还是比较简单的，Perlin噪声的实现需要三个步骤： 定义一个晶格结构，每个晶格的顶点有一个“伪随机”的梯度向量（其实就是个向量啦）。对于二维的Perlin噪声来说，晶格结构就是一个平面网格，三维的就是一个立方体网格。 输入一个点（二维的话就是二维坐标，三维就是三维坐标，n维的就是n个坐标），我们找到和它相邻的那些晶格顶点（二维下有4个，三维下有8个，n维下有2n2n个），计算该点到各个晶格顶点的距离向量，再分别与顶点上的梯度向量做点乘，得到2n2n个点乘结果。 使用缓和曲线（ease curves）来计算它们的权重和。在原始的Perlin噪声实现中，缓和曲线是s(t)=3t2−2t3s(t)=3t2−2t3。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity Shader 非真实感渲染]]></title>
    <url>%2F2019%2F03%2F10%2FUnity%E7%AC%94%E8%AE%B0%2FUnity-Shader-%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93%2F</url>
    <content type="text"><![CDATA[卡通风格的渲染与素描风格的渲染。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity Shader 深度与法线纹理]]></title>
    <url>%2F2019%2F03%2F10%2FUnity%E7%AC%94%E8%AE%B0%2FUnity-Shader-%E6%B7%B1%E5%BA%A6%E4%B8%8E%E6%B3%95%E7%BA%BF%E7%BA%B9%E7%90%86%2F</url>
    <content type="text"><![CDATA[Unity Shader 深度与法线纹理：运动模糊，全局雾效和边缘检测 获取深度和法线纹理原理：法线纹理实际上是一张渲染纹理，只不过里面存储的像素值不是颜色值，而是一个高精度的深度值。由于被储存在一张纹理中，深度纹理里的深度值范围是[0,1]，而且通常是非线性分布的。 这些深度值来自于顶点变换后得到的归一化的设备坐标（Normalized Device Coordinates，NDC）。 一个模型要绘制到屏幕上，需要把它的顶点从模型空间变换到齐次裁剪空间下，这是通过在顶点着色器中乘以MVP变换矩阵得到的；在变换的最后一步，我们需要使用一个投影矩阵来变换顶点。如果是透视投影类型的摄像机，这个投影矩阵就是非线性的。 在得到NDC后，深度纹理中的像素值可以很方便的计算得到了，这些深度值对应了NDC中顶点坐标的z分量的值，由于NDC中z分量的范围在[-1,1]，为了使其可以存到深度纹理中，要进行一次映射：d = 0.5*z(ndc) + 0.5 由于法线向量是个几何工具，而纹理通常只用于储存颜色信息，用纹理储存法线向量不是非常直接。如果你想一想，就会知道纹理中的颜色向量用r、g、b元素代表一个3D向量。类似的我们也可以将法线向量的x、y、z元素储存到纹理中，代替颜色的r、g、b元素。法线向量的范围在-1到1之间，所以我们先要将其映射到0到1的范围。 这会是一种偏蓝色调的纹理（你在网上找到的几乎所有法线贴图都是这样的）。这是因为所有法线的指向都偏向z轴（0, 0, 1）这是一种偏蓝的颜色。法线向量从z轴方向也向其他方向轻微偏移，颜色也就发生了轻微变化，这样看起来便有了一种深度。例如，你可以看到在每个砖块的顶部，颜色倾向于偏绿，这是因为砖块的顶部的法线偏向于指向正y轴方向（0, 1, 0），这样它就是绿色的了。 Unity如何得到深度纹理：深度纹理可以直接来自于真正的深度缓存，也可以是由一个单独的Pass渲染而得，这取决于使用的渲染路径与硬件。 当使用延迟渲染路径时，深度纹理可以访问到，因为延迟渲染会把这些信息渲染到G-buffer中。 无法直接获取深度缓存时，深度和法线纹理是通过一个单独的Pass渲染而得的：Unity会使用着色器替换技术选择那些渲染类型为Opaque的物体，判断它们使用的渲染队列是否小于等于2500（Background，Geometry和AlphaTest），如果满足条件，就把它渲染到深度和法线纹理中。 深度纹理的属性：深度纹理的精度通常为24位或16位，这取决于深度缓存的精度。如果生成一张深度+法线纹理，Unity会创建一张与屏幕分辨率相同、精度为32位的纹理，其中观察空间下的法线信息会被编码进纹理的R和G通道，而深度信息会被编码进B和A通道。 如何获取深度纹理：设置摄像机模式：camera.depthTextureMode = DepthTextureMode.Depth; 如果想获取深度+法线纹理：camera.depthTextureMode = DepthTextureMode.DepthNormals; 使用深度纹理模拟运动模糊：全局雾效：使用深度纹理进行边缘检测： 参考： learnopengl-cn-法线贴图]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity Shader 屏幕后处理效果]]></title>
    <url>%2F2019%2F03%2F08%2FUnity%E7%AC%94%E8%AE%B0%2FUnity-Shader-%E5%B1%8F%E5%B9%95%E5%90%8E%E5%A4%84%E7%90%86%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[Unity Shader 屏幕后处理效果：边缘检测，高斯模糊与Bloom 基本的屏幕后处理脚本系统：基本原理：想要实现屏幕后处理的基础在于得到渲染后的屏幕图像，即抓取屏幕，Unity为我们提供了一个方便的接口OnRenderImage函数： 1MonoBehaviour.OnRenderImage(RenderTexture src,RenderTexture dest) 当我们在脚本中声明此函数之后，Unity会把当前渲染得到的图像存储在第一个参数对应的源渲染纹理中（src），通过函数中的一系列操作后，再把目标渲染纹理（dest）显示在屏幕上。 在OnRenderImage函数中，我们通常是利用Graphics.Blit函数来完成对渲染纹理的处理。 1234public static void Blit(Texture source, RenderTexture dest);public static void Blit(Texture source, RenderTexture dest, Material mat, int pass = -1);public static void Blit(Texture source, Material mat, int pass = -1);public static void Blit(Texture source, RenderTexture dest, Vector2 scale, Vector2 offset); source对应原纹理，在屏幕后处理技术中，该纹理通常就是当前屏幕的渲染纹理或者是上一步处理后得到的渲染纹理。 dest对应目标渲染纹理，如果它的值为null，就会直接将结果渲染在屏幕上。 mat是我们使用的材质，这个材质使用的Unity Shader将会进行各种屏幕后处理操作，而source纹理将会被传递给Shader中名为_MainTex的纹理属性。 pass的默认值为-1，表示将会依次调用Shader中的所有Pass，否则只会调用给定索引的Pass。 处理过程：在摄像机中添加一个用于屏幕后处理的脚本，在这个脚本中，我们会实现使用OnRenderImage获取当前屏幕的渲染纹理。再调用Graphics.Blit函数使用特定的Unity Shader来对当前图像进行处理，再把返回的渲染纹理显示在屏幕上。对于复杂的屏幕特效，我们可能需要多次调用Graphics.Blit函数来对上一步的输出结果进行下一步处理。 在开始屏幕后处理之前，我们需要检查一系列条件是否满足，例如当前平台是否支持渲染纹理和屏幕特效，是否支持当前使用的Unity Shader等。 调整屏幕的亮度、饱和度与对比度每当OnRenderImage函数被调用时，它会检查材质是否可用。如果可用，就把参数传递给材质，再调用Graphics.Blit进行处理；否则，直接把原图像显示在屏幕上，不作任何处理。 屏幕后处理实际上上是在场景绘制了一个与屏幕同宽同高的四边形面片，为了防止它对其他物体产生影响，我们需要设置相关的渲染状态。 边缘检测边缘检测的原理是利用一些边缘检测算子来对图像进行卷积操作。 卷积：卷积操作指的是使用一个卷积核，对一张图像中的每个像素进行一系列操作。卷积核通常是一个四方形网格结构，每个方格都有一个权重，进行卷积时，我们将卷积核的中心放在目标像素上，翻转核之后再依次计算核中每个元素和其覆盖的图像像素值的乘积并求和，得到的结果就是该位置的新像素值。 梯度：边的形成的核心性质就是在边的两侧其差值较大，这种差值的绝对值叫做梯度。基于这个内容，我们使用几种不同的边缘检测算子来计算梯度。 Roberts Prewitt Sobel 每个算子都包含x,y两个方向上的卷积核，每次我们需要对一个像素分别计算两个方向上的梯度，再求出总梯度G。 出于性能考虑一般使用G=Gx+Gy来代替平方根。 高斯模糊高斯模糊利用卷积计算，它的卷积核名为高斯核。 Bloom效果根据一个阈值提取出图像中的较亮区域，把它们存储在一张渲染纹理中，再利用高斯模糊对这张渲染纹理进行模糊处理，模拟光线的扩散，最后再将其与原图像进行混合，得到最终的效果。 运动模糊原理： 累积缓存：当物体快速移动产生多张图像后，我们取它们之间的平均值作为最后的运动模糊图像。这种暴力的方法对性能消耗很大，想要获取多张帧图像，我们需要在同一帧里渲染多次场景。 速度缓存：这个缓存中存储了各个像素当前的运动速度，根据速度来决定模糊的方向和大小。 类似累积缓存：保存之前的渲染结果，不断把当前的渲染图像叠加到之前的渲染图像中，产生一种运动轨迹的视觉效果，这种方法与原始的累积缓存相比性能更好，但是模糊效果可能略有影响。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity Shader 高级纹理]]></title>
    <url>%2F2019%2F03%2F06%2FUnity%E7%AC%94%E8%AE%B0%2FUnity-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86%2F</url>
    <content type="text"><![CDATA[立方体纹理实现环境映射，渲染纹理以及程序纹理。 立方体纹理：定义：立方体纹理是环境映射的一种实现方式。环境映射可以模拟物体周围的环境，使用了环境映射的物体可以看起来像是镀了金属一样反射出周围的环境。 采样方式正方体纹理一共包含了6张图像，这些图像对应了一个立方体的6个面。立方体的每个面表示沿着世界空间下的轴向观察所得来的图像。对立方体纹理采样需要我们提供一个三维的纹理坐标，这个三维纹理坐标表示了我们在世界空间下的一个3D方向。这个方向矢量从立方体的中心出发，当它向外部延伸时就会和立方体的6个纹理之一发生相交，而采样得到的结果就是由该交点计算而来的。 优点与缺点： 优点：实现简单快速，得到的效果比较好。 缺点： 当场景中引入了新的物体、光源，或者物体发生移动时，我们就需要重新生成立方体纹理。 立方体纹理只能反射环境，不能反射使用了该立方体纹理的物体本身。它不能模拟多次反射的结果，故应尽量对凸面体而不是凹面体使用立方体纹理。 天空盒子（Skybox）：天空盒子是在所有不透明物体之后渲染的，而其背后使用的网格是一个立方体或一个细分后的球体。 创建用于环境映射的立方体纹理： 直接由一些特殊布局的纹理创建：需要一张具有特殊布局的纹理，然后将其Texture Type设置成Cubemap即可。 手动创建一个Cubemap资源：创建一个Cubemap，将六张纹理拖拽到它的面板中。 由脚本生成：使用Camera.RenderToCubemap函数实现——从任意位置观察到的场景图像存储到6张图像中，从而创建出该位置上对应的正方体纹理。 反射效果： 通过入射光线的方向和表面法线方向来计算反射方向，再利用反射方向对立方体纹理采样。 首先，声明需要用到的属性： 在顶点着色器中计算该顶点处的反射方向，根据CG的reflect函数来实现： 物体反射到摄像机中的光线方向，可以由光路可逆的原则来反向求得。可以计算视角方向关于顶点法线的反射方向来求得入射光线的方向。 (TRANSFER_SHADOW参见以前的博客：（此处应有链接）) 在片元着色器中，利用反射方向来对立方体纹理采样： 对立方体纹理的采样需要使用CG的texCUBE函数，用于采样的参数仅仅是作为方向变量传递给texCUBE函数的，没有必要进行归一化。 然后使用_ReflectAmount来混合漫反射颜色和反射颜色，并和环境光照相加后返回。 可以在片元着色器中计算反射方向，这样效果更好，但是差别不大；处于性能考虑，我们选择在顶点着色器中计算反射方向。 效果： 折射效果： 当光线从一种介质斜射入另一种介质时，传播方向一般会发生改变。当给定入射角时，可以使用斯涅尔定律来计算反射角。 ​ $n_1sinθ_1 = n_2sinθ_2$ 其中，n1和n2分别是两个介质的折射率。 一般对一个透明物体，准确的模拟需要计算两次折射——一次入射与一次出射。但是这样模拟很复杂，所以初学在此仅模拟一次折射。 声明属性： 使用CG的refract函数来计算折射方向。 第一个参数是入射光线的方向，必须是归一化后的矢量；第二个参数是表面法线，法线方向同样需要是归一化的；第三个参数是入射光线所在介质的折射率与折射光线所在介质的折射率之间的比值。返回计算而得的折射方向，它的模则等于入射光线的模。 在片元着色器中使用折射方向对立方体纹理进行采样： 最后使用_RefractAmount来混合漫反射和折射颜色，并和环境光照相加后返回。 效果： 菲涅尔反射： 当光线照射到物体表面上时，一部分发生反射，一部分进入物体内部，发生折射或散射。被反射的光和入射光之间存在一定的比率关系，这个比例关系可以通过菲涅尔等式进行计算。 菲涅尔等式： Schlick菲涅尔近似等式： ​ $F_{Schlick}(v,n) = F_0 + (1 - F_0)(1 - v·n)^5$ ​ $F_0$是反射系数，用于控制菲涅尔反射的强度，v是视角方向，n是表面法线。 Empricial菲涅尔近似等式： ​ $F_{Empricial}(v,n) = max(0, min(1,bias + scale * (1 - v·n)^{power})$ Bias、scale和power是控制项。 定义属性：_FresnelScale属性用于调整菲涅尔反射 在顶点着色器中计算世界空间下的法线方向、视角方向和反射方向： 在片元着色器中计算菲涅尔反射，并使用结果值混合漫反射光照和反射光照： 效果： 当_FresnelScale为1时： 为0.5时： 为0时： 渲染纹理：镜子效果的实现：玻璃效果的实现：我们可以使用GrabPass来完成获取屏幕图像的目的。在Shader中定义了一个GrabPass后，Unity会把当前屏幕的图像绘制在一张纹理中，以便在后续的Pass中访问。与简单的透明混合不同，使用GrabPass可以让我们对物体后面的图像进行更复杂的处理，例如使用法线来模拟折射效果，而不是简单的与原屏幕颜色进行混合。 使用GrabPass时，要小心物体的渲染队列设置，往往需要把物体的渲染队列设置成透明队列（“Queue ” = “Transparent”），来保证当渲染该物体的时候，所有的不透明物体已经被绘制在屏幕上，获得正确的屏幕图像。 整体思路： 首先使用一张法线纹理来修改模型的法线信息，然后使用反射方法，通过一个Cubemap来模拟玻璃的反射，而在模拟折射时，使用了GrabPass获取玻璃后面的屏幕图像，并使用切线空间下的法线对屏幕纹理坐标偏移后，再对屏幕图像进行采样来模拟近似的折射效果。 声明属性： 定义相应的渲染队列 定义变量： 定义顶点着色器阶段： 先进行必要的顶点坐标变换。 调用内置的ComputeGrabScreenPos函数来得到对应被抓取的屏幕图像的采样坐标。 计算_MainTex和_BumpMap的采样坐标，并存储在一个float4类型变量中。 接着计算顶点对应的从切线空间到世界空间的变换矩阵，并把该矩阵的每一行分别存储在三个TtoWx的xyz分量中。这样做是为了在片元着色器中把法线方向从切线空间转换到世界空间下，以便对CubeMap进行采样。 计算得到的分量被按列组成一个变换矩阵，w轴被用来存储世界空间下的顶点坐标。 定义片元着色器： 通过世界坐标得到该片元对应的视角方向。 对法线纹理进行采样，得到切线空间下的法线方向。 使用切线空间下的法线方向进行偏移（因为该空间下的法线可以反映顶点局部空间下的法线方向） 随后对scrPos透视除法得到真正的屏幕坐标，再使用该坐标对抓取的屏幕图像_RefractionTex进行采样，得到模拟的折射颜色。 下一步把法线方向从切线空间变换到了世界空间下，并据此得到视角方向相对于法线方向的反射方向。 使用反射方向对Cubemap进行采样，并把结果和主纹理颜色相乘后得到反射颜色。 最后使用_RefractAmount属性对反射和折射颜色进行混合，作为最终的输出颜色。 效果： 为什么要在Pass中使用一个字符串指明被抓取的屏幕图像存储名称？ 直接使用GrabPass{}性能消耗较大，因为这样对于每个使用它的物体，Unity会为它单独进行一次昂贵的屏幕抓取工作。不过这样可以使不同的物体得到不同的屏幕图像。 指明字符串后，可以在后续的Pass中通过名称来访问屏幕图像。这样效果更高效，但是所有物体都会使用同一张屏幕图像。 程序纹理：可以使用程序纹理来创建程序材质。 波点纹理实例：]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity UGUI 源码学习 Button]]></title>
    <url>%2F2019%2F03%2F05%2FUnity%E7%AC%94%E8%AE%B0%2FUnity-UGUI-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-Button%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[游戏编程模式：状态模式]]></title>
    <url>%2F2019%2F03%2F02%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F%EF%BC%9A%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[“允许一个对象在其内部状态改变时改变自身的行为。对象看起来好像是修改自身类。” 模式动机：在很多情况下，一个对象的行为取决于一个或多个动态变化的属性，这样的属性叫做状态，这样的对象叫做有状态的(stateful)对象，这样的对象状态是从事先定义好的一系列值中取出的。当一个这样的对象与外部事件产生互动时，其内部状态就会改变，从而使得系统的行为也随之发生变化。 模式结构： 环境类 抽象状态类 具体状态类 自动机：并发自动机：当存在两种不同类型的状态（n个，m个），它们种间会产生交叉，此时如果使用普通的有限状态机需要定义n*m个具体状态。如果使用两个并行的状态机，那么仅需n+m个具体状态。 此时环境类需要持有两个状态索引，用于处理两个状态的行为。 1234567891011class Content&#123; private State state1; private State state2; void getBehavior(Input input) &#123; state1.Update(input); state2.Update(input); &#125;&#125; 这样每一个状态机都可以响应输入事件并以此切换状态，而不用考虑其他状态机的实现细节。（当两个状态没什么关系的时候，这种方法可以很好的实现。） 层次自动机：当主角的不同行为对相同的输入可能会执行相同的行为时，我们可以将这些具体的状态类进行提取，生成一个父类。 一个状态有一个父状态，当有一个事件进入时，如果子状态不处理它，那么沿着继承链传给它的父状态来处理。 1234567891011121314151617181920212223242526272829303132class Content&#123; private FatherState state; void getBehavior(Input input) &#123; state.Update(Input); &#125;&#125;class FatherState&#123; public void Update(Input input) &#123; if(check Child) &#123; child.Update(input); // 也可以this = new Child();? &#125; else &#123; //do something; &#125; &#125;&#125;class ChildState : FatherState&#123; public override void Update(Input input) &#123; //do something; &#125;&#125; 下推自动机：如果需要恢复到上一个状态，则使用一个栈来保存当前状态，当前的状态总在栈顶，执行之后恢复，弹出栈顶状态。]]></content>
      <categories>
        <category>读书笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[游戏编程模式：单例模式]]></title>
    <url>%2F2019%2F02%2F28%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[“确保一个类只有一个实例，并为其提供一个全局访问入口。” 模式动机：有些情况下，一个类如果有多个实例就不能正常运作。（这个类与一个维持着自身全局状态的外部系统进行交互的情况。） 如何保证一个类只有一个实例并且这个实例易于被访问呢？定义一个全局变量可以确保对象随时都可以被访问，但不能防止我们实例化多个对象。 一个更好的解决办法是让类自身负责保存它的唯一实例。这个类可以保证没有其他实例被创建，并且它可以提供一个访问该实例的方法。这就是单例模式的模式动机。 模式定义：单例模式(Singleton Pattern)：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。 单例模式的要点有三个： 某个类只能有一个实例 它必须自行创建这个实例 它必须自行向整个系统提供这个实例。 单例模式是一种对象创建型模式。单例模式又名单件模式或单态模式。 优点： 如果我们不使用它，就不会创建实例。（节省内存和CPU周期，单例仅在第一次被访问的时候实例化，那么如果我们的游戏始终不使用它，它就不会初始化。） 它在运行时初始化。使用静态类来替代单例模式是一个常用的方法，但是静态类会自动初始化。这使得它不能获取游戏运行期间才得到的消息，同时也无法保证相互依赖的静态数据间的初始化顺序。单例可以将初始化延后，以至于其所需要的所有信息都可以得到。 可以继承单例。 缺点： 它们令代码晦涩难懂。 全局变量促进了耦合。 对并发并不友好。 写法：懒汉式（线程不安全）：123456789101112public class Singleton&#123; private static Singleton instance; private Singleton()&#123;&#125; public static Singleton getInstance() &#123; if(instance == null) instacne = new Singleton(); &#125; return instance;&#125; 问题：当多个线程并行调用getInstance时，会创建多个实例，在多线程下不能正常工作。 懒汉式（线程安全）：123456789101112public class Singleton&#123; private static Singleton instance; private Singleton()&#123;&#125; [MethodImpl(MethodImplOptions.Synchronized)] public static Singleton getInstance() &#123; if(instance == null) instacne = new Singleton(); &#125; return instance;&#125; 问题：保证了线程安全，但是任何时候只能由一个线程调用getInstance方法，但是同步操作只需要在第一次调用时才被需要。 （双检锁？）]]></content>
      <categories>
        <category>读书笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>创建型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[游戏编程模式：原型模式]]></title>
    <url>%2F2019%2F02%2F28%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[“使用特定原型实例来创建特定种类的对象，并且通过拷贝原型来创建新的对象。” 模式动机]]></content>
      <categories>
        <category>读书笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[游戏编程模式：观察者模式]]></title>
    <url>%2F2019%2F02%2F28%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F%EF%BC%9A%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在对象间定义一种一对多的依赖关系，以便当某对象的状态改变时，与它存在依赖关系的所有对象都能收到通知并自动进行更新。 模式动机：建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应。在此，发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展。 模式定义：定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。 模式结构：包含以下四个对象： Subject: 目标 ConcreteSubject: 具体目标 Observer: 观察者 ConcreteObserver: 具体观察者 实现方法：接受通知的对象称为观察者，我们设计一个接口，任何实现这个接口的具体类都会成为一个观察者，接口中主要的方法有： 注册成为观察者的方法 对不同事件的响应方法 发出通知的对象称为被观察者，具有一个通知方法，同时拥有观察者的一个列表和一个用来修改观察者列表的公有API。 这个集合的存在使得让每个观察者都互不干扰，在它们各自的眼里，都认为被观察者对象眼里只有它自己。 优点 观察者模式可以实现表示层和数据逻辑层的分离，并定义了稳定的消息更新传递机制，抽象了更新接口，使得可以有各种各样不同的表示层作为具体观察者角色。 观察者模式在观察目标和观察者之间建立一个抽象的耦合。 观察者模式支持广播通信。 观察者模式符合“开闭原则”的要求。 缺点： 它太慢了：如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 一些改良：链式观察者：原本的观察者使用固定大小的数组或者动态分配内存的集合，当添加或删除观察者的时候，该集合会动态的扩展或者收缩。 我们可以通过一个链表来解决动态分配内存的问题： 注册新的观察者，就将其放在链表头部（尾部也可以，但要额外维护一个尾指针） 删除特定节点可能会遍历整个链表，但是可以使用双向链表来在常量时间内删除一个节点（？） 链表节点池：每一个被观察者对象都维护一个观察者列表，但是现在的链表节点不是观察者本身，而是一个指向观察者对象的指针和指向下一个节点的指针。这样一来，多个链表节点可以指向同一个观察者，意味着一个观察者可以同时观察多个被观察者对象。 由于所有的节点都是同样的大小和类型，因此可以预分配一个内存对象池（？），这样就有了一个固定大小的链表对象池。 销毁被观察者和观察者： 当一个观察者对象被删除时，观察者本身应该负责将其从被观察者对象的列表中移除。 当一个被观察者对象被移除时，被观察者可以向所有的观察者发送一个死亡通知。 总结： 观察者模式包含四个角色：目标又称为主题，它是指被观察的对象；具体目标是目标类的子类，通常它包含有经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知；观察者将对观察目标的改变做出反应；在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致。 观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个目标对象，当这个目标对象的状态发生变化时，会通知所有观察者对象，使它们能够自动更新。 观察者模式的主要优点在于可以实现表示层和数据逻辑层的分离，并在观察目标和观察者之间建立一个抽象的耦合，支持广播通信；其主要缺点在于如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间，而且如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 观察者模式适用情况包括：一个抽象模型有两个方面，其中一个方面依赖于另一个方面；一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变；一个对象必须通知其他对象，而并不知道这些对象是谁；需要在系统中创建一个触发链。]]></content>
      <categories>
        <category>读书笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>行为型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[游戏编程模式：享元模式]]></title>
    <url>%2F2019%2F02%2F28%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F%EF%BC%9A%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[“运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。” 模式动机：当系统中对象数量太多时，将导致运行代价过高，带来性能下降等问题。 享元模式通过通过共享技术实现相同或相似对象的重用。 模式定义：运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。 模式结构：享元模式通过将对象数据切分成两种类型来解决问题。第一种类型数据是那些不属于单一实例对象并且能够被所有对象共享的数据。一般称其为内部状态。第二种数据类型为外部状态：对于每个实例它们都是唯一的。 模式分析：“享元模式是一个考虑系统性能的设计模式，通过使用享元模式可以节约内存空间，提高系统的性能。 享元模式的核心在于享元工厂类，享元工厂类的作用在于提供一个用于存储享元对象的享元池，用户需要对象时，首先从享元池中获取，如果享元池中不存在，则创建一个新的享元对象返回给用户，并在享元池中保存该新增对象。” 优点： 可以极大的节省内存空间，相同或者相似的对象在内存中只保留一份。 享元模式的的外部状态相对独立，而且不会影响其内部状态，使得享元对象可以在不同的环境下被共享。 缺点： 享元模式使得系统更加复杂，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化。 为了使对象可以共享，享元模式需要将享元对象的状态外部化，而读取外部状态使得运行时间变长。 适用场景： 一个系统有大量相同或者相似的对象，由于这类对象的大量使用，造成内存的大量耗费。 对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。 使用享元模式需要维护一个存储享元对象的享元池，而这需要耗费资源，因此，应当在多次重复使用享元对象时才值得使用享元模式。]]></content>
      <categories>
        <category>读书笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>结构型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[游戏编程模式：命令模式]]></title>
    <url>%2F2019%2F02%2F26%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在命令模式中，将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。 模式动机：将命令的调用端、命令以及命令的接受端分开，使得请求发送者与请求接收者消除彼此之间的耦合，让对象之间的调用关系更加灵活。 命令模式可以对发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。这就是命令模式的模式动机。 模式定义：命令模式(Command Pattern)：将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。 模式优点：在命令与角色之间加入的间接层使得我们可以让玩家控制游戏中的任何角色，只需通过改变命令执行时传入的角色对象即可。 一些代码生成命令并将它们放置于命令流中，一些代码执行命令并且调用它们，通过中间的队列，我们将生产者端和消费者端解耦。 撤销与重做：一个命令代表了一个可重用的对象，表示一件可完成的事情。前面的输入处理程序仅维护单一的命令对象，并在对应按钮被按下的时候调用其execute()方法。 支持一次撤销的时候，我们可以保留它们上一个命令，当输入撤销指令的时候，就会调用undo方法；如果想支持多次撤销，我们将维护一个命令列表和一个对“当前”命令的一个引用，每当玩家执行了一个命令，我们就将这个命令添加到列表中，并把current指向它。 模式分析：命令模式的本质是对命令进行封装，将发出命令的责任和执行命令的责任分割开。 每一个命令都是一个操作：请求的一方发出请求，要求执行一个操作；接收的一方收到请求，并执行操作。 命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。 命令模式使请求本身成为一个对象，这个对象和其他对象一样可以被存储和传递。 命令模式的关键在于引入了抽象命令接口，且发送者针对抽象命令接口编程，只有实现了抽象命令接口的具体命令才能与接收者相关联。 缺点： 使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个命令都需要设计一个具体命令类，因此某些系统可能需要大量具体命令类，这将影响命令模式的使用。 适用场景： 需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互；需要在不同的时间指定请求、将请求排队和执行请求；需要支持命令的撤销操作和恢复操作，需要将一组操作组合在一起，即支持宏命令。]]></content>
      <categories>
        <category>读书笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>行为型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BNEI-Chapter 1开发笔记]]></title>
    <url>%2F2019%2F01%2F25%2F%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%2FBNEI-Chapter-1%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[Lua程序设计（0）]]></title>
    <url>%2F2019%2F01%2F21%2FLua%2FLua%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%880%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Lua程序设计的第一篇，主要内容是基本语法以及运算符。 交互模式：在交互模式下，Lua语言解释器如果发现我们输入的某一行不完整，会等待知道程序块或表达式被输入完整后再进行解释执行。 我们可以使用-i参数让Lua语言解释器在执行完制定的程序段之后进入交互模式。 % lua -i prog 在执行完文件prog中的程序段之后进入交互模式。 另一种运行程序段的方式：dofile 我们可以同时打开两个窗口，一个窗口中使用文件编辑器编辑的代码，另一个窗口中使用交互模式运行lua语言解释器，当修改完代码并保存时，只要在Lua语言交互模式的提示符下执行dofile就可以加载新代码，然后就可以观察新代码的函数调用与执行结果了。 词法规范： 标识符是由任意字母，数字和下划线组成的字符串 下划线+大写字母的标识符通常用作特殊用途 可以将下划线+小写字母用作“哑变量” Lua 语言对大小写敏感 单行注释：两个连续的连字符（- -）；多行注释：两个连续的连字符加两对连续左方括号表示长注释或多行注释的开始，直到两个连续的右括号为止，需要重新启用代码时，在第一行行首添加一个连字符即可。 可以用分号对语句进行分隔，但一般不使用 全局变量： 全局变量无需声明便可使用，若使用未经初始化的全局变量，其结果为nil 当把nil赋值给全局变量时，Lua会回收该全局变量 Lua不区分未初始化变量和被赋值为nil的变量，当赋值语句执行后，Lua语言会最终回收该变量占用的内存 类型和值： Lua语言是一种动态类型语言，在这种语言中， 没有类型定义，每个值都有其自身的类型信息。 Lua中有八种基本类型： nil boolean number string userdata function thread table 使用函数type可获取一个值的对应类型名称，以字符串形式表示。 变量没有预定义的类型，任何变量都可以包含任何类型的值。 nil：只有一个nil值的类型，用于与其他所有值进行区分，来表示无效值。 boolean：拥有true与false两个值。 条件测试将除false与nil外的所有值视为真。 逻辑运算符：and、or和not and：如果它的第一个操作数为false，则返回第一个操作数，否则返回第二个操作数 or：如果第一个操作数不为false，则返回第一个操作数，否则返回第二个操作数 not：永远返回Boolean类型的值 两种便捷写法： 123456x=x or v -- 等价于if not x then x = v end -- 当x未被初始化时，将其默认值设置为v--((a and b)or c) -- 当b不为false时，等价于三目运算符：a?b:c 数值从Lua5.3版本开始，Lua为数值类型提供了两种选择： integer：64位整型 float：双精度浮点类型 数值常量： 可以使用科学计数法来表示数值常量 具有十进制小数或者指数的值的数值会被当作浮点型，其余的为整型 整型与浮点型的值的类型都为number，相同算术值的不同整型值与浮点型值是相等的 可使用math.type函数具体区分整型值与浮点型值 可用0x开头表示十六进制常量，也支持十六进制的浮点数，由小数部分和以p或P开头的指数部分组成，其转换规则大抵如下： 十六进制：0xa.bp2，将其拆解为二进制为1010.1011*10^2，即为101010.11，十进制下为42.75 可以使用%a参数与string.format函数对上述格式进行格式化输出： string.format(“%a”,419) —&gt; 0x1.a3p+8 算术运算： 支持加、减、乘、除、floor（//）、取模（%）、指数运算（^） 除法运算操作的永远是浮点数且产生浮点数的结果 floor除法：对得到的商向负无穷取整，以确保结果是一个整数 幂运算的操作数也永远是浮点类型 关系运算： 支持小于、大于、小于等于、大于等于、等于（==）、不等于（～=） 数学库：随机数发生器：math.random用于生成伪随机数，当不带参数调用时，该函数返回一个在[0，1）范围内均匀分布的伪随机实数；当使用整型n作为参数时，返回一个在[1，n]范围内的伪随机整数，使用两个整型值l和u时，返回[l，u]范围内的伪随机整数。 可以用函数randomseed来设置伪随机数发生器的种子，以使加强其随机性。 取整函数： floor函数：向负无穷取整 ceil函数：向正无穷取整 modf函数：向零取整，返回取整后的值以及小数部分作为第二个结果。 表示范围：标准Lua使用64个比特位来存储整型值，其最大值为2^63 - 1；精简Lua使用32个比特位存储整型值。 当对整形操作时出现比mininteger更小或者maxinteger更大的数值时，结果就会回环。在计算机领域，回环的意思就是丢弃最高进位。 对于浮点数而言，标准Lua使用双精度。 运算符优先级：详见：https://www.runoob.com/lua/lua-miscellaneous-operator.html]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[年终总结（2018）]]></title>
    <url>%2F2019%2F01%2F01%2F%E9%9A%8F%E7%AC%94%2F%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%EF%BC%882018%EF%BC%89%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[[Unity] 渲染路径与光源]]></title>
    <url>%2F2018%2F12%2F24%2FUnity%E7%AC%94%E8%AE%B0%2FUnity-%E6%B8%B2%E6%9F%93%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%85%89%E6%BA%90%2F</url>
    <content type="text"><![CDATA[Unity的渲染路径以及更多不同类型的光源。 Unity的渲染路径：渲染路径：在Unity里，渲染路径（Rendering Path）决定了光照是如何应用到Unity Shader中的，如果想让Shader的光照计算正确执行，必须为Shader正确的选择和设置需要的渲染路径。 分类：Unity支持多种类型的渲染路径，在Unity5.0前主要有三种：前向渲染路径（Forward Rendering Path），延迟渲染路径（Deferred Rendering Path）和顶点照明渲染路径（Vertex Lit Rendering Path）。在Unity5.0以后，顶点照明渲染路径已经被Unity抛弃（但目前仍然可以对之前使用了顶点照明渲染路径的UnityShader兼容），新的延迟渲染路径已经代替了旧的延迟渲染路径。 大多数情况下，一个项目只使用一种渲染路径，因此可以为整个项目设置渲染时的渲染路径。 Edit/Project Settings/Player/Other Settings/Rendering Path 如果希望使用多个渲染路径，可以在每个摄像机的渲染路径设置中设置该摄像机使用的渲染路径以覆盖Project Settings中的设置。 【图】 如果选择了Use Player Settings，那么这个摄像机会使用Project Settings中的设置；否则就会覆盖掉Project Settings中的设置。如果当前的显卡不支持所选择的渲染路径，Unity会自动使用更低一级的渲染路径。 LightMode支持的渲染路径设置选项： 标签名 描述 Always 不管使用哪种渲染路径，该Pass总是会被渲染，但不会计算任何光照 ForwardBase 用于前向渲染，该Pass会计算环境光、最重要的平行光、逐顶点/SH光源和Lightmaps ForwardAdd 用于前向渲染，该Pass会计算额外的逐像素光源，每个Pass对应一个光源 Deferred 用于延迟渲染，该Pass会渲染G缓冲（G-buffer） ShadowCaster 把物体的深度信息渲染到阴影映射纹理（shadowmap）或一张深度纹理中 PrepassBase 用于遗留的延迟渲染，该Pass会渲染法线和高光反射的指数部分 PrepassFinal 用于遗留的延迟渲染，该Pass通过合并纹理，光照与自发光来渲染得到最后的颜色 Vertex，VertexLMRGBM和VertexLM 用于遗留的顶点照明渲染 前向渲染路径：前向渲染路径是传统的渲染方式，也是我们最常用的一种渲染路径。 前向渲染路径的原理： 每进行一次完整的前向渲染，我们需要渲染该对象的渲染图元，并计算两个缓冲区的信息：颜色缓冲区与深度缓冲区。我们利用深度缓冲来决定一个片元是否可见，如果可见就更新颜色缓冲区中的颜色值。 12345678910111213141516Pass&#123; for(each primitive in this model)&#123; for(each fragment covered by this primitive)&#123; if(failed in depth test)&#123; // 未通过深度测试，该片元不可见 discard; &#125; else&#123; // 可见则进行光照计算 float4 color = Shading(materialInfo,pos,normal,lightDir,viewDir); // 更新帧缓冲 writeFrameBuffer(fragment,color); &#125; &#125; &#125;&#125; 对于每个逐像素光照，我们都需要进行上面一次完整的渲染流程。如果一个物体在多个逐像素光源的影响区域内，那么该物体就需要执行多个Pass，每个Pass计算一个逐像素光源的光照结果，然后在帧缓冲中把这些光照结果混合起来得到最终的颜色值。 Unity中的前向渲染 在Unity中，前向渲染路径有三种处理光照的方式：逐顶点处理，逐像素处理，球谐函数（Spherical Harmonics）处理。而决定一个光源使用哪种处理模式取决于它的类型和渲染模式。 光源类型：该光源是平行光还是其他类型的光源 光源的渲染模式：该光源是否是重要的（Important），决定是否将其当作逐像素光源处理。 在前向渲染中，Unity会根据场景中各个光源的设置以及这些光源对物体的影响程度（距离物体远近，光源强度等）来对光源进行一个重要度排序。其中，一定数目的光源会按照逐像素的方式进行排序，最多有4个光源按照逐顶点的方式进行处理，剩下的光源可以按照SH方式处理： 场景中最亮的平行光总是按照逐像素处理 渲染模式被设置成Not Important的光源，会按逐顶点或者SH处理 渲染模式被设置成Important的光源，会按逐像素处理 如果以上规则得到的逐像素光源数量小于Quality Setting中的逐像素光源数量（Pixel Light Count），会有更多的光源以逐像素的方式进行渲染 前向渲染的光照计算细节： 需要使用编译指令保证Unity可以为相应类型的Pass生成所有需要的Shader变种，这些变种会处理不同条件下的渲染逻辑：是否使用光照贴图，当前处理哪种光源类型，是否开启了阴影等。 Base Pass中的平行光默认是支持阴影的，而Additional Pass中渲染的光源在默认情况下是没有阴影效果的，即使在Light组件中设置了有阴影的Shadow Type，但可以在Additional Pass中使用#pragma multi——compile_fwdadd_fullshadows代替#pragma multi_compile_fwdadd编译指令，这会为点光源和聚光灯开启阴影效果，但需要在Unity内部使用更多的Shader变种。 如果不在Additional Pass中开启混合模式，其渲染结果将会覆盖掉之前的渲染结果，通常情况下，混合模式选择Blend One One。 对于前向渲染来说，一个Unity Shader通常会定义一个Base Pass以及一个Additional Pass。一个Base Pass仅会执行一次，而一个Additional Pass会根据影响该物体的其他逐像素光源的数目被多次调用，即每个逐像素光源会执行一次Additional Pass。 内置的光照变量和函数（前向渲染） 光照变量名称 类型 描述 _LightColor0 float4 该Pass处理的逐像素光源的颜色 _WorldSpaceLightPos0 float4 _WorldSpaceLightPos0.xyz是该Pass处理的逐像素光源的位置，如果该光源类型是平行光，则_WorldSpaceLightPos0.w = 0，其他类型为1 _LightMatrix0 float4x4 从世界空间到光源空间的变换矩阵，可以用于采样cookie和光强衰减（attenuation）纹理 unity_4LightPosX0，unity_4LightPosY0，unity_4LightPosZ0 float4 仅用于Base Pass。前四个非重要的点光源在世界空间内的位置。 unity_4LightAtten0 float4 仅用于Base Pass。存储了前四个非重要的点光源的衰减因子。 unity_LightColor half4[4] 仅用于Base Pass。存储了前四个非重要的点光源的颜色。 光照函数名 描述 float3 WorldSpaceLightDir(float4 v) 仅可用于前向渲染中。输入一个模型空间中的顶点位置，返回世界空间中从该点到光源的光照方向。内部实现使用了UnityWorldSpaceLightDir函数，没有被归一化。 float3 UnityWorldSpaceLightDir(float4 v) 仅可用于前向渲染中。输入一个世界空间中的顶点位置，返回世界空间中从该点到光源的光照方向，没有被归一化。 float3 ObjSpaceLightDir(float4 v) 仅可用于前向渲染中。输入一个模型空间中的顶点位置，返回模型空间中从该点到光源的光照方向，没有被归一化。 float3 Shade4PointLights(…) 仅可用于前向渲染中。计算四个点光源的光照，它的参数是已经打包进矢量的光照数据，通常是上述的光照变量，前向渲染通常会使用这个函数来计算逐顶点光照。 顶点照明渲染路径：顶点照明渲染是对硬件配置要求最少、运算性能最高，但同时也是得到的效果最差的一种类型。它不支持那些逐像素才能得到的效果，例如阴影、法线映射、高精度的高光反射等。 Unity中的顶点照明渲染： 顶点照明渲染路径通常在一个Pass中就可以完成对物体的渲染，在这个Pass中，我们通过逐顶点处理的方式计算所有我们关心的所有光源对该物体的照明。这是Unity中最快速的渲染路径，并且具有最广泛的硬件支持。 可访问的内置变量和函数： 如果我们只需要渲染其中两个光源对物体的照明，可以仅使用_LightColor0与_WorldSpaceLightPos0。如果影响该物体的光源数目小于8，那么数组中剩下的光源颜色会被设置成黑色。 内置变量名称 类型 描述 unity_LightColor half4[8] 光源颜色。 unity_LightPosition float4[8] xyz分量是视角空间中的光源位置，如果光源是平行光，那么z分量值为0，其他光源类型z分量值为1。 unity_LightAtten half4[8] 光源衰减因子。如果光源是聚光灯，x分量是cos(spotAngle/2)，y分量值为1/cos(spotAngle/4)；如果是其他类型的光源，x分量是-1，y分量是1。z分量是衰减的平方，w分量是光源范围开根号的结果。 unity_SpotDirection float4[8] 如果光源是聚光灯的话，值为视角空间的聚光灯的位置；如果是其他类型的光源，值为(0,0,1,0)。 内置函数名称 描述 float3 ShaderVertexLights(float4 vertex,float3 normal) 输入模型空间中的顶点位置和法线，计算四个逐顶点光源的光照以及环境光。内部实现实际上调用了ShaderVertexLightsFull函数。 Float3 ShaderVertexLightsFull (float4 vertex,float3 normal, int lightCount,bool spotLight) 输入模型空间中的顶点位置和法线，计算lightCount个光源的光照以及环境光，如果spotLight值为true，那么这些光源会被当作聚光灯来处理，虽然结果更精确，但计算更加耗时；否则按点光源处理。 延迟渲染路径： 前向渲染的问题：当场景中包含大量实时光源的时候，前向渲染的性能会急速下降。多个影响范围相互重叠的光源为了得到最终的光照效果，会将该区域的每个物体执行多个Pass来计算不同光源对该物体的光照结果，然后在颜色缓存中把这些结果混合起来得到最终的光照。然而，每执行一个Pass都要重新渲染一次物体，这导致了重复计算。 延迟渲染：利用颜色缓冲，深度缓冲以及额外的G-缓冲区，它存储了我们关心的表面的其他信息——法线，位置，用于光照计算的材质属性等。 延迟渲染的原理： 延迟渲染主要运用了两个Pass：在第一个Pass中，我们不进行任何光照计算，而是仅仅计算哪些片元是可见的，这主要是通过深度缓冲技术来实现，当发现一个片元是可见的，我们就把它的相关信息存储到G缓冲区中，然后在第二个Pass中，我们利用G缓冲区的各个片元信息来进行真正的光照计算。 延迟渲染使用的Pass数目通常就是两个，这跟场景中包含的光源数目没有关系——即延迟渲染的效率不依赖于场景的复杂度，而是和我们使用的屏幕空间大小有关。 Unity中的延迟渲染： 对于延迟渲染路径来说，它最适合在场景中光源数目很多、如果使用前向渲染会造成性能瓶颈的情况下使用。而且，延迟渲染路径中的每个光源都可以用逐像素的方式进行处理。 缺点： 不支持真正的抗锯齿（anti-aliasing）功能 不能处理半透明物体 对显卡有一定要求 当使用延迟渲染时，我们需要提供两个Pass 第一个Pass用于渲染G缓冲，在这个Pass中，我们会把物体的漫反射颜色、高光反射颜色、平滑度、法线、自发光和深度等信息渲染到屏幕空间的G缓冲区中，对于每个物体来说，这个Pass仅会执行一次。 第二个Pass用于计算真正的光照模型。这个Pass会使用上一个Pass中渲染的数据来计算最终的光照颜色，再存储到帧缓冲中。 默认的G缓冲区包含了以下几个渲染纹理： RT0：格式是ARGB32，RGB通道用于存储漫反射颜色，A通道没有被使用 RT1：格式是ARGB32，RGB通道用于存储高光反射颜色，A通道用于存储高光反射的指数部分 RT2：格式是ARGB2101010，RGB通道用于存储法线，A通道没有被使用 RT3：格式是ARGB32（非HDR）或ARGBHalf（HDR），用于存储自发光+lightmap+反射探针 深度缓冲和模版缓冲 可访问的内置变量和函数： 名称 类型 描述 _LightColor float4 光源颜色 _LightMatrix0 float4x4 从世界空间到光源空间的变换矩阵。可以用于采样cookie和光强衰减纹理 选择哪种渲染路径：关于四种渲染路径的Unity的官方文档 Unity的光源类型：支持的光源类型： 平行光 点光源 聚光灯 面光源：（仅在烘焙时才可发挥作用） 具体介绍： 光源属性：位置，强度，方向，颜色，衰减 平行光： 照亮的范围没有限制 几何属性只有方向，且到所有点的方向都是一样的 没有衰减的概念 点光源： 照亮空间有限，由空间中的一个球体定义]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>UnityShader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[图形学] 经典光照模型]]></title>
    <url>%2F2018%2F12%2F20%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%2F%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%BB%8F%E5%85%B8%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Lambert模型，Phong模型，Blinn-Phong模型，全局光照模型 光源： 环境光(Ambient Light)：从物体表面所产生的反射光的统一照明，称为环境光或背景光(计算机图形学第二版 389 页)。通常我们认为理想的环境光具有如下特性：没有空间或方向性；在所有方向上和所有物体表面上投射的环境光强度是统一的恒定值。 环境光是对光照现象的最简单抽象，局限性很大。它仅能描述光线在空间中无方向并均匀散布时的状态。真实的情况是：光线通常都有方向。点光源是发光体的最简单的模型，光线由光源出发向四周发散。还有一种是平行光，即光线都从同一个方向照射。通过模拟方向光和物体表面的交互模式，可以渲染出具有高真实感(明暗变化、镜面反射等)的三维场景。 漫反射与 Lambert 模型：定义： 漫反射：粗糙的物体表面向各个方向等强度地反射光，这种等同地向各个方向散射的现象称为光的漫反射(diffuse reflection)。 产生光的漫反射现象的物体表面称为理想漫反射体，也称为朗伯(Lambert)反射体。 仅暴露在环境光下：对于仅暴露在环境光下的朗伯反射体，可以用公式1表示某点处漫反射的光强： 公式1：$I_{ambdiff} = K_dI_a$ 其中$Ia$表示环境光强度(简称光强)，$K_d (0&lt; K_d &lt;1)$为材质对环境光的反射系数，$I{ambdiff}$ 是漫反射体与环境光交互反射的光强。 即使一个理想的漫反射体在所有方向上具有等量的反射光线，但是表面光强还依赖于光线的入射方向(方向光)。例如，入射光方向垂直的表面与入射光方向成斜角的表面相比，其光强要大的多。这种现象可以用 Lambert 定律进行数学上的量化。 Lambert 定律当方向光照射到朗伯反射体上时，漫反射光的光强与入射光的方向和入射点表面法向夹角的余弦成正比。 Lambert漫反射模型： 公式2：$I_{ldiff} = k_dI_lcosθ$ $Il$ 是点光源强度，$θ$ 是入射光方向与顶点法线的夹角，称为入射 $(0≤θ≤90°)$，$I{ldiff}$ 是漫反射体与方向光交互反射的光强。入射角为零时，说明光线垂直于物体表面，漫反射光强最大;90°时光线与物体表面平行，物体接收不到任何光线。 若 N 为顶点单位法向量，L 表示从顶点指向光源的单位向量(注意，是由顶点指向光源，不要弄反了)，则cosθ 等价于N 与L的点积。所以公式2可以表示为公式3: 公式3：$I_{ldiff} = k_dI_l(N·L)$ Lambert光照模型：结合环境光与漫反射模型 $I{diff} = I{ambdiff} + I_{ldiff} = K_dI_a + k_dI_l(N·L)$ 在实际应用中，为了防止点积结果为负值，需要用max函数对其进行筛选。 Unity Shader实现漫反射光照模型：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 仅为核心实现Properties&#123; // 属性，用于存储我们想得到并控制的漫反射颜色 _Diffuse(&quot;Diffuse&quot;,Color) = (1,1,1,1)&#125;SubShader&#123; Pass&#123; Tags&#123;&quot;LightMode&quot; = &quot;ForwardBase&quot;&#125; &#125; CGPROGRAM #pragma vertex vert #pragma fragment frag #include &quot;Lighting.cginc&quot; fixed4 _Diffuse; struct a2v&#123; float4 vertex : POSITION; // 模型顶点的法线信息 float3 normal : NORMAL; &#125;; struct v2f&#123; float4 pos : SV_POSITION; fixed3 color : COLOR; &#125; v2f vert(a2v v) &#123; v2f o; // 将顶点位置从模型空间转换到裁剪空间 o.pos = mul(UNITY_MATRIX_MVP,v.vertex); // 内置环境光 fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz; // 将法线转换到世界空间下与光源方向做点积(只有在同一坐标空间下的点积才有意义) fixed3 worldNormal = normalize(mul(v.normal,(float3x3)_World2Object)) fixed3 worldLight = normalize(_WorldSpaceLightPos0.xyz); // 即上述I_diff模型公式 fixed diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal,worldLight)); o.color = ambient + diffuse; return o; &#125; fixed4 frag(v2f i):SV_Target&#123; return fixed4(i.color,1.0); &#125; Fallback &quot;Diffuse&quot;&#125; 半兰伯特（Half Lambert）光照模型：$I{diffuse} = (I{light}·k_{diffuse})(α(n·l)+β)$ 对点积结果进行一个α倍的缩放与大小为β的偏移。通过这样的方式，我们可以将点积的结果从[-1,1]映射到[0,1]范围内，对于模型的背光面，兰伯特光照模型将统一映射到0处，而半兰伯特光照模型中，背光面也可以有明暗变化，不同的点积结果将会映射到不同的值上。 Unity Shader 实现半兰伯特模型：123456789101112// ...环境光照与上大致相同fixed4 frag(v2f i):SV_Target&#123; ... // Compute diffuse term fixed halfLambert = dot(worldNormal,worldLightDir) * 0.5 + 0.5; fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * halfLambert; fixed3 color = ambient + diffuse; return fixed4(color,1.0);&#125; 镜面反射与 Phong 模型：定义： 镜面反射：一个光滑物体被光照射时，可以在某个方向上看到很强的反射光，这是因为在接近镜面反射角的一个区域内，反射了入射光的全部或绝大部分光强，该现象称为镜面反射。 phong模型：Phong Bui Tuong 提出一个计算镜面反射光强的经验模型，称为phong模型，认为镜面反射的光强与反射光线和视线的夹角相关。 Phong模型的数学表达：$I_{spec} = k_sI_l（V·R）^{n_s}$ $k_s$ 为材质的镜面反射系数，$n_s$ 是高光指数，$V$ 表示从顶点到视点的观察方向， $R$ 代表反射光方向。 高光指数反映了物体表面的光泽程度。${n_s}$越大，反射光越集中，当偏离反射方向时，光线衰减的越厉害，只有当视线方向与反射光线方向非常接近时才能看到镜面反射的高光现象，此时，镜面反射光将会在反射方向附近形成亮且小的光斑；$n_s $越小，表示物体越粗糙，反射光分散，观察到的光斑区域小，强度弱。 反射光的方向$R$可以通过入射光方向$L$(从顶点指向光源)和物体法向量 $N$ 求出: $R+L = (2N·L)N$ 故：$R = (2N·L)N-L$ Unity Shader实现Phong模型：12345678910111213141516171819202122// ...仅给出核心实现代码v2f vert(a2v v)&#123; v2f o; o.pos = mul(UNITY_MATRIX_MVP,v.vertex); fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz; fixed3 worldNormal = normalize(mul(v.normal,(float3x3)_World2Object)); fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz); fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal,worldLightDir)); fixed3 reflectDir = normalize(reflect(-worldLightDir,worldNormal)); fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - mul(_Object2World,v.vertex).xyz); fixed3 specular = _LightColor.rgb * _Specular.rgb * pow(saturate(dot(reflectDir,viewDir)),_Gloss); o.color = ambient + diffuse + specular; return o;&#125; Blinn-Phong 光照模型：定义： Blinn-Phong 光照模型：又称为 Blinn-phong 反射模型(Blinn–Phong reflectionmodel)或者 phong 修正模型(modified Phong reflection model)和传统 phong 光照模型相比，Blinn-phong 光照模型混合了 Lambert 的漫射部分和标准的高光，渲染效果有时比 Phong 高光更柔和、更平滑，此外它在速度上相当快，因此成为许多 CG 软件中的默认光照渲染方法。 Blinn-Phong模型的数学表达：phong 光照模型中，必须计算$V • R$ 的值，其中 $R$ 为反射光线方向单位向量，$V$ 为视线方向单位向量，但是在 Blinn-phong 光照模型中，用 $N • H$ 的值取代了$V • R$ 。Blinn-phong 光照模型公式为: $I_{spec} = k_sI_l(N·H)^{n_s}$ 其中 N 是入射点的单位法向量， $H$是“光入射方向 $L$ 和视点方向$V$ 的中间向量”，通常也称之为半角向量。注意:半角向量被广泛用于各类光照模型，原因不但在于半角向量蕴含的信息价值，也在于计算半角向量是一件简单、耗时不多的工作。 $H = {L+V}/{|L+V|}$ 通常情况下，使用 Blinn-phong 光照模型渲染的效果和 phong 模型渲染的效果没有太大的区别，有些艺术工作者认为 phong 光照模型比 blinn-phong 更加真实，实际上也是如此。Blinn-phong 渲染效果要更加柔和一些，Blinn-phong 光照模型省去了计算反射光线方向向量的两个乘法运算，速度更快。由于 Blinn-phong和 phong 模型的唯一区别一个使用半角向量，一个使用反射光方向向量。 Unity Shader 实现Blinn-Phong模型：123456789101112// ...fixed4 frag(v2f i):SV_Target&#123; ... fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz); fixed3 halfDir = normalize(worldLightDir + viewDir); fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0,dot(worldNormal,halfDir)),_Gloss); return fixed4(ambient + diffuse + specular,1.0);&#125; 全局光照模型与 Rendering Equation：数学表达：$L_o (x, w_o ) = L_e (x, w_o ) + ∫ f_r (x, w_i , w_o )L_i (x, w_i )(n • w_i )dw_i$ $x$表示入射点，$L_o (x, w_o ) $即从物体表面$x$点，沿方向$w_o$反射的光强；$L_e (x, w_o )$表示从物体表面$x$以方向$w_o$发射出去的光强，该值仅对自发光体有效；$ f_r (x, w_i , w_o )$为入射光线方向为$w_i$，照射到点x上，然后从$w_o$方向发射出去的BRDF值；$L_i (x, w_i )$为入射方向为$w_i$，照射到点$x$上的入射光强；$n$表示点$x$处的法向量。然后对入射方向进行积分（因为光线入射的方向是四面八方的，积分的意义是对每个方向进行一遍计算后进行相加），计算的结果就是“从观察方向上看到的辐射率”。 该公式基于物理光学，对观察方向上的辐射率进行了本质上的量化，前面所讲的漫反射光照模型以及phong高光模型其实是公式在单一光源，特定BRDF下的推导。 对于单个点光源照射到不会自发光的物体上，公式可以简化为： $L_o (x, w_o ) = f_r (x, w_i , w_o )L_i (x, w_i )(n • w_i )$ 对于漫反射表面，公式可以写成： $Lo (x, w_o ) = I{diff}+ f_r (x, w_i , w_o )L_i (x, w_i )(n • w_i )$ 对于phong高光而言： $f_{rs}(x,w_i,w_o)=k_s(n·h)^{n_s}/n·w_i$ 参考书目： 《Unity Shader入门精要》冯乐乐 《GPU 编程与CG 语言之阳春白雪下里巴人》康玉之]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>图形学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[翻译] CineMachine用户手册（0）]]></title>
    <url>%2F2018%2F12%2F20%2F%E7%BF%BB%E8%AF%91%2F%E7%BF%BB%E8%AF%91-CineMachine%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C%EF%BC%880%EF%BC%89%2F</url>
    <content type="text"><![CDATA[CineMachine用户手册翻译的第一部分：安装并开始，以及一些相机组件的属性介绍。 [TOC] What is Cinemachine? : 什么是Cinemachine？Cinemachine is a suite of ‘smart’ procedural modules which allow you to define the shot andthey’ll dynamically follow your direction. Setup shots which track and compose motion inrealtime, like AI camera operators. The procedural nature makes them bug-resistant as theyalways work to make the shot based on your direction. That’s great for gameplay, but they’realso amazingly fast for cutscenes. Change an animation, a vehicle speed, ground terrain -whatever - and Cinemachine will dynamically make the shot. You can use really telephotolenses and not have to update the cutscene if things change . Cinemachine是一套“智能”程序模块，可以让你定义镜头并且他们会动态地按照你的指示行事。如同一个AI相机操作员般，实时地设置跟踪和组成运动的镜头。程序性质使它们像它们一样具有抗病性总是根据你的方向努力拍摄。这对于游戏玩法来说非常棒，并且它们在过场动画的表现也出人意料的快。改变动画、车速、地面地形或者无论什么效果——Cinemachine都将动态拍摄。你可以使用真正的长焦镜头，如果事情发生变化，不必更新过场动画。 History :Cinemachine has been in development over a number of years across multiple projects We’ve been designing camera systems for almost 20 years and have shipped millions of AAA titles across numerous genres. The Cinemachine team has an award winning cinematographer and a senior engineer with heavy math skills. Also, we love this stuff to bits. Cinemachine多年来一直处于多个项目的开发之下，我们已经设计了相当近20年的相机系统，并已经出版了数百万种AAA级别的游戏。 Cinemachine团队拥有一位屡获殊荣的摄影师和一名具有繁重数学技能的高级工程师。 此外，我们喜欢这些东西。 Mission :Our mission with Cinemachine is built to be an entirely united camera system bridging gameplay, cutscenes, from fully procedural cameras to entirely canned sequences and everything in between. 我们与Cinemachine的使命是建立一个完全统一的相机系统，与游戏玩法，过场动画，从完全程序相机到完全固定序列以及介于两者之间的所有内容相衔接。 Example Scenes :Please have a look at our example scenes. They are shipped with the package under Assets/Cinemachine/Examples. This folder also includes some handy noise presets that you can use as a starting point for implementing camera noise. 请看一下我们的示例场景。 它们随Assets / Cinemachine / Examples下的package一起提供。 此文件夹还包括一些方便的噪音预设，您可以将其用作实现相机噪音的起点。 Forums :We have a busy discussion area on the forums.https://forum.unity3d.com/forums/cinemachine.136/ 我们在论坛上有一个热闹的讨论区。 Frequently asked questions : Do we have to replace our camera system with Cinemachine? No, Cinemachine can work alongside your existing camera system and you can seamlessly blend back and forth between both systems. If you wrote some camera tech you love but want Cinemachine for something else, no problem, mix the two together. 我们是否必须用Cinemachine替换我们的相机系统？ 不，Cinemachine可以与您现有的相机系统配合使用，您可以在两个系统之间来回无缝混合。 如果你写了一些你喜欢的相机技术，但想要Cinemachine的一些别的东西，没问题，将两者混合在一起。 Isn’t having all these cameras around kind of heavy?No, in fact it’s incredibly light. Each virtual camera has a super low overhead - make as many as you want. If you are hypersensitive to performance you can disable all the cameras and just enable the ones you wish to have running at any given moment for extreme performance. 是不是所有这些相机都很沉重（耗费性能）？ 不，实际上它非常轻盈。 每个虚拟摄像机都具有超低的开销 - 可以根据需要进行调整。 如果您对性能敏感，可以禁用所有摄像头，只需启用您希望在任何给定时刻运行的摄像头以获得极致性能。 How does it all work?Cinemachine works a bit like a marionette system for your existing Main Camera. It doesn’t create any new cameras, only new virtual ones. The Cinemachine ‘Brain’ component is automatically added to the Main Camera in your scene and Cinemachine works with all its camera blending, priority, mixing magic to deliver a set of transforms to your Main Camera. Because it’s a completely unified system, you can blend from any camera type to any other. Seamlessly go from an in-game freelook system to a keyframed cutscene camera and back. Any combination is possible and the options are limitless. 它是怎么运行的？ Cinemachine的工作方式有点像现有主摄像头的牵线木偶系统。 它不会创建任何新的相机，只会创建新的虚拟相机。 Cinemachine’Brain’组件会自动添加到场景中的主摄像头中，Cinemachine可以使用其所有摄像头混合，优先级，混合效果来为主摄像头提供一组变换。 因为它是一个完全统一的系统，您可以从任何相机类型混合到任何其他类型。 无缝地从游戏中的freelook系统转变为关键帧的过场动画相机和背部。 任何组合都是可能的，选项是无限的。 Can I really save all my tunings in Play mode?Yes! Almost everything in Cinemachine saves in play mode so jump in and tune some cameras while the game is running. When you think about it, it’s really the only way to do it. We want you to get right into the zone and massage cameras at any point in your game - while you’re in there playing it. Our engineer spent a long time on our camera system and doesn’t want to change it. We hear this a lot. It’s never fun to throw code away but you need to think about the big picture of your project. If you can get up and running really quickly creating and tuning cameras without further bothering your engineer, isn’t that an advantage? It’s doubtful your existing system behaves exactly as desired in every scenario so there’s yet more coding to be done anyway. Cameras are such a huge part of your project and good cameras can make the difference between an OK game and an amazing one. Try running Cinemachine next to your existing cameras and see what it’s like. If that engineer is still reluctant share this idea with them - Rockets eject perfectly great booster sections to get into space. That camera code helped push you into orbit! Great scenes are often left on the editing room floor. Make the decision that’s best for your project. 我可以在Play模式下真正保存所有调试吗？ 当然！ Cinemachine中的几乎所有内容都保存在播放模式中，因此在游戏运行时跳入并调整一些相机。 当你想到它时，它确实是唯一的方法。 我们希望您在游戏中的任何一个时间点都能直接进入区域并调整相机 - 即使您在运行中时。 我们的工程师花了很长时间在我们的相机系统上，并不想改变它。 我们听到了很多。抛弃代码永远不会有趣，但你需要考虑项目的大局。如果您能够在不进一步打扰工程师的情况下快速启动并运行创建和调整摄像头，那么这不是一个优势吗？令人怀疑的是，您现有的系统在每种情况下的行为都完全符合要求，因此无论如何还有更多的编码要做。 摄像机是你项目中非常重要的一部分，好的摄像机可以在一个尚可的游戏和一个惊人的游戏之间产生差距。尝试在现有相机旁边运行Cinemachine，看看它是什么样的。如果那个工程师仍然不愿意与他们分享这个想法——火箭队会弹出非常好的助推器部分进入太空。相机代码帮助你进入轨道！编辑室的场景经常留下很棒的场景。做出最适合您项目的决定。 Can I mix between gameplay and cutscene cameras?You can mix between any cameras. Seamless transitions from gameplay to cutscene and back are as easy as turning on a camera or playing a Timeline with CM clips on it. 我可以将游戏玩法和过场动画相机过渡吗？ 你可以在任何相机之间过渡。 从游戏玩法到过场动画和后背的无缝过渡就像打开相机或播放带有CM剪辑的时间轴一样简单。 How do you typically configure the cameras for a project?Instead of one big ball-of-code camera trying to do everything, you make lots of custom vcams for every given moment and turn them on when needed. Blending or cutting to a new camera is as easy as turning one on. If the priority is the same or higher, CM will use the new camera and blend to it based on how you’ve defined the default blend or any other blends in the Custom Blends section of the CM ‘Brain’ on the Main Camera. 您通常如何为项目配置摄像头？ 区别于一个大的代码相机试图做所有事情，你为每个给定的时刻制作了许多自定义vcams，并在需要时打开它们。 将新相机混合或切割就像打开一个相机一样简单。 如果优先级相同或更高，CM将使用新相机并根据您在主相机上CM’Brain’的自定义混合部分中定义的默认混合方式或任何其他混合的方式进行混合。 I don’t want to drastically change the camera in X scenario, I just want a little tweak. Camera changes can be really subtle. You can duplicate your main camera, only change the FOV or Composition and then blend to that camera just when a player enters a trigger volume. You can turn on vcams with only the subtlest of differences to get exactly the behavior you want in whatever situation. Projects can have many vcams all with only minor changes, ready and waiting for whatever game scenario demands them. 我不想在X场景中大幅改变相机，我只想稍微调整一下。 相机的变化可能会非常微妙。 您可以复制主摄像头，仅更改FOV或构成方式，然后在玩家进入触发音量时混合到该摄像头。您可以只使用最细微的差异打开vcams，以在任何情况下获得您想要的行为。 项目可以拥有许多vcams，只需进行微小的更改，准备好并等待任何游戏场景需要它们。 When would I use the State Driven Camera? Why have so many camera rigs?The SDC makes it super easy to link animations and states to different cameras. Picture your character’s local-motion system and orbit camera. It makes your game feel so much more alive when the camera shakes a bit more when your character is running, when the camera pulls back to a larger orbit when they go outside, when the camera gets all close when the character is sneaking around. The SDC allows you to craft the cameras to best suit what your player is doing. 我何时使用状态驱动相机？ 为什么有这么多摄像机装备？ SDC可以非常轻松地将动画和状态链接到不同的摄像机。 想象你角色的本地运动系统和轨道摄像机。 当你的角色在跑步时，相机可以轻微的抖动；当角色向外走时，相机可进入一个更大的轨道；当角色偷偷摸摸移动时，相机可以全部靠近，这些会使你的游戏感觉更加生动。 SDC允许您制作最适合您的播放器正在进行的相机。 For example, one project in dev had 20+ different camera rigs all listening to animations and game events. Stand, walk, sprint, jump, attack, &gt;3 enemies arrive, inside, outside, trigger volumes in particular areas of the map, health &lt;20%, etc. So much control is easily possible. 例如，开发中的一个项目有20多个不同的摄像机装备都在收听动画和游戏事件。 站立，行走，冲刺，跳跃，攻击，3个以上的敌人到达，内部，外部，触发地图特定区域的体积，健康&lt;20％等。如此多的控制很容易。 Overview :Cinemachine is a modular suite of camera tools for Unity which give AAA game quality controls for every camera in your project. It’s an easy to install plugin which lets you add functionality to cameras you’ve already got, or make new ones with amazing behaviors. Cinemachine has been designed to be the entire unified camera system in your project but can be used alongside your existing cameras as well. If you have a bunch of camera stuff working already and just want to use Cinemachine for cutscenes or something specific, no problem at all. However when you use it across your project it allows you to blend any camera to any other camera in a gameplay-to-cutscene-and-back-seamlessly kind of way. The heart of Cinemachine is two components; everything else builds on those. They are: Cinemachine是Unity的模块化相机工具套件，可为项目中的每个相机提供AAA游戏质量控制。 这是一个易于安装的插件，可以让您为已经拥有的相机添加功能，或者制作具有丰富行为的新相机。 Cinemachine被设计出来作为您项目中的整个统一摄像系统，但也可以与现有摄像头一起使用。 如果你有一堆相机的东西已经工作，只是想使用Cinemachine的过场动画或特定的东西，没有任何问题。 除此之外，当您在整个项目中使用它时，它也允许您将任何相机混合到从游戏玩法到过场动画再返回过程中的任何其他相机，诸如此类。 Cinemachine的核心是两个件; 其他的一切内容都建立在它们之上。 他们是： Cinemachine Virtual Camera :The Virtual Camera is a shot, a single camera. It has child modules which you can turn on to make it do things like procedurally track and compose objects, follow things and shake with procedural noise. Together they are a very powerful combination and can yield an unlimited number of results. These modules have been designed, re-designed and re-designed again to offer the widest range of possibilities with the least number of controls. The math driving these camera behaviours is complex and sophisticated, having gone through many different scenarios across all sorts of games. The reason for the ‘virtual’ camera scenario is because Unity renders from the main camera. Out-of-the-box Unity is limited to only one camera being active camera at a time – which makes the blending of two shots effectively impossible. Cinemachine is engineered to solve this and provide a wealth of simple, powerful functionality at the same time, allowing unsurpassed camera behaviors which are fast and easy to setup. 虚拟相机是一个镜头，一个相机。它有一些子模块，您可以打开这些模块，使其执行程序跟踪和组合对象，跟踪事物并使用程序噪声进行抖动。它们是一个非常强大的组合，可以产生无数的结果。 这些模块经过设计，重新设计和再次重新设计，以最少的控制提供最广泛的可能性。推动这些摄像机行为的数学复杂而精密，在各种游戏中经历了许多不同的场景（的考验）。 “虚拟”相机场景的原因是因为Unity从主相机渲染。开箱即用的Unity限定在同一时间仅能有一台摄像机是有源摄像机 —— 这使得有效地无法混合两个镜头。 Cinemachine旨在解决这个问题，同时提供丰富的简单，强大的功能，允许无与伦比的相机行为，并且它们快速，易于设置。 Cinemachine Brain :This is the central Cinemachine component that does all the magic. It’s a component attached to the Unity camera and it monitors all the Virtual Cameras in the scene and drives the Unity camera using the shot it likes best. 这是中央Cinemachine组件，可以完成所有效果。 它是连接到Unity摄像头的一个组件，它监视场景中的所有虚拟摄像机，并使用它最喜欢的镜头驱动Unity摄像机。 Installation and Getting Started ：安装并开始Installing Cinemachine is easy. Drag the Cinemachine unitypackage onto your assets folder in Unity, OR Install it directly: Assets-&gt;Import Package -&gt;Custom Package… and point to the Cinemachine unitypackage. Setup the Cinemachine Virtual Cameraenvironment Cinemachine-&gt; Create Virtual Camera. This is also the way to create additional Cinemachine shots. That’s it! You now have Cinemachine installed on your machine. 安装Cinemachine很容易。 将Cinemachine unitypackage拖到Unity中的assets文件夹中，或直接安装：Assets-&gt; Import Package - &gt; Custom Package …并指向Cinemachine unitypackage。 设置Cinemachine虚拟摄像机环境Cinemachine-&gt;创建虚拟摄像机。这也是创建其他Cinemachine镜头的方法。 仅此而已！您现在已在计算机上安装了Cinemachine。 You will notice two changes to your scene: The main camera has a little icon next to it in the scene hierarchy. This indicates that your camera has been Cinemachine-enabled using a new component: the CinemachineBrain. A new GameObject CM vcam1 with a CinemachineVirtualCamera component, which is a single camera or shot. 您会注意到场景的两处变化： 主摄像机在场景层次结构中旁边有一个小图标。这表示您的相机已使用新组件启用Cinemachine：CinemachineBrain。 带有CinemachineVirtualCamera组件的新GameObject CM vcam1，它是一个摄像头或镜头。 There’s more info below on how to use these new things. Don’t forget to check out the example scenes included in Cinemachine/Examples/Scenes, and please visit our user forum at https://forum.unity3d.com/forums/cinemachine.136/ 下面有关于如何使用这些新东西的更多信息。不要忘记查看Cinemachine / Examples / Scenes中包含的示例场景，请访问我们的用户论坛：https：//forum.unity3d.com/forums/cinemachine.136/ User Guide ：用户指南This guide is organized in logical sections that cover the ground from simple basic setups all the way through to advanced cinematic features of Cinemachine. Each of the classes and behaviours that make up Cinemachine are described in detail. 本指南按逻辑部分组织，涵盖了从简单的基本设置到Cinemachine的高级电影功能。 组成Cinemachine的每个类和行为都将详细介绍。 Cinemachine is by no means limited to the classes and behaviours described here. It has an open pipeline architecture, and we look forward to seeing the exciting new behaviours and intelligence that our users will build into the system. Cinemachine绝不仅限于此处描述的类和行为。 它具有开放的管道架构，我们期待看到用户将在系统中构建的令人兴奋的新行为和智能。 Basic Virtual CamerasEach virtual camera is a ‘shot’, or a single camera. You can animate them directly or blend two together to create camera moves. The reason they are ‘virtual’ cameras is to allow for blending, camera selection based on priorities and the ability to have Cinemachine hold multiple cameras in memory with the final product being presented to the current active Unity camera(s) which are rendering. Cinemachine allows you to create an unlimited number of virtual cameras, blend them together with the result being presented to the single Unity camera. It does all this automatically. 每个虚拟摄像机都是“镜头”或单个摄像机。 您可以直接为它们设置动画或将两者混合在一起以创建相机移动。 它们是“虚拟”摄像机的原因是为了允许混合，基于优先级的摄像机选择以及使Cinemachine在内存中保持多个摄像机的能力，最终产品被呈现给正在渲染的当前活动Unity摄像机。 Cinemachine允许您创建无限数量的虚拟摄像机，将它们混合在一起，并将结果呈现给单个Unity摄像机。 它自动完成所有这些。 Key components of the Virtual Camera are: Priority: The priority of this shot. Equal or Higher value camera priorities compared to the current camera priority will be activated. This allows for camera state machine setups where cameras are called based on trigger volumes, animations, health states, etc. Important cameras will trigger over lower priority ones. Lens Settings : What kind of lens to use for this shot: FOV, clipping planes, and dutch (camera roll). Post-processing effects can also be included here. Body: Where the camera is placed in your scene, and procedural ways to ‘mount’ your camera to any object and move the camera with it. Aim: What the camera looks at, and procedural ways to track and compose any subject. Noise: Procedural Perlin multi-layered noise system for handheld behaviors, shakes, and vibrations. Extensions: These are add-ons to the basic Cinemachine pipeline. Post-Processing and Collision Avoidance are examples of standard extensions shipped with Cinemachine. The API is open, so that you can author your own extensions as well. 虚拟相机的关键组件是： 优先级：此镜头的优先级。与当前摄像机优先级相比，优先级相等或更高值的摄像机将被激活。这允许摄像机状态机设置，使得基于触发音量，动画，健康状态等调用摄像机。重要的摄像机将触发优先级较低的摄像机。 镜头设置：此镜头使用哪种镜头效果：FOV（画幅），剪裁平面和荷兰（相机胶卷）。这里也可以包括后处理效果。 主体：摄像机放置在场景中的位置，以及将摄像机“安装”到任何物体并用它移动摄像机的程序方法。 目标：相机所看到的内容，以及跟踪和撰写任何主题的程序方法。 噪音：程序Perlin多层噪音系统，用于手持行为，震动和振动。 扩展：这些是基本Cinemachine管道的附加组件。后处理和冲突避免是Cinemachine附带的标准扩展的示例。 API是开放的，因此您也可以创建自己的扩展程序。 The Solo Button in the Virtual Camera inspector panel will make the virtual camera temporarily Live so that you can have immediate visual feedback in the game view when tweaking the behavioural parameters of the camera. The Game Window Guides checkbox toggles the visibility of any screen compositional guides that the virtual camera might want to display in the game window. This toggle is a static global, and applies to all virtual cameras. The Save During Play checkbox enables the Cinemachine feature of taking camera settings tweaks made while in Play mode, and propagating them back to the scene. This allows in-game fine tuning of cameras without having to do a whole lot of copy/pasting. After you exit play mode, the scene will be updated to reflect the changes made during play. Pressing Undo will revert those changes. The following sections describe the behaviours and classes that make up the Cinemachine Virtual Camera, and some of its standard procedural components. 虚拟相机检查器面板中的Solo按钮将使虚拟相机暂时生效，以便在调整相机的行为参数时可以在游戏视图中立即获得视觉反馈。 “Game Window Guides”复选框可切换虚拟摄像机可能要在游戏窗口中显示的任何屏幕组成指南的可见性。此切换是静态全局，适用于所有虚拟摄像机。 “Save During Play”复选框启用Cinemachine功能，即在播放模式下进行相机设置调整，并将它们传播回场景。这允许在游戏中对相机进行微调，而无需进行大量的复制/粘贴。退出播放模式后，将更新场景以反映播放期间所做的更改。按撤消将还原这些更改。 以下部分描述了构成Cinemachine虚拟相机的行为和类，以及它的一些标准过程组件。 CinemachineVirtualCameraThis behaviour is intended to be attached to an empty Transform GameObject, and it represents a Virtual Camera within the Unity scene. The Virtual Camera will animate its Transform according to the rules contained in its CinemachineComponent pipeline (Aim, Body, and Noise). When the virtual camera is Live, the Unity Camera equipped with a CinemachineBrain will assume the position and orientation of the virtual camera. A virtual camera is not a camera. Instead, it can be thought of as a camera controller, not unlike a cameraman. It can drive the Unity Camera and control its position, orientation, lens settings, and PostProcessing effects. Each Virtual Camera owns its own Cinemachine Component Pipeline, through which you provide the instructions for dynamically tracking specific game objects. A virtual camera is very lightweight, and does no rendering of its own. It merely tracks interesting GameObjects, and positions itself accordingly. A typical game can have dozens of virtual cameras, each set up to follow a particular character or capture a particular event. 此行为旨在附加到空的Transform GameObject，它表示Unity场景中的虚拟相机。 虚拟摄像机将根据其CinemachineComponent管道（目标，主体和噪声）中包含的规则为其变换设置动画。当虚拟摄像机处于实时状态时，配备CinemachineBrain的Unity摄像机将采用虚拟摄像机的位置和方向。 虚拟相机不是相机。相反，它可以被认为是相机控制器，与摄影师不同。它可以驱动Unity相机并控制其位置，方向，镜头设置和后处理效果。每个虚拟相机都拥有自己的Cinemachine组件管道，通过它您可以提供动态跟踪特定游戏对象的说明。 虚拟相机非常轻巧，不会自行渲染。它只跟踪有趣的GameObjects，并相应地定位自己。典型的游戏可以具有数十个虚拟摄像机，每个摄像机设置为跟随特定角色或捕获特定事件。 A Virtual Camera can be in any of three states: Live : The virtual camera is actively controlling the Unity Camera. The virtual camera is tracking its targets and being updated every frame. Standby : The virtual camera is tracking its targets and being updated every frame, but no Unity Camera is actively being controlled by it. This is the state of a virtual camera that is enabled in the scene but perhaps at a lower priority than the Live virtual camera. Disabled : The virtual camera is present but disabled in the scene. It is not actively tracking its targets and so consumes no processing power. However, the virtual camera can be made live from the Timeline. 虚拟摄像机可以处于以下三种状态中的任何一种： 直播：虚拟摄像机正在主动控制Unity摄像头。 虚拟摄像机正在跟踪其目标并每帧更新。 待机：虚拟摄像机正在跟踪其目标并每帧更新，但没有Unity摄像机正在被它主动控制。 这是在场景中启用的虚拟摄像机的状态，但可能比实时虚拟摄像机的优先级低。 已禁用：虚拟摄像机存在但在场景中已禁用。 它没有主动跟踪其目标，因此不消耗处理能力。 但是，虚拟摄像机可以从时间轴生成。 The Unity Camera can be driven by any virtual camera in the scene. The game logic can choose the virtual camera to make live by manipulating the virtual cameras’ enabled flags and their priorities, based on game logic. In order to be driven by a virtual camera, the Unity Camera must have a CinemachineBrain behaviour, which will select the most eligible virtual camera based on its priority or on other criteria, and will manage blending. Unity Camera可以由场景中的任何虚拟摄像头驱动。 游戏逻辑可以通过基于游戏逻辑操纵虚拟相机的启用标志及其优先级来选择虚拟相机来实现。 为了由虚拟摄像头驱动，Unity Camera必须具有CinemachineBrain行为，该行为将根据其优先级或其他标准选择最符合条件的虚拟摄像机，并将管理混合。 Setting Type Description Look At Transform The object that the camera wants to look at (the Aim target). If this is null, then the vcam’s Transform orientation will define the camera’s orientation. Follow Transform The object that the camera wants to move with (the Body target). If this is null, then the vcam’s Transform position will define the camera’s position. Lens LensSettings Specifies the lens properties of this Virtual Camera. This generally mirrors the Unity Camera’s lens settings, and will beused to drive the Unity camera when the vcam is active. Priority Int32 The priority will determine which camera becomes active based on the state of other cameras and this camera. Higher number shave greater priority. 设置 类型 描述 LookAt Transform 相机想要查看的对象（Aim 目标）。 如果为null，则vcam的Transform方向将定义摄像机的方向。 Follow Transform 相机想要跟随的对象（Body目标）。 如果为null，则vcam的Transform位置将定义摄像机的位置。 Lens LensSettings 指定此虚拟摄像机的镜头属性。 这通常反映了Unity Camera的镜头设置，并将在vcam处于活动状态时用于驱动Unity相机。 Priority Int32 优先级将根据其他摄像机和本摄像机的状态确定哪个摄像机变为活动状态。 数字越大，优先级越高。 LensSettingsDescribes the FOV and clip planes for a camera. This generally mirrors the Unity Camera’s lens settings, and will be used to drive the Unity camera when the vcam is active. 描述摄像机的FOV和剪裁平面。 这通常反映了Unity Camera的镜头设置，并将在vcam处于活动状态时用于驱动Unity相机。 Setting Type Description Field Of View Single This is the camera view in vertical degrees. For cinematic people, a 50mm lens on a super-35mm sensor would equal a 19.6 degree FOV. Orthographic Size Single When using an orthographic camera, this defines the half-height, in world coordinates, of the camera view. Near Clip Plane Single This defines the near region in the renderable range of the camera frustum. Raising this value will stop the game from drawing things near the camera, which can sometimes come in handy. Larger values will also increase your shadow resolution. Far Clip Plane Single This defines the far region of the renderable range of the camera frustum. Typically you want to set this value as low as possible without cutting off desired distant objects. Dutch Single Camera Z roll, or tilt, in degrees. 设置 类型 描述 视野 Single 这是垂直度的摄像机视图。 对于电影人来说，超35mm传感器上的50mm镜头等于19.6度FOV。 正交尺寸 Single 使用正交相机时，它定义了摄像机视图的世界坐标的半高。 近裁剪平面 Single 这定义了相机平截头体的可渲染范围内的近区域。 提高此值将阻止游戏在相机附近绘制物品，这有时会派上用场。 较大的值也会增加阴影分辨率。 远裁剪平面 Single 这定义了相机平截头体的可渲染范围的远区域。 通常，您希望在不切断所需远处物体的情况下将此值设置得尽可能低。 Dutch（镜头倾斜） Single 相机Z以度为单位滚动或倾斜。 CinemachineComposer ：This is a CinemachineComponent in the Aim section of the component pipeline. Its job is to aim the camera at the vcam’s LookAt target object, with configurable offsets, damping, and composition rules. The composer does not change the camera’s position. It will only pan and tilt the camera where it is, in order to get the desired framing. To move the camera, you have to use the virtual camera’s Body section. The vcam’s LookAt target is the Composer’s target. Common Composer targets: include bones on a character like the upper spine or head bone, vehicles, or dummy objects which are controlled or animated programmatically. 这是组件管道的Aim部分中的CinemachineComponent。 它的工作是将摄像机对准vcam的LookAt目标对象，具有可配置的偏移，阻尼和合成规则。 Composer不会改变相机的位置。 它只会将摄像机平移和倾斜，以获得所需的取景。 要移动相机，您必须使用虚拟相机的“身体”部分。 vcam的LookAt目标是Composer的目标。 Common Composer目标：在角色上绑定骨骼，例如上部脊柱或头骨，车辆或虚拟对象，这些对象可通过编程方式进行控制或动画处理。 Once you’ve set the vcam’s LookAt target and are tracking something, you need to define where you’d like it to be on the screen and how aggressively you’d like to camera to track it. The degree of lag, or how tightly the camera follows the subject is defined by the two controls: Horizontal/Vertical Soft Damping: Setting these values to zero means the camera will hard track the subject and the blue regions above will act as rigid barriers locking the camera movement to keep the target inside those values. Setting the larger will allow the target to ‘squish’ into the blue regions, giving you some really nice camera weight and lag. This is what real camera operators do!. The vertical and horizontal values are separated so you can let the camera squish more left to right or follow tighter up and down, etc. SoftZone/DeadZone: Tune these to define where you want the subject to be onscreen. These controls are incredibly versatile. The blue areas are the ‘squishy’ areas based on how much horizontal/vertical damping you have, and the red areas define the ‘no pass’ limits where the camera will always track the subject. Opening up the soft areas to create a ‘dead zone’ in the middle allows you to make areas of the screen immune to target motion, handy for things like animation cycles where you don’t want the camera to track the target if it moves just a little. 一旦你设置了vcam的LookAt目标并跟踪某些东西，你需要定义你想要它在屏幕上的位置以及你想要相机跟踪它的积极程度。两个控件定义了延迟程度或相机跟随主体的紧密程度： 水平/垂直软阻尼：将这些值设置为零意味着摄像机将硬跟踪主体，上方的蓝色区域将作为锁定摄像机移动的刚性障碍，以使目标保持在这些值内。设置较大的将允许目标“挤压”到蓝色区域，给你一些非常好的相机重量和滞后。这就是真正的相机操作员所做的！垂直和水平值是分开的，因此您可以让相机从左到右更加挤压，或者跟随上下更紧，等等。 SoftZone / DeadZone：调整这些以定义主体在屏幕上的位置。这些控件非常通用。蓝色区域是基于您具有多少水平/垂直阻尼的“柔软”区域，红色区域定义了摄像机始终跟踪主体的“无通过”限制。打开柔和区域以在中间创建“死区”允许您使屏幕区域免受目标运动的影响，这对于像动画周期这样的事情很方便，如果它只是移动一点点的话，你可能不希望摄像机跟踪目标。 Setting Type Description Tracked Object Offset Vector3 Target offset from the target object’s center in target-local space. Use this to fine-tune the tracking target position when the desired area is not the tracked object’s center. Lookahead Time Single This setting will instruct the composer to adjust its target offset based on the motion of the target. The composer will look at a point where it estimates the target will be this many seconds into the future. Note that this setting is sensitive to noisy animation, and can amplify the noise, resulting in undesirable camera jitter. If the camera jitters unacceptably when the target is in motion, turn down this setting, or animate the target more smoothly. Horizontal Damping Single How aggressively the camera tries to follow the target in the screen-horizontal direction. Small numbers are more responsive, rapidly orienting the camera to keep the target in the dead zone. Larger numbers give a more heavy slowly responding camera. Using different vertical and horizontal settings can yield a wide range of camera behaviors. Vertical Damping Single How aggressively the camera tries to follow the target in the screen-vertical direction. Small numbers are more responsive, rapidly orienting the camera to keep the target in the dead zone. Larger numbers give a more heavy slowly responding camera. Using different vertical and horizontal settings can yield a wide range of camera behaviors. Screen X Single Horizontal screen position for target. The camera will rotate to position the tracked object here. Screen Y Single Vertical screen position for target, The camera will rotate to position the tracked object here. Dead Zone Width Single Camera will not rotate horizontally if the target is within this range of the position. Dead Zone Height Single Camera will not rotate vertically if the target is within this range of the position. Soft Zone Width Single When target is within this region, camera will gradually rotate horizontally to re-align towards the desired position, depending on the damping speed. Soft Zone Height Single When target is within this region, camera will gradually rotate vertically to re-align towards the desired position, depending on the damping speed. Bias X Single A non-zero bias will move the target position horizontally away from the center of the soft zone. Bias Y Single A non-zero bias will move the target position vertically away fromthe center of the soft zone. 设置 类型 描述 跟踪对象偏移 Vector3 目标对象在目标 - 本地空间中心的目标偏移量。 当所需区域不是被跟踪对象的中心时，使用此选项微调跟踪目标位置。 前瞻时间 Single 此设置将指示Composer根据目标的运动调整其目标偏移。 Composer将会看到一个点，它估计目标在未来的多少秒内到达目标点。 请注意，此设置对噪声动画很敏感，并且可能会放大噪声，从而导致不需要的相机抖动。 如果在目标运动时相机抖动不可接受，请调低此设置，或者更平稳地为目标设置动画。 水平阻尼 Single 相机在屏幕水平方向上试图跟踪目标的程度如何。 小数字响应更快，快速定向相机以使目标保持在死区。 较大的数字给出了一个更加沉重的慢响应相机。 使用不同的垂直和水平设置可以产生各种相机行为。 垂直阻尼 Single 相机在屏幕垂直方向上试图跟踪目标的程度如何。 小数字响应更快，快速定向相机以使目标保持在死区。 较大的数字给出了一个更加沉重的慢响应相机。 使用不同的垂直和水平设置可以产生各种相机行为。 水平屏幕位置 Single 目标的水平屏幕位置。 相机将旋转以将跟踪对象定位在此处。 垂直屏幕位置 Single 目标的垂直屏幕位置，摄像机将旋转以将跟踪对象定位在此处。 死区宽度 Single 如果目标位于该位置范围内，相机将不会水平旋转。 死区高度 Single 如果目标位于该位置范围内，相机将不会垂直旋转。 软区宽度 Single 当目标位于此区域内时，摄像机将逐渐水平旋转，以根据阻尼速度重新对齐到所需位置。 软区高度 Single 当目标位于此区域内时，摄像机将逐渐垂直旋转，以根据阻尼速度重新对齐到所需位置。 水平非零偏差 Single 非零偏差将使目标位置水平移动远离软区域的中心。 垂直非零偏差 Single 非零偏差将使目标位置垂直移动远离软区域的中心。 CinemachineTransposerThis is a CinemachineComponent in the Body section of the component pipeline. Its job is to position the camera in a fixed relationship to the vcam’s Follow target object, with offsets and damping. The Transposer will only change the camera’s position in space. It will not re-orient or otherwise aim the camera. To to that, you need to instruct the vcam in the Aim section of its pipeline. Transposer is a component which mounts a camera to any object. It has a number of advantages over just putting the camera under the object you want to have the camera follow. Hood Cam, Door Cam, POV Cam, Missile Cam - if you want to mount the camera to something, use Transposer. 这是组件管道的Body部分中的CinemachineComponent。 它的工作是将摄像机定位到与摄像机的跟随目标物体固定的关系，具有偏移和阻尼。 Transposer只会改变相机在空间中的位置。 它不会重新定位或以其他方式瞄准相机。 为此，您需要在其管道的Aim部分中指示vcam。 Transposer是将相机安装到任何物体上的组件。 与将相机放在想要让相机跟随的物体之下相比，它具有许多优点。 相机遮光罩，门镜，视点相机，投掷相机（类似R6的女武神？）如果你想将相机安装到某物上，请使用转换器。 Using Transposer for your camera body motion has advantages: The position tuning is kept, even if the game is running. Tune a regular camera in game mode and the position is lost once you quit, not with Transposer. Tune it up while the game is running and you’re done. Add damping to the camera - if your camera follows something, the damping values can give you some ‘weight’ to the camera so they feel smoother. Organization: Put all your cameras in one place, instead of having them hidden under all sorts of assets in your project - you pick their targets vs. put the camera under them in the hierarchy. 使用Transposer进行相机机身运动具有以下优势： 即使游戏正在运行，也会保持位置调整。 在游戏模式下调整普通相机，一旦退出，位置就会丢失，而不是使用Transposer。 在游戏运行时调整它并完成。 为相机增加阻尼 - 如果你的相机跟随某些东西，阻尼值可以给你一些相机的“重量”，让它们感觉更顺畅。 组织：将所有摄像机放在一个位置，而不是将它们隐藏在项目中的各种资产下 - 选择目标而不是将摄像机置于层次结构中。 Follow Offset: The camera will go to the centre of the object you’re targeting in the Transposer Camera Target, so if you want the camera to be further behind, put in some offsets. We default at -10 so the camera is behind whatever you’re targeting. Damping: Per channel damping which will cause the camera to lag behind the target. You can control both the position damping, and the orientation damping. 跟随偏移：摄像机将转到您在转置相机目标中定位的对象的中心，因此如果您希望将摄像机放在后面，请放入一些偏移。 我们默认为-10，因此无论您的目标是什么，相机都会落后。 阻尼：每通道阻尼，这将导致相机滞后于目标。 您可以控制位置阻尼(线阻力？)和方向阻尼（角阻力？）。 Binding Mode: There’s options in the relationship between the camera and the target object. Lock To Target interprets the camera offset in target-local coords. As the target rotates, the camera rotates around it to maintain the offset. Lock to Target With World Up is the same as the above but it keeps the camera pointing up. Handy if your target flips over. Lock to Target On Target Assign mounts the camera relative to the target’s local coordinate system at the time the camera is initialized. This offset remains constant in world space, and the camera will not rotate along with the target. World Space offsets positions the camera relative to the target in world coords no matter what direction the target object is facing. Simple Follow this will follow the target at the desired distance and height while moving the camera position as little as possible. This is quite similar to what a human camera operator would do when instructed to follow a target. 绑定模式：这是一些摄像机和目标对象之间的关系选项。 Lock To Target：解释目标局部坐标中的摄像机偏移。 当目标旋转时，相机围绕它旋转以保持偏移。 使用World Up锁定目标：与上面相同，但它会使摄像机朝上。 如果您的目标翻转，很方便。 基于目标分配锁定目标：摄像机相对于目标的本地坐标系在摄像机初始化时的安装。 此偏移在世界空间中保持不变，并且摄像机不会与目标一起旋转。 无论目标物体朝向什么方向，世界空间偏移都会使相机相对于目标在世界坐标中定位。 简单跟随：此操作将在所需距离和高度处跟随目标，同时尽可能少地移动摄像机位置。 这非常类似于人类摄像机操作员在被指示跟随目标时所做的事情。 These different modes do incredibly different things, so try them out and one should work well for whatever your requirements are. The ‘Door Cam’ or ‘Hood Cam’ ideas would use L ocal Space Locked To Target. 这些不同的模式做了非常不同的事情，所以尝试一下，某个应该适合你的要求。 “监视器”或“固定在遮光罩上的镜头”的想法应使用Local Space Locked To Target。 Setting Type Description Binding Mode BindingMode The coordinate space to use when interpreting the offset from the target. This is also used to set the camera’s Up vector, which will be maintained when aiming the camera. Possible Values: Lock To Target On Assign: Camera will be bound to the Follow target using a frame of reference consisting of the target’s local frame at the moment when the virtual camera was enabled, or when the target was assigned. Lock To Target With World Up: Camera will be bound to the Follow target using a frame of reference consisting of the target’s local frame, with the tilt and roll zeroed out. Lock To Target No Roll: Camera will be bound to the Follow target using a frame of reference consisting of the target’s local frame, with the roll zeroed out. Lock To Target: Camera will be bound to the Follow target using the target’s local frame. World Space: Camera will be bound to the Follow target using a world space offset. Simple Follow: Offsets will be calculated relative to the target, using Camera-local axes. Follow Offset Vector3 The distance vector that the transposer will attempt to maintain from the Follow target. X Damping Single How aggressively the camera tries to maintain the offset in the X-axis. Small numbers are more responsive, rapidly translating the camera to keep the target’s x-axis offset. Larger numbers give a more heavy slowly responding camera. Using different settings per axis can yield a wide range of camera behaviors. Y Damping Single How aggressively the camera tries to maintain the offset in the Y-axis. Small numbers are more responsive, rapidly translating the camera to keep the target’s y-axis offset. Larger numbers give a more heavy slowly responding camera. Using different settings per axis can yield a wide range of camera behaviors. Z Damping Single How aggressively the camera tries to maintain the offset in the Z-axis. Small numbers are more responsive, rapidly translating the camera to keep the target’s z-axis offset. Larger numbers give a more heavy slowly responding camera. Using different settings per axis can yield a wide range of camera behaviors. Pitch Damping Single How aggressively the camera tries to track the target rotation’s X angle. Small numbers are more responsive. Larger numbers give a more heavy slowly responding camera. Yaw Damping Single How aggressively the camera tries to track the target rotation’s Y angle. Small numbers are more responsive. Larger numbers give a more heavy slowly responding camera. Roll Damping Single How aggressively the camera tries to track the target rotation’s Z angle. Small numbers are more responsive. Larger numbers give a more heavy slowly responding camera. 设置 类型 描述 绑定模式 绑定模式 解释目标偏移时使用的坐标空间。 这也用于设置相机的向上矢量，瞄准相机时将保持该矢量。 可能的值： 锁定目标开启分配：摄像机将使用参考框架绑定到“跟随”目标，该框架由启用虚拟摄像机时或目标分配时目标的本地帧组成。 使用World Up锁定目标：使用由目标的本地帧组成的参照系将摄像机绑定到Follow目标，并将倾斜和滚动归零。 锁定目标无滚动：摄像机将使用由目标的本地框架组成的参考框架绑定到“跟随”目标，并将滚动归零。 锁定目标：使用目标的本地帧将相机绑定到关注目标。 世界空间：使用世界空间偏移将摄像机绑定到关注目标。 简单跟随：使用相机局部轴，相对于目标计算偏移。 跟随位移 Vector3 转置器将尝试从Follow目标维护的距离向量。 X轴阻尼 Single 相机如何积极地保持X轴的偏移。 小数字响应更快，快速转换相机以保持目标的x轴偏移。 较大的数字给出了一个更加沉重的慢响应相机。 每个轴使用不同的设置可以产生各种相机行为。 Y轴阻尼 Single 相机如何积极地保持Y轴的偏移。 小数字响应更快，快速转换相机以保持目标的x轴偏移。 较大的数字给出了一个更加沉重的慢响应相机。 每个轴使用不同的设置可以产生各种相机行为。 Z轴阻尼 Single 相机如何积极地保持Z轴的偏移。 小数字响应更快，快速转换相机以保持目标的x轴偏移。 较大的数字给出了一个更加沉重的慢响应相机。 每个轴使用不同的设置可以产生各种相机行为。 音高阻尼 Single 相机如何积极地尝试跟踪目标旋转的X角度。 小数字响应更快。 较大的数字给出了一个更加沉重的慢响应相机。 偏航阻尼 Single 相机如何积极地尝试跟踪目标旋转的Y角度。 小数字响应更快。 较大的数字给出了一个更加沉重的慢响应相机。 滚动阻尼 Single 相机如何积极地尝试跟踪目标旋转的Z角度。 小数字响应更快。 较大的数字给出了一个更加沉重的慢响应相机。 Cinemachine BasicMultiChannelPerlinNoiseSettingsNoiseSettings.NoiseParamsNoiseSettings.Transform NoiseParams]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>CineMachine</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[indlecamp GameJam 开发笔记]]></title>
    <url>%2F2018%2F12%2F17%2F%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%2Findlecamp-GameJam-%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[[翻译] StateMachine]]></title>
    <url>%2F2018%2F12%2F17%2F%E7%BF%BB%E8%AF%91%2F%E7%BF%BB%E8%AF%91-StateMachine%2F</url>
    <content type="text"><![CDATA[[TOC] 游戏中的状态机，分层状态机以及伪代码实现。 Chapter 5 Decision Making5.3 STATE MACHINES：状态机Often, characters in a game will act in one of a limited set of ways. They will carry on doing the same thing until some event or influence makes them change. A covenant warrior in Halo [Bungie Software, 2001], for example, will stand at its post until it notices the player, then it will switch into attack mode, taking cover and firing. 通常来说，游戏中的角色所进行的行为将会从有限的行为集合中选取。它们将会保持这个状态，直到一些事件或者影响使得它们改变。以 光环：战斗进化 为例，敌人将会一直驻守直到它们注意到玩家，此时将会转换到攻击状态，寻求掩体以及开火。 We can support this kind of behavior using decision trees, and we’ve gone some way to doing that using random decisions. In most cases, however, it is easier to use a technique designed for this purpose: state machines. 我们可以通过决策树来实现这种行为，并且我们已经采用某种方式使用随机决策来做到这一点。然而，在大多数情况下，对于这个目标，我们可以采用更为容易的技术设计：状态机。 State machines are the technique most often used for this kind of decision making and, along with scripting (see Section 5.9), make up the vast majority of decision making systems used in current games. 状态机是一种经常用于这类决策的技术，它与脚本一起使用（参见第5.9节），构成当前游戏中使用的绝大多数（vast majority）决策系统。 State machines take account of both the world around them (like decision trees) and their internal makeup (their state). 状态机既与它周围的世界相关（类似于决策树）又与其内部组成相关（它们自身的状态）。 A Basic State Machine ：一个基本状态机In a state machine each character occupies one state. Normally, actions or behaviors are associated with each state. So as long as the character remains in that state, it will continue carrying out the same action. 在状态机中，每个角色占据一个状态。通常，动作或行为与每个状态相关联。因此，只要角色保持在该状态，它将继续执行相同的动作。 States are connected together by transitions. Each transition leads from one state to another, the target state, and each has a set of associated conditions. If the game determines that the conditions of a transition are met, then the character changes state to the transition’s target state. When a transition’s conditions are met, it is said to trigger, and when the transition is followed to a new state, it has fired. 每个状态通过状态转换联系在一起。每个转换从一个状态引导到另一个状态，即目标状态，并且每个转换具有一组相关条件。如果游戏确定满足转换的条件，则角色将状态改变为要转换的目标状态。当满足转换条件时，它会被触发，当转换到新状态时，它就会被触发。 Figure 5.13 shows a simple state machine with three states: On Guard, Fight, and Run Away. Notice that each state has its own set of transitions. 图5.13显示了一个具有三种状态的简单状态机：On Guard，Fight和Run Away。请注意，每个状态都有自己的一组转换。 The state machine diagrams in this chapter are based on the UML state chart di- agram format, a standard notation used throughout software engineering. States are shown as curved corner boxes. Transitions are arrowed lines, labelled by the condition that triggers them. Conditions are contained in square brackets. 本章中的状态机图表基于UML状态图表格式，这是整个软件工程中使用的标准符号。状态显示为弯角框。过渡是箭头线，由触发它们的条件标记。条件包含在方括号中。 The solid circle in Figure 5.13 has only one transition without a trigger condition. The transition points to the initial state that will be entered when the state machine is first run. 图5.13中的实心圆只有一个没有触发条件的转换。转换指向首次运行状态机时将进入的初始状态。 You won’t need an in-depth understanding of UML to understand this chapter. If you want to find out more about UML, I’d recommend Pilone [2005]. 您不需要深入了解UML来理解本章。如果你想了解更多关于UML的信息，我推荐Pilone [2005]。 In a decision tree the same set of decisions is always used, and any action can be reached through the tree. In a state machine only transitions from the current state are considered, so not every action can be reached. 在决策树中，始终使用相同的决策集，并且可以通过树到达任何操作。在状态机中，仅考虑从当前状态的转换，因此不是每个动作都可以到达。 Finite State Machines ：有限状态机In game AI any state machine with this kind of structure is usually called a finite state machine (FSM). This and the following sections will cover a range of increasingly powerful state machine implementations, all of which are often referred to as FSMs. 在游戏AI中，具有这种结构的任何状态机通常称为有限状态机（FSM）。本节和以下部分将介绍一系列日益强大的状态机实现，所有这些实现通常都称为FSM。 This causes confusion with non-games programmers, for whom the term FSM is more commonly used for a particular type of simple state machine. An FSM in computer science normally refers to an algorithm used for parsing text. Compilers use an FSM to tokenize the input code into symbols that can be interpreted by the compiler. 这导致与非游戏程序员的混淆，对于他们来说，术语FSM更常用于特定类型的简单状态机。计算机科学中的FSM通常是指用于解析文本的算法。编译器使用FSM将输入代码标记为可由编译器解释的符号。 The Game FSM ：游戏中的有限状态机The basic state machine structure is very general and admits any number of imple- mentations. I have seen tens of different ways to implement a game FSM, and it is rare to find any two developers using exactly the same technique. That makes it difficult to put forward a single algorithm as being the “state machine” algorithm. 基本状态机结构非常通用，允许任意数量的实现。我已经看到了几种不同的方法来实现游戏FSM，并且很少发现任何两个开发人员使用完全相同的技术。这使得将单个算法提出为“状态机”算法变得困难。 Later in this section, I’ll look at a range of different implementation styles for the FSM, but the main algorithm I work through is just one. I chose it for its flexibility and the cleanness of its implementation. 在本节的后面部分，我将介绍FSM的一系列不同的实现样式，但我使用的主要算法只有一个。我之所以选择它是因为它的灵活性和实现的优雅性。 5.3.1 THE PROBLEM ：问题We would like a general system that supports arbitrary state machines with any kind of transition condition. The state machine will conform to the structure given above and will occupy only one state at a time. 我们想要一个支持具有任何转换条件的任意状态机的通用系统。这个状态机将符合上面给出的结构，并且一次只占用一个状态。 5.3.2 THE ALGORITHM ：算法We will use a generic state interface which can be implemented to include any spe- cific code. The state machine keeps track of the set of possible states and records the current state it is in. Alongside each state, a series of transitions are maintained. Each transition is again a generic interface that can be implemented with the appropriate conditions. It simply reports to the state machine whether it is triggered or not. 我们将使用通用状态接口，可以实现包含任何特定代码。 状态机跟踪可能状态的集合并记录它所处的当前状态。在每个状态下，保持一系列转换。 每次转换都是一个通用接口，可以使用适当的条件实现。 它只是向状态机报告它是否被触发。 At each iteration (normally each frame), the state machine’s update function is called. This checks to see if any transition from the current state is triggered. The first transition that is triggered is scheduled to fire. The method then compiles a list of actions to perform from the currently active state. If a transition has been triggered, then the transition is fired. 在每次迭代（通常是每个帧），调用状态机的更新函数。 这将检查是否触发了当前状态的任何转换。 触发的第一个转换将会被执行。 然后，该方法维护一个要从当前活动状态执行的动作列表(actions)。 如果已触发某个转换，则会执行这个转换。 This separation of the triggering and firing of transitions allows the transitions to also have their own actions. Often, transitioning from one state to another also involves carrying out some action. In this case a fired transition can add the action it needs to those returned by the state. 这种转换的触发和触发的分离允许转换也具有它们自己的动作。 通常，从一个状态转换到另一个状态也涉及执行某些行动。 //在这种情况下，触发转换可以将所需的操作添加到状态返回的操作。 5.3.3 PSEUDO-CODE ：伪代码实现The state machine holds a list of states, with an indication of which one is the current state. It has an update function for triggering and firing transitions and a function that returns a set of actions to carry out. 状态机保存状态列表，指示哪一个是当前状态。 //它具有用于执行和触发转换的更新功能以及返回要执行的一组操作的功能。 12345678910111213141516171819202122232425262728293031323334353637383940414243class machine&#123; // 维护一个状态机的状态列表 list&lt;State&gt; states; // 初始状态 State initialState； // 当前状态 currentState = initialState; // 检查并执行转换，同时返回一个动作列表 Update() &#123; // 假定没有转换被触发 triggeredTransition = None; // 遍历所有状态并保存第一个被触发的状态 for transition in currentState.getTransitions() &#123; if transition.isTriggered(): triggeredTransition = transition; break; &#125; // 检查是否有状态被触发？ if triggeredTransition &#123; targetState = triggeredTransition.getTargetState(); // 在行为列表之中增加旧状态的退出操作、状态转移的操作以及新状态的入口操作 actions = currentState.getExitAction() actions += triggeredTransition.getAction() actions += targetState.getEntryAction() // 完成状态转移并返回行为列表 currentState = targetState return actions &#125; // 否则直接返回当前状态的行为列表 else return currentState.getAction() &#125;&#125; 5.3.4 DATA STRUCTURES AND INTERFACES ：数据结构与接口The state machine relies on having states and transitions with a particular interface.The state interface has the following form: 状态机依赖于具有特定接口的状态和转换。状态接口具有以下形式： 12345678class State&#123; def getAction(); def getEntryAction(); def getExitAction(); def getTransitions();&#125; Each of the getAction methods should return a list of actions to carry out. As we will see below, the getEntryAction is only called when the state is entered from a transition, and the getExitAction is only called when the state is exited. The rest of the time that the state is active, getAction is called. The getTransitions method should return a list of transitions that are outgoing from this state. The transition interface has the following form: 每个getAction方法都应返回要执行的操作列表。 正如我们将在下面看到的，只有在从转换进入状态时才调用getEntryAction，并且仅在退出状态时调用getExitAction。 其余时间状态为活动状态，调用getAction。 getTransitions方法应返回从此状态传出的转换列表。 转换接口具有以下形式： 123456class Transition&#123; def isTriggered(); def getTargetState(); def getAction();&#125; The isTriggered method returns true if the transition can fire; the getTarget-State method reports which state to transition to; and the getAction method returns a list of actions to carry out when the transition fires. 如果转换可以触发，则isTriggered方法返回true; getTarget-State方法报告要转换到的状态; 并且getAction方法返回转换触发时要执行的操作列表。 Transition Implementation ：实现转换Only one implementation of the state class should be required: it can simply hold the three lists of actions and the list of transitions as data members, returning them in the corresponding get methods. 只需要一个状态类的实现：它可以简单地将三个动作列表和转换列表保存为数据成员，并在相应的get方法中返回它们。 In the same way, we can store the target state and a list of actions in the transition class and have its methods return the stored values. The isTriggered method is more difficult to generalize. Each transition will have its own set of conditions, and much of the power in this method is allowing the transition to implement any kind of tests it likes. 以同样的方式，我们可以在转换类中存储目标状态和操作列表，并使其方法返回存储的值。 isTriggered方法更难以概括。 每个转换都有自己的一组条件，这种方法的大部分功能是允许转换实现它喜欢的任何类型的条件测试。 Because state machines are often defined in a data file and read into the game at run time, it is a common requirement to have a set of generic transitions. The state machine can then be set up from the data file by using the appropriate transitions for each state. 由于状态机通常在数据文件中定义并在运行时读入游戏，因此通常需要具有一组通用转换。 然后，可以通过使用每个状态的适当转换从数据文件中设置状态机。 In the previous section on decision trees, we saw generic testing decisions that operated on basic data types. The same principle can be used with state machine transitions: we have generic transitions that trigger when data they are looking at is in a given range. 在上一节关于决策树的部分中，我们看到了对基本数据类型进行操作的通用测试决策。 相同的原理可以与状态机转换一起使用：我们具有通用转换，当它们正在查看的数据处于给定范围内时触发。 Unlike decision trees, state machines don’t provide a simple way of combining these tests together to make more complex queries. If we need to transition based on the condition that the enemy is far away AND health is low, then we need some way of combining triggers together. 与决策树不同，状态机不提供将这些测试组合在一起以进行更复杂查询的简单方法。// 如果我们需要根据敌人在远处且健康状况低的条件进行过渡，那么我们需要一些将触发器组合在一起的方法。 In keeping with our polymorphic design for the state machine, we can accom- plish this with the addition of another interface: the condition interface. We can use a general transition class of the following form: 为了与状态机的多态设计保持一致，我们可以通过添加另一个接口来实现这一点：条件接口。 我们可以使用以下形式的一般转换类： 1234567891011class Transition&#123;// 条件接口类 actions def getAction(): return actions targetState def getTargetState(): return targetState condition def isTriggered(): return condition.test()&#125; The isTriggered function now delegates the testing to its condition member.Conditions have the following simple format: isTriggered函数现在将测试委托给其条件成员。条件具有以下简单格式： 1234class Condition&#123; def test();&#125; We can then make a set of sub-classes of condition for particular tests, just like we did for decision trees: 然后，我们可以为特定测试创建一组条件子类，就像我们为决策树所做的那样： 12345678910class FloatCondition (Condition)&#123;// 数值条件 minValue; maxValue; testValue; // 我们想关注的游戏数据 def test() &#123; return minValue &lt;= testValue &lt;= maxValue &#125;&#125; We can combine conditions together using Boolean sub-classes, such as AND, NOT, and OR: 我们可以使用布尔子类将条件组合在一起，例如AND，NOT和OR： 1234567891011121314151617181920212223242526272829class AndCondition (Condition)&#123;// 布尔条件 conditionA conditionB def test() &#123; return conditionA.test() and conditionB.test(); &#125;&#125;class NotCondition (Condition)&#123; condition def test() &#123; return not condition.test(); &#125; &#125;class OrCondition (Condition)&#123; conditionA conditionB def test() &#123; return conditionA.test() or conditionB.test() &#125;&#125; and so on, for any level of sophistication we need. 等等……，支持我们需要的任何复杂程度。 Weaknesses ：缺点This approach to transitions gives a lot of flexibility, but at the price of lots of method calls. In C++ these method calls have to be polymorphic, which can slow down the call and confuse the processor. All this adds time, which may make it unsuitable for use in every frame on lots of characters. 这种转换方法提供了很大的灵活性，但代价是大量的方法调用。 在C ++中，这些方法调用必须是多态的，这会降低调用速度并使处理器混淆。 所有这些都增加了时间，这可能使其不适合在许多角色的每个帧中使用。 Several developers I have come across use a homegrown scripting language to ex- press conditions for transitions. This still allows designers to create the state machine rules, but can be slightly more efficient. In practice, however, the speed up over this approach is quite small, unless the scripting language includes some kind of compila- tion into machine code (i.e., Just In Time Compiling). For all but the simplest code, interpreting a script is at least as time-consuming as calling polymorphic functions. 我遇到的几个开发人员使用自己开发的脚本语言来表达转换条件。 这仍然允许设计人员创建状态机规则，但可以稍微提高效率。 然而，在实践中，除非脚本语言包括对机器代码的某种编译（即，及时编译），否则这种方法的速度非常快。 对于除最简单代码之外的所有代码，解释脚本至少与调用多态函数一样耗时。 5.3.6 PERFORMANCE ：开销The state machine algorithm only requires memory to hold a triggered transition and the current state. It is O(1) in memory, and O(m) in time, where m is the number of transitions per state. 状态机算法仅需要存储器来保持触发转换和当前状态。 它在存储器中是O（1），在时间上是O（m），其中m是每个状态的转换数。 The algorithm calls other functions in both the state and the transition classes, and in most cases the execution time of these functions accounts for most of the time spent in the algorithm. 该算法调用状态和转换类中的其他函数，并且在大多数情况下，这些函数的执行时间占算法中花费的大部分时间。 5.3.7 IMPLEMENTATION NOTES ：实现的一些说明As I mentioned earlier, there are any number of ways to implement a state machine. The state machine described in this section is as flexible as possible. I’ve tried to aim for an implementation that allows you to experiment with any kind of state machine and add interesting features. In many cases it may be too flexible. If you’re only planning to use a small subset of its flexibility, then it is very likely to be unnecessarily inefficient. 正如我之前提到的，有许多方法可以实现状态机。 本节中描述的状态机尽可能灵活。 我试图实现一个允许您尝试任何类型的状态机并添加有趣功能的实现。 在许多情况下，它可能过于灵活。 如果您只计划使用其灵活性的一小部分，则很可能会产生不必要的低效率。 5.3.8 HARD-CODED FSM ：FSM的硬编码问题A few years back, almost all state machines were hard-coded. The rules for transitions and the execution of actions were part of the game code. It has become less common as level designers get more control over building the state machine logic, but it is still an important approach. 几年前，几乎所有的状态机都是硬编码的。 转换规则和动作的执行是游戏代码的一部分。 随着关卡设计师对构建状态机逻辑的更多控制，它变得不那么常见，但它仍然是一种重要的方法。 Pseudo-Code ：伪代码In a hard-coded FSM, the state machine consists of an enumerated value, indicating which state is currently occupied, and a function that checks if a transition should be followed. Here I’ve combined the two into a class definition (although I personally tend to associate hard-coded FSMs with developers still working in C). 在硬编码的FSM中，状态机由枚举值组成，指示当前占用的状态，以及检查是否应遵循转换的函数。 在这里，我将两者合并为一个类定义（尽管我个人倾向于将硬编码的FSM与仍在C中工作的开发人员联系起来）。 1234567891011121314151617181920212223242526272829303132333435363738class MyFSM&#123; // 声明所有状态名 enum State &#123; PATROL, DEFEND, SLEEP &#125;; // 当前状态 myState； def update() &#123; // 寻找当前状态 if myState == PATROL &#123; if canSeePlayer() myState = DEFEND if tired() myState = SLEEP &#125; else if myState == DEFEND &#123; if not canSeePlayer() myState = PATROL &#125; else if myState == SLEEP &#123; if not tired() myState = PATROL &#125; def notifyNoiseHeard(volume) &#123; if myState == SLEEP and volume &gt; 10: myState = DEFEND &#125; &#125;&#125; Notice that this is pseudo-code for a particular state machine rather than a type of state machine. In the update function there is a block of code for each state. In that block of code the conditions for each transition are checked in turn, and the state is updated if required. The transitions in this example all call functions (tired and canSeePlayer), which I am assuming have access to the current game state. 请注意，这是特定状态机的伪代码，而不是一种状态机。 在更新功能中，每个状态都有一个代码块。 在该代码块中，依次检查每个转换的条件，并在需要时更新状态。 这个例子中的转换都是调用函数（tired()和canSeePlayer()），我假设它们可以访问当前的游戏状态。 In addition, I’ve added a state transition in a separate function, notifyNoiseHeard. I am assuming that the game code will call this function whenever the character hears a loud noise. This illustrates the difference between a polling (asking for informa- tion explicitly) and an event-based (waiting to be told information) approach to state transitions. Chapter 10 on world interfacing contains more details on this distinction. 另外，我在一个单独的函数notifyNoiseHeard中添加了一个状态转换。 我假设只要角色听到很大的噪音，游戏代码就会调用此函数。 这说明了轮询（明确要求信息）和基于事件（等待被告知信息）的状态转换方法之间的区别。 关于世界接口的第10章包含有关这种区别的更多细节。 The update function is called in each frame, as before, and the current state is used to generate an output action. To do this, the FSM might have a method containing conditional blocks of the following form: 更新函数像以前一样在每个帧中调用，当前状态用于生成输出动作。 为此，FSM可能有一个包含以下形式的条件块的方法： 123456def getAction()&#123; if myState == PATROL: return PatrolAction elif myState == DEFEND: return DefendAction elif myState == SLEEP: return SleepAction&#125; Often, the state machine simply carries out the actions directly, rather than returning details of the action for another piece of code to execute. 通常，状态机只是直接执行操作，而不是返回要执行的另一段代码的操作细节。 Performance ：开销This approach requires no memory and is O(n + m), where n is the number of states, and m is the number of transitions per state. 这种方法不需要存储器，并且是O（n + m），其中n是状态数，m是每个状态的转换数。 Although this appears to perform worse than the flexible implementation, it is usually faster in practice for all but huge state machines (i.e., thousands of states). 虽然这似乎比灵活的实现更糟糕，但实际上除了巨大的状态机（即数千个状态）之外通常更快。 Weaknesses ：缺点Although hard-coded state machines are easy to write, they are notoriously difficult to maintain. State machines in games can often get fairly large, and this can appear as ugly and unclear code. 虽然硬编码的状态机很容易编写，但它们很难维护。 游戏中的状态机通常会变得相当大，这可能看起来像丑陋和不清楚的代码。 Most developers, however, find that the main drawback is the need for program- mers to write the AI behaviors for each character. This implies a need to recompile the game each time the behavior changes. While it may not be a problem for a hobby game writer, it can become critical in a large game project that takes many minutes or hours to rebuild. 然而，大多数开发人员发现主要缺点是程序员需要为每个角色编写AI行为。 这意味着每次行为改变时都需要重新编译游戏。 虽然它可能不是一个业余爱好游戏开发者的问题，但它可能在一个大型游戏项目中变得至关重要，需要花费很多分钟或几小时来重建。 More complex structures, such as hierarchical state machines (see below), are also difficult to coordinate using hard-coded FSMs. With a more flexible implementation, debugging output can easily be added to all state machines, making it easier to track down problems in the AI. 更复杂的结构，例如分层状态机（见下文），也很难使用硬编码的FSM进行协调。 通过更灵活的实现，可以轻松地将调试输出添加到所有状态机，从而更容易跟踪AI中的问题。 5.3.9 HIERARCHICAL STATE MACHINES：分层状态机On its own, one state machine is a powerful tool, but it can be difficult to express some behaviors. One common source of difficulty is “alarm behaviors.” 就其本身而言，一台状态机是一种强大的工具，但表达某些行为可能很困难。一个常见的例子是“警报行为”。 Imagine a service robot that moves around a facility cleaning the floors. It has a state machine allowing it to do this. It might search around for objects that have been dropped, pick one up when it finds it, and carry it off to the trash compactor. This can be simply implemented using a normal state machine (see Figure 5.14). 想象一下一个机器人在清洁地板的设施周围移动。 它有一个状态机允许它这样做。 它可能会搜索掉落的物体，找到它时拾取一个物体，然后将它带到垃圾压缩机。 这可以使用普通状态机简单地实现（参见图5.14）。 Unfortunately, the robot can run low on power, whereupon it has to scurry off to the nearest electrical point and get recharged. Regardless of what it is doing at the time, it needs to stop, and when it is fully charged again, it needs to pick up where it left off. The recharging periods could allow the player to sneak by unnoticed, for example, or allow the player to disable all electricity to the area and thereby disable the robot. 不幸的是，机器人的能源不是无限的，因此它必须赶到最近的电气点并进行充电。 不管它当时在做什么，它需要停止。当它再次充满电时，它需要从它停止的地方开始。 例如，充电时段可允许玩家不加注意地潜行，或允许玩家禁用该区域的所有电力，从而禁用机器人。（注：游戏场景模拟） This is an alarm mechanism: something that interrupts normal behavior to respond to something important. Representing this in a state machine leads to a dou- bling in the number of states. 这是一种警报机制：可以中断正常行为以回应重要事件。 在状态机中表示这一点会导致状态数量的增加。 With one level of alarm this isn’t a problem, but what would happen if we wanted the robot to hide when fighting breaks out in the corridor. If its hiding instinct is more important than its refuelling instinct, then it will have to interrupt refuelling to go hide. After the battle it will need to pick up refuelling where it left off, after which it will pick up whatever it was doing before that. For just 2 levels of alarm, we would have 16 states. 通过一层警报，这不是问题，但如果我们希望机器人在走廊中发生战斗时隐藏会发生什么。 如果它的隐藏决策比加油决策优先级更高，那么就不得不中断加油才能隐藏起来。 在战斗结束后，它需要在停止的地方接受加油，之后它将重拾它之前做的事情。 对于仅2层警报，我们将有16个状态。（？） Rather than combining all the logic into a single state machine, we can separate it into several. Each alarm mechanism has its own state machine, along with the original behavior. They are arranged in a hierarchy, so the next state machine down is only considered when the higher level state machine is not responding to its alarm. 我们可以将它分成几个，而不是将所有逻辑组合到一个状态机中。 每个报警机制都有自己的状态机以及原始行为。 它们按层次结构排列，因此仅当较高级别的状态机未响应其警报时才考虑下一个状态机。 Figure 5.15 shows one alarm mechanism and corresponds exactly to the diagram above. 图5.15显示了一种报警机制，与上图完全一致。 We will nest one state machine inside another to indicate a hierarchical state ma- chine (Figure 5.16). The solid circle again represents the start state of the machine. When a composite state is first entered, the circle with H* inside it indicates which sub-state should be entered. 我们将一个状态机嵌套在另一个状态机中以指示分层状态机（图5.16）。 实心圆圈再次表示机器的启动状态。 首次输入复合状态时，其中带有H *的圆圈表示应输入哪个子状态。 If the composite state has already been entered, then the previous sub-state is returned to. The H* node is called the “history state” for this reason. 如果已经输入复合状态，则返回先前的子状态。 由于这个原因，H *节点被称为“历史状态”。 The details of why there’s an asterisk after the H, and some of the other vagaries of the UML state chart diagram, are beyond the scope of this chapter. Refer back to Pilone [2005] for more details. H之后有一个星号的原因以及UML状态图表中的一些其他变幻莫测的细节超出了本章的范围。 有关更多详细信息，请参阅Pilone [2005]。 Rather than having separate states to keep track of the non-alarm state, we intro- duce nested states. We still keep track of the state of the cleaning state machine, even if we are in the process of refuelling. When the refuelling is over, the cleaning state machine will pick up where it left off. 我们引入嵌套状态，而不是使用单独的状态来跟踪非警报状态。 即使我们正在加油，我们仍然会跟踪清洁状态机的状态。 当加油结束时，清洁状态机将从停止的地方开始。 In effect, we are in more than one state at once: we might be in the “Refuel” state in the alarm mechanism, while at the same time be in the “Pick Up Object” state in the cleaning machine. Because there is a strict hierarchy, there is never any confusion about which state wins out: the highest state in the hierarchy is always in control. 实际上，我们同时处于多个状态：我们可能处于报警机制中的“加油”状态，同时处于清洗机制中的“拾取对象”状态。 因为存在严格的层次结构，所以对于执行哪个状态并不存在任何混淆：层次结构中的最高状态始终处于控制之中。 To implement this, we could simply arrange the state machines in our program so that one state machine calls another if it needs to. So if the refuelling state ma- chine is in its “Clean Up” state, it calls the cleaning state machine and asks it for the action to take. When it is in the “Refuel” state, it returns the refuelling action directly. 为了实现这一点，我们可以简单地在我们的程序中安排状态机，以便一个状态机在需要时调用另一个状态机。 因此，如果加油状态机处于“清理”状态，它会调用清洁状态机并要求其采取措施。 当它处于“加油”状态时，它直接返回加油动作。 While this would lead to slightly ugly code, it would implement our scenario. Most hierarchical state machines, however, support transitions between levels of the hierarchy, and for that we’ll need more complex algorithms. 虽然这会导致稍微丑陋的代码，但它会实现我们的场景。 但是，大多数分层状态机支持层次结构级别之间的转换，为此我们需要更复杂的算法。 For example, let’s expand our robot so that it can do something useful if there are no objects to collect. It makes sense that it will use the opportunity to go and recharge, rather than standing around waiting for its battery to go flat. The new state machine is shown in Figure 5.17. 例如，让我们扩展我们的机器人，以便在没有要收集的对象时它可以做一些有用的事情。 这是有意义的，它会利用这个机会去充电，而不是站在那里等待电池电量消失。 新的状态机如图5.17所示。 Notice that we’ve added one more transition: from the “Search” state right out into the “Refuel” state. This transition is triggered when there are no objects to collect. Because we transitioned directly out of this state, the inner state machine no longer has any state. When the robot has refuelled and the alarm system transitions back to cleaning, the robot will not have a record of where to pick up from, so it must start the state machine again from its initial node (“Search”). 请注意，我们又添加了一个转换：从“搜索”状态直接进入“加油”状态。 没有要收集的对象时会触发此转换。 因为我们直接从这个状态转换，内部状态机不再具有任何状态。 当机器人加满了油并且报警系统转换回清洁时，机器人将无法记录从哪里取货，因此它必须从其初始节点（“搜索”）再次启动状态机。 The Problem ：问题We’d like an implementation of a state machine system that supports hierarchical state machines. We’d also like transitions that pass between different layers of the machine. 我们想要一个支持分层状态机的状态机系统的实现。 我们也喜欢在机器的不同层之间传递的过渡。 The Algorithm ：算法In a hierarchical state machine each state can be a complete state machine in its own right. We therefore rely on recursive algorithms to process the whole hierarchy. As with most recursive algorithms, this can be pretty tricky to follow. The simplest im- plementation covered here is doubly tricky because it recurses up and down the hier- archy at different points. I’d encourage you to use the informal discussion and exam- ples in this section alongside the pseudo-code in the next section and play with the Hierarchical State Machine program on the CD to get a feel for how it is all working. 在分层状态机中，每个状态本身可以是完整的状态机。 因此，我们依靠递归算法来处理整个层次结构。 与大多数递归算法一样，这可能非常棘手。 这里涉及的最简单的实现是双重棘手的，因为它在不同的点上上下起伏。 我鼓励您使用本节中的非正式讨论和示例以及下一节中的伪代码，并使用CD上的Hierarchical State Machine程序来了解它是如何工作的。 The first part of the system returns the current state. The result is a list of states, from highest to lowest in the hierarchy. The state machine asks its current state to return its hierarchy. If the state is a terminal state, it returns itself; otherwise, it returns itself and adds to it the hierarchy of state from its own current state. 系统的第一部分返回当前状态。 结果是状态列表，从层次结构的最高到最低。 状态机要求其当前状态返回其层次结构。 如果状态是终端状态，则返回自身; 否则，它返回自身并从其当前状态向其添加状态层次结构。 In Figure 5.18 the current state is [State L, State A]. 在图5.18中，当前状态是[状态L，状态A]。 The second part of the hierarchical state machine is its update. In the original state machine we assumed that each state machine started off in its initial state. Because the state machine always transitioned from one state to another, there was never any need to check if there was no state. State machines in a hierarchy can be in no state; they may have a cross hierarchy transition. The first stage of the update, then, is to check if the state machine has a state. If not, it should enter its initial state. 分层状态机的第二部分是它的更新。 在原始状态机中，我们假设每个状态机在其初始状态下启动。 因为状态机总是从一个状态转换到另一个状态，所以从来没有必要检查是否没有状态。 层次结构中的状态机可以处于无状态; 他们可能有一个跨层次的过渡。 然后，更新的第一阶段是检查状态机是否具有状态。 如果没有，它应该进入其初始状态。 Next, we check if the current state has a transition it wants to execute. Transitions at higher levels in the hierarchy always take priority, and the transitions of sub-states will not be considered if the super-state has one that triggers. 接下来，我们检查当前状态是否有要执行的转换。 层次结构中较高级别的转换始终具有优先级，如果父状态已经被触发，则不会考虑子状态的转换。 A triggered transition may be one of three types: it might be a transition to an- other state at the current level of the hierarchy; it might be a transition to a state higher up in the hierarchy; or it might be a transition to a state lower in the hierarchy. Clearly, the transition needs to provide more data than just a target state. We allow it to return a relative level: how many steps up or down the hierarchy the target state is. 触发转换可以是以下三种类型之一：它可能是在层次结构的当前级别转换到另一种状态; 它可能是向层次结构中更高级别的状态过渡; 或者它可能是转换到层次结构中较低的状态。 显然，转换需要提供的数据多于目标状态。 我们允许它返回一个相对级别：目标状态在层次结构中向上或向下的步数。 We could simply search the hierarchy for the target state and not require an ex- plicit level. While this would be more flexible (we wouldn’t have to worry about the level values being wrong), it would be considerably more time-consuming. A hybrid, but fully automatic, extension could search the hierarchy once offline and store all appropriate level values. 我们可以简单地在层次结构中搜索目标状态，而不需要一个明确的级别。 虽然这会更灵活（我们不必担心水平值是错误的），但它会更加耗时。 混合但全自动的扩展可以在离线时搜索层次结构并存储所有适当的级别值。 So the triggered transition has a level of zero (state is at the same level), a level greater than zero (state is higher in the hierarchy), or a level less than zero (state is lower in the hierarchy). It acts differently depending on which category the level falls into. 因此，触发转换拥有三种情况：级别为零（状态处于同一级别），级别大于零（层次结构中的状态较高），或小于零的级别（状态在层次结构中较低）。 它的行为取决于级别所属的类别。 If the level is zero, then the transition is a normal state machine transition and can be performed at the current level, using the same algorithm used in the finite state machine. 如果级别为零，则转换是正常状态机转换，并且可以使用在有限状态机中使用的相同算法在当前级别执行。 If the level is greater than zero, then the current state needs to be exited and noth- ing else needs to be done at this level. The exit action is returned, along with an indication to whoever called the update function that the transition hasn’t been com- pleted. We will return the exit action, the transition outstanding, and the number of levels higher to pass the transition. This level value is decreased by one as it is returned. As we will see, the update function will be returning to the next highest state machine in the hierarchy. 如果级别大于零，则需要退出当前状态，而不需要在此级别完成其他操作。 返回退出操作，同时向任何调用Update()的位置指示转换尚未完成。 我们将返回退出时执行的行为、未完成的转换以及更高级别的数量以通过转换。 该级别值在返回时减少一。 正如我们将看到的，更新功能将返回到层次结构中的下一个最高状态机。 If the level is less than zero, then the current state needs to transition to the ancestor of the target state on the current level in the hierarchy. In addition, each of the children of that state also needs to do the same, down to the level of the final desti- nation state. To achieve this we use a separate function, updateDown, that recursively performs this transition from the level of the target state back up to the current level and returns any exit and entry actions along the way. The transition is then complete and doesn’t need to be passed on up. All the accumulated actions can be returned. // 如果级别小于零，则当前状态需要转换到层次结构中当前级别上的目标状态的父状态。 此外，该状态的每个孩子也需要做同样的事情，直到最终目标状态的水平。 为了实现这一点，我们使用一个单独的函数updateDown，它递归地执行从目标状态级别到当前级别的转换，并返回任何退出和进入操作。 然后转换完成，不需要向上传递。 可以返回所有累积的动作。 So we’ve covered all possibilities if the current state has a transition that triggers. If it does not have a transition that triggers, then its action depends on whether the current state is a state machine itself. If not, and if the current state is a plain state, then we can return the actions associated with being in that state, just as before. 因此，如果当前状态具有触发的转换，我们已经涵盖了所有可能性。 如果它没有触发的转换，那么它的动作取决于当前状态是否是状态机本身。 如果不是，并且如果当前状态是普通状态，那么我们可以像以前一样返回与处于该状态相关联的动作。 If the current state is a state machine, then we need to give it the opportunity to trigger any transitions. We can do this by calling its update function. The update func- tion will handle any triggers and transitions automatically. As we saw above, a lower level transition that fires may have its target state at a higher level. The update func- tion will return a list of actions, but it may also return a transition that it is passing up the hierarchy and that hasn’t yet been fired. 如果当前状态是状态机，那么我们需要给它机会来触发任何转换。 我们可以通过调用它的更新函数来实现。 更新功能将自动处理任何触发和转换。 如上所述，触发的较低级别转换可能使其目标状态处于较高级别。 更新功能将返回一个操作列表，但它也可能返回一个它正在向层次结构传递但尚未触发的转换。 If such a transition is received, its level is checked. If the level is zero, then the transition should be acted on at this level. The transition is honored, just as if it were a regular transition for the current state. If the level is still greater than zero (it should never be less than zero, because we are passing up the hierarchy at this point), then the state machine should keep passing it up. It does this, as before, by exiting the current state and returning the following pieces of information: the exit action; any actions provided by the current state’s update function; the transition that is still pending; and the transition’s level, less one. 如果收到这样的转换，则检查其级别。 如果级别为零，则应在此级别上执行转换。转换已经执行，就像它是当前状态的常规过渡一样。 如果级别仍然大于零（它应该永远不会小于零，因为我们此时正在调整层次结构），那么状态机应该继续传递它。 它像以前一样通过退出当前状态并返回以下信息来执行此操作：退出操作; 当前状态更新功能提供的任何行动; 仍未决的状态转换; 和转换的层级//，少一个。 If no transition is returned from the current state’s update function, then we can simply return its list of actions. If we are at the top level of the hierarchy, the list alone is fine. If we are lower down, then we are also within a state, so we need to add the action for the state we’re in to the list we return. 如果没有从当前状态的更新函数返回转换，那么我们可以简单地返回其动作列表。 如果我们处于层次结构的顶层，那么单独列表就可以了。 如果我们处于较低的层级，那么我们也处于一个状态，所以我们需要为我们返回的列表中的状态添加动作。 Fortunately, this algorithm is at least as difficult to explain as it is to implement. To see how and why it works, let’s work through an example. 幸运的是，这种算法至少与实现一样难以解释。 为了了解它的工作原理和原因，让我们来看一个例子。 Examples ：例子Figure 5.19 shows a hierarchical state machine that we will use as an example. 图5.19显示了我们将用作示例的分层状态机。 To clarify the actions returned for each example, we will say S-entry is the set of entry actions for state S, similarly S-active and S-exit for active and exit actions. In transitions we use the same format 1-actions for the actions associated with transi- tion 1. 为了阐明每个示例返回的操作，我们将说S-entry是状态S的入口操作集，类似于活动和退出操作的S-active和S-exit。 在转换中，我们对与转换1相关的操作使用相同的格式1动作。 These examples can appear confusing if you skim them through. If you’re having trouble with the algorithm, I urge you to follow through step by step with both the diagram above and the pseudo-code from the next section. 如果您浏览它们，这些示例可能会让您感到困惑。 如果您在使用算法时遇到问题，我建议您按照上图和下一部分的伪代码一步一步地进行操作。 Suppose we start just in State L, and no transition triggers. We will transition into State [L, A], because L’s initial state is A. The update function will return: L-active and A-entry, because we are staying in L and just entering A. 假设我们只是在状态L开始，没有转换触发器。 我们将转换到状态[L，A]，因为L’的初始状态是A.更新函数将返回：L-active和A-entry，因为我们留在L并且只是进入A. Now suppose transition 1 is the only one that triggers. The top-level state ma- chine will detect no valid transitions, so will call state machine L to see if it has any. L finds that its current state (A) has a triggered transition. Transition 1 is a transition at the current level, so it is handled within L and not passed anywhere. A transitions to A, and L’s update function returns: A-exit, 1-actions, B-entry. The top-level state machine accepts these actions and adds its own active action. Because we have stayed in State L throughout, the final set of actions is A-exit, 1-actions, B-entry, L-active. The current state is [L, B]. 现在假设转换1是唯一触发的转换。 顶层状态机将检测到无有效转换，因此将调用状态机L以查看它是否有任何转换。 L发现其当前状态（A）具有触发转换。 转换1是当前级别的转换，因此它在L内处理，不会在任何地方传递。 转换到A，并且L的更新函数返回：A-exit，1—actions，B-entry。 顶层状态机接受这些操作并添加其自己的活动操作。 因为我们始终处于状态L，所以最后一组动作是A-exit，1-actions，B-entry，L-active。 当前状态是[L，B]。 From this state, transition 4 triggers. The top-level state machine sees that transi- tion 4 triggers, and because it is a top-level transition, it can be honored immediately. The transition leads to State M, and the corresponding actions are L-exit, 4-actions, M-entry. The current state is [M]. Note that L is still keeping a record of being in State B, but because the top-level state machine is in State M, this record isn’t used at the moment. 从这个状态，转换4触发。 顶级状态机看到转换4触发，并且因为它是顶级转换，所以它可以立即兑现。 转换导致状态M，并且相应的动作是L-exit，4-actions，M-entry。 当前状态是[M]。 请注意，L仍然保留在状态B中的记录，但由于顶级状态机处于状态M，因此此记录不会被使用。 We’ll go from State M to State N in the normal way through transition 5. The pro- cedure is exactly the same as for the previous example and the non-hierarchical state machine. Now transition 6 triggers. Because it is a level zero transition, the top-level state machine can honor it immediately. It transitions into State L and returns the ac- tions N-exit, 6-actions, L-entry. But now, L’s record of being in State B is important: we end up in State [L, B] again. In our implementation we don’t return the B-entry action, because we didn’t return the B-exit action when we left State L previously. This is a personal preference on my part and isn’t fixed in stone. If you want to exit and re-enter State B, then you can modify your algorithm to return these extra actions at the appropriate time. 我们将通过转换5以正常方式从状态M转到状态N.该过程与前一个示例和非分层状态机完全相同。 现在转换6个触发器。 因为它是一个零级转换，所以顶级状态机可以立即兑现它。 它转换到状态L并返回N-exit，6-actions，L-entry的动作。 但是现在，L在状态B的记录很重要：我们再次进入状态[L，B]。 在我们的实现中，我们不返回B-entry动作，因为我们之前离开状态L时没有返回B-exit动作。 这是我个人的偏好，并不是固定的。 如果要退出并重新输入状态B，则可以修改算法以在适当的时间返回这些额外的操作。 Now suppose from State [L, B] transition 3 triggers. The top-level state machine finds no triggers, so it will call state machine L to see if it has any. L finds that State B has a triggered transition. This transition has a level of one: its target is one level higher in the hierarchy. This means that State B is being exited, and it means that we can’t honor the transition at this level. We return B-exit, along with the uncompleted transition, and the level minus one (i.e., zero, indicating that the next level up needs to handle the transition). So control returns to the top-level update function. It sees that L returned an outstanding transition, with zero level, so it honors it, transitioning in the normal way to State N. It combines the actions that L returned (namely,B-exit) with the normal transition actions to give a final set of actions: B-exit, L-exit,3-actions, N-entry. Note that, unlike in our third example, L is no longer keeping track of the fact that it is in State B, because we transitioned out of that state. If we fire transition 6 to return to State L, then State L’s initial state, A, would be entered, just like in the first example. 现在假设从状态[L，B]过渡3触发。顶级状态机找不到触发器，因此它将调用状态机L以查看它是否有任何触发器。 L发现状态B已经触发转换。此转换的级别为1：其目标在层次结构中高一级。这意味着状态B正在退出，并且我们无法履行这一级别的过渡。我们返回B-exit，以及未完成的转换，以及级别减1（即，零，表示下一级需要处理转换）。因此控制移交回上层的Update函数。Update函数得到了一个未完成的状态转换，零级别，所以Update函数将执行这个转换：以正常方式转换到状态N。它将L返回的动作（即B-exit）与正常的过渡动作结合起来给出一组最终动作集：B-exit，L-exit，3-actions，N-entry。请注意，与我们的第三个示例不同，L不再跟踪它在状态B中执行的事，因为我们已经转换出该状态。如果我们触发转换6返回到状态L，则将输入State L’的初始状态A，就像在第一个示例中一样。 Our final example covers transitions with level less than zero. Suppose we moved from State N to State M via transition 7. Now we make transition 2 trigger. The top- level state machine looks at its current state (M) and finds transition 2 triggered. It has a level of minus one, because it is descending one level in the hierarchy. Because it has a level of minus one, the state machine calls the updateDown function to perform the recursive transition. The updateDown function starts at the state machine (L) that contains the final target state (C), asking it to perform the transition at its level. State machine L, in turn, asks the top-level state machine to perform the transition at its level. The top-level state machine changes from State M to State L, returning M-exit, L-entry as the appropriate actions. Control returns to state machine L’s updateDown function. State machine L checks if it is currently in any state (it isn’t, since we left State B in the last example). It adds its action, C-entry, to those returned by the top- level machine. Control then returns to the top-level state machine’s update function: the descending transition has been honored, it adds the transition’s actions to the result, and returns M-exit, C-entry, L-entry, 2-actions. 我们的最后一个示例涵盖了级别小于零的转换。假设我们通过转换7从状态N移动到状态M，现在我们通过触发器2执行转换。顶级状态机查看其当前状态（M）并找到触发的转换2。它的级别为-1，因为它在层次结构中下降一级。因为它的级别为-1，所以状态机调用updateDown函数来执行递归转换。 updateDown函数从包含最终目标状态（C）的状态机（L）开始，要求它在其级别执行转换。状态机L反过来要求顶级状态机在其级别执行转换。顶级状态机从状态M变为状态L，返回M-exit，L-entry作为适当的动作。控制返回状态机L的updateDown函数。状态机L检查它当前是否处于任何状态（它不是，因为我们在最后一个例子中离开了状态B）。它将其操作C-entry添加到顶级计算机返回的操作中。然后，Control返回到顶级状态机的Update函数：已经执行过降序转换，它将转换的动作添加到结果中，并返回M-exit，C-entry，L-entry，2-actions。 If state machine L had still been in State B, then when L’s updateDown function was called, it would transition out of B and into C. It would add B-exit and C-entry to the actions that it received from the top-level state machine. 如果状态机L仍处于状态B，那么当调用L的 updateDown函数时，它将从B转换为C。它会将B-exit和C-entry添加到它从顶层状态机接收的操作集中。 Pseudo-Code ：伪代码The hierarchical state machine implementation is made up of five classes and forms one of the longest algorithms in this book. The State and Transition classes are similar to those in the regular finite state machine. The HierarchicalStateMachine class runs state transitions, and SubMachineState combines the functionality of the state machine and a state. It is used for state machines that aren’t at the top level of the hierarchy. All classes but the Transition inherit from a HSMBase class, which simpli- fies the algorithm by allowing functions to treat anything in the hierarchy in the same way. 分层状态机实现由五个类组成，并形成本书中最长的算法之一。 State和Transition类与常规有限状态机中的类相似。 HierarchicalStateMachine类运行状态转换，SubMachineState结合状态机和状态的功能。 它用于不在层次结构顶层的状态机。 除了Transition之外的所有类都继承自HSMBase类，它通过允许函数以相同的方式处理层次结构中的任何内容来简化算法。 The HSMBase has the following form: HSMBase类如下所示： 12345678910111213141516171819class HSMBase # The structure returned by update // Update函数返回结果的结构体 struct UpdateResult actions // 行为 transition// 转换路径 level // 层级 def getAction(): return [] def update() &#123; UpdateResult result result.actions = getAction() result.transition = None result.level = 0 return result &#125; // 未实现的功能？ def getStates() # unimplemented function The HierarchicalStateMachine class has the following implementation: HierarchicalStateMachine类有着如下实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132class HierarchicalStateMachine (HSMBase) # List of states at this level of the hierarchy // 本层次的状态列表 states # The initial state for when the machine has to # current state. // 机器必须处于当前状态的初始状态 initialState # The current state of the machine. // 状态机的当前状态 currentState = initialState # Gets the current state stack // 获得当前状态栈 def getStates(): if currentState: return currentState.getStates() else: return [] # Recursively updates the machine. // 递归更新状态机 def update(): # If we’re in no state, use the initial state // 如果没有处于任何状态，使用初始状态 if not currentState: currentState = initialState return currentState.getEntryAction() # Try to find a transition in the current state // 从当前状态尝试找到一个转换 triggeredTransition = None for transition in currentState.getTransitions(): if transition.isTriggered(): triggeredTransition = transition break # If we’ve found one, make a result structure for it // 如果我们找到了一个转换，为其生成一个结果结构体 if triggeredTransition: result = UpdateResult() result.actions = [] result.transition = triggeredTransition result.level = triggeredTransition.getLevel() # Otherwise recurse down for a result // 否则递归获得结果 else: result = currentState.update() # Check if the result contains a transition // 检查结果中是否包含转换 if result.transition: # Act based on its level // 基于本层执行 if result.level == 0: # Its on our level: honor it // 结果行为在本层：执行 targetState = result.transition.getTargetState() result.actions += currentState.getExitAction() result.actions += result.transition.getAction() result.actions += targetState.getEntryAction() # Set our current state // 设置当前状态 currentState = targetState # Add our normal action (we may be a state) // 添加基本操作 result.actions += getAction() # Clear the transition, so nobody else does it // 清除转换，因此没有其他(?)执行它 result.transition = None else if result.level &gt; 0: # Its destined for a higher level // 这表示一个更高的层级 # Exit our current state // 退出当前状态 result.actions += currentState.getExitAction() currentState = None # Decrease the number of levels to go // 当相对于目标层级为降低时 result.level -= 1 else: # It needs to be passed down // 它需要向下迁移 targetState = result.transition.getTargetState() targetMachine = targetState.parent result.actions += result.transition.getAction() result.actions += targetMachine.updateDown(targetState, -result.level) # Clear the transition, so nobody else does it // 清除转换，因此没有其他(?)执行它 result.transition = None # If we didn’t get a transition // 如果我们没有（从结果中）取得转换 else: # We can simply do our normal action // 我们可以简单的执行我们的基本行为 result.action += getAction() # Return the accumulated result // 返回积累的结果 return result# Recurses up the parent hierarchy, transitioning into# each state in turn for the given number of levels// 递归父层次结构，依次转换到指定层级号的每个状态def updateDown(state, level): # If we’re not at top level, continue recursing // 如果不在顶层，继续递归 if level &gt; 0: # Pass ourself as the transition state to our parent // 将自己作为转换状态传递给父状态 actions = parent.updateDown(this, level-1) # Otherwise we have no actions to add to // 否则我们将没有要添加的行为 else: actions = [] # If we have a current state, exit it // 如果当前状态存在，退出 if currentState: actions += currentState.getExitAction() # Move to the new state, and return all the actions // 转移到新的状态，并且返回所有行为 currentState = state actions += state.getEntryAction() return actions The state class is substantially the same as before, but adds an implementation for getStates: 状态类的实现与之前的实现大体相同，但是增加了一个有关getStates的实现： 12345678910class State (HSMBase): def getStates(): # If we’re just a state, then the stack is just us // 如果是一个状态，那么要返回的状态栈仅有这个状态自身 return [this] # As before... def getAction() def getEntryAction() def getExitAction() def getTransitions() Similarly, the Transition class is the same, but adds a method to retrieve the level of the transition. 无独有偶，Transition类的实现也一样，但是添加了一个方法来返回的转换所在的层级。 123456789class Transition: # Returns the different in levels of the hierarchy from # the source to the target of the transition. // 返回 def getLevel() # As before... def isTriggered() def getTargetState() def getAction() Finally, the SubMachineState class merges the functionality of a state and a state machine. 最后，SubMachineState类整合了一个状态的功能与一个状态机。 1234567891011121314class SubMachineState (State, HierarchicalStateMachine): # Route get action to the state // 转换 def getAction(): return State::getAction() # Route update to the state machine // 转换 def update(): return HierarchicalStateMachine::update() # We get states by adding ourself to our active children // 通过将自身加入活跃子节点集中获取当前状态 def getStates(): if currentState: return [this] + currentState.getStates() else: return [this] Implementation Notes：实现说明I’ve used multiple inheritance to implement SubMachineState. For languages (or programmers) that don’t support multiple inheritance, there are two options. The Sub- MachineState could encapsulate HierarchicalStateMachine, or the Hierarchical- StateMachine can be converted so that it is a sub-class of State. The downside with the latter approach is that the top-level state machine will always return its active action from the update function, and getStates will always have it as the head of the list. 我已经使用多重继承来实现SubMachineState类。对于不支持多重继承的语言（或程序员），有两种选择。 Sub-MachineState可以封装HierarchicalStateMachine，或者Hierarchical-StateMachine可以被转换，使其成为State的子类。后一种方法的缺点是顶级状态机将始终从更新函数返回其活动操作，并且getStates将始终将其作为列表的头部。 I’ve elected to use a polymorphic structure for the state machine again. It is possible to implement the same algorithm without any polymorphic method calls. Given that it is complex enough already, however, I’ll leave that as an exercise. My experience deploying a hierarchical state machine involved an implementation using poly- morphic method calls (provided on the CD). In-game profiling on both PC and PS2 showed that the method call overhead was not a bottleneck in the algorithm. In a system with hundreds or thousands of states, it may well be, as cache efficiency issues come into play.Some implementations of hierarchical state machines are significantly simpler than this by making it a requirement that transitions can only occur between states at the same level. With this requirement, all the recursion code can be eliminated. If you don’t need cross hierarchy transitions, then the simpler version will be easier to implement. It is unlikely to be any faster, however. Because the recursion isn’t used when the transition is at the same level, the code above will run about as fast if all the transitions have a zero level. 我已经选择再次使用状态机的多态结构。没有任何多态方法调用就可以实现相同的算法。鉴于它已经足够复杂了，我将把它留作练习。我部署分层状态机的经验涉及使用多态方法调用的实现（在CD上提供）。 PC和PS2上的游戏内分析表明，方法调用开销不是算法中的瓶颈。在具有数百或数千个状态的系统中，很可能会出现缓存效率问题。分层状态机的一些实现比这更简单，因为要求转换只能在同一级别的状态之间发生。根据此要求，可以消除所有递归代码。如果您不需要跨层次转换，则更简单的版本将更容易实现。然而，它不太可能更快。因为当转换处于相同级别时不使用递归，所以如果所有转换具有零级别，则上述代码将以相同的速度运行。 Performance ：开销The algorithm is O(n) in memory, where n is the number of layers in the hierarchy. It requires temporary storage for actions when it recurses down and up the hierarchy. 该算法在内存中是O（n），其中n是层次结构中的层数。它需要临时存储操作，以便在向下和向下递增层次结构时执行操作。 Similarly, it is O(nt) in time, where t is the number of transitions per state. To find the correct transition to fire, it potentially needs to search each transition at each level of the hierarchy and O(nt) process. The recursion, both for a transition level 0 is O(n), so it does not affect the O(nt) for the whole algorithm. 类似地，它是时间上的O（nt），其中t是每个状态的转换数。要找到正确的触发转换，可能需要在层次结构的每个级别和O（nt）进程中搜索每个转换。对于转换级别 0的递归都是O（n），因此它不会影响整个算法的O（nt）。 5.3.10 COMBINING DECISION TREES AND STATE MACHINES ：决策树与状态机的结合The implementation of transitions bears more than a passing resemblance to the implementation of decision trees. This is no coincidence, but we can take it even further. Decision trees are an efficient way of matching a series of conditions, and this has application in state machines for matching transitions. We can combine the two approaches by replacing transitions from a state with a decision tree. The leaves of the tree, rather than being actions as before, are transitions to new states. 转换的实现不仅仅与决策树的实现有相似之处。这不是巧合，但我们可以更进一步。决策树是匹配一系列条件的有效方式，而且具有这种行为在用于匹配转换的状态机中有效。 我们可以通过用状态替换状态转换的方式来组合这两种方法决策树。树的叶子，而不是像以前那样的动作，是向新状态的过渡。 A simple state machine might look like Figure 5.20. 一个简单的状态机可能如图5.20所示。 The diamond symbol is also part of the UML state chart diagram format, repre- senting a decision. In UML there is no differentiation between decisions and transi- tions, and the decisions themselves are usually not labelled. In this book I’ve labelled the decisions with the test that they perform, which is clearer for our needs. 菱形符号也是UML状态图表格式的一部分，代表了一个决定。在UML中，决策和转换之间没有区别，决策本身通常没有标记。 在本书中，我用他们执行的测试标记了决策，这更符合我们的需求。 When in the “Alert” state, a sentry has only one possible transition: via the de- cision tree. It quickly ascertains whether the sentry can see the player. If the sentry is not able to see the player, then the transition ends and no new state is reached. If the sentry is able to see the player, then the decision tree makes a choice based on the distance of the player. Depending on the result of this choice, two different states may be reached: “Raise Alarm” or “Defend.” The latter can only be reached if a further test (distance to the player) passes. 当处于“警报”状态时，哨兵只有一个可能的过渡：通过决策树。它可以快速确定哨兵是否可以看到玩家。如果哨兵无法看到该玩家，则转换结束并且不会达到新的状态。如果哨兵能够看到玩家，则决策树根据玩家的距离做出选择。根据此选择的结果，可能会达到两种不同的状态：“提升警报”或“防御”。只有在进一步测试（与玩家的距离）通过后才能达到后者。 To implement the same state machine without the decision nodes, the state ma- chine in Figure 5.21 would be required. Note that now we have two very complex con- ditions and both have to evaluate the same information (distance to the player and distance to the alarm point). If the condition involved a time-consuming algorithm (such as the line of sight test in our example), then the decision tree implementationwould be significantly faster. 要在没有决策节点的情况下实现相同的状态机，将需要图5.21中的状态机。请注意，现在我们有两个非常复杂的条件，两者都必须评估相同的信息（到播放器的距离和到报警点的距离）。如果条件涉及耗时的算法（例如我们示例中的视线测试），那么决策树实现将明显更快。 Pseudo-Code ：伪代码We can incorporate a decision tree into the state machine framework we’ve developed so far. 我们可以将决策树合并到我们迄今为止开发的状态机框架中。 The decision tree, as before, consists of DecisionTreeNodes. These may be decisions (using the same Decision class as before) or TargetStates (which replace the Action class in the basic decision tree). TargetStates hold the state to transition to and can contain actions. As before, if a branch of the decision tree should lead to no result, then we can have some null value at the leaf of the tree. 与以前一样，决策树由DecisionTreeNodes组成。这些可能是决策（使用与之前相同的Decision类）或TargetStates（它们替换基本决策树中的Action类）。 TargetStates保持状态转换并可以包含操作。和以前一样，如果决策树的一个分支应该导致没有结果，那么我们可以在树的叶子上有一些空值。 The decision making algorithm needs to change. Rather than testing for Actions to return, it now tests for TargetState instances: 决策算法需要改变。它不是测试要返回的Actions，而是测试TargetState实例： We can then build an implementation of the Transition interface which supports these decision trees. It has the following algorithm: 然后我们可以构建支持的Transition接口的实现这些决策树。它有以下算法： Implementation：实现As before, this implementation relies heavily on polymorphic methods in an object- oriented framework. The corresponding performance overhead may be unacceptable in some cases where lots of transitions or decisions are being considered.和以前一样，这种实现在很大程度上依赖于面向对象框架中的多态方法。在考虑大量转换或决策的某些情况下，相应的性能开销可能是不可接受的。]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>Artificial Intelligence for Games</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unity shader 透明效果]]></title>
    <url>%2F2018%2F10%2F22%2FUnity%E7%AC%94%E8%AE%B0%2Funity-shader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[unity shader 基础纹理]]></title>
    <url>%2F2018%2F10%2F22%2FUnity%E7%AC%94%E8%AE%B0%2Funity-shader-%E5%9F%BA%E7%A1%80%E7%BA%B9%E7%90%86%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[unity shader 渲染管线]]></title>
    <url>%2F2018%2F10%2F22%2FUnity%E7%AC%94%E8%AE%B0%2Funity-shader-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[GPU图形渲染管线流程流程概述应用程序阶段应用程序阶段，使用高级编程语言(C、C++、JAVA 等)进行开发，主要和CPU、内存打交道，诸如碰撞检测、场景图建立、空间八叉树更新、视锥裁剪等经典算法都在此阶段执行。在该阶段的末端，几何体数据(顶点坐标、法向量、纹理坐标、纹理等)通过数据总线传送到图形硬件。 工作： 准备场景数据：如摄像机的位置、视锥体、场景中包含的模型、光源等 粗粒度剔除：把不可见的物体剔除 设置好每个模型的渲染状态：包括材质、使用的纹理、使用的Shader等 输出： 渲染图元：渲染所需的几何信息 几何阶段几何阶段，主要负责顶点坐标变换、光照、裁剪、投影以及屏幕映射，该阶段基于GPU进行运算，在该阶段的末端得到了经过变换和投影之后的顶点坐标、颜色、以及纹理坐标。光照计算属于几何阶段，因为光照计算涉及视点、光源和物体的世界坐标，所以通常放在世界坐标系中进行计算。 工作： 决定需要绘制的图元是什么 怎样绘制 在哪里绘制 输出： 屏幕空间的二维顶点坐标 每个顶点的深度值、着色等相关信息 光栅阶段 光栅阶段，基于几何阶段的输出数据，为像素(Pixel)正确配色，以便绘制完整图像，该阶段进行的都是单个像素的操作，每个像素的信息存储在颜色缓冲器(color buffer 或者 frame buffer)中。 雾化以及涉及物体透明度的计算属于光栅化阶段，因为上述两种计算都需要深度值信息(Z 值)，而深度值是在几何阶段中计算，并传递到光栅阶段的。 工作：根据上个阶段传递的数据来产生屏幕上的像素，并渲染出最终的图像。 输出：逐像素处理过的渲染图元。 从几何阶段到光栅化阶段： 几何阶段：变换三维顶点坐标和光照计算 将模型空间坐标（object space coordinate）通过四阶矩阵变换矩阵（world matrix）转换为世界空间坐标（ world space coordinate ）。 进行光照计算。 将模型空间下的顶点法向量转换为世界空间下的，所用的转换矩阵为world matrix的转置矩阵的逆矩阵。 将物体顶点坐标从世界空间（world space）转换到观察空间下（eye space）。 将顶点坐标从观察空间下转换到裁剪空间下（project and clip space）。 投影：用透视变换矩阵把顶点从视锥体（viewing frustum）中变换到裁剪空间的规范立方体（CVV）中。 图元装配（Primitive Assembly）：将顶点根据原始的连接关系还原出网格结构。 裁剪：在CVV中将位于视体外的场景数据去除。 将得到的完全位于视体中的场景数据映射到屏幕坐标系上。 光栅化阶段：决定哪些像素被集合图元覆盖。光栅化是将几何数据经过一系列变换后最终转换为像素，从而呈现在显示设备上的过程，光栅化的本质是坐标变换，几何离散化。 三角形设置：计算光栅化一个三角网格所需的信息 三角形遍历：检查每个像素是否被一个三角网格所覆盖，被覆盖则生成一个片元（对顶点信息插值）。 读取模型的顶点，3个3个的读，因为要画三角形。 将3个顶点两两连成线，形成三角形。 计算屏幕像素点在三角形内还是三角形外。在三角形内部的，就上色（颜色是之前算出来的），在三角形外部的，就不上色。http://www.cnblogs.com/graphics/archive/2010/08/05/1793393.html（可以通过叉积来实现，连接PA，将PA和AB做叉积，再将CA和AB做叉积，如果两个叉积的结果方向一致，那么两个点在同一测。判断两个向量的是否同向可以用点积实现，如果点积大于0，则两向量夹角是锐角，否则是钝角。） Pixel Operation 纹理操作（Texture operation）：根据像素的纹理坐标，查询对应的纹理值。 消除遮挡面：深度测试，模版测试等。 混色（Blending）：根据目前已经画好的颜色，与正在计算的颜色的透明度(Alpha)，混合为两种颜色，作为新的颜色输出。 滤波（Filtering）：将正在算的颜色通过某种滤波后输出。 HLSL、GLSL与Cg：常见的着色语言： DirectX的HLSL：微软控制着色器编译，编译结果在不同硬件上相同，但平台有限。 OpenGL的GLSL：跨平台性良好，编译结果取决于硬件供应商。 NVIDIA的Cg：真正的跨平台。 DrawCall：CPU调用图像编程接口，命令GPU进行渲染的操作。 Shader： GPU流水线上一些可高度编程的阶段，由着色器编译出来的最终代码会在GPU上运行 有一些特定类型的着色器 依靠着色器来控制流水线中的渲染细节。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGL学习笔记（0）]]></title>
    <url>%2F2018%2F07%2F28%2FOpenGL%E7%AC%94%E8%AE%B0%2FOpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%880%EF%BC%89%2F</url>
    <content type="text"><![CDATA[配置OpenGL 以及第一个程序。 Mac下配置OpenGL 安装homebrew ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 安装GLEW与GLFW brew install glew brew install glfw 新建Xcode的Command Line C++项目，在build settings中设置Header Search Path与Library Search Path，在其中添加对应的glew与glfw的头文件(include)与库文件(lib)路径。 在build Phases中添加库文件 （在对应的文件夹中将两个/.dylib的文件直接拖拽进来） 配置GLAD： 打开在线服务，API选择3.3及以上，Profile选择Core，勾选Options中的Generate a loader，点击GENERATE，会生成一个压缩包，下载。 将子目录中的/include/glad与/include/KHR复制到/usr/Local/include文件夹下。（如果/usr文件夹隐藏，可用快捷键command+shift+G输入访问） 将/src中的glad.c复制到Xcode工程文件夹下。 在build settings中添加路径/usr/local/include 此时如果不出意外的话，你的第一个测试程序已经可以运行了，点击测试代码，复制到自己的.cpp文件中执行，会出现一个黑色窗口。 图形渲染管线（Graphics PipeLines）​ 图形渲染管线接受一组3D坐标，然后转换成屏幕上的2D像素。 顶点着色器：以数组的形式传递3个3D坐标作为图形渲染管线的输入，用来表示一个三角形，这个数组称为顶点数据（Vertex Data）。顶点数据是一系列顶点的集合，一个顶点是一个3D坐标的数据的集合。顶点数据由顶点属性表示。顶点着色器将一种3D坐标转换成另一种3D坐标，同时对顶点属性做出一些处理。 图元装配：将顶点着色器输出的所有顶点作为输入，将所有顶点装配成制定形状的图元。 几何着色器：把图元形式的一系列顶点集合作为输入，通过产生新的顶点构造出新的图元来产生其他形状。 光栅化阶段：把图元映射为最终屏幕上的像素，生成供片段着色器使用的片段，在片段着色器使用之前进行裁剪，丢弃视图之外的所有像素，以提升执行效率。 片段着色器：计算一个像素的最终颜色。 Alpha 测试与混合阶段。 对象：顶点缓冲对象（Vertex Buffer Objects,VBO）:​ 普通的顶点数组的传输，需要在绘制的时候频繁的从CPU向GPU传送数据，这种做法效率低下，为了加快显示速度，显卡增加了一个扩展，用于管理内存，在GPU内存中存储大量顶点数据，这样大大减少了从CPU到GPU的数据拷贝开销，从而提升了程序运行的效率。 12345void glGenBuffers(GLsizei n,GLuint* buffers); // 返回n个当前未使用的缓存对象名称，并保存到buffers数组中void glBindBuffer(GLenum target,GLuint buffer); // 指定当前激活的缓存对象，target表示指定绑定的目标类型，buffer为要绑定的缓存对象的名称void glBufferData (GLenum target, GLsizeiptr size, const GLvoid* data, GLenum usage); // 把用户定义的数据复制到当前绑定缓冲：target目标缓冲的类型，size指定传输数据的大小，data希望发送的实际数据，usage表示希望显卡如何使用该数据 usage的可选内容及意义： GL_STATIC_DRAW ：数据不会或几乎不会改变。 GL_DYNAMIC_DRAW：数据会被改变很多。 GL_STREAM_DRAW ：数据每次绘制时都会改变。 顶点数组对象（Vertex Array Object,VAO）:​ 每当我们绘制一个几何体时，我们需要重复同样的工作（首先绑定缓冲区、然后设置顶点属性）。当需要绘制的物体很多时，这个过程就显得有些耗时。VAO将所有顶点绘制过程中的这些设置与绑定过程集中存储在一起，当配置顶点属性指针时，只需要将那些调用执行一次，之后再绘制物体的时候只需要绑定相应的VAO就行了。这使在不同顶点数据和属性配置之间切换变得非常简单，只需要绑定不同的VAO就行了。刚刚设置的所有状态都将存储在VAO中。VAO可以看作一个容器，包含了多个VBO。 一个顶点数组对象会储存以下这些内容： glEnableVertexAttribArray和glDisableVertexAttribArray的调用。 通过glVertexAttribPointer设置的顶点属性配置。 通过glVertexAttribPointer调用与顶点属性关联的顶点缓冲对象。 索引缓冲对象（Element Buffer Object，EBO）：​ 和顶点缓冲对象一样，EBO也是一个缓冲，它专门储存索引，OpenGL调用这些顶点的索引来决定该绘制哪个顶点。 ​ glDrawElements函数从当前绑定到GL_ELEMENT_ARRAY_BUFFER目标的EBO中获取索引。这意味着我们必须在每次要用索引渲染一个物体时绑定相应的EBO，这还是有点麻烦。不过顶点数组对象同样可以保存索引缓冲对象的绑定状态。VAO绑定时正在绑定的索引缓冲对象会被保存为VAO的元素缓冲对象。绑定VAO的同时也会自动绑定EBO。 ​ 当目标是GL_ELEMENT_ARRAY_BUFFER的时候，VAO会储存glBindBuffer的函数调用。这也意味着它也会储存解绑调用，所以确保你没有在解绑VAO之前解绑索引数组缓冲，否则它就没有这个EBO配置了。]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[六月七日随笔]]></title>
    <url>%2F2018%2F06%2F07%2F%E9%9A%8F%E7%AC%94%2F%E5%85%AD%E6%9C%88%E4%B8%83%E6%97%A5%E9%9A%8F%E7%AC%94%2F</url>
    <content type="text"><![CDATA[无聊夜晚的碎碎念罢了。 近来还好。 不知道是什么原因，现在拿起笔或者打开word，面对着一片空白，总不知道该敲下点什么。但是偏偏又觉得应该写点什么，作为一种记录被遗忘，在机缘巧合之下向某个尘封已久的服务器发出一个请求，再把这点文字翻出来，以一种陌生人的眼光重新审视当时的自己。 事实上，以上所描述的情况很可能不会发生，于我自己而言，以往写过的那些烂东西（包括这一篇），我只能让它静静地躺在我的日志列表里，并不指望以后翻出来再得到什么愉悦的享受。 之所以有记录的想法，与对他人的效仿不无关系。去年工程实训的时候偶然接触到学长的游戏——《没有人知道的大冒险》，后来在种子班宣讲的时候才得知，原来这款游戏是学长所做。我对这个游戏本身所表达的内容很有感触，便由此对学长其人也生出了些许好奇。互联网是有记忆的，我还是找到了学长的博客，虽然它已经好久没有更新，但是我还是从他当时的文字中依稀看到他当时的状态。我想，文字的魅力在于，它无法向你描述所有，但是你却可以从文字本身生发出基于你人生经验的幻想世界。它或许只是一个截面、一个场景、甚至是一种氛围，但是却可以给你无比真实的代入感。 但是记录仅仅是记录本身，它代表着我当下思想的一部分——用文字所能表述的那部分。 很久没有读过书，我是指文学类的书籍。笼统的把原因归结为每天太忙其实是不成立的，每天固然有很多事情要去做，但是闲下来的时间，还是投入到了无限的收割快速愉悦事业中去了。刷刷微博、看看视频、翻翻好友的动态（所幸目前还没有接触短视频），我的大脑就告诉我：“哦，我感受到多巴胺了！”。纵使我知道这世界也没那么需要我，也没有什么动态是非我知道不可的，我还是这样做了。低级并快乐。 伴随而来的就是，快乐的阈值提高了，而表达自己的水平降低了。可表达的事情越来越少，能感触到的事情也越来越少。我从心底里觉得这不是什么好事，当一部分情绪很久不再出现在你的备选项中，其实是一件非常无聊的事情。就如同炒菜少了那么几位调料，寡淡而无趣。 很清楚的意识到这一点的时候，大概是在成都站的gamejam结束，当主持人宣布第二组入围的时候，我以为我会很开心，但是并没有发生。对事物的好奇、对成就的满足和那种单纯的想要做某件事情的欲望——这些好像都在离我而去。 当然，这或许可以解释为所谓的“佛系”或者“人间不值得”或者随便一句什么用烂了的腔调，但是我想我不该是这样，我想象中的自己是一个有血有肉的、愚蠢的、有着清楚欲望的年轻人，而不是一个默认着某些事情发生、而盲从于某些“看起来好”的人。 我知道这团火终归会熄，但至少不应该是现在。 无知且狂妄总要好过纠结且麻木，起码前者看起来还活着。 先记到这。]]></content>
      <categories>
        <category>文字</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity Shader 基础]]></title>
    <url>%2F2018%2F05%2F11%2FUnity%E7%AC%94%E8%AE%B0%2FUnity-Shader%20%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Unity Shader的一些基础知识 Chapter3 Unity Shader 基础概述在Unity需要材质（Material）与Unity Shader配合使用来达到满意的效果。 Unity Shader定义了渲染需要的各种代码（顶点着色器与片元着色器等），属性（使用哪些纹理）和指令（渲染和标签设置），我们通过材质调节这些属性，再赋给相应的模型。 材质：配合GameObject的Mesh或者Particle Systems组件来工作。 Unity Shader： Standard Surface Shader:使用了一个包含了标准光照模型的表面着色器模板 Unlit Shader: 一个不包含光照但是包含雾效的基本顶点/片元着色器 Image Effect Shader: 为实现屏幕后处理提供基本模板 Compute Shader: 借助GPU的并行性来进行一些与渲染流水线无关的计算 ShaderLab一款专门为Unity Shader服务的语言。 Properties 属性 语句格式：Name(&quot;display name&quot;,PropertyType)=DefaultValue 支持的属性类型： |属性类型|定义语法| |:————:|:————:| |Int|number| |Float|number| |Range(min,max)|number| |Color|(number,number,number,number)| |Vector|(number,number,number,number)| |2D|”defaulttexture”{}| |Cube|”defaulttexture”{}| |3D|”defaulttexture”{}| Unity允许重载默认的材质编辑面板以提供更多的自定义数据类型。 关键词“Custom Shader GUI”Properties语义块的作用仅仅是为了让这些属性可以出现在材质面板里。 SubShader:表面着色器 语句格式 123456789101112SubShader&#123; //可选的，标签 [Tags] //可选的，状态 [RenderSetup] //一次完整的渲染流程，如果pass的数目过多，会造成渲染性能的下降。 Pass&#123; &#125; ...&#125; RenderSetup 状态：关于渲染状态的设置指令| 状态名称 | 设置指令 |解释||:————:|:————:|:——:|| Cull |Cull Back/Front/Off| 剔除模式：剔除背面/正面/关闭剔除||ZTest|ZTest Less Greater/LEqual/GEqual/Equal/NotEqual/Always|设置深度剔除时使用的函数||ZWrite|ZWrite On/Off|关闭/开启深度写入||Blend|Blend SrcFactor DstFactor|开启并设置混合模式| Tags 标签：希望怎样以及何时渲染这个对象Tags{&quot;TagName1&quot;=&quot;Value1&quot; &quot;TagName2&quot;=&quot;Value2&quot;}| 标签类型 | 说明 ||————|————|| Queue | 控制渲染顺序，指定该物体属于哪一个渲染队列 ||RenderType|对着色器进行分类，可以用于着色器替换功能||DisableBatching|指明是否对该SubShader使用批处理||ForceNoShadowCasting|控制使用该SubShader的物体是否会投射阴影||IgnoreProjector|控制使用该SubShader的物体是否受projector（投影仪？）的影响||CanUseSpriteAtlas|当该SubShader是用于sprite时，将该标签设为“false”||PreviewType|指明材质面板将如何预览该材质。默认材质下，材质将显示为一个球形，我们可以通过将该标签的值设为“Plane”“SkyBox”来改变预览类型|上述标签可以在SubShader中声明，而不可以在Pass块中声明，Pass块有专属于自己的标签。 Pass语义块： 123456Pass&#123; [Name] [Tag] [RenderSetup] // Other code&#125; Name “MyPassName”：定义该Pass的名称，可以使用UsePass命令来直接使用其他unity shader中的Pass，例如：UsePass &quot;MyShader/MYPASSNAME&quot;，由于Unity 内部会将所有Pass 名称转换为大写字母的表示，所以在使用UsePass的时候必须使用大写形式的名字。 RenderSetup：我们可以对Pass设置渲染状态，除上述状态设置以外，我们还可以使用固定管线的着色器。 Tag：|标签类型|说明|例子||—-|——|—-||LightMode|定义该Pass在Unity渲染流水线中的角色|Tags{“LightMode”=”ForwardBase”}||RequireOptions|用于制定当满足某些条件的时候才渲染该Pass，它的值是一个由空格分割的字符串，目前支持的选项：SoftVegetation|Tags{“RequireOptions”=”SoftVegetation”}| 特殊的Pass： UsePass：使用该指令复用其他UnityShader中的Pass。 GrabPass：负责抓取屏幕并将结果存储在一张纹理之中，以用于后续的Pass 处理。 FallBack如果上面所有的SubShader在这块显卡上都不能运行，那么就用这个最低级的Shader。 123FallBack &quot;name&quot;// 或者FallBack Off 通过一个字符串通知引擎最低级的Shader是哪个，也可以关闭Fallback功能——如果上述的SubShader无法使用，那就不要管它了。 其他语义 拓展编辑界面：CustomEditor 对命令进行分组：CateGory UnityShader的形式ShaderLab语句块：1234567891011121314Shader &quot;Myshader&quot;&#123; Properties&#123; // 所需的各种属性 &#125; SubShader&#123; // 真正意义上的SubShdaer代码会出现在这里 // 表面着色器(Surface Shader) // 顶点/片元着色器(Vertex/Fragment Shader) // 固定函数着色器(Fixed Function Shader) &#125; SubShader&#123; // 与上一个Shader类似 &#125;&#125; 表面着色器当给Unity提供一个表面着色器的时候，它在背后依旧将其转换为对应的顶点/片元着色器。意义在于Unity为我们处理了很多光照细节，使得我们无需再操心这些事情。 12345678910111213141516Shader &quot;Custom/Simple Surface Shader&quot;&#123; SubShader&#123; Tags&#123; &quot;RenderType&quot; = &quot;Opaque&quot; &#125; CGPROGRAM #pragma surface surf Lambert struct Input &#123; float4 color:COLOR; &#125;; void surf (Input IN,inout SurfaceOutput o) &#123; o.Albedo = 1; &#125; ENDCG &#125; Fallback &quot;Diffuse&quot;&#125; 表面着色器被定义在SubShader语义块中的CGPROGRAM与ENDCG之间。之间的代码使用Cg/HLSL语言编写，它嵌套在ShaderLab语言中。 顶点/片元着色器顶点/片元着色器的代码需要定义在CGPROGRAM与ENDCG之间，而着色器是写在Pass语义块内，而非SubShader内，这样做来定义每个Pass需要的Shader代码，灵活性更高，同时控制渲染的实现细节。 1234567891011121314151617181920Shader &quot;Custom/Simple VertexFragment Shader&quot;&#123; SubShader&#123; Pass&#123; CGPROGRAM #pragma vertex vert #pragma fragment frag float4 vert(float4 v:POSITION):SV_POSITION&#123; return mul(UNITY_MATRIX_MVP,v); &#125; fixed4 frag():SV_Target&#123; return fixed4(1.0,0.0,0.0,1.0); &#125; ENDCG &#125; &#125;&#125; 固定函数着色器上面两种UnityShader形式都使用了可编程管线，而对于一些旧的设备不支持可编程管线着色器，此时需要使用固定函数着色器来完成渲染，这些着色器往往只可以完成一些非常简单的效果。 12345678910111213Shader &quot;Tutorial/Basic&quot;&#123; Properties&#123; _Color(&quot;Main Color&quot;,color)=(1.0,5.0,5.1) &#125; SubShader&#123; Pass&#123; Material&#123; Diffuse[_Color] &#125; Lighting On &#125; &#125;&#125; 乐乐女神的一些建议： 除非有明确的需求必须要使用固定函数着色器，否则请使用可编程管线的着色器。 如果想和各种光源打交道，你可能更喜欢表面着色器，但需要小心它在移动平台的性能表现。 如果需要使用的光照数目非常少，使用顶点/片元着色器是一个更好的选择。 如果有很多自定义的渲染效果，请选择顶点/片元着色器。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式笔记（2）-观察者模式]]></title>
    <url>%2F2018%2F04%2F27%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[建立一个一对多的依赖，当一个对象改变状态，依赖它的对象都将收到通知并自动更新。 观察者模式 观察者模式定义了对象之间的一对多依赖，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。 观察者模式提供了一种对象设计，让主题和观察者之间松耦合： 主题只知道观察者实现了Observer接口，不需要知道观察者的具体类是谁。 任何时候我们都可以增加、删除、改变现有的观察者，而不会发生问题。 有新类型的观察者出现时，主题的代码不需要进行修改，而是在新类中实现观察者接口，然后注册为观察者。 我们可以独立的复用主题或观察者。 模式结构： Subject: 目标——接口，声明了注册、删除具体观察者的函数。 ConcreteSubject:具体目标——具体类，实现了Subject接口的函数，并包含具体对数据处理的方法。 Obsever: 观察者——接口，声明了更新数据的函数。 ConcreteSubject: 具体观察者——具体类，实现了Obsever接口自动更新的函数。 类图： 优缺点: 优点： 可以实现表示层与数据逻辑层的分离，并定义了稳定的消息更新机制，抽象了更新接口，使得各种表示层可以作为具体观察者。 在观察者与主题间构建了一种抽象的耦合。 支持“广播通信”。 缺点： 如果观察者的数量太多，通知到所有的观察者将会耗时很长。 如果观察者与主题间存在着循环依赖的话，观察主题将会触发循环调用，可能会引起系统崩溃。 观察者模式没有相应的机制使得观察者得知变化是如何发生的，而仅仅是“发生了”。 适用场景： 一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。 一个对象必须通知其他对象，而并不知道这些对象是谁。 任何涉及到一对一或一对多的对象交互场景。]]></content>
      <categories>
        <category>读书笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Unity】 Cursor学习]]></title>
    <url>%2F2018%2F04%2F11%2FUnity%E7%AC%94%E8%AE%B0%2FUnity-Cursor%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[关于CursorLockMode 光标锁定模式的一个随手记。 CursorLockMode.None 光标行为未修改，第一人称视角下鼠标可以突破窗口。 CursorLockMode.Locked 光标锁定到游戏窗口的中心，与全屏与否无关，同时隐藏光标（这一点在3D相机下成立，在2D相机下貌似不成立，还需要用visible来控制隐藏），无论如何移动光标光标都无法出现，按‘esc’切换到None模式。 CursorLockMode.Confined 光标限制在游戏窗口内，光标不会隐藏，在窗口模式下无法突破窗口，限制在窗口区域内。 Cursor.visible 光标可见性，和人感觉用来实现鼠标隐藏的效果并不好，或许和Confined联合可以有Locked的效果？那为什么不用Locked呢…… 示例代码：https://docs.unity3d.com/ScriptReference/Cursor-lockState.html资料来源：http://wiki.ceeger.com/script/unityengine/enumerations/cursorlockmode/cursorlockmode]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>unity学习</tag>
      </tags>
  </entry>
</search>
