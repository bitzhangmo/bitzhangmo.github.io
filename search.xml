<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C++Primer笔记(第七章)]]></title>
    <url>%2F2022%2F01%2F04%2FC%2B%2BPrimer%E7%AC%94%E8%AE%B0%2FC-Primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%83%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[关键词: 成员函数, 构造函数, 友元, 静态成员 类 : 定义在类内部的函数是隐式的inline函数. 成员函数:成员函数通过一个名为this的额外的隐式参数来访问调用它的那个对象, 当我们调用一个成员函数时, 用请求该函数的对象地址初始化this. 任何对类成员的直接访问都被看作this的隐式引用, this是一个常量指针. const成员函数 : 默认情况下, this的类型是指向类类型非常量版本的常量指针. 即this的类型为T *const, 所以按照初始化原则, 在默认情况下不能把this绑定到一个常量对象上, 因此就不能在常量对象上调用普通的成员函数. 如果想调用常量成员函数, 可以在参数列表后添加一个const, 表示this是一个指向常量的指针 , 也因此常量成员函数对于对象来说是只读的. 常量对象, 以及常量对象的引用或指针都只能调用常量成员函数. 类作用域和成员函数 :编译器分两步处理类 : 首先编译成员的声明, 然后才轮到成员函数体, 因此成员函数体可以随意使用类中的其他成员而无需在意这些成员出现的次序. 在类的外部定义成员函数时, 成员函数的定义必须与声明匹配, 同时包含所属类名. 构造函数：构造函数没有返回类型, 与类的名字相同, 不能被声明成const的. 默认构造函数 如果没有显式的定义构造函数 (只有当类没有声明任何构造函数时), 编译器会隐式的定义一个默认构造函数, 按照如下规则初始化类的数据成员: 如果存在类内的初始值, 用它来初始化成员 否则默认初始化该成员. 在C++11中可以通过在参数列表后面写上= default来要求编译器生成构造函数. 如果一个函数为所有参数都提供了默认实参, 则它实际上也定义了默认构造函数. 成员初始化相关: 如果没有在构造函数的初始值列表中显式的初始化成员, 则该成员将在构造函数体之前执行默认初始化. 对于成员是const或者引用的情况, 必须将其初始化而非先定义再赋值. 构造函数初始值列表只说明用于初始化成员的值, 而不限定初始化的具体执行顺序. 成员的初始化顺序和它们在类定义中的出现顺序一致, 当用某些成员初始化其他成员的时候, 要注意初始化顺序, 不要用未定义的值初始化已经定义的成员. 委托构造函数 简单的说就是构造函数调用其他构造函数. 当一个构造函数委托给另一个构造函数时, 受委托的构造函数的初始值列表和函数体被一次执行, 假如函数体包含代码的话, 将先执行这些代码, 然后控制权才会交还给委托者的函数体. 隐式的类类型转换(转换构造函数) 如果构造函数只接受一个实参, 则它实际上定义了转换为此类类型的隐式转换机制, 但编译器只会执行一步类型转换. 可以通过explicit关键字来屏蔽这个特性, 使得被修饰的构造函数不可用于隐式类型转换, 只能以直接初始化的方式使用. 该关键字只能用来修饰”转换构造函数”, 而且只能在类内声明构造函数时使用, 而在类外部定义时不应重复. 访问控制与封装: 定义在public说明符之后的成员在整个程序内可被访问, public成员定义类的接口 定义在private说明符之后的成员可以被类的成员函数访问, 但是不能被使用该类的代码访问, private部分封装了类的实现细节. class和struct定义类唯一的区别就是默认的访问权限: 在struct中, 定义第一个访问说明符之前的成员是public的, 而在class中, 这些成员是private的. 友元:通过友元使其他类或函数访问类的非公有成员, 在函数声明前加一条friend关键字即可. 友元声明只能出现在类定义的内部, 但是在类内出现的具体位置不限. 友元不是类的成员也不受它所在区域访问级别的约束. 友元的声明仅仅指定了访问的权限, 而非一个通常意义上的函数声明, 如果我们希望类的用户能够调用某个友元函数, 那么我们就必须在友元声明之外再专门对函数进行一次声明. 友元关系不存在传递性, B类被声明成A类的友元, B类的友元C类不能拥有访问A类的特性, 即每个类负责控制自己的友元类或友元函数. 如果一个类想把一组重载函数声明其友元, 它需要对这组函数中的每一个分别声明. 可变数据成员:背景: 我们希望能修改类的某个数据成员, 即使它是const对象的成员.因此一个const成员函数可以改变一个可变成员的值. 可以通过在变量的声明中加入mutable关键字实现这个目的. 从const成员函数返回*this:一个const成员函数如果以引用的形式返回*this, 那么它的返回类型将是常量引用, 这意味着不能将其嵌入到一组动作中的序列中去. 类的声明:类可以通过暂时仅声明类而不定义来进行前向声明, 此时它是个不完全类型. 使用场景: 可以定义指向这种类型的指针或引用, 也可以声明(但是不能定义)以不完全类型作为参数或者返回类型的函数. 名字查找与类的作用域:声明中使用的名字, 包括返回类型或者参数列表中使用的名字, 都必须在使用前确保可见. 对于定义在类内部的成员函数来说(只适用于成员函数), 分两步解析其中名字: 首先, 编译成员的声明 直到类全部可见后才编译函数体 123456789typedef double Money;string bal;class Account &#123;public: Money balance() &#123; return bal; &#125;private: Money bal; &#125;// 该例中, balance函数返回的是类成员而非string对象, 因为"直到类全部可见后才编译函数体, 此时先查找类中是否出现bal, 已经出现则返回" 在类中, 如果成员使用了外层作用域中的某个名字, 而该名字代表一种类型, 则类不能在之后重新定义该名字. 成员函数的匹配方式类似, 都是先从最小的作用域搜索起, 逐步向上扩大范围, 这里就不做赘述了. 当形参名和成员名相同时, 按照上面的规则就是先匹配到形参名, 如果想访问成员可以通过显式使用this指针来强制访问.(但是最好别这么写了……) 聚合类与字面值常量类 聚合类: 所有成员都是public的 没有定义任何构造函数 没有类内初始值 没有基类和virtual函数 字面值常量类: 数据成员都是字面值类型的聚合类或满足下述要求 数据成员都必须是字面值类型 类必须至少含有一个constexpr构造函数 如果一个数据成员含有类内初始值, 则内置类型成员的初始值必须是一条常量表达式; 或者如果成员属于某种类类型, 则初始值必须使用成员自己的constexpr构造函数 类必须使用析构函数的默认定义, 该成员负责销毁类的对象. (没有想象出使用的场景应该是什么) 类的静态成员;在成员的声明前加上关键字static使得其与类关联在一起, 它与对象无关, 对象中不包含与静态数据成员有关的数据, 静态成员对象被所有类对象共享. 静态成员函数也不与任何对象绑定在一起, 不包含this指针, 不能声明成const的, 且不能在static函数体内使用this指针. 可以使用作用域运算符, 类的对象, 引用或指针来访问类的静态成员. 成员函数不用通过作用域运算符就能直接使用静态成员. 一般来说, 我们不能在类的内部初始化静态成员, 必须在类的外部定义和初始化每个静态成员, 12// 定义并初始化一个静态成员double Account::interestRate = initRate(); 可以给字面值常量类型的静态成员提供const整数类型的类内初始值. 静态数据成员可以使不完全类型, 可以是其所属的类类型, 而非静态数据成员则受到限制, 只能声明成它所属的类的指针或引用. 12345678class Bar &#123;public: //...private: static Bar mem1; // 正确, 静态成员可以是不完全类型 Bar *mem2; // 正确, 指针成员可以是不完全类型 Bar mem2; // 错误, 数据成员必须是完全类型&#125; 静态成员还可以作为默认实参.]]></content>
      <categories>
        <category>2022笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++Primer笔记(第四、五、六章)]]></title>
    <url>%2F2021%2F12%2F30%2FC%2B%2BPrimer%E7%AC%94%E8%AE%B0%2FC-Primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%9B%9B%E3%80%81%E4%BA%94%E3%80%81%E5%85%AD%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[关键词: 左值, 右值, 运算符, 强制类型转换, 函数重载, 函数指针等 第四章主要描述了运算符以及相关的优先级; 第五章讲了一些基本的语句以及流程控制符; 第六章讲了函数相关的内容, 重点在于参数, 重载函数以及函数指针等. 第四章左值和右值 :当一个对象被用作右值的时候, 用的是对象的值(内容); 当对象被用作左值的时候, 用的是对象的身份(内存中的位置). 在需要右值的地方可以用左值来代替, 但不能把右值当做左值来使用, 当一个左值被用作右值时, 实际使用的是它的值. 复合运算符 :使用复合运算符只求值一次 , 使用普通的运算符则求值两次 . (区别除了对程序性能有些许影响外几乎可以忽略不计) 12int a += 1;int a = a + 1; // 基本等价 递增和递减运算符 :此前只知道这里的区别在于先递增(减)还是后递增(减) , 还有一个求值结果的细节. 1234int i = 0, j;j = ++i; // j = 1, i = 1; 前置版本得到递增后的值(即改变后的对象作为求值结果)j = i++; // j = 1, i = 2; 后置版本得到递增之前的值(即运算对象改变之前的副本作为求值结果)/* 前置版本把对象本身作为左值返回, 后置版本则将对象原始值的副本作为右值返回 */ 后置递增运算符的优先级高于解引用运算符: 123auto pbeg = v.begin();while(pbeg != v.end() &amp;&amp; *pbeg &gt;=0) cout &lt;&lt; *pbeg++ &lt;&lt; endl; // 等价于*(pbeg++); sizeof运算符 :sizeof运算符返回一条表达式或一个类型名字所占的字节数 , 所得的值类型为size_t. sizeof并不实际计算其运算对象的值.对数组执行sizeof运算得到整个数组所占空间的大小, 等价于对数组中所有的元素各执行一次sizeof运算并将所得结果求和. 强制类型转换 : static_cast : 任何具有明确定义的类型转换, 只要不包含底层const, 都可以使用static_cast. const_cast : const_cast只能改变运算对象的底层const (移除or增加对象的const性质). 如果对象本身不是一个常量, 使用强制类型转换获得写权限是合法的行为, 如果对象是一个常量, 再使用const_cast执行写操作就会产生未定义的后果. reinterpret_cast : 通常为运算对象的位模式提供较低层次上的重新解释.(想像不出对应的应用场景) 第五章switch语句 : 为了安全起见, 最好在最后一个标签后面加上break, 这样新增case就不需要加了. 如果在某处一个带有初值的变量位于作用域之外, 在另一处该变量位于作用域之内, 则从前一处跳转到后一处的行为是非法行为. 范围for语句 :如果需要对序列中的元素进行写操作, 循环变量必须声明成引用类型. 第六章 : 函数局部静态对象 :可以将局部变量定义成static类型从而获得局部静态对象, 在程序的执行路径第一次经过对象定义语句时初始化, 并且直到程序终止才被销毁 ; 在此期间即使对象所在的函数结束执行也不会对它有影响. 12345678910111213size_t count_calls()&#123; static size_t ctr = 0; // 调用结束后, 这个值仍然有效 return ++ctr;&#125;int main()&#123; for(size_t i = 0; i != 10; ++i) &#123; cout &lt;&lt; count_calls() &lt;&lt; endl; &#125; return 0;&#125; 参数传递 : 拷贝大的类类型对象或者容器对象比较低效, 有的类烈性不支持拷贝操作, 出于这两种原因, 函数只能通过引用形参访问该类型的对象. 当函数无需修改引用形参的值时, 最好使用常量引用. 通过引用形参, 可以突破函数一次只能返回一个值的限制 (C#里可以使用out关键字) const形参和实参 :当用实参初始化形参时会忽略掉顶层const, 可以传递给它常量对象与非常量对象. 这个初始化方式和变量的初始化方式相同. 1void fcn(const int i) &#123;/* fcn能够读取i, 但是不能向i写值 */&#125; 数组形参 :因为不能拷贝数组, 所以我们无法以值传递的方式使用数组参数. 当为函数传递一个数组时, 实际上传递的是指向数组首元素的指针. 123void print(const int*);void print(const int[]);void print(const int[10]); // 三种写法是等价的,这里的10仅仅是希望的维度,实际不一定 数组引用形参 : 123f(int &amp;arr[10]) // 第三章提过: 这是引用的数组, 但不存在引用的数组f(int (&amp;arr)[10]) // 正确, arr是具有10个整型的整形数组的引用f(int (&amp;arr)[]) // 错误:无法将参数 1 从“int [10]”转换为“int (&amp;)[]” 传递多维数组: 12void print(int (*matrix)[10], int rowSize) &#123;&#125;void print(int (*matrix)[][10], int rowSize) &#123;&#125; // 两种等价, 注意第二维开始的维度都是数组类型的一部分, 不可缺少 含有可变形参的函数 : initializer_list形参 : 如果函数的实参数量未知但是全部实参的类型都相同, 我们可以使用initializer_list类型的形参. initializer_list是一种标准库类型, 用于表示某种特定类型的值的数组. 与vector不一样的是, initializer_list对象中的元素永远是常量值, 我们无法改变其中元素的值. 12345678910111213141516void error_msg(initializer_list&lt;string&gt; il)&#123; for(auto beg = il.begin(); beg != il.end(); ++beg) cout &lt;&lt; *beg &lt;&lt; " "; cout &lt;&lt; endl;&#125;void error_msg3(const vector&lt;string&gt; il)&#123; for(auto beg = il.begin(); beg != il.end(); ++beg) cout &lt;&lt; *beg &lt;&lt; " "; cout &lt;&lt; endl;&#125;// 两个函数输出相同error_msg(&#123;"moss1", "moss2", "moss3"&#125;);error_msg3(&#123;"moss1", "moss2", "moss3"&#125;); 为什么不能用const vector&lt;T&gt;? 这个问题在网上搜了下, 发现8年前就有人问过了 : Why use initializer_list instead of vector in parameters? 看了下里面的回答, 大概是说vector不支持列表初始化? 不过上面的代码是可以正常运行不报错的.同样的问题在2015年也有人问过 :Initializer list vs. vector , 此时的最高赞回答大意为initializer_list的实现更加高效, 而vector由于需要动态分配内存导致此处开销可能增大. 具体实现逻辑以及根据笔者暂时没有能力考究, 欢迎读者在本文的评论区附上相关讨论.另附拓展阅读 : The cost of std::initializer_list 省略符形参 :省略符形参是为了便于C++程序访问某些特殊的C代码而设置的, 这些代码使用了名为varargs的C标准库功能(详见C编译器文档).省略符形参应该仅仅用于C和C++通用的类型, 应当特别注意的是: 大多数类型的对象在传递给省略符形参时都无法正确拷贝, 省略符形参只能出现在形参列表的最后一个位置. 12void foo(parm_list, ...);void foo(...); 函数的返回值 :返回一个值的方式和初始化一个变量或者形参的方式完全一样: 返回的值用于初始化调用点的一个临时量, 该临时量就是函数调用的结果. 不要返回局部对象的引用或指针, 因为函数终止之后局部变量的引用将不再指向有效的内存区域. 返回数组指针 :因为数组不能被拷贝, 所以函数不能返回数组, 但可以返回数组的指针或引用, 可以通过以下几种方法进行定义: 类型别名: 1234typedef int arrT[10]; // 类型别名: 含有10个整数的数组using arrT = int[10]; // 等价于第一行arrT* func(int i); // func返回一个指向含有10个整数的数组的指针 直接声明: 1int (*func(int i))[10]; // 最外层的括号必须存在, 不然将返回指针的数组 尾置返回类型: 1auto func(int i)-&gt; int(*)[10]; // 跟在形参列表后, 并以一个-&gt;开头 使用decltype: 123456int odd[] =&#123;1,3,5,7,9&#125;;int even[] = &#123;2,4,6,8,10&#125;;decltype(odd) *arrPtr(int i)&#123; return (i % 2) ? &amp;odd : &amp;even; // 返回一个指向数组的指针&#125; 函数重载 :同一作用域内的几个函数名字相同但形参列表不同. 12345678910// top-level const 无法用来区分形参Record lookup(Phone);Record lookup(const Phone); // 重复声明了// low-level const 可以用来区分形参Record lookup(Account&amp;); // 作用于Account的引用Record lookup(const Account&amp;); // 作用于常量引用Record lookup(Account*); // 作用于Account的指针Record lookup(const Account*); // 作用域指向常量的指针 const_cast和重载 : 123456789101112// 参数和返回类型都是const string, 传入非const时, 返回的依然为const stringconst string &amp;shorterString(const string &amp;s1, const string &amp;s2)&#123; return s1.size() &lt;= s2.size() ? s1 : s2;&#125;// 当实参不是常量时, 得到的结果依然是一个普通的引用string &amp;shorterString(string &amp;s1, string&amp; s2)&#123; auto &amp;r = shorterString(const_cast&lt;const string&amp;&gt;(s1), const_cast&lt;const string&amp;&gt;(s2)); return const_cast&lt;string&amp;&gt;(r);&#125; 特殊用途语言特性: 默认实参 : 1234string screen(int ht = 24, int wid = 80. char backgrnd = ' ');// 为每个形参提供了默认实参, 一旦某个形参被赋予了默认值, 它后面的所有形参都必须有默认值// 在给定的作用域中一个形参只能被赋予一次默认实参// 局部变量不能作为默认实参 内联函数 : 背景: 调用函数一般比求等价表达式的值要慢一些 , 将函数指定为内联函数可避免函数调用的开销. 在函数的返回类型前面加上关键字inline, 将其声明为内联函数, 适用于规模较小, 流程直接, 频繁调用的函数. (感觉类似#define的功能) 12345678inline const string&amp; shorterString(const string &amp;s1, const string &amp;s2)&#123; return si.size() &lt;= s2.size() ? s1 : s2;&#125;cout &lt;&lt; shorterString(s1, s2) &lt;&lt; endl;// 在编译过程中展开如下(原书此处为&lt;号, 没道理吧......)cout &lt;&lt; s1.size() &lt;= s2.size() &gt; s1 : s2; constexpr函数 : 能用于常量表达式的函数, 函数的返回值类型以及所有形参的类型都得是字面值类型, 而且函数体中必须有且仅有一条return语句(注: 在C++14标准中这条被删除了, 参考来源:constexpr specifier). 当constexpr函数的实参是常量表达式时, 返回值也是常量表达式, 反之不然. 书中这里特意强调了 : constexpr函数不一定返回常量表达式. 在不需要返回常量表达式的上下文, constexpr函数可以不返回常量表达式, 编译器不会检查函数的结果是否是一个常量表达式; 但在需要返回常量表达式的上下文中, 如果结果不是常量表达式, 编译器会报错. 123456789#include &lt;iostream&gt;constexpr size_t scale(size_t cnt) &#123; return 32 * cnt; &#125; // scale是一个constexpr函数int main()&#123; int num = 10; // num非常量表达式 constexpr int a = scale(10); // 正确,实参是一个字面值常量 //constexpr int b = scale(num); // 错误, 实参非常量表达式, 返回值也不是 int c = scale(num); // 正确, 上下文未要求返回常量表达式, 可以不返回&#125; 相关讨论 : 关于constexpr函数的一个问题 A constexpr function is not required to return a constant expression? 调试帮助 : assert预处理宏 : 1assert(expr); // 如果表达式为假, assert输出信息并终止程序的执行; 如果为真则什么也不做 感觉应用的场景不多, 是debug模式下的一些错误保护函数, 相比自己添加保护可能就就是NDEBUG可以关闭它比较方便吧…… NDEBUG预处理变量 : assert的行为依赖于一个名为NDEBUG的预处理变量的状态, 如果定义了NDEBUG, 则assert什么也不做, 默认状态下没有定义NDEBUG, 此时assert将执行运行时检查. 函数匹配 :对重载函数进行匹配 : 候选函数 : 与被调用的函数同名; 其声明在调用点可见 可行函数: 形参数量和提供的实参相等; 实参类型与对应的形参类型相同, 或者可以转换成形参的类型 最佳匹配: 实参类型与形参类型越接近, 匹配的越好 多个形参时, 如果有且只有一个函数满足以下条件: 该函数每个实参的匹配都不劣于其他可行函数需要的匹配 至少有一个实参的匹配优于其他可行函数提供的匹配 如果没有函数满足, 编译器将报错并返回二义性调用的信息. 函数指针 :指针指向函数, 函数的类型由它的返回类型和形参类型共同决定. (我以为这个集合叫函数签名, 但并不是, 函数签名的定义要比这个范围广的多) 1234bool lengthCompare(const string &amp;, const string &amp;);bool (*pf)(const string &amp;, const string &amp;); // 未初始化// 括号必不可少, 少了括号将是一个返回bool指针的函数 当把函数名作为一个值使用时, 该函数自动地转换成指针. 12pf = lengthCompare;pf = &amp;lengthCompare; // 取地址符是可选的 可以直接调用指向函数的指针调用该函数, 无需解引用指针. 12bool b1 = pf("hello", "bye");bool b2 = (*pf)("hello", "bye"); // 解引用也是可选的 在指向不同函数类型的指针间不存在转换规则. 指针类型必须与重载函数中的某一个精确匹配. 将decltype作用于某个函数是, 它返回函数类型而非指针类型 函数指针形参 :形参可以是指向函数的指针. 直接使用函数指针类型显得冗长而繁琐, typedef和decltype可以简化这个步骤. 1234567891011121314bool lengthCompare(const string&amp;, const string&amp;);// 函数类型typedef bool Func(const string&amp;, const string&amp;);typedef decltype(lengthCompare) Func2;// 指向函数的指针typedef bool (*FuncP)(const string&amp;, const string&amp;);typedef decltype(lengthCompare) *FuncP2;// 等价void useBigger(const string&amp;, const string&amp;, Func); // 编译器自动将Func表示的函数类型转换为指针void useBigger(const string&amp;, const string&amp;, FuncP2);// 在Clion中验证该种写法也未报错void useBigger(const string&amp;, const string&amp;, Func2); // decltype的结果是函数类型, 在结果前加上*才是指针 返回指向函数的指针我的建议是用类型别名, 直接写看着太乱了. 12345using PF = int(*)(int*, int);PF f1(int); // 返回指向函数的指针int (*f1(int))(int*, int); // 等价auto f1(int)-&gt;int(*)(int*, int); // 尾置返回类型, 等价]]></content>
      <categories>
        <category>2022笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++Primer笔记(第三章)]]></title>
    <url>%2F2021%2F12%2F30%2FC%2B%2BPrimer%E7%AC%94%E8%AE%B0%2FC-Primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%89%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[关键词 : string, vector, 迭代器, 数组 第三章关于string类型 : 直接初始化和拷贝初始化 : 1234/* 我理解使用的场景就是初始化需要重复的时候用直接初始化 */string s5 = "hiya";string s6("hiya"); // 直接初始化string s7(10, 'c'); // 直接初始化,s7 = "cccccccccc" 读取操作时, string对象会自动忽略掉开头的空白(空格符, 换行符, 制表符等) , 并从第一个真正的字符开始读起 , 直到遇见下一处空白为止. string类型内置的size函数返回string对象中字符的个数 , 但是其类型并不是int或者unsigned, 而是string::size_type , 作为标准库类型与机器无关 , 但可以确定的是size函数返回的是一个无符号整数 , 所以尽量避免在size()的表达式中调用int类型. 1if(s.size() &lt; -1) // 通常为true, -1会被自动转换成一个较大的无符号值 标准库允许把字符字面值和字符串字面值转换为string对象, 但每个加法运算符的两侧必须确保至少有一个string对象. “ 因为某些历史原因 , 也为了与C兼容 “, C++中的字符串字面值并不是标准库类型string的对象, 即字符串字面值和string是不同的类型. cctype头文件中定义了一组标准库函数改变某个字符的特性. 使用范围for语句改变字符串中的字符 , 必须把循环变量定义成引用类型 : 12345678910111213string str1 = "moss";for(auto c: str1)&#123; c = toupper(c);&#125; cout &lt;&lt; "str1 " + str1 &lt;&lt; endl; // 输出str1 moss for(auto &amp;c: str1)&#123; c = toupper(c);&#125;cout &lt;&lt; "str2 " + str1 &lt;&lt; endl; // 输出str2 MOSS 下标运算符接受的输入参数是string::size_type类型的值 , 返回值是该位置上字符的引用. 关于vector : 模板本身不是类或函数 , 相反可以将模板看做为编译器生成类或函数编写的一份说明 . 编译器根据模板创建类或函数的过程称为实例化. vector能容纳绝大多数类型的对象作为其元素 , 但是因为引用不是对象 , 所以不存在包含引用的vector. 早期对于嵌套的vector需要在右尖括号和元素类型间加个空格 : 12vector&lt;vector&lt;int&gt; &gt; // oldvector&lt;vector&lt;int&gt;&gt; // now 初始化的三个要点: 使用拷贝初始化时 , 只能提供一个初始值 . 如果提供的是一个类内初始值 , 则只能使用拷贝初始化或者使用花括号的形式初始化 (还有什么方式? 直接初始化? ). 如果提供的是初始元素值的列表 , 则只能把初始值都放在花括号里进行列表初始化 , 而不是圆括号里. 123456vector&lt;string&gt; articles = &#123;"a", "an", "the"&#125;; // 列表初始化vector&lt;int&gt; ivec(10); // 值初始化,长度为10,每个都是0vector&lt;string&gt; svec(10); // 值初始化,长度为10,每个都是空字符串/* 如果vector对象中元素的类型不支持默认初始化, 则必须提供初始的元素值 *//* 如果只提供了元素的数量而没有设定初始值, 则只能使用直接初始化 *//* 总结: 圆括号()用来构造vector对象, 花括号&#123;&#125;用于列表初始化vector对象*/ 范围for语句内不应改变其所遍历序列的大小( 这点lua与其相同 ). vector对象(以及string对象)的下标运算符可用于访问已存在的元素 , 而不能用于添加元素 .(仅仅是添加吗 ? 删除可不可以?) 关于迭代器 : 所有标准库容器都可以使用迭代器 , 但是其中只有少数几种才同时支持下标运算符 . end成员返回的迭代器称为尾后迭代器 , 指向容器尾元素的下一位置 , 当容器为空时 , begin和end指向的是同一个迭代器 . 迭代器类型 : 拥有迭代器类型的标准库类型使用iterator和const_iterator来表示迭代器的类型 . 顾名思义, const_iterator只能读它所指元素值. 当容器中对象是一个常量 , 则只能使用const_iterator , 同样返回值也依据这个规则 , 可以使用cbegin()和cend()来强制获得const_iterator. 结合解引用和成员访问操作 : 解引用迭代器可获得迭代器所指的对象, 对于类对象可以进一步访问它的成员 : 1234vector&lt;string&gt; vecs; // 定义vecsvector&lt;string&gt;::iterator it = vecs.begin(); // 定义vecs的迭代器(*it).empty(); // 解引用it, 并调用对象的empty成员, 必须加圆括号(应该是运算符优先级问题)it-&gt;empty(); // 与上文等效 箭头运算符把解引用和成员访问两个操作结合到了一起. 已知的一个限制是不能在范围for循环中向vector对象添加元素 , 另外一个限制是任何一种可能改变vector对象容量的操作 , 比如push_back, 都会使该vector对象的迭代器失效(待测试删除) 关于数组 : 数组长度固定 , 在编译的时候维度应该是已知的 , 所以定义的时候维度应是一个常量表达式. 字符串字面值末尾的空字符也会被拷贝到字符数组中. 不能将数组的内容拷贝给其他数组作为初始值, 也不能用数组给其他数组赋值. (某些编译器可能支持但最好不要依赖) 复杂的数组声明 : 123456/* 要想理解数组声明的含义, 最好的办法是从数组的名字开始按照由内向外的顺序阅读 */int *ptrs[10]; // 含有10个整型指针的数组int &amp;refs[10] = ; // 不存在引用的数组int (*Parray)[10] = &amp;arr; // 指针, 指向一个长度为10的整型数组int (&amp;arrRef)[10] = arr; // 引用, 绑定于一个长度为10的整型数组int *(&amp;arry)[10] = ptrs; // 引用, 绑定于一个含有10个指针的数组 在大多数表达式中 , 使用数组类型的对象其实是使用一个指向该数组首元素的指针. 1234int ia = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;auto ia2(ia); // ia2是一个整型指针, 指向ia的第一个元素/* decltype关键字不会发生从数组对象到指针的转换 */decltype(ia) ia3 = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;; // ia3是一个长度为10的整形数组 标准库函数begin和end 由于数组不是类 , 所以没有对应的成员函数 , 不过可以作为参数传入begin和end中返回对应位置的指针 . 两个指针相减的结果类型为ptrdiff_t, 是一种带符号类型 . 参与运算的两个指针必须是指向同一个数组中的元素. 对数组执行下标运算其实是对指向数组元素的指针执行下标运算 : 12int *p = &amp;ia[2];int k = p[-2]; // p[-2] = ia[0] 多维数组 : 数组的数组 要使用范围for语句处理多维数组 , 除了最内层的循环外 , 其他所有循环的控制边浪都应该是引用类型. (否则控制变量将转换为指针, 遍历指针将非法) 12for(auto row : ia) for(auto col: row) // 将无法通过编译 string对象与C风格字符串 允许使用以空字符结束的字符数组来初始化string对象或为string对象赋值 以空字符结束的字符数组可以参与string对象的加法运算 ; 在string对象的复合赋值运算中允许使用以空字符结束的字符数组作为右侧的运算对象 规则反过来则不成立 123char *str = s; // 错误, 不能用string对象初始化char*const char *str = s.c_str(); // 正确/* 无法保证c_str返回的数组一直有效, 所以如果想一直使用最好copy一份自己维护 */ 可以使用数组初始化vector对象: 1vector&lt;int&gt; ivec(begin(ia), end(ia)); // 同理, 可以计算指针使用部分ia内容初始化ivec]]></content>
      <categories>
        <category>2022笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++Primer笔记(第二章)]]></title>
    <url>%2F2021%2F12%2F29%2FC%2B%2BPrimer%E7%AC%94%E8%AE%B0%2FC-Primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[关键词 : 对象 , 变量 , 引用 , 指针 , const , auto , decltype 第二章 :有关对象 :对象是指一块能存储数据并具有某种类型的内存空间 , 当对象创建时获得了一个特定的值 , 这个行为被称作初始化 . 初始化与赋值的区别在于赋值是把对象的当前值擦除 , 而以一个新值来替代.(“擦除”和”替代”) 有关变量 :声明 : 规定了变量的类型和名字 定义 : 任何包含了显式初始化的声明即成为定义(申请储存空间并赋值) 如果想声明一个变量而非定义 , 就在变量名前添加关键字extern, 而且不要显式的初始化变量 . 在函数体内部 , 如果试图初始化一个extern关键字标记的变量将引发错误. 变量能且只能被定义一次 , 但是可以被多次声明.(怎么理解?) 变量的定义必须出现在且只能出现在一个文件中 , 而其他用到该变量的文件必须对其进行声明 , 却绝对不能重复定义. 有关作用域 :::称为作用域操作符 , 当左侧为空的时候 , 向全局作用域请求获得操作符右侧名字的变量. 有关引用和指针 :引用和指针应该算是第二章里比较重点 , 同时也比较绕的内容 , 特将内容梳理如下以备查阅与理解: 引用 : 引用是为已经存在的对象起的另外一个名字. 引用必须被初始化 : 在定义引用的时候 , 程序就把引用和它的初始值绑定在了一起 , 因为无法重新绑定到其他对象 , 所以引用必须被初始化 . 因为引用本身不是一个对象(可寻址的空间) , 所以无法定义引用的引用. 引用只能绑定在对象上 , 而不能绑定在字面值或者某个表达式的计算结果上.(原因 : 首先字面值本身不是一个对象 , 所以不能绑定 , 表达式的计算结果应该是一个临时变量 , 也不是一个对象所以无法绑定 ? 怎么理解 ?) 指针 : 指针本身就是一个对象 , 允许对指针进行赋值以及拷贝 , 在指针的生命周期里可以先后指向不同的对象 . 指针无需在定义时赋初值 , 如果定义时未初始化则有一个不确定的值. 同样(与引用类似) , 一个指向常量的指针可以指向一个非常量对象. 引用不是对象 , 没有实际地址 , 所以无法定义指向引用的指针. 指针的值应属于以下四种状态之一 : 指向一个对象 指向紧邻对象所占空间的下一个位置 空指针 , 没有指向任何对象 无效指针 , 除了上述情况的其他值 指针伴随着一对操作符 : 取地址符&amp;和解引用符* , 前者获得对应对象的地址 , 后者获得地址所指的对象(解引用操作仅适用于那些指向了有效地址的指针). 尽量初始化所有的指针 , 并且在可能的情况下 , 尽量等定义了对象再定义指向它的指针 , 如果不知道应该指向何处 , 可以把它初始化为nullptr或者0 . 指针可以使用==进行比较 , 当指向的地址值相同时为true. void 是一种特殊的指针类型 , 可以用于存放任意对象的地址 . 可以用来拿它和别的指针比较 , 作为函数的输入和输出 , 或者赋给另外一个void指针 . 关于复合类型的声明 : 最简单的办法就是从右向左阅读r的定义，离变量名最近的符号对变量的类型有最直接的影响 . 关于const限定符 : const对象必须初始化. 只能在const类型的对象上执行不改变其内容的操作 , 默认情况下 , const变量仅在文件中有效 , 当多个文件中出现了同名的const变量时 , 其实等同于在不同文件中定义了独立的变量. 如果想在多个文件之间共享const对象 , 必须在变量的定义前添加extern关键字. 可以把引用绑定到const对象上 , 称之为对常量的引用 , 不能被用作修改它所绑定的对象. 引用的使用场景(怎么理解?) : 别名—&gt;减少拷贝开销 参数传递—&gt;减少拷贝开销 , 避免空指针 函数返回值—&gt; 123456789double dval = 3.14;const int &amp;ri = dval;/* 编译器做法 */const int temp = dval; // 让double类型生成一个临时的int变量const int &amp;ri = temp; // 让ri绑定这个临时量/* 因为不可以通过被const修饰符限定的常量引用修改被引用的对象,所以该引用可以绑定在临时量上,不会对临时量产生修改的操作; 如果是非常量引用,则可能通过该引用修改对应的临时量,但是代码的目的是通过ri来修改试图绑定的dval,却绑定到了临时量上,与预期不符,所以非法 */int &amp;ri = dval; // 非法 常量引用仅仅对引用可参与的操作进行了限制 , 即不能通过该引用改变其引用的对象 , 对于对象本身是否是常量未做限定. 指针和const 指向常量的指针(pointer to const)不能用于改变其所指对象的值 , 存放常量对象的地址 , 只能使用指向常量的指针. 1234const double pi = 3.14;double *ptr = &amp;pi; // 非法const double *cptr = &amp;pi; // 合法*cptr = 43; // 非法, 不能给*cptr赋值. 同样指向常量的指针也对指向的对象本身是否是常量未做限定 , 仅仅是不能通过该指针改变所指对象的值. 常量指针(const pointer) , 指针本身是常量 , 根据const的规则 , 必须初始化 , 初始化完成后其值不可改变 , 不可变的是指针本身而不是指向的值 , 是否可以通过该指针改变其指向的值取决于它指向的值是否是常量. “是否可以通过该指针改变其指向的值, 取决于它指向的值是否是常量” , 这句话并不意味着常量指针可以指向常量对象, 详见例子: 12345const int a = 1;int *const p = &amp;a; // 错误, 常量指针指向了常量对象const int *p1 = &amp;a; // 正确, 指向常量的指针指向了常量对象int *p2 = &amp;a; // 错误, 普通指针指向了常量对象const int *const p3 = &amp;a; // 正确, 指向常量的常量指针指向了常量对象, 此处对常量对象的引用主要取决于指向常量的指针, 对于指针本身是否是常量并不做要求 顶层const与底层const顶层const(top-level const) : 表示指针本身是个常量 底层const(low-level const) : 表示指针所指的对象是个常量 123456789101112131415int i = 0;int *const p1 = &amp;i; // 指向int的常量指针,top-levelconst int ci = 42; // 常量int, top-levelconst int *p2 = &amp;ci; // 指向常量int的指针, low-levelconst int *const p3 = p2;// 指向常量int的常量指针,第一个为low-level,第二个为top-levelconst int &amp;r = ci; // 用于声明引用的const都是底层const(怎么理解? 不能通过引用改变绑定的变量, 所以是底层const? 换句话说, 常量引用认为自己绑定的变量是个常量?)/* 当执行对象的拷贝操作时, 拷入和拷出的对象必须有相同的底层const资格, 或者两个对象的数据类型可以相互转换, 非常量可以转换成常量, 反之不行*/int *p = p3; // 错误: p3包含了底层const, 如果正确则可能通过p改变p3指向的值, 与const冲突p2 = p3; // 正确: p2和p3都是底层constp2 = &amp;i; // 正确: int *可以转换成const int *int &amp;r = ci; // 错误: int&amp;不能绑定到const int上const int &amp;r2 = i; // 正确: const int&amp; 可以绑定到int上/* 可以通过"试图改变某对象"的思路来判断是否正确, 不过这些内容应该编译器都会提示吧...... */ constexpr和常量表达式 :值不会改变并且在编译过程中就能得到计算结果的表达式 . 12345int staff_size = 27; // 不是常量表达式, staff_size可以改变const int sz = get_size(); // 不是常量表达式, sz的具体值直到运行时才能获得const int *p = nullptr; // 指向整形常量的指针constexpr int *q = nullptr; // 指向整数的常量指针 将会提到 , 函数体内定义的变量一般来说并非存放在固定地址中 , 因此constexpr指针不能指向这样的变量, 定义于所有函数体之外的对象地址固定不变, 能用来初始化constexpr指针 , 允许函数定义一类有效范围超出函数本身的变量, 这类变量和定义在函数体之外的变量一样有固定地址, 因此, constexpr引用能绑定到这样的变量上, constexpr指针也能指向这样的变量. (后面提到再看吧……) 关于类型别名 :可以使用typedef和using两种关键字进行定义. 12345678typedef char* pstring;const pstring cstr = 0; // 指向char的常量指针const pstring *ps; // 指向一个指向char的常量指针的指针const char* cstr = 0; // 指向const char的指针const char **ptr; // 指向一个const char指针的指针/* const是对给定类型的修饰, 所以const pstring为指向char的常量指针, 而非指向常量char的指针*//* 不能通过替换类型别名来理解 */ 关于auto类型说明符 :auto定义的变量必须有初始值 . 当引用被用作初始值时 , 真正参与初始化的其实是引用对象的值 , 编译器以引用对象的类型作为auto的类型. auto一般会忽略掉顶层const , 同时底层const则会保留下来 : 1234567int i = 0, &amp;r = i;auto a = r;const int ci = i, &amp;cr = ci;auto b = ci; // b推断为一个int(ci作为top-level被忽略)auto c = cr; // c推断为一个int(cr是ci的引用,ci本身是一个top-level) ??? cr不是一个底层const吗(理解: cr是ci的引用, c是ci的copy, 目的不是通过c去改变ci, 所以c推断为一个int)const auto f = ci; // f为const int, 需要显式指定const来推断出top-level const 符号&amp;和*只从属于某个声明符 , 而非基本数据类型的一部分 , 因此初始值必须是同一种类型. decltype类型指示符: 类似于lua中的type()用来推断类型, 它的作用是选择并返回操作数的数据类型 , 编译器分析表达式并得到它的类型, 却不实际计算表达式的值. 1decltype(f()) sum = x; // sun类型为函数f的返回类型 如果decltype使用的表达式是一个变量, 则decltype返回该变量的类型 (包括top-level const和引用在内) ; 如果decltype使用的表达式不是一个变量 , 则decltype返回表达式结果对应的类型. decltype((variable))的结果永远是引用 , 而decltype(variable)结果只有当variable本身是一个引用时才是引用. 1decltype((i)) d; // d是int&amp;, 必须初始化 有关头文件 :头文件通常只包含那些只能被定义一次的实体, 如类 , const和constexpr变量. 1234#define // 把一个名字设定成预处理变量#ifdef // 当且仅当变量已定义时为真#ifndef // 当且仅当变量未定义时为真#endif // 结束符]]></content>
      <categories>
        <category>2022笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记]]></title>
    <url>%2F2021%2F07%2F06%2FLua%2F%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0Lua-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8C%E6%A0%87%E5%87%86%E5%BA%93-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[本篇是《自己动手实现Lua：虚拟机、编译器和标准库》的读书笔记，持续更新中。 第一章：第一章的内容本质上就是配环境，值得一提的一点是，如果下载了最新版的Go，可能会和书上的内容有些出入，所以为了避免不必要的麻烦，我还是按照书上的描述下载了Go(v1.10.2)。 第二章：二进制chunk Lua脚本并不是直接被Lua解释器解释执行，而是先由Lua编译器编译成字节码，然后再交给Lua虚拟机去执行。 Lua解释器会在内部编译lua脚本（此处描述存疑），预编译可以加快脚本加载的速度，并可以在一定程度上保护源代码。 Lua本身提供了命令行工具luac来编译lua源代码，以函数为单位进行编译，每个函数都会被编译成名为Prototype的结构，包含内容有下： 函数基本信息 字节码 常量表 Upvalue表 调试信息 子函数原型列表 Lua编译器会为我们的脚本添加一个主函数，把整个程序都放进这个函数里，然后以其为起点进行编译。这个函数既是编译的起点，也是虚拟机解释执行程序的入口。对于一行代码print(&quot;Hello world!&quot;)，使用luac反编译编译出来的.luac文件可以看到输出： 【图】 二进制chunk格式： 二进制chunk属于lua虚拟机内部实现细节，并没有标准化以及相关的说明文档。 二进制chunk没有考虑跨平台需求：编译lua脚本时，会按照本机的大小端方式生成二进制chunk文件，如果加载的文件大小端方式与本机不匹配就拒绝加载。 加载二进制chunk文件时，会检测被加载文件的版本号，如果和当前lua版本不匹配，就拒绝加载。 总体结构：12345type binaryChunk struct &#123; header // 头部 sizeUpvalues byte // 主函数upvalue数量 mainFunc *Prototype // 主函数原型&#125; 头部： 12345678910111213type header struct &#123; signature [4]byte // 魔数，用来标示文件开头(用来快速识别文件) version byte // lua版本号 校验用 format byte // 格式号 校验用 luacData [6]byte // LUAC_DATA 校验用 cintSize byte // 指令宽度 cint 校验用 sizetSize byte // 指令宽度 size_t 校验用 instructionSize byte // 指令宽度 Lua虚拟机指令 校验用 luaIntegerSize byte // 指令宽度 Lua整数 校验用 luaNumberSize byte // 指令宽度 Lua浮点数 校验用 luacInt int64 // Lua整数值(用来检查大小端方式) luacNum float64 // Lua浮点数(用来检查浮点数格式)&#125; 【图】 函数原型： 123456789101112131415type Prototype struct &#123; Source string // 源文件名(仅在主函数中有值，避免重复) LineDefined uint32 // 起止行号(对应函数的起止行号) LastLineDefined uint32 NumParams byte // 固定参数个数 IsVararg byte // 是否有变长参数，0否1是 MaxStackSize byte // 寄存器数量:函数执行期间至少用到的 Code []uint32 // 指令表(每条指令4个字节) Constants []interface&#123;&#125; // 常量表,存放Lua代码中出现的字面量 Upvalues []Upvalue // Upvalue表(第十章介绍，待补，不过我估计是把闭包用到的值的拷贝) Protos []*Prototype // 子函数原型表(递归) LineInfo []uint32 // 行号表(每条指令对应源代码中的行号) LocVars []LocVar // 局部变量表(结构：变量名，起止行号) UpvalueNames []string // Upvalue名列表（与Upvalues一一对应）&#125; 第二章中后续的部分都是用Go实现一个简单的编译器的细节，和Lua实现细节关系不大，故在此不做赘述。 第三章：指令集虚拟机根据实现方式大致可以分为两类： 基于栈(Stack Based)：Java虚拟机、.NET CLR、Python虚拟机、Ruby YARV等 使用PUSH类指令向栈顶推入值，其他指令是对栈顶进行操作，指令集相对较大，但指令长度较短。 基于寄存器(Register Based)：Lua虚拟机（5.0版之后） 可以直接对寄存器进行寻址、指令集相对较小，但需要把寄存器地址编码到指令里，所以指令的平均长度较长。 指令长度是否固定，可以分为定长和变长两种指令集：Lua虚拟机是定长指令集，6bit为操作码，其余26bit为操作数。 编码模式： Lua虚拟机是定长指令集，6bit为操作码，其余26bit为操作数。 Lua虚拟机指令可以分为四类：iABC、iABx、iAsBx、iAx 指令与操作数的关系如图所示： 【图】 只有iAsBx模式下的sBx操作数会被解释成有符号整数，其他情况下操作数均被解释为无符号整数。 本章剩余部分完善了上个部分实现的反编译器。 第四章：Lua API Lua核心是以库的形式实现的，其他应用程序只需要链接Lua库就可以使用Lua提供的API。 Lua栈 Lua State内部封装的最为基础的一个状态就是虚拟栈，是宿主语言和Lua进行沟通的桥梁。 栈索引： Lua API中，栈索引是从1开始的； 索引可以是负数，正数从1（栈底）开始递增，负数从-1（栈顶）开始递减，Lua API会在内部把负数转换为正数。 假设栈的容量为n，位于[1,top]区间内的索引为有效索引，位于[1,n]区间内的索引为可接受索引。写入值必须在有效索引区间，读取值可以从可接受索引中读取。 本章剩余部分使用go语言实现了一个简单的库，包含了入栈出栈函数等。 第五章：Lua运算符 算术运算符（加减乘除，整除，取模，乘方）： 除法运算符和乘方会先把操作数转换为浮点数再进行运算，计算结果也一定是浮点数。其他六个运算符会先判断操作数是不是整数，如果是则进行整数运算，结果也一定是整数；否则转换为浮点数计算，结果也是浮点数。 整除运算符会将结果向下取整。 1234print(5 // 3) -- 1print(-5 // 3) -- -2print(5 // -3.0) -- -2.0print(-5.0 // -3.0) -- -1.0 - 取模： 1a % b == a - ((a // b) * b) - 乘方和字符串拼接运算符为右结合性，其他二元运算符具有左结合性。 按位运算符： 按位运算符会先把操作数转换成整数再运算，结果也一定是整数。 右移运算符是无符号右移，空出来的bit补0。 移动-n bit 等于反向移动 n bit。 逻辑运算符： Lua 会对逻辑与(and)和逻辑或(or)进行短路求值，运算结果为操作数之一，不一定是布尔值。 12t = t or &#123;&#125; -- if not t then t = &#123;&#125; endmax = a &gt; b and a or b -- a &gt; b ? a : b 逻辑非(not)会把操作数转换为布尔值，结果也一定是布尔值。 本章接下来的内容为用 Go 实现基本的 LuaAPI 方法： 12345// 覆盖了除逻辑运算符以外的所有 Lua 运算符Arith() // 算术与按位运算Compare() // 比较运算Len() // 取长度运算Concat() // 字符串拼接运算]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记]]></title>
    <url>%2F2021%2F06%2F02%2FLua%2FLua%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[康复训练。 3 数值 从Lua5.3版本开始，Lua语言为数值格式提供了两种选择：64位整型的Integer和双精度浮点类型的float。 3.2 算术运算 当操作数一个整型值，一个是浮点型值时，Lua会在进行算数运算前先将整型值转换成浮点型值。 为了避免两个整型值相除和两个浮点型值相除导致不一样的结果，除法运算操作的永远是浮点数且产生浮点型值的结果。 Lua5.3针对整数除法引入了一个称为floor除法的新算数运算符//。floor除法会对得到的商向负无穷取整，从而保证结果是一个整数。 对于任意指定的正常量K，即使x是负数，表达式x%K的结果也永远在[0， k-1]之间。 对于实数类型的操作数而言，取模运算有一些不同，例如，x-x%0.01恰好是x保留两位小数的结果，x-x%0.001恰好是x保留三位小数的结果。 3.4 数学库 floor向负无穷取整，ceil向正无穷取整，modf向零取整。 3.6 惯例 通过与零进行按位或运算，可以把浮点型值强制转换为整型值。 可以使用函数math.tointeger把数值强制转换为整型值，在输入参数无法转换为整型值时返回nil。 4 字符串4.1 字符串常量 从Lua5.3开始，也可以使用转义序列\u{h…h}来声明UTF-8字符，花括号里可以支持任意有效的十六进制。 4.3 强制类型转换 当在数值后紧接着使用字符串连接时，必须使用空格将它们分开，否则Lua语言会把第一个点当成小数点。 默认情况下，函数tonumber使用的是十进制，但是也可以指明使用二进制到三十六进制之间的任意进制。 5 表 表永远是匿名的，表本身和保存表的变量之间没有固定的关系。 5.1 表索引 如同全局变量一样，未经初始化的表元素为nil，将nil赋值给表元素可以将其删除。 实际上，a.x代表的是a[“x”]，即由字符串“x”索引的表，而a[x]则是指由变量x对应的值索引的表。 被用作表索引是，任何能够被转换成整型的浮点数都会被转换成整型数。 5.2 表构造器a = {x = 10, y = 20}等价于a = {}; a.x = 10; a.y = 20，在第一种写法中，由于能够提前判断表的大小，所以运行速度更快。 6 函数6.1 多返回值 在多重赋值中，如果一个函数调用是一系列表达式中的最后（或者是唯一）一个表达式，则该函数调用将产生尽可能多的返回值以匹配待赋值变量。 当一个函数调用是另一个函数调用的最后一个（或者是唯一）实参时，第一个函数的所有返回值都会作为实参传给第二个函数。 调用f(g())时，如果f的参数是固定的，那么Lua语言会把g返回值的个数调整为与f的参数个数一致。 表构造器会完整的接收函数调用的所有返回值，而不会调整返回值的个数。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unreal Engine 4 SDK构建相关笔记]]></title>
    <url>%2F2020%2F12%2F24%2FUnreal4%E7%AC%94%E8%AE%B0%2FUnreal-Engine-4-SDK%E6%9E%84%E5%BB%BA%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[SDK构建相关阅读[toc] 在Unreal项目开发的过程中，可能会用到第三方开发的库来集成一些第三方的功能，例如语音通话、播放视频等功能。虚幻引擎本身也引用了很多第三方的库,例如物理库PhysX、Steam平台相关的库SteamWorks、GoogleVR等等。这些库可以在引擎的Engine\Source\ThirdParty目录下找到。Unreal官方推荐将第三方库集成到插件目录中，这样可以将游戏代码与第三方代码进行隔离。 使用插件引入第三方库在Unreal的编辑器中，可以新建一个ThirdParty插件来引入SDK：在项目中点击编辑-插件-新插件-第三方库就可以创建一个使用已包含第三方库的插件。 11. 貌似只有C++项目中才可以创建第三方库插件，蓝图项目中貌似只能建立空白插件 新插件的目录结构如下： 其中SDKTest是插件本身逻辑的目录，ThirdParty是第三方库的目录，对于不同平台，所使用的SDK文件格式也有不同，这一点我们在后面再详细展开讲。 .uplugin文件是插件描述文件，虚幻引擎通过搜索这个格式的文件来查找插件，这个文件提供插件相关的基本信息。 XXX.Build.cs文件是模块描述文件，虚幻引擎使用UnrealBuildTool编译这个文件，并构造来确定整个编译环境。 Mac,x64文件夹内是不同平台下引入的库文件，x64平台下一般为.lib和.dll文件，Mac平台下一般为dylib，IOS平台下一般为.a文件、.dylib文件和.framework文件，Android平台下一般为.aar和.jar文件。这些文件在模块描述文件中进行引入，在实例项目中如图所示： 一个例子：以GCloud的相关SDK接入为例（GCloud相关文档）: (由于没有SDK的下载权限所以只能用官网的图来意思意思) 下载之后将文件夹拷贝到插件的Public目录下，并参考AAInfo4Copy.txt，在xxx.Build.cs文件中引入相应的插件。 在官方文档中引入插件的方法是： 12345PrivateDependencyModuleNames.AddRange(new string[] &#123; "GCloudCore" &#125;);PrivateDependencyModuleNames.AddRange(new string[] &#123; "GCloud" &#125;);PrivateDependencyModuleNames.AddRange(new string[] &#123; "TApm" &#125;);PrivateDependencyModuleNames.AddRange(new string[] &#123; "GVoice" &#125;);PrivateDependencyModuleNames.AddRange(new string[] &#123; "GEM_OneSDK" &#125;); 这部分的代码原理可以参考Engine\Source\Programs\UnrealBuildTool\Configuration\ModuleRules.cs文件中的相关定义 123456789101112131415161718// 通过将插件中的Public文件夹下的相对路径添加进这个List中来暴露给其他模块public List&lt;string&gt; PublicIncludePaths = new List&lt;string&gt;();// 同理，如果不想暴露给其他模块，则将相对路径添加到这个List中public List&lt;string&gt; PrivateIncludePaths = new List&lt;string&gt;();// 公共依赖模块名称列表（不需要路径）（自动进行私有/公共包含）。这些模块是我们的公共源文件所需要的。public List&lt;string&gt; PublicDependencyModuleNames = new List&lt;string&gt;();// 私有依赖模块名称列表。 这些模块是我们的私有代码所依赖的模块，但在公共的include文件中没有任何模块可以依赖。public List&lt;string&gt; PrivateDependencyModuleNames = new List&lt;string&gt;();// 附加库列表（包括拓展名在内的.lib文件名），通常用于第三方模块public List&lt;string&gt; PublicAdditionalLibraries = new List&lt;string&gt;();//...除此之外还有很多列表，可以在上述路径中文件内查看源码和注释// ReceiptProperty在\Engine\Source\Programs\UnrealBuildTool\System\TargetReceipt.cs中定义// 任意属性名/值，来自构建脚本的元数据可以传递给下游任务。（这是一对键值对），在文件中存储着UPL格式写的XML文件，其中可以进行一些设置，并且可以插入代码到AndroidManifest.xml和GameActivity.java中，关于这两个文件的作用在后面会解释public List&lt;ReceiptProperty&gt; AdditionalPropertiesForReceipt = new List&lt;ReceiptProperty&gt;(); 总而言之，在xxx.Build.cs文件中，将对应的第三方库路径和设置文件的路径加入到了全局的List中，在之后的编译过程中，UBT会根据这个文件将对应的第三方库文件编译构建到指定的位置。 虚幻插件语言（Unreal Plugin Language, UPL） 虚幻插件语言 (UPL)是一种基于XML的简单语言，用于操作XML和返回字符串。它包含一个分段，在计算任何其他分段之前，每个架构计算一次这个分段。状态被维护并推进到下个分段进行评估，因此分段的执行顺序很重要。虽然UPL是一个用于修改和查询XML的通用系统，但它专门用于允许插件影响其所属包的全局配置。例如，它允许插件修改Android APK AndroidManfiest.xml文件或IOS IPA plist文件。UBT还将查询插件的UPL xml文件，查找文件中要包含的字符串（对于包来说必须是常见的字符串），例如Android上的一些.java文件。 首先贴一个相关的文档在这里：https://docs.unrealengine.com/zh-CN/SharingAndReleasing/Mobile/UnrealPluginLanguage/index.html 在第三方库的引入过程中，可能会涉及到一些平台相关的功能，比如说权限获取等，这部分的设置文件，不同平台下有不同的规定，以Android和ios为例，在安卓平台下，使用应用清单概览文件对组件和权限进行控制，即AndroidManifest.xml文件；而在IOS下，使用Property List文件来存储用户设置。 对于Android平台，可能需要对AndroidManifest.xml文件进行一些修改，这时候就需要使用UPL来对该文件进行改动。 一个例子以GCloudSDK中的MSDK为例： 这里的一些参数本质上是Android的一些参数，如果详细了解请阅读：Android开发者指南，(有一说一Google这个文档写的是真滴好，什么是国际大厂啊) 以其中几个为例： android:name : 实现 Activity 的类的名称，是 Activity 的子类。此属性值应为完全限定类名称（例如，“com.example.project.ExtracurricularActivity”）。不过，为简便起见，如果名称的第一个字符是句点（例如，“.ExtracurricularActivity”），则名称将追加至 &lt;manifest&gt; 元素中指定的软件包名称。 android:screenOrientation : Activity 在设备上的显示方向。如果 Activity 是在多窗口模式下运行，则系统会忽略该属性。 对GameActivity.java的拓展： 什么是GameActivity.java： 在网上搜索了一下，大多数都是讲述这个文件是如何通过UPL插入修改的，没有描述这个文件本身是什么作用的。这个文件可以在\Engine\Build\Android\Java\src\com\epicgames\ue4\GameActivity.java下找到，在开头的注释中可以看到： Extending NativeActivity so that this Java class is instantiated from the beginning of the program. This will allow the user to instantiate other Java libraries from here, that the user can then use the functions from C++ 扩展NativeActivity，使这个Java类从程序开始就被实例化。 这将允许用户从这里实例化其他Java库，然后用户可以使用C++中的函数。 NOTE — This class is not necessary for the UnrealEngine C++ code to startup, as this is handled through the base NativeActivity class. This class’s functionality is to provide a way to instantiate other Java libraries at the startup of the program and store references to them in this class. 注意 — 这个类对于UnrealEngine C++代码的启动是不必要的，因为这是由基础NativeActivity类处理的。这个类的功能是提供一种方法，在程序启动时实例化其他Java库，并在这个类中存储对它们的引用。 那么，在Android的文档中找到了关于NativeActivity类的描述，而GameActivity类继承自这个类。在文档内对NativeActivity的描述如下： Convenience for implementing an activity that will be implemented purely in native code. That is, a game (or game-like thing). There is no need to derive from this class; you can simply declare it in your manifest, and use the NDK APIs from there. 方便实现一个将纯用本地代码实现的活动。也就是说，一个游戏（或类似游戏的东西）。不需要从这个类派生出来；你可以简单地在你的manifest中声明它，然后从那里使用NDK API。 继续向上追溯，看看Acitvity类意在负责什么事： An activity is a single, focused thing that the user can do. Almost all activities interact with the user, so the Activity class takes care of creating a window for you in which you can place your UI with setContentView(View). While activities are often presented to the user as full-screen windows, they can also be used in other ways: as floating windows (via a theme with R.attr.windowIsFloating set), Multi-Window mode or embedded into other windows. There are two methods almost all subclasses of Activity will implement: 一个Activity是用户可以做的独立的事情。几乎所有的Activity都可以与用户产生交互，因此Activity类负责为你创建一个窗口，你可以通过setContentView(View)来放置你的UI。虽然Activity通常以全屏窗口的方式呈现给用户，但是它们同样可以以其他的方式进行展示：例如浮动窗口（通过一个主题设置R.attr.windowIsFloating实现），多窗口模式或者嵌入到其他窗口中。几乎所有的Activity的子类都会实现两个方法: onCreate(Bundle) onPause() 看到这两个函数命名就大概能知道这个Activity类是贯穿一个应用的生命周期的，那么NaviteActivity类以及GameActivity类中的内容就是用来在应用生命周期的不同阶段执行不同逻辑的。 如何拓展： 在UPL的源代码中可以看到全部的API，在SDK文档中应该会说明SDK的使用步骤，例如GCloud的文档中： 这部分的初始化代码就可以使用UPL插入到GameActivity.java中： 123456789&lt;gameActivityOnCreateAdditions&gt; &lt;insert&gt; GCloud::InitializeInfo initInfo; initInfo.GameId = GCLOUD_GAME_ID; initInfo.GameKey = GCLOUD_GAME_KEY; IGCloud::GetInstance().Initialize(initInfo); &lt;/insert&gt;&lt;/gameActivityOnCreateAdditions&gt; 当然具体的实现要参考不同SDK文档中提供的实现。 IOS平台设置相关： info.plist文件 这个文件的作用就是提供应用在运行期间的一些设置，是一个XML格式组织起来的文件。 在虚幻引擎中的设置： 在 Project Settings - iOS - Extra Plist Data - Aditional Plist Data - 中添加相关的配置信息中添加相关的渠道信息。 一些详细的解读可以参考查利鹏大佬的这篇博文：UE4 开发笔记：Mac/iOS 篇 在虚幻中调用Java代码JNI：Java Native InterfaceJava Native Interface , Java原生接口，一种让其他语言或程序调用Java代码的方法，具体实现细节笔者并不清楚，可以参考官方文档，此处仅对项目中遇到的问题进行总结和梳理。 对于Android平台，SDK提供方可能会提供一些Java版本的函数接口，这些Java函数接口需要我们在虚幻引擎中调用，我们假定前置的接入插件的步骤已经完成。 以SlugSDK为例，它提供了一个初始化SDK组件的接口： 12345678910/** @url 打开的页面url* @supportedOrientations 设置屏幕方向类型（1：只支持横屏，2：只支持竖屏，3：横竖屏都支持）* @qqAppid 设置游戏的qq Appid（用来分享到qq）* @wxAppid 设置游戏的微信Appid（用来分享到微信）* @className: String类型,比如"com.tencent.ingame.TestActivity"，从H5页面跳转到游戏的某个界面，如果不需要可以设置为""，H5页面跳转到游戏的某个界面时，会先跳转到游戏的该Activity（Activity声明需设置singleTask或singleTop）再由该Activity作为中转跳转到具体的游戏界面，该Activity先在onNewIntent方法setIntent(intent)，然后可以通过getIntent().getStringExtra("routeInfo")获取跳转的路由信息，比如关闭浏览器时获取的routeInfo值为"close"* @finishShouldSendMsgToGame 浏览器webview finish时向游戏发送close消息，不需要可以传false，如果需要则必须先设置@className参数* @webviewBackground 设置打开的浏览器背景颜色，比如#ffffffff* */public static void openIngameCommunityByUrl(Activity currentActivity, String url, int supportedOrientations, String qqAppid, String wxAppid, String className, boolean finishShouldSendMsgToGame, String webviewBackground) 该函数的函数签名如下: 参数 : Activity currentActivity, String url, int supportedOrientations, String qqAppid, String wxAppid, String className, boolean finishShouldSendMsgToGame, String webviewBackground 返回值 :void 我们可以用命令行工具 : javap -s输出函数签名 , 具体可以参考博文 : Java dos命令窗口获取方法的签名 ; 也可以根据JNI函数签名的转换规则(详见Type Signatures部分)进行转换 , 以上面的函数为例 : 123456789Activity -- Landroid/app/Activitystring -- Ljava/lang/String;int -- Istring -- Ljava/lang/String;string -- Ljava/lang/String;string -- Ljava/lang/String;bool -- Zstring -- Ljava/lang/String;void -- V 需要注意的是 : 内置基础类型对应的签名后面没有分号 , 不要擅自加上分号 , 这样会导致搜索不到对应的方法! 因此最后该函数我们导出的函数签名为(注意为ILjava/lang/String) : 1(Landroid/app/Activity;Ljava/lang/String;ILjava/lang/String;Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)V 至此 , 我们完成了调用Java代码的准备工作。 在虚幻中调用 :我们需要JNIEnv环境 , 在虚幻中我们可以使用FAndroidApplication::GetJavaEnv(); 我们需要对应的jclass , 在虚幻中我们可以使用FAndroidApplication::FindJavaClass(ClassName)进行获取 我们需要对应的函数 , 此时我们就用上了刚刚推导的函数签名 , 同样在虚幻中我们可以使用env-&gt;GetStaticMethodID(signature)获得 最后我们需要调用函数 , 还是通过env完成 , 可以调用env-&gt;CallStaticVoidMethod()完成 整个过程的伪代码如下(对于env , cls , jmethodID必要时可以做一些防御性检查): 1234567891011void AndroidSlugSDK::OpenIngameCommunity(FString url, int supportedOrientations, FString qqAppid, FString wxAppid, FString className, bool finishShouldSendMsgToGame, FString webviewBackground)&#123; JNIEnv *env = FAndroidApplication::GetJavaEnv(); jclass cls = FAndroidApplication::FindJavaClass("com/tencent/slugsdk/SlugWebAdapter"); jmethodID jOpenCommunityMthod = env-&gt;GetStaticMethodID(cls, "openIngameCommunityByUrl", "(Landroid/app/Activity;Ljava/lang/String;ILjava/lang/String;Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)V"); jstring jUrl = env-&gt;NewStringUTF(TCHAR_TO_UTF8(*url)); jstring jqqAppID = env-&gt;NewStringUTF(TCHAR_TO_UTF8(*qqAppID)); jstring jwxAppID = env-&gt;NewStringUTF(TCHAR_TO_UTF8(*wxAppID)); jstring jclassName = env-&gt;NewStringUTF(TCHAR_TO_UTF8(*className)); jstring jwebColor = env-&gt;NewStringUTF(TCHAR_TO_UTF8(*WebViewBackgroundColor)); env-&gt;CallStaticVoidMethod(cls, jOpenCommunityMthod, FAndroidApplication::GetGameActivityThis(), jUrl, supportedOrientations, jqqAppID, jwxAppID, jclassName, finishShouldSendMsgToGame, jwebColor);&#125; 一些其他的坑 : 要明确项目是否支持aar包 , 貌似用gradle构建才可以使用aar包 ios的代码调用要在主线程 , 防止崩溃 参考插件 虚幻插件语言(Unreal Plugin Language) : https://docs.unrealengine.com/en-US/SharingAndReleasing/Mobile/UnrealPluginLanguage/index.html 虚幻插件语言参考：https://qiita.com/shiena/items/fe0e4cc1de4ddbaa60f0 UE4:UPL与JNI调用的最佳实践：https://imzlp.me/posts/27289/ 模块 模块的官方文档 : https://docs.unrealengine.com/en-US/ProductionPipelines/BuildTools/UnrealBuildTool/ModuleFiles/index.html 详解UE4静态库与动态库的导入与使用：https://www.cnblogs.com/sevenyuan/p/7161516.html 平台相关Android 应用清单 (AndroidManifest) : https://developer.android.com/guide/topics/manifest/manifest-intro?hl=zh-cn AndroidManifest.xml详解 : https://www.jianshu.com/p/3b5b89d4e154 权限 (Permission) : https://developer.android.com/guide/topics/permissions/overview?hl=zh-cn 应用二进制接口 (Android ABI, Application Binary Interface) : https://developer.android.com/ndk/guides/abis Android 关于arm64-v8a、armeabi-v7a、armeabi、x86下的so文件兼容问题：https://zhuanlan.zhihu.com/p/23102158 aar与jar : https://developer.android.com/studio/projects/android-library?hl=zh-cn IOS .bundle资源文件 : https://www.jianshu.com/p/55038871e7de framework库文件 : https://blog.csdn.net/lvxiangan/article/details/43115131 info.plist：https://my.oschina.net/hmj/blog/104196]]></content>
      <categories>
        <category>开发相关</category>
      </categories>
      <tags>
        <tag>Unreal,SDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Minigame以及其他有的没的]]></title>
    <url>%2F2020%2F09%2F17%2F%E9%9A%8F%E7%AC%94%2FMinigame%E4%BB%A5%E5%8F%8A%E5%85%B6%E4%BB%96%E6%9C%89%E7%9A%84%E6%B2%A1%E7%9A%84%2F</url>
    <content type="text"><![CDATA[从上海归来：这一段时间在搞Minigame，有点感触。从上海和顺佬还有翔仔回来的路上还是挺挫败的，一方面是有点中二的想法，感觉自己GameJam的好运气到此为止了；另一方面是觉得自己的技术力实在是不太行，有点对不起我的队友们；还有一方面是觉得是不是有的时候过于主观了，就像顺佬自述「我的优点是听人讲话」，感觉自己有时候对于别人的想法还是有点不太重视？ 从上海那次回来之后，挫败感也没有持续太久，当时在回酒店还是哪里的大巴上和隆德聊着说还是应该多看看GameJam的优秀作品找点启发。可除了整理了一个Ludum Dare历届主题之外，也没有额外的做什么事，只是在某次Minigame开会上临时抱佛脚的看了几个Demo。 当然这远远不够，等我再入职之后，和蒙哥聊起来什么「localmotion」说的我一愣一愣的，感觉对于游戏开发还是了解的太少太少了。 哀叹至此，实际上对现状也不会产生什么影响，还是说回本次Minigame。 Minigame和表达这次的MiniGame定的主题就是一个「文学」向的拼字游戏，为什么要给文学加引号呢，是因为本质上玩法并不怎么文学，只是拼字组成某种东西罢了。我们对于字的理解不会比其他人更多。 说来有点好笑，一开始我们的两个想法都是所谓的「公益」游戏，但实际上，我觉得游戏其实还是好玩比较重要。这点也是前不久才转变观点的，还和顺佬聊过。此前以为个人表达很重要，我可以不care任何受众，只表达我想表达的：当然这全然可以，只不过以部分人的水平来看，这么搞只会做出一团只有自己可以理解的shit，此外在表达自我和让它变得有趣or让更多的人可以理解之间并不冲突，其间的难处在于这需要一定的技术和审美。这里的技术不单单是指编码的技术，而是综合起来让自己的表达更高级的技术。 这很难。 当然这是现阶段看来一条值得追求的方向，即在提升自己技术力的同时，多多试着感受、记录、表达和修正（或者说优化）。 该做什么 最直观的应该是完成之前说的多看看GameJam视频，积累积累灵感，类似骑砍盾牌分析 by SecluSong)这类积累可以多做一做，哦，按我司的话来说应该是多沉淀一些。 再上一层的可能是多试着去实现一些东西，保持一个手热的状态，对于自己的知识库应该不断更新巩固，而不是一劳永逸，很多东西可能放一段时间之后就忘掉了。 再上一层的其实是一些生活上的一些东西，比如如何提高效率，如何利用下班时间提升自己（当然这属于知乎经典句式了），这些都还有待探索和学习，感觉可以先从调整作息开始，既然晚上的时间不多，其实可以早点睡觉，早上起来做一些事情。 最后的最后想了一些方法，但是说出来像是flag一样的东西，所以还是等验证过，有些结果之后再总结一下。]]></content>
      <categories>
        <category>文字</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“2020年第33周周报”]]></title>
    <url>%2F2020%2F08%2F19%2F%E4%B8%AA%E4%BA%BA%E6%8A%A5%E5%91%8A%2F202033%2F</url>
    <content type="text"><![CDATA[这是2020年的第33周报告。 上周计划完成情况 导师给Review了一下代码，改了之后提交了。 测试了一下性能，没什么问题。 本周做了什么 接了一个新需求，目前就是在看新需求涉及到的相关代码。 在看现有系统有没有可以重构的地方。 购物： 《世界经典鸡尾酒大全（珍藏版）》，可以说受到《赛博朋克酒保行动 VA-11 Hall-A: Cyberpunk Bartender Action》的强烈影响，对调酒有点感兴趣，二手书，130r。 摩飞的多功能锅，打算学学做饭，750r。 投资： 定投50r。 把1000左右放进余额宝了。 锻炼：无，体重维持在150上下，有点怪，现在进入了平衡，虽然感觉每天上下班汽车运动量也很大，但是从数字上看还是不太行。 下周打算做点什么 弹电吉他，我的电吉他到了，买了4年了还没有好好练过。 看看Unity的知识，写一点小轮子。 锻炼，看EVA。]]></content>
      <categories>
        <category>reports</category>
      </categories>
      <tags>
        <tag>report</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“2020年第32周周报”]]></title>
    <url>%2F2020%2F08%2F09%2F%E4%B8%AA%E4%BA%BA%E6%8A%A5%E5%91%8A%2F202032%2F</url>
    <content type="text"><![CDATA[这是2020年的第32周报告。 上周计划完成情况 邮箱基本上重构完成了，wiki读的还是太少，周五的时候把代码提了，等新包出来测试一下。 本周做了什么 前两天去事业群的培训了，大概就是通知一些事情。 开始读《大象无形：虚幻引擎程序设计浅析》，周末打游戏的时候脑海里总回想着“客户端是对服务端的拙劣模仿”这句话，可能是打游戏的时候总卡顿的缘故。还是要多看文档。 购物，简要清单如下： 铁三角CLR100，99r，放在公司用来听电脑的音频。 投资：买了50块的基金，每周一 定投50r。 锻炼：无，体重维持着150上下。 公益：给水灾捐了20r，助学捐了20r 下周打算做点什么 我必健身环。 看看Unity的知识，阅读项目代码，接需求。 等补发的自行车零件到了就可以骑自行车上班了。]]></content>
      <categories>
        <category>reports</category>
      </categories>
      <tags>
        <tag>report</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“2020年第31周周报”]]></title>
    <url>%2F2020%2F08%2F05%2F%E4%B8%AA%E4%BA%BA%E6%8A%A5%E5%91%8A%2F202031%2F</url>
    <content type="text"><![CDATA[这是2020年的第31周报告。 上周计划完成情况 邮箱重构要比想象中难很多，导师说的原来是两周不是两天。 本周做了什么入职快一个月了，上周去封闭培训了，所以两周报告和在一起，简单讲讲做了什么： 封闭培训，认识了一些还不错的人，但我并不怀念它。 阅读项目源码并重构某系统：大概实际耗时应该在5天，其中某些流程卡了我很久，还有一个恶性Bug需要明天去公司解决，如果顺利的话这周就能解决（希望这周就能解决，听说下周要接现行分支上的需求了）。 购物，简要清单如下： 充电宝：99r，华为 瑜伽垫：49r，用于健身环大冒险 剃须刀：小米 自行车：600r，凤凰，通勤用 上述消费大概在1000以内 锻炼：两周实际上没有怎么锻炼，封培期间一直在忙各种事，开始上班之后才能走走路，重新回到每天1w+的节奏，体重从7月25日的152.7斤降到了149.2斤，距离目标体重还有29.2斤。 本周开销较少，都是一些一次性消费重复使用的物品。 书影音：基本没有。 只言片语：这部分是从封培期间得到的一点体悟： 用利益驱动别人构成合作。（其实是换位思考的一种，想想对方想要什么。） 沟通时把别人当傻逼似的事无巨细有助于帮助你把潜在的傻逼教成正常人，从而规避掉坑。 人太分奴，或者得失心太重有时候会搞得吃相太难看。 待人礼貌是基本原则。 下周打算做点什么 把邮箱系统重构完，梳理整个系统结构。 学习性能分析部分。 读书，学习Lua和Unity。 找个周末去看场电影，《乔乔的奇妙冒险》、《妙先生》都在想看之列。]]></content>
      <categories>
        <category>reports</category>
      </categories>
      <tags>
        <tag>report</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“2020年第29周周报”]]></title>
    <url>%2F2020%2F07%2F18%2F%E4%B8%AA%E4%BA%BA%E6%8A%A5%E5%91%8A%2F202029%2F</url>
    <content type="text"><![CDATA[这是2020年的第29周报告。 本周做了什么这周是入职之后的经历过的第一个完整的一周，简单讲讲做了些什么。 阅读项目源码：项目发展到现在已经很庞大了，如果想要入手需要对整个项目有一个明确的认识，这一周就择性的阅读了项目的源码。 购物，简要清单如下： 吹风机：小米 台灯：小米 桌子：宜家 椅子：宜家 邮差包：TIMBUK2 锻炼：除了每天的1w+步以外，周三还玩了10分钟的健身环大冒险，体重情况则从157斤减少到了154斤，距离目标还有30斤。 本月开销较大，粗略计算达到了惊人的15600块，其中有12000属于房租，暂无收入。 想了下不是暂无收入，四个月前买了10块钱的基金，前两天卖了，扣除手续费之后大概卖了10块零八毛。 书影音： 在读《Lua设计与实现》和《Lua程序设计》 看过了《千年女优》，很喜欢，运镜太流畅了。 游戏打了打《和平精英》，算是做作业了。 只言片语： ​ 「我们一切都是从体验出发，我们要去了解后台那边是怎么写的，如果仅仅是少了几个函数，导致体验变差了，他们不给我们改，这说不过去的。」——我们组长和其他前辈沟通时说的话，有点动人。 ​ 「企业会怕你混日子，不怕你有企图。」——请教张老师后，张老师给出的点拨，挺有道理的，欲望写在脸上，如果是正当的欲望，没什么不好，我这人其实有欲望，但是因为胆怯或者懦弱总不愿意表达出来，感觉有的时候有点吃亏。 下周打算做点什么 工作：把邮箱系统改写好，听导师说好像两三天就能写好（？）。 体重：再减三斤！ 书影音： 把在读的两本书尽量读一些。 电影的话可能会再看一部今敏的片子。 消费：自行车？还有一些衣物。 自我盘点： 工作时应该更专心，必要时应该去除一些干扰。 记得写日志和周报，起码让你的上级了解你在做什么，这没什么坏处，就够了。]]></content>
      <categories>
        <category>reports</category>
      </categories>
      <tags>
        <tag>report</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“2020年第21周周报”]]></title>
    <url>%2F2020%2F05%2F26%2F%E4%B8%AA%E4%BA%BA%E6%8A%A5%E5%91%8A%2F202021%2F</url>
    <content type="text"><![CDATA[这是2020年的第21周报告（0518～0524）。 上周计划完成情况 摸鱼。 本周做了什么输出 答辩：18号毕业答辩结束，反正是平平淡淡就结束了，竟然还有点怅然若失，不知道是不是没有进行过一段校园恋情的缘故，还是对未来的迷茫，也或者两者都有。 答辩结束之后提交各种表格，文档。 摄影一则：寒风中接着大街上插座给手机充电的男子。生活不易啊。 消费 机票退款了，退了一半。 下周打算做点什么 看看蒙哥推荐的那个那本小说：《doom启示录》 尝试着写一个软渲染的Demo。 学C++。]]></content>
      <categories>
        <category>reports</category>
      </categories>
      <tags>
        <tag>report</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“2020年第20周周报”]]></title>
    <url>%2F2020%2F05%2F26%2F%E4%B8%AA%E4%BA%BA%E6%8A%A5%E5%91%8A%2F202020%2F</url>
    <content type="text"><![CDATA[这是2020年的第20周报告（0511～0517）。 上周计划完成情况 毕业论文：把论文的重复率降了下来。 本周做了什么输出 论文：把论文的内容修改了一下。 制作了一个毕业设计答辩的PPT和对应的讲稿。 消费 返校机票：¥880 无主之地3：¥35.48，Epic就是我大哥。 发现账本app只记到11日，没有坚持记账的习惯并不好。 输入 看了Epic关于Unreal Engine 5的演示视频，有点恍惚，我还能跟得上吗？ 虚幻引擎5！！！4K画质PS5实机演示！ 下周打算做点什么 摸鱼]]></content>
      <categories>
        <category>reports</category>
      </categories>
      <tags>
        <tag>report</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“2020年第19周周报”]]></title>
    <url>%2F2020%2F05%2F12%2F%E4%B8%AA%E4%BA%BA%E6%8A%A5%E5%91%8A%2F202019%2F</url>
    <content type="text"><![CDATA[这是2020年的第19周报告（0504～0510）。 上周计划完成情况 毕业设计：改初稿。 8号老师才给我反馈意见，在这之前基本上是放飞自我，这之后开始苦哈哈的改稿。 本周做了什么输出 摄影： 姑且命名为「马其顿防线」 改论文稿。 消费 美的台灯：¥59，之前搬家，东西都搬走了，在家这边又买了一个台灯，和寝室用的一样，能亮就行。 和朋友聚餐：¥88，社交花费。 输入 《羞羞的铁拳》：作为一个喜剧片来说还可以。 《bilibili献给新一代的演讲《后浪》》：一种目前无法企及的生活状态宣传片。 《动物新世代 BNA ビー・エヌ・エー》：老生常谈的设定和出色的画面表现，以及合适的BGM切入时机。 下周打算做点什么 论文改稿，降重，答辩。 学习C++。 学习Unreal。 坚持跑步。]]></content>
      <categories>
        <category>reports</category>
      </categories>
      <tags>
        <tag>report</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“2020年第18周周报”]]></title>
    <url>%2F2020%2F05%2F07%2F%E4%B8%AA%E4%BA%BA%E6%8A%A5%E5%91%8A%2F202018%2F</url>
    <content type="text"><![CDATA[这是2020年的第18周报告（0427～0503）。 上周计划完成情况 毕业设计：继续写论文。 基本完成了，稍作修改就可以发给老师看看了。 本周做了什么输出 毕业设计：把论文写的差不多了。由于毕业设计的存在，这一周基本上都是起床、摸鱼、吃饭、写论文、和方佬快乐联盟，看直播、睡觉度过的。 消费 FPX的锤石冠军皮肤：¥115.43，冲动消费一则。 Moo音乐会员月票：¥15，非必要消费一则。 敲钟牛皮肤：¥21.82，冲动消费两则。 输入 看了一眼让·鲍德里亚的《消费社会》，感觉太高深了，没看下去。 《新喜剧之王》：一场尴尬的闹剧和并不高明的讽刺。 下周打算做点什么 毕业设计：改初稿。]]></content>
      <categories>
        <category>reports</category>
      </categories>
      <tags>
        <tag>report</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“2020年第17周周报”]]></title>
    <url>%2F2020%2F04%2F28%2F%E4%B8%AA%E4%BA%BA%E6%8A%A5%E5%91%8A%2F202017%2F</url>
    <content type="text"><![CDATA[这是2020年的第17周报告（0420～0426）。 上周计划完成情况 毕设：把测试用例写完，虽然感觉大概率是我自己写，而不是从CTS这个项目里移植过来。然后把日志整理出来，再写一份论文初稿。 基本完成，但是日志还没有写完……太难编了。 出门走走：买了相机之后利用率不高，希望下周开始能出门透透气，顺便拍点东西。 调整作息：就像这篇周报写完的此刻，已经是00:52分了，希望之后能12点前睡觉，早上早点起床。 没有完成，下周继续努力。 本周做了什么输出： 毕业设计：改写了一部分CTS项目里的测试用例到GP101的测试框架下，然后每天写了写论文。 每天基本上都是在写毕业设计和论文，没什么其他好说的。 消费： 《仙剑奇侠传4》：¥25，Steam上买的，买一个算是补票，致敬一下当年感动到我的经典游戏。 《游戏开发：世嘉新人培训教材》：¥138.60，当当网购买，打算读读看。 《程序员修炼之道：通向务实的最高境界》：¥75.65，当当网购买，既然游戏业内的dalao都推荐了，就买来看看，当然这种思路不太理性。 《算法竞赛入门到进阶》：¥52.62，当当网购买，本质上说这本书是为了凑满减的，另一个动机来说这本书当作刷leetcode的一个教材来看，纯粹属于个人爱好了，类似于数独那种脑力游戏罢了，没有指望发挥什么现实作用。 输入： 了解了一下「入关学」的概念：https://zhuanlan.zhihu.com/p/120432699 看了看英雄联盟里锤石的玩法，虽然已经玩了好几年的锤石了，但是想看看还能不能更上一层楼。 下周打算做点什么 毕业设计：继续写论文。]]></content>
      <categories>
        <category>reports</category>
      </categories>
      <tags>
        <tag>report</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“2020年第16周周报”]]></title>
    <url>%2F2020%2F04%2F20%2F%E4%B8%AA%E4%BA%BA%E6%8A%A5%E5%91%8A%2F202016%2F</url>
    <content type="text"><![CDATA[这是2020年的第16周报告。 上周计划完成情况上周实际上没有什么计划，说起来这是第一次正式记录周报，就写这些好了。 本周做了什么本周实际上也没有完成什么特别值得拿来说说的事情。 消费： 路由器：京东上买的TP-LINK WDR7660千兆路由器，189.90元。 动机：买这个的缘由是觉得内蒙广电这里的机顶盒&amp;路由器太垃圾了（误），所以想换一个相对好一点点的路由器，上知乎看了一圈，买了这个。家里的宽带实际上只有100M，想着饱和式配置，就直接上了一个千兆的路由器，如果以后升级宽带就能派上用场了，就算不能，那其实这100M的宽带也能跑满。 体验：目前还可以，算是从东非走出来了，终于从手动在浏览器里输入192.168.1.1变成了在手机&amp;电脑双端都能进行控制，美中不足的是这个路由器貌似可玩性小一点，不能自己设置加速器的相关配置，不过一分钱一分货，也没什么奢望了。 输出： 博客相关：探索了一下关于hexo模版以及生成命令的知识 比如这篇博客，生成的命令就是hexo new report -p /个人报告/202016 “2020年第16周周报”，这行命令会从我写好的report模版出发，在-post文件夹下的「个人报告」文件夹中生成一篇报告，这样做的好处是省去了一些手动复制的过程，比较省事，同时看起来比较整洁。 社交媒体：没有什么值得一说的更新。 输入： 《我是于欢水》：看了这部电视剧，感觉还可以，一开始在朋友的豆瓣动态里看过，后来因为有关女权的争论所以打算看看。不到一下午的时间，用2倍速看完了这部剧。一些内容不能细品，另外一些内容又详细的出人意料，我不喜欢国产电视剧的一个原因在于感觉房间里的布景太亮了，过于惨白，以至于有一种隔阂感。日剧里的房间给我的印象都是暖黄色的光，比较柔和。此外还有一点就是有的时候主人公居住的环境往往超过他的消费水平，让我感觉非常突兀。说回这部剧，如果你把他当作一个重逻辑的电视剧去推敲可能会大失所望；但如果你就把他当作茶余饭后打发时间的剧，那还是能看看的。 《OpenGL ES 3.0 编程指南》：非常粗浅的翻阅了开头，记录了一下ES2.0与ES3.0的差别，作为毕业设计测试API的选取标准。 看了一下有关斐讯的新闻，为了骗钱真是什么手段都有啊，防不胜防。 事件： 笔记本电脑电池彻底不行了，只有33%的容量了，而且现在也完全充不进去电了，打算忙完毕设之后就保存数据，再之后要么换个新电脑，要么换个新电池了。 忘了买大头菜了，血亏。 下周打算做点什么 毕设：把测试用例写完，虽然感觉大概率是我自己写，而不是从CTS这个项目里移植过来。然后把日志整理出来，再写一份论文初稿。 出门走走：买了相机之后利用率不高，希望下周开始能出门透透气，顺便拍点东西。 调整作息：就像这篇周报写完的此刻，已经是00:52分了，希望之后能12点前睡觉，早上早点起床。]]></content>
      <categories>
        <category>reports</category>
      </categories>
      <tags>
        <tag>report</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ludum Dare 历届主题]]></title>
    <url>%2F2019%2F12%2F18%2F%E9%9A%8F%E7%AC%94%2FLudum-Dare-%E5%8E%86%E5%B1%8A%E4%B8%BB%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Ludum Dare 历届主题 No. Month Theme (bonus) 0† April 2002 Indirect interaction（间接干扰） 1 July 2002 Guardian（保卫者） 2 November 2002 Construction/destruction (sheep)（建立/毁灭（绵羊）） 3 April 2003 Preparation – Set it up, let it go（准备—设置好，放手） 4 April 2004 Infection（感染） 5 October 2004 Random（随机） 6 April 2005 Light and darkness（光与暗） 7 December 2005 Growth（生长） 8 April 2006 Swarms（密集） 8.5† January 2007 Moon/anti-text（月/反文本（不知道这个在中文中表达什么）） 9 April 2007 Build the level you play（构建你玩的关卡） 10 December 2007 Chain reaction（连锁反应） 10.5 February 2008 Weird/unexpected/surprise（奇怪/意想不到/惊奇） 11 April 2008 Minimalist（极简主义者） 12 August 2008 The tower（塔） 13 December 2008 Roads（路） 14 April 2009 Advancing wall of doom（前进的末日之墙） 15 August 2009 Caverns（洞穴） 16 December 2009 Exploration（探索） 17 April 2010 Islands（群岛，岛屿） 18 August 2010 Enemies as weapons（敌人作为武器，作为武器的敌人） 19 December 2010 Discovery（发现） 20 April 2011 It’s dangerous to go alone! Take this!（一个人去是很危险的!拿着这个！） 21 August 2011 Escape（逃脱） 22 December 2011 Alone (kitten challenge)（单独（小猫挑战）） 23 April 2012 Tiny world（小世界） 24 August 2012 Evolution（演变） 25 December 2012 You are the villain (goat)（你是恶棍 （山羊）） 26 April 2013 Minimalism (potato)（简约主义（马铃薯）） 27 August 2013 10 seconds（十秒） 28 December 2013 You only get one（你只得到一个） 29 April 2014 Beneath the surface（表面下） 30 August 2014 Connected Worlds（被连接的世界） 31 December 2014 Entire Game on One Screen（整个游戏在一个屏幕上） 32 April 2015 An Unconventional Weapon（非常规武器） 33 August 2015 You are the Monster（你是怪兽） 34 December 2015 Growing/two button controls（增长/两个按钮控件） 35 April 2016 Shapeshift（变形） 36 August 2016 Ancient Technology（古代科技） 37 December 2016 One Room（一个房间） 38 April 2017 A Small World（一个小世界） 39 July 2017 Running out of Power（电源耗尽） 40 December 2017 The more you have, the worse it is（你拥有的越多, 就越糟糕） 41 April 2018 Combine two incompatible genres（结合两种不相容的体裁） 42 August 2018 Running out of space（空间耗尽） 43 December 2018 Sacrifices must be made（必须作出牺牲） 44 April 2019 Your life is currency（你的生命（生活）是一种货币） 45 October 2019 Start with nothing（从无到有） 46 April 2020 Keep it Alive（保持或者）]]></content>
      <tags>
        <tag>灵感</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[翻译]Integrating Lua]]></title>
    <url>%2F2019%2F09%2F24%2F%E7%BF%BB%E8%AF%91%2F%E7%BF%BB%E8%AF%91-Integrating-Lua%2F</url>
    <content type="text"><![CDATA[一篇名为Integrating Lua的Wiki页面翻译。 原文链接：https://wiki.unrealengine.com/Integrating_Lua Integrating LuaOverview欢迎来到我的第三个Wiki页面，这个页面是关于那个很棒的游戏引擎的——虚幻引擎！这篇文章包含了人们最近问我数次的那个问题，我认为这将对游戏逻辑编程和一个高水平的mod-abilty（模块化能力？）：整合Lua很有用。 RequirementsStarting off : code in our projectAquiring:现在，我们需要向项目中引入Lua，以便于其与我们的项目一起编译并包含在最终游戏中。但是首先，我们需要获取到Lua的二进制文件。有些项目会为您提供预编译的二进制文件，或者您也可以自行编译！因为编译的过程耗费时间，而且这个过程是必要的，所以我们将使用预编译的版本。LuaBinaries是一个很棒的项目，它始终是最新的，并且具有适用于每个平台的二进制文件（在本文中，我们将只涉及Windows）。选择最新版本，然后选择Windows库，接着选择静态（Static），因为我们会将Lua嵌入到游戏的可执行文件中，然后根据需要搜索软件包。在我们下载过这些包后，我们应该在它们的结构中找到如下文件： Include/(essential includes for working with Lua) luaxlib.h lua.h lua.hpp luaconf.h lualib.h luaXX.lib（XX代表Lua的当前版本，例如Lua 5.3.3就为lu a53.lib） 现在，我们拥有了二进制文件和包含文件，我们可以开始我们的集成工作了！ Copying the files在虚幻引擎中链接Lua很容易。首先，我们需要在项目目录中创建一个新文件夹，将Lua内容放入其中。我个人更喜欢在项目的主目录（.uproject所在的位置）中创建一个新文件夹，并将其命名为“ThirdParty”。然后在这个文件夹中，我创建了一个名为“Lua”的文件夹，并将其分为“includes”和“libraries”。结构如下： Project Home/ ThirdParty/ Lua/ includes/（我们只需要复制一次，因为它们与体系结构没有区别，最后请注意“s”） libraries/ luaXX.x64.lib（这是您在Win64包中下载的库文件，重命名来做区分） luaXX.x32.lib（这是您在Win32包中下载的库文件，重命名来做区分） Linking在Visual Studio中，打开YourProjectName.Build.cs，这个文件位于 Source/YourProjectName/ 文件夹中。默认情况下，此文件仅链接默认引擎模块。要对此链接Lua，我们需要向其中添加一些代码。由于展示每一个细节实在是太多了，所以我只向你展示我对Build.cs文件的改动： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849using System.IO;using UnrealBuildTool;public class ProjectName : ModuleRules&#123; private string ThirdPartyPath &#123; get &#123; return Path.GetFullPath(Path.Combine(ModuleDirectory, "../../ThirdParty/")); &#125; &#125; public ProjectName(TargetInfo Target) &#123; PublicDependencyModuleNames.AddRange(new string[] &#123; "Core", "CoreUObject", "Engine", "InputCore" &#125;); PrivateDependencyModuleNames.AddRange(new string[] &#123; &#125;); // 如果使用Slate UI，则取消注释 // PrivateDependencyModuleNames.AddRange(new string[] &#123; "Slate", "SlateCore" &#125;); // 如果使用在线功能，则取消注释 // PrivateDependencyModuleNames.Add("OnlineSubsystem"); // 要包含 OnlineSubsystemSteam, 请将其添加到uproject文件的plugins部分中，并将Enabled属性设置为true LoadLua(TargetRules); // 此函数加载Lua &#125; private bool LoadLua(ReadOnlyTargetRules TargetRules) &#123; bool isLibSupported = false; // 检查是否使用的是Windows if ((Target.Platform == UnrealTargetPlatform.Win64) || (Target.Platform == UnrealTargetPlatform.Win32)) &#123; isLibSupported = true; string PlatformString = (Target.Platform == UnrealTargetPlatform.Win64) ? "x64" : "x86"; // 此字符串是“x64”或“x86”，因此我们可以将其附加到lib文件名 string LibrariesPath = Path.Combine(ThirdPartyPath, "Lua", "libraries"); PublicAdditionalLibraries.Add(Path.Combine(LibrariesPath, "lua53." + PlatformString + ".lib")); PublicIncludePaths.Add(Path.Combine(ThirdPartyPath, "Lua", "includes")); &#125; Definitions.Add(string.Format("WITH_LUA_BINDING=&#123;0&#125;", isLibSupported ? 1 : 0)); return isLibSupported; &#125;&#125; “LoadLua”方法检查我们是否在Windows上，如果是，则根据编译的体系结构创建一个包含“x64”或“x86”的字符串，因此我们可以轻松的找到lib文件。然后，我们创建库路径，该路径就是（在这个例子中为“ThirdParty/”）/Lua/libraries。从那里，我们将平台字符串附加到文件名的前缀和后缀，因此最后应该是lua53.xxx.lib。此路径已添加到PublicAdditionalLibraries中，这会强制编译器使用我们放在其中的lib文件。我们还将includes目录添加到PublicIncludePaths，以便编译器找到我们的includes。最后也很重要的一点是，我们向已编译的游戏中添加了一个定义：WITH_LUA_BINDING = x，其中x为0（不支持Lua）或1（支持Lua）。 First steps现在，我们已经将Lua二进制文件集成到我们的游戏中，让我们通过在Visual Studio中右键单击该项目并选择“Build”来进行尝试。它应该会成功！下一步：编写一个蓝图节点，该节点从我们输入的字符串中执行Lua代码。打开您创建的蓝图函数库的头文件（.h）。空文件如下所示： 12345678910111213#pragma once#include "Kismet/BlueprintFunctionLibrary.h"#include "LuaBlueprints.generated.h"/** * */UCLASS()class YOURPROJECT_API ULuaBlueprints : public UBlueprintFunctionLibrary&#123; GENERATED_BODY()&#125;; 首先，在顶部添加Lua包含项，以便编译器知道声明函数的位置。为此，请在其他包含项的头部添加#include &quot;lua.hpp&quot;。接下来，我们向其中添加一个新的UFUNCTION，将其解析为带有以下声明的蓝图节点： 123public: UFUNCTION(BlueprintCallable, Category = "Lua") static void RunLua(const FString&amp; code); 这将创建一个可调用的蓝图节点，该节点带有一个字符串（FString），我们可以在其中输入将要运行的Lua代码。请注意，这是静态的，因为我们没有要在上下文中调用此对象的对象，换言之，我们想在没有任何目标的情况下从任何地方调用它。让我们进入LuaBlueprints.cpp文件，该文件应该为空（include文件除外）。我们为RunLua函数添加定义： 1234567891011void ULuaBlueprints::RunLua(const FString&amp; code)&#123; lua_State* L = luaL_newstate(); luaL_openlibs(L); int result = luaL_dostring(L, TCHAR_TO_ANSI(*code)); if (result != 0) &#123; UE_LOG(LogTemp, Error, TEXT("Lua Script error: %s"), ANSI_TO_TCHAR(lua_tostring(L, -1))); &#125;&#125; 这很容易。它使用Lua C API创建一个新的Lua状态，将其分配给名为L的变量。然后，打开标准的lua库（例如math），然后通过执行luaL_dostring()运行代码。这将Lua状态L作为一个参数，并将要运行的代码作为另一个参数。该函数返回一个整数，如果一切正常，则返回0。如果不为0，则显然出了问题。在这种情况下，我使用UE_LOG将其打印到日志中。注意，我们通过lua_tostring(L,-1)得到Lua错误消息。]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>Lua</tag>
        <tag>Unreal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下配置OpenGL环境]]></title>
    <url>%2F2019%2F09%2F11%2FOpenGL%E7%AC%94%E8%AE%B0%2FMac%E4%B8%8B%E9%85%8D%E7%BD%AEOpenGL%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[Mac下配置OpenGL环境。 Mac下配置OpenGL 安装homebrew ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 安装GLEW与GLFW brew install glew brew install glfw3 CLion法（推荐） 在CLion:A cross-platform IDE for C and C++下载CLion 配置GLAD： 打开在线服务（点击这个链接），API选择3.3及以上，Profile选择Core，勾选Options中的Generate a loader，点击GENERATE，会生成一个压缩包，下载。 将子目录中的/include/glad与/include/KHR复制到/usr/Local/include文件夹下。（如果/usr文件夹隐藏，可用快捷键command+shift+G输入访问） 新建一个项目，配置对应的Cmake文件： 1234567891011121314151617181920212223242526cmake_minimum_required(VERSION 3.12)project(OpenGL)set(CMAKE_CXX_STANDARD 14)set(GLEW_H /usr/local/Cellar/glew/2.1.0/include/GL)set(GLFW_H /usr/local/Cellar/glfw/3.2.1/include/GLFW)set(GLAD_H /usr/local/include/glad)set(KH_H /usr/local/include/KHR)include_directories($&#123;GLEW_H&#125; $&#123;GLFW_H&#125; $&#123;GLAD_H&#125; $&#123;KH_H&#125;)# 添加目标链接set(GLEW_LINK /usr/local/Cellar/glew/2.1.0/lib/libGLEW.2.1.dylib)set(GLFW_LINK /usr/local/Cellar/glfw/3.2.1/lib/libglfw.3.dylib)link_libraries($&#123;OPENGL&#125; $&#123;GLEW_LINK&#125; $&#123;GLFW_LINK&#125;)# 执行编译命令# 这个glad.c在第2步中说过要拉到项目中，注意路径set(SOURCE_FILES "src/glad.c" "main.cpp")add_executable(OpenGL $&#123;SOURCE_FILES&#125;)# mac下这步很重要if (APPLE) target_link_libraries(OpenGL "-framework OpenGL") target_link_libraries(OpenGL "-framework GLUT")endif() 4. 注意这样配置之后需要更改`/usr/local/include/glad文件夹下的glad.h`中的`#include &lt;KHR/khrplatform.h&gt;`更改为`#include &lt;khrplatform.h&gt;`，具体步骤： 1. 在CLion中打开`glad.c`文件，command+点按`#include &lt;glad.h&gt;`会跳到`glad.h` 2. 然后在`glad.h`中command+f找到`#include &lt;KHR/khrplatform.h&gt;`，将它改为`#include &lt;khrplatform.h&gt;` 5. 运行测试代码（把下列代码复制到main.cpp中）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;glew.h&gt;#include &lt;glfw3.h&gt;#include &lt;iostream&gt;using namespace std;void key_callback(GLFWwindow* window, int key, int scancode, int action, int mode)&#123; //如果按下ESC，把windowShouldClose设置为True，外面的循环会关闭应用 if(key==GLFW_KEY_ESCAPE &amp;&amp; action == GLFW_PRESS) glfwSetWindowShouldClose(window, GL_TRUE); std::cout&lt;&lt;"ESC"&lt;&lt;mode;&#125;int main(void)&#123; //初始化GLFW库 if(!glfwInit()) return -1; //创建窗口以及上下文 GLFWwindow* window = glfwCreateWindow(640, 480, "hello world", NULL, NULL); if(!window) &#123; //创建失败会返回NULL glfwTerminate(); &#125; //建立当前窗口的上下文 glfwMakeContextCurrent(window); glfwSetKeyCallback(window, key_callback); //注册回调函数 //循环，直到用户关闭窗口 while(!glfwWindowShouldClose(window)) &#123; /*******轮询事件*******/ glfwPollEvents(); /*******渲染*******/ //选择清空的颜色RGBA glClearColor(0.2, 0.3, 0.3, 1); glClear(GL_COLOR_BUFFER_BIT); //开始画一个三角形 glBegin(GL_TRIANGLES); glColor3f(1, 0, 0); //Red glVertex3f(0, 1, 1); glColor3f(0, 1, 0); //Green glVertex3f(-1, -1, 0); glColor3f(0, 0, 1); //Blue glVertex3f(1, -1, 0); //结束一个画图步骤 glEnd(); glBegin(GL_POLYGON); //再画个梯形，需要注意笔顺 glColor3f(0.5, 0.5, 0.5); //Grey glVertex2d(0.5, 0.5); glVertex2d(1, 1); glVertex2d(1, 0); glVertex2d(0.5, 0); glEnd(); /******交换缓冲区，更新window上的内容******/ glfwSwapBuffers(window); &#125; glfwTerminate(); return 0;&#125; 如果出现如下窗口说明配置成功： XCode法 在App Store中搜索XCode并安装。 新建Xcode的Command Line C++项目，在build settings中设置Header Search Path与Library Search Path，在其中添加对应的glew与glfw的头文件(include)与库文件(lib)路径。 在build Phases中添加库文件 ​ （在对应的文件夹中将两个/.dylib的文件直接拖拽进来） 配置GLAD： 打开在线服务（点击这个链接），API选择3.3及以上，Profile选择Core，勾选Options中的Generate a loader，点击GENERATE，会生成一个压缩包，下载。 将子目录中的/include/glad与/include/KHR复制到/usr/Local/include文件夹下。（如果/usr文件夹隐藏，可用快捷键command+shift+G输入访问） 将/src中的glad.c复制到Xcode工程文件夹下。 在build settings中添加路径/usr/local/include 此时如果不出意外的话，你的第一个测试程序已经可以运行了，点击测试代码，复制到自己的.cpp文件中执行，会出现一个黑色窗口。(或者直接复制下面的代码) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;glad/glad.h&gt;#include &lt;GLFW/glfw3.h&gt;#include &lt;iostream&gt;void framebuffer_size_callback(GLFWwindow* window, int width, int height);void processInput(GLFWwindow *window);// settingsconst unsigned int SCR_WIDTH = 800;const unsigned int SCR_HEIGHT = 600;int main()&#123; // glfw: initialize and configure // ------------------------------ glfwInit(); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);#ifdef __APPLE__ glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); // uncomment this statement to fix compilation on OS X#endif // glfw window creation // -------------------- GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, "LearnOpenGL", NULL, NULL); if (window == NULL) &#123; std::cout &lt;&lt; "Failed to create GLFW window" &lt;&lt; std::endl; glfwTerminate(); return -1; &#125; glfwMakeContextCurrent(window); glfwSetFramebufferSizeCallback(window, framebuffer_size_callback); // glad: load all OpenGL function pointers // --------------------------------------- if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) &#123; std::cout &lt;&lt; "Failed to initialize GLAD" &lt;&lt; std::endl; return -1; &#125; // render loop // ----------- while (!glfwWindowShouldClose(window)) &#123; // input // ----- processInput(window); // glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.) // ------------------------------------------------------------------------------- glfwSwapBuffers(window); glfwPollEvents(); &#125; // glfw: terminate, clearing all previously allocated GLFW resources. // ------------------------------------------------------------------ glfwTerminate(); return 0;&#125;// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly// ---------------------------------------------------------------------------------------------------------void processInput(GLFWwindow *window)&#123; if(glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) glfwSetWindowShouldClose(window, true);&#125;// glfw: whenever the window size changed (by OS or user resize) this callback function executes// ---------------------------------------------------------------------------------------------void framebuffer_size_callback(GLFWwindow* window, int width, int height)&#123; // make sure the viewport matches the new window dimensions; note that width and // height will be significantly larger than specified on retina displays. glViewport(0, 0, width, height);&#125; 如果运行出现如下窗口，说明配置成功： 参考： https://www.cnblogs.com/shayue/p/Mac-CLion-xiaOpenGL-huan-jing-pei-zhi.html]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua源码阅读：虚拟机概述]]></title>
    <url>%2F2019%2F08%2F21%2FLua%2FLua%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%9A%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[Lua 虚拟机的执行过程。 Lua 执行过程概述：解释型脚本语言与编译型语言的区别如下： 由于每个脚本语言都有自己的一套字节码，与具体的硬件平台无关，所以不用修改脚本代码，就能运行在各个平台上。硬件、软件平台的差异都由语言自身的虚拟机解决。 由于脚本语言的字节码需要虚拟机执行，而不像机器代码能够直接执行，所以运行速度比编译型语言差不少。 虚拟机需要完成以下工作： 将源代码编译成虚拟机可以识别执行的字节码。 为函数调用准备调用栈。 内部维持一个 IP（Instruction Pointer，指令指针）来保存下一个将执行的指令地址。在 Lua 代码中，IP 对应的是 PC 指针。 模拟一个 CPU 的运行：循环拿出由 IP 指向的字节码，根据字节码格式进行解码，然后执行字节码。 虚拟机的实现方式：虚拟机有两种不同的实现方式：基于栈的虚拟机和基于寄存器的虚拟机。Lua 是基于寄存器虚拟机的语言。 区别： 在基于栈的虚拟机中，字节码的操作数是从栈顶上弹出（pop），在执行完操作后再压入栈顶的，这样的缺点是会多出几条指令来准备数据，优点是指令中不需要关心操作数的地址，在执行操作之前就已经将操作数准备在栈顶上了。 在基于寄存器的指令中，操作数是放在“CPU 的寄存器”中，因此，同样的操作不再需要 PUSH、POP 指令，取而代之的是在字节码中带上具体操作数所在的寄存器地址。对比需要栈的寄存器，这里的指令数会减少，但缺点是此时程序需要关注操作数所在的位置。 实现一个脚本语言的解释器： 设计一套字节码，分析源代码文件生成字节码。 在虚拟机中执行字节码。 如何在整个执行过程中保存整个执行环境。 执行Lua文件调用的是luaL_dofile 函数： 12#define luaL_dofile(L, fn) \ (luaL_loadfile(L, fn) || lua_pcall(L, 0, LUA_MULTRET, 0)) 其中 luaL_loadfile 函数用于进行词法和语法分析，lua_pcall 用于将第一步中分析的结果（字节码）放在虚拟机中执行。 luaL_loadfile 函数，通过lua_load，luaD_protectedparser，最终调用 f_parser 函数： 1234567891011121314151617// ldo.cstatic void f_parser (lua_State *L, void *ud) &#123; LClosure *cl; struct SParser *p = cast(struct SParser *, ud); int c = zgetc(p-&gt;z); /* read first character */ if (c == LUA_SIGNATURE[0]) &#123; checkmode(L, p-&gt;mode, "binary"); cl = luaU_undump(L, p-&gt;z, &amp;p-&gt;buff, p-&gt;name); &#125; else &#123; checkmode(L, p-&gt;mode, "text"); cl = luaY_parser(L, p-&gt;z, &amp;p-&gt;buff, &amp;p-&gt;dyd, p-&gt;name, c); &#125; lua_assert(cl-&gt;nupvalues == cl-&gt;p-&gt;sizeupvalues); luaF_initupvals(L, cl);&#125; 完成词法分析之后，返回了 Proto 类型的指针tf，然后将其绑定在新创建的 Closure 指针上，初始化 Upvalue，最后压入栈中。 词法分析之后产生的字节码等相关数据都在这个 Proto 类型的结构体中，而这个数据又作为 Closure 保存了下来。 lua_pcall 内部调用了lua_pcallk函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344// lapi.cLUA_API int lua_pcallk (lua_State *L, int nargs, int nresults, int errfunc, lua_KContext ctx, lua_KFunction k) &#123; struct CallS c; int status; ptrdiff_t func; lua_lock(L); api_check(k == NULL || !isLua(L-&gt;ci), "cannot use continuations inside hooks"); api_checknelems(L, nargs+1); api_check(L-&gt;status == LUA_OK, "cannot do calls on non-normal thread"); checkresults(L, nargs, nresults); if (errfunc == 0) func = 0; else &#123; StkId o = index2addr(L, errfunc); api_checkstackindex(errfunc, o); func = savestack(L, o); &#125; c.func = L-&gt;top - (nargs+1); /* function to be called */ if (k == NULL || L-&gt;nny &gt; 0) &#123; /* no continuation or no yieldable? */ c.nresults = nresults; /* do a 'conventional' protected call */ status = luaD_pcall(L, f_call, &amp;c, savestack(L, c.func), func); &#125; else &#123; /* prepare continuation (call is already protected by 'resume') */ CallInfo *ci = L-&gt;ci; ci-&gt;u.c.k = k; /* save continuation */ ci-&gt;u.c.ctx = ctx; /* save context */ /* save information for error recovery */ ci-&gt;extra = savestack(L, c.func); ci-&gt;u.c.old_errfunc = L-&gt;errfunc; L-&gt;errfunc = func; setoah(ci-&gt;callstatus, L-&gt;allowhook); /* save value of 'allowhook' */ ci-&gt;callstatus |= CIST_YPCALL; /* function can do error recovery */ luaD_call(L, c.func, nresults, 1); /* do the call */ ci-&gt;callstatus &amp;= ~CIST_YPCALL; L-&gt;errfunc = ci-&gt;u.c.old_errfunc; status = LUA_OK; /* if it is here, there were no errors */ &#125; adjustresults(L, nresults); lua_unlock(L); return status;&#125; 可以看到，首先获取需要调用的函数指针： 1c.func = L-&gt;top - (nargs+1); /* function to be called */ 这里的 nargs 是由函数参数传入的，在 lual_dofile 中调用 lua_pcall 时，这里传入的参数是 0。换句话说，这里得到的函数对象指针就是前面 f_parser 函数中最后两句代码放入 Lua 栈的 Closure 指针。 继续向下执行，在调用函数 luaD_pcall 时，最终会执行到 luaD_call 函数，其中有： 12if (!luaD_precall(L, func, nResults)) /* is a Lua function? */ luaV_execute(L); /* call it */ 首先调用 luaD_precall 函数进行执行前的准备工作： 1234567891011121314151617181920212223242526272829303132333435/*** returns true if function has been executed (C function) ...部分有省略*/int luaD_precall (lua_State *L, StkId func, int nresults) &#123; lua_CFunction f; CallInfo *ci; int n; /* number of arguments (Lua) or returns (C) */ ptrdiff_t funcr = savestack(L, func); switch (ttype(func)) &#123; ... case LUA_TLCL: &#123; /* Lua function: prepare its call */ StkId base; Proto *p = clLvalue(func)-&gt;p; ... ci = next_ci(L); /* now 'enter' new function */ ci-&gt;nresults = nresults; ci-&gt;func = func; ci-&gt;u.l.base = base; ci-&gt;top = base + p-&gt;maxstacksize; lua_assert(ci-&gt;top &lt;= L-&gt;stack_last); ci-&gt;u.l.savedpc = p-&gt;code; /* starting point */ ci-&gt;callstatus = CIST_LUA; L-&gt;top = ci-&gt;top; luaC_checkGC(L); /* stack grow uses memory */ if (L-&gt;hookmask &amp; LUA_MASKCALL) callhook(L, ci); return 0; &#125; ... &#125;&#125; 从 lua_State 的 CallInfo 数组中得到一个新的 CallInfo 结构体，设置它的func、base、top 指针 从前面分析阶段生成的 Closure 指针中，取出保存下来的 Proto 结构体。这个结构体中保存的是分析过程完结之后生成的字节码等信息。 将这里创建的 CallInfo 指针的 top、base 指针赋给 lua_State 结构体的 top、base 指针。将 Proto 结构体的 code 成员赋值给 lua_State 指针的 savedpc 字段，code 成员保留的就是字节码。 将多余的函数参数赋值为 nil，比如一个函数定义中需要的是两个参数，实际传入的只有一个，那么多出来的那个参数会被赋值为 nil。 执行完 luaD_precall 函数之后，接着会进入 luaV_execute 函数，这里是虚拟机执行代码的主函数： 1234567891011121314151617181920212223// lvm.cvoid luaV_execute (lua_State *L) &#123; CallInfo *ci = L-&gt;ci; LClosure *cl; TValue *k; StkId base; newframe: /* reentry point when frame changes (call/return) */ lua_assert(ci == L-&gt;ci); cl = clLvalue(ci-&gt;func); k = cl-&gt;p-&gt;k; base = ci-&gt;u.l.base; /* main loop of interpreter */ for (;;) &#123; Instruction i = *(ci-&gt;u.l.savedpc++); StkId ra; if ((L-&gt;hookmask &amp; (LUA_MASKLINE | LUA_MASKCOUNT)) &amp;&amp; (--L-&gt;hookcount == 0 || L-&gt;hookmask &amp; LUA_MASKLINE)) &#123; Protect(luaG_traceexec(L)); &#125; /* WARNING: several calls may realloc the stack and invalidate 'ra' */ ra = RA(i); /* 后面是各种字节码的处理流程 */&#125; 这里的 ci-&gt;u.l.savedpc存放的是虚拟机 OpCode 代码，这部分从 L-&gt;savepc 初始化而来，而 L-&gt;savepc 在 luaD_precall 中赋值。可以看到，luaV_execute 函数最主要的作用就是一个大循环，将当前传入的指令依次执行。 执行完毕后，会调用 luaD_poscall 函数恢复到上一次函数调用的环境。 1234567891011121314151617181920212223int luaD_poscall (lua_State *L, StkId firstResult) &#123; StkId res; int wanted, i; CallInfo *ci = L-&gt;ci; if (L-&gt;hookmask &amp; (LUA_MASKRET | LUA_MASKLINE)) &#123; if (L-&gt;hookmask &amp; LUA_MASKRET) &#123; ptrdiff_t fr = savestack(L, firstResult); /* hook may change stack */ luaD_hook(L, LUA_HOOKRET, -1); firstResult = restorestack(L, fr); &#125; L-&gt;oldpc = ci-&gt;previous-&gt;u.l.savedpc; /* 'oldpc' for caller function */ &#125; res = ci-&gt;func; /* res == final position of 1st result */ wanted = ci-&gt;nresults; L-&gt;ci = ci = ci-&gt;previous; /* back to caller */ /* move results to correct place */ for (i = wanted; i != 0 &amp;&amp; firstResult &lt; L-&gt;top; i--) setobjs2s(L, res++, firstResult++); while (i-- &gt; 0) setnilvalue(res++); L-&gt;top = res; return (wanted - LUA_MULTRET); /* 0 iff wanted == LUA_MULTRET */&#125; 虚拟机执行流程： 在f_parser函数中，对代码文件的分析返回了Proto指针。这个指针会保存在Closure指针中，留待后续继续使用。 在luaD_precall函数中，将lua_state的savedpc指针指向第一步中Proto结构体的code指针，同时准备好函数调用时的栈信息。 在luaV_execute函数中，pc指针指向第二步的savedpc指针（Lua5.3中似乎直接使用的savedpc指针），紧跟着就是一个大的循环体，依次取出其中的OpCode执行。 执行完毕后，调用luaD_poscall函数恢复到上一个函数的环境。 虚拟机指令执行的两大入口如下： 词法、语法分析阶段的luaY_parser，Lua一次遍历脚本文件完成了词法分析和语法分析，生成的OpCode存放在Proto结构体的code数组中。 luaV_execute：虚拟机执行指令阶段的入口函数，取出第一步生成的Proto结构体中的指令执行。 Proto结构体中的数据： 函数的常量数组 编译生成的字节码信息 函数的局部变量信息 保存upvalue名字的数组 1234567891011121314151617181920212223242526/*** Function Prototypes*/typedef struct Proto &#123; CommonHeader; lu_byte numparams; /* number of fixed parameters */ lu_byte is_vararg; lu_byte maxstacksize; /* maximum stack used by this function */ int sizeupvalues; /* size of 'upvalues' */ int sizek; /* size of 'k' */ int sizecode; int sizelineinfo; int sizep; /* size of 'p' */ int sizelocvars; int linedefined; int lastlinedefined; TValue *k; /* constants used by the function */ Instruction *code; struct Proto **p; /* functions defined inside the function */ int *lineinfo; /* map from opcodes to source lines (debug information) */ LocVar *locvars; /* information about local variables (debug information) */ Upvaldesc *upvalues; /* upvalue information */ struct LClosure *cache; /* last created closure with this prototype */ TString *source; /* used for debug information */ GCObject *gclist;&#125; Proto; 该程序最终会调用 luaV_execute() 函数执行，开始会初始化 global_State、lua_State 两个结构体，用来保存上下文的相关信息。 12345678910111213main() |-luaL_newstate() # 创建global_State+lua_State，并初始化 |-lua_pcall() # 实际会调用pmain()函数 | # 根据不同的参数调用不同的函数 |-runargs() # 执行命令行通过-e指定的命令 |-doREPL() # 执行交互模式，也即read-eval-print loop |-handle_script() # 执行lua脚本 |-luaL_loadfile() # 加载lua文件，后面详细介绍 | |-lua_load() | |-docall() # 调用执行 |-lua_pcall() |-luaD_pcall() # 实际会调用f_call()函数 在调用函数执行过程中，最终会调用 luaV_execute() 函数。其中，主要处理字节码的是 for(;;){} 循环，也即进入到解释器的主循环，处理很简单，取得当前指令，pc 递增，初始化 ra，然后根据指令的操作码进行选择；然后接下来是一大串的 switch … case … 处理。 接下来对其中有主要的几类指令进行说明。 关于define部分符号用法详见：https://www.jianshu.com/p/e9f00097904a，先转一个，有时间了再写。 另一个参考：https://gcc.gnu.org/onlinedocs/cpp/Macros.html#Macros]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua与C交互相关]]></title>
    <url>%2F2019%2F08%2F16%2FLua%2FLua%E4%B8%8EC%E4%BA%A4%E4%BA%92%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[C语言API总览。 C语言和Lua语言的两种交互形式： C语言拥有控制权，而Lua语言被用作库，这种交互形式中的C代码被称为应用代码。 Lua语言拥有控制权，而C语言被用作库，此时的C代码被称为库代码。 应用代码和库代码都适用相同的API和Lua语言通信，这些API称为C API。 一个简单的独立解释器：1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include "lua.h"#include "lauxlib.h"#include "lualib.h"int main(void)&#123; char buff[256]; int error; lua_State *L = luaL_newstate(); /* 打开Lua */ luaL_openlibs(L); /* 打开标准库 */ while(fgets(buuff,sizeof(buff),stdin) != NULL) &#123; error = luaL_loadstring(L,buff) || lua_pcall(L,0,0,0); if(error) &#123; fprintf(stderr,"%s\n",lua_tostring(L,-1)); lua_pop(L,1); /* 从栈中弹出错误信息 */ &#125; &#125; lua_close(L); return 0;&#125; 头文件lua.h声明了Lua提供的基础函数，其中包括创建新Lua环境的函数、调用Lua函数的函数、读写环境中的全局变量的函数，以及注册供Lua语言调用的新函数的函数，等等。其中声明的所有内容都有一个前缀lua_。 头文件lauxlib.h声明了辅助库所提供的函数，其中所有的声明均以luaL_开头。 头文件lualib.h中声明了用于打开这些库的函数。 栈：Lua和C之间通信的主要组件是虚拟栈，几乎所有的API的调用都是在操作这个栈中的值，Lua和C之间所有的数据交换都是通过这个栈完成的，此外，还可以利用栈保存中间结果。 为了解决动态类型和静态类型体系之间不匹配，以及自动内存管理和手动内存管理之间不匹配：Lua API中没有定义任何类似于lua_Value的类型，而是使用栈在Lua和C之间交换数据。栈中的每个元素都能保存Lua中任意类型的值。当我们想要从Lua中获取一个值时，只需调用Lua，Lua就会将指定的值压入栈中。当想要将一个值传给Lua时，首先要将这个值压入栈，然后调用Lua将其从栈中弹出即可。这需要每个C语言类型都有一个函数将其压入栈，还需要每个类型都有一个弹出的函数，但是避免了过多的组合，另外由于这个栈是Lua状态的一部分，因此垃圾收集器知道C语言正在使用哪些值。 压入元素：针对每一种能用C语言直接表示的Lua数据类型，C API中都有一个对应的压栈函数。 对栈空间的检查可以使用int lua_checkstack(lua_State *L,int sz);这里，sz是我们所需的额外栈位置的数量，如果可能，函数 lua_checkstack 会增加栈的大小，以容纳所需的额外空间；否则该函数返回0。 查询元素：第一个被压入栈的元素索引为1，第二个被压入的元素索引为2，依此类推。也可以使用负数索引来访问栈中的元素，栈顶的元素为-1，-2表示在它之前被压入栈中的元素。 与Lua栈相关的函数游一系列，在此不做赘述。 使用C API进行错误处理：处理应用程序中的错误：Lua语言通常通过长跳转来提示错误，但是如果没有相应的setjmp，解释器就无法进行长跳转。此时，API中的任何错误都会导致Lua调用紧急函数。当这个函数返回后，应用就会退出。 要正确的处理应用代码中的错误，就必须通过Lua语言调用我们自己的代码，即在setjmp的上下文中运行代码。 我们可以把C代码封装到一个函数F中，然后使用lua_pcall调用这个函数F，通过这种方式，我们的C代码会在保护模式下运行。即便发生内存分配失败，函数lua_pcall也会返回一个对应的错误码，使解释器能够保持一致的状态： 1234567891011static int foo(lua_State *L)&#123; //code to run in protected mode return 0;&#125;int secure_foo(lua_State *L)&#123; lua_pushcfunction(L,foo); return (lua_pcall(L,0,0,0) == 0)&#125; 无论发生什么，调用secure_foo时都会返回一个布尔值，来表示foo执行是否成功。 处理库代码中的错误：当C语言库中的函数检测到错误时，只需简单的调用lua_error即可。 内存分配：Lua语言核心对内存分配不进行任何假设，只会通过一个分配函数来分配和释放内存，当用户创建lua状态时必须提供该函数。 luaL_newstate是一个用默认分配函数来创建Lua状态的辅助函数。该默认分配函数使用了来自C语言标准函数库的标准函数malloc-realloc-free，对于大多数应用程序来说已经够了，但是，要完全控制Lua的内存分配也很容易，使用原始的lua_newstate来创建我们自己的Lua状态即可： 1lua_State *lua_newstate(lua_Alloc f,void *ud) 该函数有两个参数：一个是分配函数，另一个是用户数据。用这种方式创建的Lua状态会通过调用f完成所有的内存分配和释放，甚至结构lua_State也是由f分配的。 分配函数f必须满足lua_Alloc的类型声明： 1234typedef void *(*lua_Alloc)(void *ud, // 为lua_newstate所提供的用户数据 void *ptr, // 正要被分配或者释放的块的地址 size_t osize, // 原始块的大小 size_t nsize); // 请求的块大小 如果ptr不是NULL，则lua会保证其之前被分配的大小就是osize。 当nsize为0时，分配函数必须释放ptr指向的块并返回NULL，对应于所要求的大小为零的块。当ptr时NULL时，该函数必须分配并返回一个指定大小的块；如果无法分配指定的块，则必须返回NULL。 pcall：在调用函数lua_pcall时，第二个参数表示传递的参数数量，第三个参数是期望的结果数量，第四个参数代表错误处理函数。就像Lua语言的赋值一样，函数lua_pcall会根据所要求的数量来调整返回值的个数，即压入nil或丢弃多余的结果。在压入结果前，lua_pcall会把函数和其参数从栈中移除。当一个函数返回多个结果时，那么第一个结果最后被压入。 在Lua中调用C语言：当Lua调用C函数时，我们必须注册该函数，即必须以一种恰当的方式为Lua提供该C函数的地址。Lua调用C函数时，也使用了一个与C语言调用Lua函数时相同类型的栈，C函数从栈中获取参数，并将结果压入栈中。 这个栈不是一个全局结构；每个函数都有其私有的局部栈。当Lua调用一个C函数时，第一个参数总是位于这个局部栈中索引为1的位置。即使一个C函数调用了Lua代码，而且Lua代码又再次调用了同一个的C函数，这些调用每一个都只会看到本次调用自己的私有栈，其中索引为1的位置上就是第一个参数。 所有在Lua中注册的函数都必须使用一个相同的原型，该原型就是定义在lua.h中的lua_CFunction： 1typedef int (*lua_CFunction)(lua_State *L) 在Lua中，调用这个函数前，还必须通过lua_pushcfunction注册该函数。函数lua_pushcfunction会获取一个指向C函数的指针，然后在Lua中创建一个“function”类型，代表待注册的函数。一旦完成注册，C函数就可以像其他Lua函数一样行事了。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua源码阅读：基本数据类型Table]]></title>
    <url>%2F2019%2F08%2F12%2FLua%2FLua%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8BTable%2F</url>
    <content type="text"><![CDATA[Lua中Table数据结构的定义、初始化、查找等。 Table数据结构的定义：123456789101112131415161718192021222324typedef union TKey &#123; struct &#123; TValuefields; int next; /* for chaining (offset for next node) */ &#125; nk; TValue tvk;&#125; TKey;typedef struct Node &#123; TValue i_val; TKey i_key;&#125; Node;typedef struct Table &#123; CommonHeader; lu_byte flags; /* 1&lt;&lt;p means tagmethod(p) is not present */ lu_byte lsizenode; /* log2 of size of 'node' array */ unsigned int sizearray; /* size of 'array' array */ TValue *array; /* array part */ Node *node; Node *lastfree; /* any free position is before this position */ struct Table *metatable; GCObject *gclist;&#125; Table; Table的结构中有CommonHeader成员，这是一个在lObject.h中定义的宏，包含了一些成员，所有受gc管理的对象均含有CommonHeader，其继承自GObject对象。CommonHeader 相当于来自父类的数据，在整个结构的最前面，其他成员相当于子类数据。通过这种方式可以让GCObject 指针指向所有受gc管理的lua的对象，并且CommonHeader 结构中还有当前对象的类型，可以转换成具体类型的对象。 12345/*** Common Header for all collectable objects (in macro form, to be** included in other objects)*/#define CommonHeader GCObject *next; lu_byte tt; lu_byte marked TValue是所有lua数据类型的集合，其包含一个类型_tt和一个value，Value类型是一个union，可以是lua的任意类型： 12345678910111213141516171819202122/*** Tagged Values. This is the basic representation of values in Lua,** an actual value plus a tag with its type.*/#define TValuefields Value value_; int tt_typedef struct lua_TValue TValue;union Value &#123; GCObject *gc; /* collectable objects */ void *p; /* light userdata */ int b; /* booleans */ lua_CFunction f; /* light C functions */ lua_Integer i; /* integer numbers */ lua_Number n; /* float numbers */&#125;;struct lua_TValue &#123; TValuefields;&#125;; Table主要有两部分，数组和哈希： array和node是两个一维数组，array是普通的数组，成员为TValue，node是一个hash表存放key,value键值对。node的key为TKey类型，Tkey是一个union，当没有hash冲突的时候是一个TValue，当有hash冲突的时候TKey是一个struct，多一个next值，指向下一个有冲突的节点。 1234567891011121314151617181920typedef union TKey &#123; struct &#123; TValuefields; int next; /* for chaining (offset for next node) */ &#125; nk; TValue tvk;&#125; TKey;/* copy a value into a key without messing up field 'next' */#define setnodekey(L,key,obj) \ &#123; TKey *k_=(key); const TValue *io_=(obj); \ k_-&gt;nk.value_ = io_-&gt;value_; k_-&gt;nk.tt_ = io_-&gt;tt_; \ (void)L; checkliveness(G(L),io_); &#125;typedef struct Node &#123; TValue i_val; TKey i_key;&#125; Node; sizearray：是数组array的大小 lsizenode：2^lsizenode 的值为node 的大小 lastfree：lastfree 指针的右边均由非空的或者不能访问的node (即不属于自己的空间，访问会越界)组成 metatable ：元表 gclist：与gc 有关，将table加入到gray表中时，gclist指向gray表中的下一个元素或者NULL flags : 这是一个byte类型的数据，用于表示这个表中提供了哪些元方法，最开始的flag为1，当查找了一次之后，如果该表中存在某个元方法，那么将该元方法对应的flag bit置为0，这样下一次查找时只需要比较这个bit就行了。每个元方法对应的bit定义在ltm.h中 。 Table的初始化：12345678910Table *luaH_new (lua_State *L) &#123; GCObject *o = luaC_newobj(L, LUA_TTABLE, sizeof(Table)); Table *t = gco2t(o); t-&gt;metatable = NULL; t-&gt;flags = cast_byte(~0); t-&gt;array = NULL; t-&gt;sizearray = 0; setnodevector(L, t, 0); return t;&#125; 首先，为Table开辟空间，然后将其加到allgc链表上通过gc进行管理，之后初始化Table的内容。 1234567891011121314151617181920212223242526272829303132static void setnodevector (lua_State *L, Table *t, unsigned int size) &#123; int lsize; if (size == 0) &#123; /* no elements to hash part? */ t-&gt;node = cast(Node *, dummynode); /* use common 'dummynode' */ lsize = 0; &#125; else &#123; int i; lsize = luaO_ceillog2(size); if (lsize &gt; MAXHBITS) luaG_runerror(L, "table overflow"); size = twoto(lsize); t-&gt;node = luaM_newvector(L, size, Node); for (i = 0; i &lt; (int)size; i++) &#123; Node *n = gnode(t, i); gnext(n) = 0; setnilvalue(wgkey(n)); setnilvalue(gval(n)); &#125; &#125; t-&gt;lsizenode = cast_byte(lsize); t-&gt;lastfree = gnode(t, size); /* all positions are free */&#125;#define dummynode (&amp;dummynode_)#define isdummy(n) ((n) == dummynode)static const Node dummynode_ = &#123; &#123;NILCONSTANT&#125;, /* value */ &#123;&#123;NILCONSTANT, 0&#125;&#125; /* key */&#125;; flag设置为全1表示没有元方法，node指向的不是NULL而是dummynode，dummynode是一个全局共享的对象（key和value均为nil），这样做可以减少NULL的判断：例如，刚初始化完table，需要查找一个key为“test”的对象，因为lsizenode为0，所以经过运算确定的位置肯定为node[0]，然后读取node[0].i_key和“test”的TKey进行比较，判断是否相同，node[0]是dummynode，所以比较结果肯定不相同，所以返回nil；如果node[0]为NULL，访问node[0]的时候必须先判断node[0]是否为NULL，否则直接访问会越界，dummynode的设计省去了NULL的判断。 Table的查找：因为table有两部分，数组和hash表，所以查找也分为两部分来进行： 在数组中查找，如果传入的key是integer类型，而且其值-1小于sizearray的话，在数组中查找。 其他情况在hash表中查找：计算出该key的散列值，根据此散列值访问Node数组得到散列桶所在的位置，遍历该散列桶下的所有链表元素，直到找到该key为止。 在Lua中除了nil，其他类型均可以作为表的key，那么table的key是如何与其array数组与hash表的下标对应的呢？ 对于array数组，如果是上述的第一种情况，则直接将key-1即得到了下标，对于hash表则需要将key转换成uint类型，然后通过计算得到下标。 通过运算将各类型转换为uint 类型的值，如将LUA_TNUMFLT 类型二进制数值转成以uint 型类 型表示，将LUA_TTABLE 的gc 指针转换为uint 类型， LUA_TSHRSTR 类型直接取其hash值，因为短字符串在构造时会计算其hash值，LUA_TLNGSTR 类型则需要通过hash函数计算其hash值。在 完成了对key 的hash运算以后，需要根据key 的hash值计算该key对应hash表中的哪个下标，计算的公式是: 1index = hash_value &amp; ((2^lsizenode) - 1) 其中2^lsizenode - 1 为一个二进制低位全为1 的值，和hash_value 相与可以保证hash_value超过2^lsizenode - 1 的部分为0，则得到的值一定在[0，(2^lsizenode) - 1] 区间内，此时key和hash 表的下标就对应了起来，并且不会越界。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/*** main search function*/const TValue *luaH_get (Table *t, const TValue *key) &#123; switch (ttype(key)) &#123; case LUA_TSHRSTR: return luaH_getstr(t, tsvalue(key)); case LUA_TNUMINT: return luaH_getint(t, ivalue(key)); case LUA_TNIL: return luaO_nilobject; case LUA_TNUMFLT: &#123; lua_Integer k; if (numisinteger(fltvalue(key), &amp;k)) /* index is int? */ return luaH_getint(t, k); /* use specialized version */ /* else go through */ &#125; default: &#123; Node *n = mainposition(t, key); for (;;) &#123; /* check whether 'key' is somewhere in the chain */ if (luaV_rawequalobj(gkey(n), key)) return gval(n); /* that's it */ else &#123; int nx = gnext(n); if (nx == 0) break; n += nx; &#125; &#125;; return luaO_nilobject; &#125; &#125;&#125;/*** search function for integers*/const TValue *luaH_getint (Table *t, lua_Integer key) &#123; /* (1 &lt;= key &amp;&amp; key &lt;= t-&gt;sizearray) */ if (l_castS2U(key - 1) &lt; t-&gt;sizearray) return &amp;t-&gt;array[key - 1]; else &#123; Node *n = hashint(t, key); for (;;) &#123; /* check whether 'key' is somewhere in the chain */ if (ttisinteger(gkey(n)) &amp;&amp; ivalue(gkey(n)) == key) return gval(n); /* that's it */ else &#123; int nx = gnext(n); if (nx == 0) break; n += nx; &#125; &#125;; return luaO_nilobject; &#125;&#125; Table的更新：table 更新也分两种情况: 通过上述查找的 value 如果不是 luaO_nilobject ，直接将 value 更改即可，即table的修改和删除(将值置为nil) 查找返回的是 luaO_nilobject ，即 key 在 table 中不存在时( table 的插入操作)需要先找一个空的槽，然后完成插入操作，如果找不到空槽则需要扩容。 散列表部分的数据组织是，首先计算数据的key所在的桶数组位置，这个位置称为mainposition。相同mainposition的数据以链表形式组织： 这部分的API包括luaH_set、luaH_setnum、luaH_setstr 这三个函数，它们的实际行为并不在其函数内部对 key 所对应的数据进行添加或者修改，而是返回根据该 key 查找到的 TValue 指针，由外部的使用者来进行实际的替换操作。 当找不到对应的 key 时，这几个 API 最终都会调用内部的 newkey 函数分配一个新的 key 来返回。 具体的更新操作如下： 如果查找一个空槽： 在lua Table中有一个lastfree指针，在更新时通过该指针寻找一个空槽，lastfree 指针在最开始的时候指向NULL ，当空间不够rehash 时，lastfree 指针指向 node 数组中最后不可用的空间，如node 数组size为4 其指向的就是4 的位置(从0开始)。当需要找一个空槽时，lastfree指针向左移，判断当前位置有没有被占用，即key 是否为nil ，如果被占用则继续左移，直到找到一个空槽，或者地址大于node 的地址，即移动到了node 的前一个，表示没有找到。这种方式可以保证lastfree的右边和当前指向的位置均不可用或者被占用，可以减少在查找空槽时对非nil元素的遍历。 冲突时谁移动： 记冲突位置为index ，找到的空槽位置为freeindex ，发生冲突位置的key 为oldkey ， 新的key 为newkey 。发生冲突时计算oldkey 的下标，如果值为index ，则将newkey 建立 到freeindex 位置处，如果oldkey 计算后不是index ，而是因为冲突被移动到index 位置的，则移动oldkey 的node到新的槽。 Tkey的Next如何设置： lua 中的Tkey 中添加了一个next 成员，通过next 可以查找冲突位置的所有元素。比如两个元素冲突了，冲突位置为index (下标，后面的freeindex 也是下标)，这两个元素分别 为node1 、node2 ，假设将node1 移动到了另一个位置freeindex ，那么node2 则在index位置，node2 的next 为freeindex 减去index ，当需要查找node1 时，通过hash 运算找到是node2 ，比较发现不是要找的元素，此时可以通过index + next 找到freeindex 的位置，继续比较判断发现是node1 则返回结果。这种方式可以减少查找时对非冲突元素的遍 历，加快查找效率，不过也有弊端就是每个节点占用的空间会增减四个字节。 Table的扩容：rehash操作是hash 表不可避免的，当空间不够时就需要进行扩容，而扩容后每个元素的下标就需要重新计算。对于一般的开放地址法会有一个负载因子 ，当负载因子大于某个值的时候就需要扩容，这个是为了考虑效率问题，当负载因子越来越大的时候，元素之间冲突的可能性会越来越大，导致插入和查找的时间复杂度会增大所以需要扩容降低负载因子。lua 的table没有负载因子，而是当node 的所有空间都用完的时候才会扩容(被置为nil 也算，lastfree指针不会向右移动，而判断满的条件就是lastfree 已经到了第一个元素的位置)。 1234567891011121314151617181920/*** nums[i] = number of keys 'k' where 2^(i - 1) &lt; k &lt;= 2^i*/static void rehash (lua_State *L, Table *t, const TValue *ek) &#123; unsigned int nasize, na; unsigned int nums[MAXABITS + 1]; int i; int totaluse; for (i = 0; i &lt;= MAXABITS; i++) nums[i] = 0; /* reset counts */ nasize = numusearray(t, nums); /* count keys in array part */ totaluse = nasize; /* all those keys are integer keys */ totaluse += numusehash(t, nums, &amp;nasize); /* count keys in hash part */ /* count extra key */ nasize += countint(ek, nums); totaluse++; /* compute new size for array part */ na = computesizes(nums, &amp;nasize); /* resize the table to new computed sizes */ luaH_resize(L, t, nasize, totaluse - na);&#125; 扩容前会先统计table中的数量，将其存至nasize中；建立了一个大小为32的数组并且初始化为0，然后统计array数组中不为nil的元素个数，统计时通过分段的方式进行统计，将所有的元素按(2\^(i-1),2\^i]分段，分为32 个区间段：(0.5, 1]、(1, 2]、(2, 4]、 (4, 8] ……，统计步骤如下： 分配一个位图 nums，将其中的所有位置 0。这个位图的意义在于：nums 数组中第 i 个元素存放的是 key 在 2^(i-1)和 2^i 之间的元素数量。 遍历 Lua 表中的数组部分，计算其中的元素数量，更新对应的 nums 数组中的元素数量（numusearray函数）。 遍历 Lua 表中的散列桶部分，因为其中也可能存放了正整数，需要根据这里的正整数数量更新对应的 nums 数组元素数量（numusehash 函数）。 此时nums 数组已经拥有了当前这个 Table 中所有正整数的分配统计，逐个遍历 nums 数组，获得其范围区间内所包含的整数数量大于 50%的最大索引，作为重新散列之后的数组大小，超过这个范围的正整数，就分配到散列桶部分了（computesizes 函数） 根据上面计算得到的调整后的数组和散列桶大小调整表（resize 函数）。 调整标准：希望在调整过后，数组在每一个二次方位置容纳的元素数量都超过该范围的 50%。能达到这个目标的话，我们就认为这个数组范围发挥了最大的效率。 重新散列的代价与解决：1234local a = &#123;&#125;for i = 1,3 do a[i] = trueend 最开始，Lua 创建了一个空表 在第一次迭代中，a[1]为 true 触发了一次重新散列操作，将数组部分长度设置为 2^0，即 1，散列表部分仍为空。 在第二次迭代中，a[2]为 true 触发了一次重新散列操作，将数组部分长度设置为 2^1，即 2。 最后一次迭代中，a[3]又触发了一次重新散列操作，将数组部分长度设置为 2^2，即 4。 如果有很多很小的表要进行创建，则会对开销造成巨大的影响——可以预先填充以避免重新散列操作。 Table 的迭代：12345678910111213141516171819202122232425int luaH_next (lua_State *L, Table *t, StkId key) &#123; unsigned int i = findindex(L, t, key); /* find original element */ for (; i &lt; t-&gt;sizearray; i++) &#123; /* try first array part */ if (!ttisnil(&amp;t-&gt;array[i])) &#123; /* a non-nil value? */ setivalue(key, i + 1); setobj2s(L, key+1, &amp;t-&gt;array[i]); return 1; &#125; &#125; for (i -= t-&gt;sizearray; cast_int(i) &lt; sizenode(t); i++) &#123; /* hash part */ if (!ttisnil(gval(gnode(t, i)))) &#123; /* a non-nil value? */ setobj2s(L, key, gkey(gnode(t, i))); setobj2s(L, key+1, gval(gnode(t, i))); return 1; &#125; &#125; return 0; /* no more elements */&#125;/* 在数组部分查找数据： 查找成功，则返回该 key 的下一个数据 否则在散列桶部分查找数据： 查找成功，则返回该 key 的下一个数据*/ 一开始进入 findindex 函数，返回一个整数索引，如果这个索引在表的 sizearray 之内，则说明落入到数组部分，否则就落入到散列桶部分。 Table 取长度操作：对Lua 中的表进行取长度的操作时，如果没有提供该表的原方法 _len，那么该操作只针对该表的序列部分进行——序列指的是该表的一个子集{1…n}，n是一个正整数，其中每个键对应的数据都不为 nil。 123456789101112131415161718192021/*** Try to find a boundary in table 't'. A 'boundary' is an integer index** such that t[i] is non-nil and t[i+1] is nil (and 0 if t[1] is nil).*/int luaH_getn (Table *t) &#123; unsigned int j = t-&gt;sizearray; if (j &gt; 0 &amp;&amp; ttisnil(&amp;t-&gt;array[j - 1])) &#123; /* there is a boundary in the array part: (binary) search for it */ unsigned int i = 0; while (j - i &gt; 1) &#123; unsigned int m = (i+j)/2; if (ttisnil(&amp;t-&gt;array[m - 1])) j = m; else i = m; &#125; return i; &#125; /* else must find a boundary in hash part */ else if (isdummy(t-&gt;node)) /* hash part is empty? */ return j; /* that is easy... */ else return unbound_search(t, j);&#125; Table的元表：注意事项： 尽量不要在一个表中混用数组和散列桶部分，即一个表最好只存放一类数据。Lua 的实现上确实提供了两者统一表示的遍历，但这并不意味着使用者就应该混用这两种方式。 尽量不要在表中存放 nil 值，这会让取长度操作的行为不稳定。 尽量避免重新散列操作，因为这个操作的代价极大，通过预分配、只使用数组部分等策略规避这个 Lua 解释器背后的动作，能提升不少效率。 参考： 《lua 设计与实现》codedump 著]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua源码阅读：基本数据类型String]]></title>
    <url>%2F2019%2F08%2F08%2FLua%2FLua%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8BString%2F</url>
    <content type="text"><![CDATA[Lua中对于String的实现。 Lua使用TString结构体代表一个字符串对象。 12345678910111213141516171819/*** Header for string value; string bytes follow the end of this structure** (aligned according to 'UTString'; see next).*/typedef struct TString &#123; CommonHeader; lu_byte extra; /* reserved words for short strings; "has hash" for longs */ unsigned int hash; size_t len; /* number of characters in string */ struct TString *hnext; /* linked list for hash table */&#125; TString;/*** Ensures that address after this type is always fully aligned.*/typedef union UTString &#123; L_Umaxalign dummy; /* ensures maximum alignment for strings 用于最大字节对齐 */ TString tsv;&#125; UTString; hash用来记录字符串对应的哈希值，len用来记录字符串的长度。 在Lua中，分为长字符串和短字符串，长度大于40的是长字符串，小于40的是短字符串，这部分在luaconf.h中定义： 1234567/*@@ LUAI_MAXSHORTLEN is the maximum length for short strings, that is,** strings that are internalized. (Cannot be smaller than reserved words** or tags for metamethods, as these strings must be internalized;** #("function") = 8, #("__newindex") = 10.)*/#define LUAI_MAXSHORTLEN 40 对于短字符串，在实际使用中一般用来作为索引或需要进行字符串比较，存放在global_State-&gt;strt中，这个字符串表（strt）是一个stringtable类型的全局唯一的哈希表，当需要创建一个短字符串对象时，会首先在这个表中查找已有对象。所有的短字符串都是全局唯一的，不会存在两个相同的短字符串对象，如果短字符串对象的extra&gt;0，表示这是一个系统保留的字符串；长字符串一般用来存放文本数据，很少需要比较或者索引，所以长字符串被挂接到allgc链表上当作普通的对象来处理。 12345678910111213141516171819/*** new string (with explicit length) 生成新字符串的函数*/TString *luaS_newlstr (lua_State *L, const char *str, size_t l) &#123; if (l &lt;= LUAI_MAXSHORTLEN) /* short string? */ return internshrstr(L, str, l); else &#123; if (l + 1 &gt; (MAX_SIZE - sizeof(TString))/sizeof(char)) luaM_toobig(L); return createstrobj(L, str, l, LUA_TLNGSTR, G(L)-&gt;seed); &#125;&#125;/* 在global_State中存储的哈希表结构体 */typedef struct stringtable &#123; TString **hash; int nuse; /* number of elements 已装元素的个数 */ int size; /* 实际hash桶的大小 */&#125; stringtable; 对于短字符串，在创建的时候，首先计算str的哈希值。计算时会得到一个随机种子，这个种子就是global_State-&gt;seed，然后通过LUAI_HASHLIMIT控制步长，每一个步长范围内取字符串中的一个字符，和上次hash的结果相加，得到新的hash结果，计算出hash后，开始找是否存在这个字符串，方法是遍历global_State-&gt;strt-&gt;hash，短字符串表申请内存的大小和实际使用大小由后两个字段表示。 1234567891011121314151617181920212223242526272829303132333435363738/*** checks whether short string exists and reuses it or creates a new one** 检查短字符串的存在性，根据结果重用已存在的字符串或创建一个新的字符串*/static TString *internshrstr (lua_State *L, const char *str, size_t l) &#123; TString *ts; global_State *g = G(L); unsigned int h = luaS_hash(str, l, g-&gt;seed); TString **list = &amp;g-&gt;strt.hash[lmod(h, g-&gt;strt.size)]; for (ts = *list; ts != NULL; ts = ts-&gt;hnext) &#123; if (l == ts-&gt;len &amp;&amp; (memcmp(str, getstr(ts), l * sizeof(char)) == 0)) &#123; /* found! */ if (isdead(g, ts)) /* dead (but not collected yet)? */ changewhite(ts); /* resurrect it */ return ts; &#125; &#125; if (g-&gt;strt.nuse &gt;= g-&gt;strt.size &amp;&amp; g-&gt;strt.size &lt;= MAX_INT/2) &#123; luaS_resize(L, g-&gt;strt.size * 2); list = &amp;g-&gt;strt.hash[lmod(h, g-&gt;strt.size)]; /* recompute with new size */ &#125; ts = createstrobj(L, str, l, LUA_TSHRSTR, h); ts-&gt;hnext = *list; *list = ts; g-&gt;strt.nuse++; return ts;&#125;/* 对字符串按步长hash的函数 */unsigned int luaS_hash (const char *str, size_t l, unsigned int seed) &#123; unsigned int h = seed ^ cast(unsigned int, l); size_t l1; size_t step = (l &gt;&gt; LUAI_HASHLIMIT) + 1; for (l1 = l; l1 &gt;= step; l1 -= step) h = h ^ ((h&lt;&lt;5) + (h&gt;&gt;2) + cast_byte(str[l1 - 1])); return h;&#125;]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua中的垃圾回收机制]]></title>
    <url>%2F2019%2F08%2F07%2FLua%2FLua%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Lua中的垃圾回收机制：弱引用表，析构器和函数collectgarbage 垃圾收集：Lua语言使用自动内存管理，程序可以创建对象（表，闭包等），但却没有函数来删除对象。Lua语言通过垃圾收集自动的删除成为垃圾的对象。 弱引用表，析构器和函数collectgarbage是在Lua语言中用来辅助垃圾收集器的主要机制。弱引用表允许收集Lua语言中还可以被程序访问的对象；析构器允许收集不在垃圾收集器直接控制下的外部对象；函数collectgarbage则允许我们控制垃圾收集器的步长。 弱引用表：垃圾收集器不能猜测我们认为哪些是垃圾，程序不会再用到的、存储在全局变量中的对象，对于Lua语言来说不是垃圾，需要我们的代码将这些对象所在的位置赋为nil，以便这些位置不会锁定可释放的对象。 简单的清除引用并不够，有些情况下，还需要程序和垃圾收集器之间的协作——当我们要保存某种类型的活跃对象的列表时，只需要将新对象插入数组即可；但是，一旦一个对象成为了数组的一部分，即使没有其他任何地方在引用它，但数组依然在引用它，无法被回收。 弱引用表就是这样一种用来告知Lua语言一个引用不应阻止对一个对象回收的的机制。 所谓弱引用是一种不在垃圾收集器考虑范围内的对象引用。如果对一个对象的所有引用都是弱引用，那么垃圾收集器将会回收这个对象并删除这些弱引用。Lua通过弱引用表来实现弱引用，弱引用表就是元素均为弱引用的表，这意味着如果一个对象只被一个弱引用表持有，那么Lua语言最终会回收这个对象。 表由键值对组成，其两者都可以容纳任意类型的对象。在正常情况下，垃圾收集器不会回收一个在可访问表中作为键和值的对象。也就是说，键和值都是强引用，他们会阻止对其所指向对象的回收。在一个弱引用表中，键和值都可以是弱引用的。这就意味着有三种类型的弱引用表：具有弱引用键的表、具有弱引用值的表及同时具有弱引用键和值的表。不论是哪种类型的弱引用表，只要有一个键或值被回收了，那么对应的整个键值对都会被从表中删除。 一个表是否为弱引用表是由其元表中的__mode字段所决定的。当这个字段存在时，其值应为一个字符串：如果这个字符串是”k”，则说明这个表的键（key）是弱引用的，如果这个字符串是”v”，那么这个表的值是弱引用的；如果这个字符串是“kv”，那么这个表的键和值都是弱引用的。 只有对象可以从弱引用表中被移除，而像数字和布尔这样的“值”是不可回收的。 析构器：析构器是一个与对象关联的函数，当该对象即将被回收时该函数会被调用。 Lua语言通过元方法__gc实现析构器： 1234o = &#123;x = "hi"&#125;setmetatable(o,&#123;__gc = function(o) print(o.x) end&#125;)o = nilcollectgarbage() --&gt; hi 通过给对象设置一个具有非空__gc元方法的元表，就可以将一个对象标记为需要进行析构处理，如果不标记对象，那么对象就不会被析构。 当垃圾收集器在同一个周期中析构多个对象时，它会按照对象被标记为需要析构处理的顺序逆序调用这些对象的析构器。 析构器的另一个特点是复苏：当一个析构器被调用时，它的参数是正在被析构的对象。因此，这个对象会至少在析构期间重新变成活跃的，这叫做“临时复苏”；在析构器执行期间，我们无法阻止析构器把该对象存储在全局变量中，使得该对象在析构器返回后仍然可访问，这称为“永久复苏”。 由于复苏的存在，Lua语言会在两个阶段中回收具有析构器的对象。当垃圾收集器首次发现某个具有析构器的对象不可达的时候，垃圾收集器就把这个对象复苏，并将其放入等待被析构的队列中。一旦析构器开始执行，Lua语言就将该对象标记为已被析构，当下一次垃圾收集器又发现这个对象不可达时，它就将这个对象删除。 如果想保证我们程序中的所有垃圾都被真正的释放了的话，那么必须调用collectgarbage两次，第二次调用才会删除第一次调用中被析构的对象。 由于Lua语言在被析构对象上设置的标记，每一个对象的析构器都会精确的运行一次，如果一个对象直到程序运行结束还没有被回收，那么Lua语言就会在整个Lua虚拟机关闭后调用它的析构器。 另一个有趣的技巧会允许程序在每次完成垃圾回收后调用指定的函数。由于析构器只运行一次，所以这种技巧是让每个析构器创建一个用来运行下一个析构器的新对象。 具有析构器的对象和弱引用表之间的交互也有些微妙：在每个垃圾收集周期内，垃圾收集器会在调用析构器前清理弱引用表的值，在调用析构器之后再清理键。这种行为的原理在于我们经常使用带有弱引用键来保存对象的属性，因此，析构器可能需要访问那些属性。不过，我们也会使用具有弱引用值的表来重用活跃的对象，在这种情况下，正在被析构的对象就不再有用了。 垃圾收集器：一直到Lua5.0，Lua语言使用的都是一个简单的标记-清除式垃圾收集器，这种收集器又被称为全局暂停式的收集器，意味着Lua语言会时不时地停止主程序的运行来执行一次完整的垃圾收集周期。每一个垃圾收集周期由四个阶段组成：标记、清理、清除和析构。 标记阶段：把根结点集合（由Lua语言可以直接访问的对象组成）标记为活跃。在Lua语言中，这个集合只包括C注册表。保存在一个活跃对象中的对象是程序可达的，因此也会被标记为活跃（弱引用表中的内容除外），当所有可达对象都被标记为活跃后，标记阶段完成。 清理阶段：首先，Lua语言遍历所有被标记为需要进行析构、但又没有被标记为活跃状态的对象。这些没有被标记为活跃状态的对象会被标记为活跃（复苏），并被放在一个单独的列表中，这个列表会在析构阶段用到。然后，Lua语言遍历弱引用表并从中移除键或值未被标记的元素。 清除阶段：遍历所有对象（Lua 语言把所有创建的对象放在一个链表中），如果一个对象没有被标记为活跃，Lua语言就将其回收。否则，Lua语言清理标记，然后准备进行下一个清理周期。 析构阶段：Lua语言调用清理阶段被分离出的对象的析构器。 Lua5.1使用了增量式垃圾收集器。这种垃圾收集器像老版的垃圾收集器一样执行相同的步骤，但是不需要在垃圾收集期间停止主程序的运行：它与解释器一起交替运行，每当解释器分配了一定数量的内存时，垃圾收集器也执行一小步。 Lua5.2引入了紧急垃圾收集，当内存分配失败时，Lua语言会强制进行一次完整的垃圾收集，然后再次尝试分配。这些紧急情况可以发生在Lua语言进行内存分配的任意时刻，包括Lua语言处于不一致的代码执行状态时，因此，这些收集动作不能运行析构器。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua源码阅读：C API]]></title>
    <url>%2F2019%2F08%2F06%2FLua%2FLua%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%9AC%20API%2F</url>
    <content type="text"><![CDATA[Lua中关于C API的内容。 Iapi.cindex2addr：12345678910111213141516171819202122232425static TValue *index2addr (lua_State *L, int idx) &#123; CallInfo *ci = L-&gt;ci; if (idx &gt; 0) &#123; TValue *o = ci-&gt;func + idx; api_check(idx &lt;= ci-&gt;top - (ci-&gt;func + 1), "unacceptable index"); if (o &gt;= L-&gt;top) return NONVALIDVALUE; else return o; &#125; else if (!ispseudo(idx)) &#123; /* negative index */ api_check(idx != 0 &amp;&amp; -idx &lt;= L-&gt;top - (ci-&gt;func + 1), "invalid index"); return L-&gt;top + idx; &#125; else if (idx == LUA_REGISTRYINDEX) return &amp;G(L)-&gt;l_registry; else &#123; /* upvalues */ idx = LUA_REGISTRYINDEX - idx; api_check(idx &lt;= MAXUPVAL + 1, "upvalue index too large"); if (ttislcf(ci-&gt;func)) /* light C function? */ return NONVALIDVALUE; /* it has no upvalues */ else &#123; CClosure *func = clCvalue(ci-&gt;func); return (idx &lt;= func-&gt;nupvalues) ? &amp;func-&gt;upvalue[idx-1] : NONVALIDVALUE; &#125; &#125;&#125; 这个index2addr函数的作用就是通过给定的 index 参数取出对应的TValue类型的对象指针。 情况 执行 当 index &gt; 0 时 在当前function的栈空间找对应的TValue 当 LUA_REGISTRYINDEX &lt; index &lt;= 0 时 在当前function的栈空间逆向找对应的TValue 当LUA_REGISTRYINDEX == index 时 返回registry（注册表） 否则当 LUA_REGISTRYINDEX &gt; index 时 查找upvalues]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua源码阅读：标准库]]></title>
    <url>%2F2019%2F08%2F06%2FLua%2FLua%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%9A%E6%A0%87%E5%87%86%E5%BA%93%2F</url>
    <content type="text"><![CDATA[Lua标准库中定义的一些函数及其实现方式。 lmathlib.c从一个简单的math.Abs()函数开始： 12345678910static int math_abs (lua_State *L) &#123; if (lua_isinteger(L, 1)) &#123; lua_Integer n = lua_tointeger(L, 1); if (n &lt; 0) n = (lua_Integer)(0u - n); lua_pushinteger(L, n); &#125; else lua_pushnumber(L, l_mathop(fabs)(luaL_checknumber(L, 1))); return 1;&#125; 首先，先检查传入的值是否是int类型，这里调用了lapi.c中的lua_isinteger函数，检查传入值的TValue原始类型标签是否是LUA_TNUMINT，这部分的检查在lObject.h中定义的函数完成，同时数据类型LUA_TNUMINT也在lObject.h中定义： 12345/* Variant tags for numbers */#define LUA_TNUMFLT (LUA_TNUMBER | (0 &lt;&lt; 4)) /* float numbers */#define LUA_TNUMINT (LUA_TNUMBER | (1 &lt;&lt; 4)) /* integer numbers */// lObject.h 如果传入的值的TValue是int类型的（传入的值是lua_state类型的），调用lua_tointeger将传入的值转换为int类型（实际上是lua_Integer类型，其最根源是longlong类型的，在luaconf.h中定义），将其赋给n，如果n小于零，则用一个unsigned 0减去它，将其置为正数，最后将n存入到TValue中，将其存放在lua_state的栈顶。 如果不是int类型的，则检查其是否是一个number类型的值，如果是一个number则调用fabs，将其push栈，否则返回一个错误提示。 lstrlib.cstrlib中一部分是关于字符串的操作函数，一部分是关于模式匹配的函数，先挑选一个Reverse函数进行分析： 12345678910static int str_reverse (lua_State *L) &#123; size_t l, i; luaL_Buffer b; const char *s = luaL_checklstring(L, 1, &amp;l); char *p = luaL_buffinitsize(L, &amp;b, l); for (i = 0; i &lt; l; i++) p[i] = s[l - i - 1]; luaL_pushresultsize(&amp;b, l); return 1;&#125; 简单来说就是利用一个指针（index）来对字符数组进行逆序的赋值，从数组s中获取赋值给数组p。]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua源码阅读：目录及模块结构]]></title>
    <url>%2F2019%2F08%2F05%2FLua%2FLua%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%9A%E7%9B%AE%E5%BD%95%E5%8F%8A%E6%A8%A1%E5%9D%97%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[Lua源码阅读的第一期，主要内容：系列内容计划以及目录。 Lua源码阅读：本篇转载于LuaSource 目录 第一篇：目录及模块结构 第二篇：基本数据类型 第三篇：实用函数 第四篇：标准库 第五篇：C API lua.c12345678910111213141516int main (int argc, char **argv) &#123; int status, result; lua_State *L = luaL_newstate(); /* create state */ if (L == NULL) &#123; l_message(argv[0], "cannot create state: not enough memory"); return EXIT_FAILURE; &#125; lua_pushcfunction(L, &amp;pmain); /* to call 'pmain' in protected mode */ lua_pushinteger(L, argc); /* 1st argument */ lua_pushlightuserdata(L, argv); /* 2nd argument */ status = lua_pcall(L, 2, 1, 0); /* do the call */ result = lua_toboolean(L, -1); /* get result */ report(L, status); lua_close(L); return (result &amp;&amp; status == LUA_OK) ? EXIT_SUCCESS : EXIT_FAILURE;&#125; 模块结构Lua代码的模块概要介绍如下： 以下模块实现了一些实用函数： ldebug.c - 调试接口，包含功能有：访问调试钩子（lua_sethook、lua_gethook、lua_gethookcount）；访问运行时栈（lua_getstack、lua_getlocal、lua_setlocal）；检测字节码（luaG_checkopenop、luaG_checkcode）；抛出错误（luaG_typeerror、luaG_concaterror、luaG_aritherror、luaG_ordererror、luaG_errormsg、luaG_runerror） lzio.c - 通用的输入流接口 lmem.c - 内存管理接口。实现了luaM_realloc / luaM_growaux_ 两个函数，其中封装了内存分配函数 lgc.c - 增量的垃圾回收器 以下模块实现了基本的数据类型： lstate.c - 全局状态。包括打开、关闭Lua状态机（lua_newstate / lua_close）和线程（luaE_newthread / luaE_freethread）。 lobject.c - 一些操作Lua Object的通用函数。包括一些数据类型到字符串的互转函数，原生类型的相等性测试（luaO_rawequalObj），和以2为底的对数函数（luaO_log2） lstring.c - 字符串哈希表（管理了所有被Lua用到的字符串） lfunc.c - 一些用于操作函数原型(Proto）和闭包（Closure）的辅助函数 ltable.c - Lua的table实现 以下模块做语法解析和代码生成： lcode.c - 代码生成器，被lparser.c用到 llex.c - 词法分析器，被lparser.c用到 lparser.c - Lua语法解析器 lundump.c - 加载预编译的Lua代码块。实现了luaU_undump函数，此函数加载预编译的代码块。还提供了另外一个函数lua_header（被luaU_undump内部使用），用于加载代码块中的函数头信息。 ldump.c - 保存预编译的Lua代码块。实现了luaU_dump函数，些函数导出Lua函数为二进制形式的字符串 以下模块处理Lua字节码的执行： lopcodes.c - 定义Lua虚拟机的操作码。定义了所有操作码的名字和操作模式等信息（通过列表luaP_opnames、luaP_opmodes定义的） lvm.c - Lua虚拟机（luaV_execute），可执行Lua字节码。另外还暴露了一些被lapi.c用到的函数，比如：luaV_concat ldo.c - 函数调用栈。处理函数调用（luaD_call、luaD_pcall），栈空间增长，协程等 ltm.c - 元方法。实现从对象访问元方法的一些函数 以下模块实现标准库： lbaselib.c - 基础函数 lstrlib.c - 字符串函数 ltablib.c - 表函数 lmathlib.c - 数学函数 loslib.c - 系统函数 liolib.c - 输入输出、文件读写 loadlib.c - 包、模块 ldblib.c - 调试函数 以下模块定义了C API： lapi.c - Lua API。实现了大部分Lua C API（lua_* 系列函数） lauxlib.c - 定义了luaL_*系列函数 linit.c - 实现luaL_openlibs，这个函数中加载了所有的标准库函数 以下模块实现Lua和Luac两个程序： lua.c - Lua的独立解释器 print.c - 定义了“PrintFunction”函数，它可以打印出一个函数的字节码（可在Luac中使用 -l 选项） luac.c - Lua编译器（可保存字节码到文件中，也可在控制台列出字节码） 命名约定一个函数的前缀表明了它来自哪个模块 luaA_ - lapi.c luaB_ - lbaselib.c luaC_ - lgc.c luaD_ - ldo.c luaE_ - lstate.c luaF_ - lfunc.c luaG_ - ldebug.c luaH_ - ltable.c luaI_ - lauxlib.c luaK_ - lcode.c luaL_ - llauxlib.c/h linit.c luaM_ - lmem.c luaO_ - lobject.c luaP_ - lopcodes.c luaS_ - lstring.c luaT_ - ltm.c luaU_ - lundump.c luaV_ - lvm.c luaX_ - llex.c luaY_ - lparser.c luaZ_ - lzio.c lua_ - lapi.c/h + luaconfig.h, ldebug.c luai_ - luaconf.h luaopen_ - luaconf.h + libraries (lbaselib.c, ldblib.c, liolib.c, lmathlib.c, loadlib.c, loslib.c, lstrlib.c, ltablib.c) 参考： Lua源码阅读笔记 Lua有关的论文和The Lua Architecture从各个方面论述了Lua的实现 Lua VM指令在文档A No-Frills Introduction to Lua 5.1 VM Instructions中 Yueliang项目（用Lua实现Lua VM），其中的大量的源码注释，可以帮助理解相关的C代码 LuaAnnotate - C代码注释，注释单独存放在外部文件中，用某些文本工具可以将注释嵌入显示在代码中 stevedonovan.github.com/lua-5.1.4 包含LuaAnnotate注释的源码 可在http://www.lua.org/source/网站上浏览Lua源码]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[����ʼ�]]></title>
    <url>%2F2019%2F07%2F29%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%2FRayTracing-In-Weekend-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[����RayTracing In A Weekendһ���ʵ��ϸ�ڡ� Chapter1��Output an Image����һ��ppm�����������ص���XnView�� ��һ����������Ĵ��벢�������������õ�PPM��ʽ���ļ��Ļ�����Ҫ�ڴ��������д��txt�ļ��Ĵ��룺 1234567891011121314151617181920212223242526272829#include "pch.h"#include &lt;iostream&gt;#include &lt;fstream&gt;using namespace std;int main()&#123; int nx = 200; int ny = 100; ofstream outfile(".\\result\\FirstPicture.txt", ios_base::out); outfile &lt;&lt; "P3\n" &lt;&lt; nx &lt;&lt; " " &lt;&lt; ny &lt;&lt; "\n255\n"; for (int j = ny - 1; j &gt;= 0; j--) &#123; for (int i = 0; i &lt; nx; i++) &#123; float r = float(i) / float(nx); float g = float(j) / float(ny); float b = 0.2; int ir = int(255.99*r); int ig = int(255.99*g); int ib = int(255.99*b); outfile &lt;&lt; ir &lt;&lt; " " &lt;&lt; ig &lt;&lt; " " &lt;&lt; ib &lt;&lt; "\n"; std::cout &lt;&lt; ir &lt;&lt; " " &lt;&lt; ig &lt;&lt; " " &lt;&lt; ib &lt;&lt; "\n"; &#125; &#125; return 0;&#125; ��VmView�п��Կ�����Ӧ��ͼƬ�� Chapter2��The vec3 class������һ�����vec3��������� ����������ļӼ��˳�������������ļӼ��˳��������Ĳ������ȡ� 1234567891011inline float dot(const vec3 &amp;v1, const vec3 &amp;v2)&#123; return v1.e[0] * v2.e[0] + v1.e[1] * v2.e[1] + v1.e[2] * v2.e[2];&#125;inline vec3 cross(const vec3 &amp;v1, const vec3 &amp;v2)&#123; return vec3((v1.e[1] * v2.e[2] - v1.e[2] * v2.e[1]), (-(v1.e[0] * v2.e[2] - v1.e[2] * v2.e[0])), (v1.e[0] * v2.e[1] - v1.e[1] * v2.e[0]));&#125; Chapter3��Rays,a simple camera, and background�����������࣬�������������������ֱ𷵻�ԭ�㡢�����Լ����߱��������߱�����һ��Vec3��ʾ�� Chapter4:�����еĴ����м�����һ������������ཻ�ĺ���������������Դ�2D��������Բ���ཻ��⺯������ȥ���⡣ ����Ὣ����뵽������ͷ�ļ��С� 1234567891011121314151617181920212223242526272829bool sphere :: hit(const ray&amp; r, float t_min, float t_max, hit_record&amp; rec)const &#123; vec3 oc = r.origin() - center; float a = dot(r.direction(), r.direction()); float b = dot(oc, r.direction()); float c = dot(oc, oc) - radius * radius; float discriminant = b * b - a * c; if (discriminant &gt; 0) &#123; float temp = (-b - sqrt(b*b - a * c)) / a; if (temp &lt; t_max &amp;&amp; temp &gt; t_min) &#123; rec.t = temp; rec.p = r.point_at_parameter(rec.t); rec.normal = (rec.p - center) / radius; return true; &#125; temp = (-b + sqrt(b*b - a * c)) / a; if (temp&lt;t_max &amp;&amp; temp&gt;t_min) &#123; rec.t = temp; rec.p = r.point_at_parameter(rec.t); rec.normal = (rec.p - center) / radius; return true; &#125; &#125; return false;&#125; Chapter5��Surface normals and multiple objects.�����˶Է��߷�������㣬������Ӧ�����߼�⺯�����뵽�˶�Ӧ��ͷ�ļ��С� �����ĵ�����ĳ���������Ϊ�õ�ķ��߷��� ���ⶨ����һ���࣬�������㲢�洢�����������������һ����о�������ԭ�������һ���㡣 Chapter6��Antialasing��Ŀ��Ϊ����ݡ� �������������ÿ�������ص�Ϊ���ģ��������Ϊ1�ķ�Χ�ڲ���n�Σ���n��������ֵ����ƽ����Ϊ�õ����յ�����ֵ�� ������ͼ���������Ƶķ�ʽ����Ϊ��ֵ�˲��� 1234567891011vec3 col(0, 0, 0);for (int s = 0; s &lt; ns; s++)&#123; float random = rand() % (100) / (float)(100); float u = float(i + random) / float(nx); float v = float(j + random) / float(ny); ray r = cam.get_ray(u, v); vec3 p = r.point_at_parameter(2.0); col += color(r, world);&#125;col /= float(ns); Chapter7��Diffuse Materials��Ŀ��Ϊ��������ʡ� Pick a random point s from the unit radius sphere that is tangent to the hitpoint, and send a ray from the hitpoint p to the random point s. That sphere has center (p+N): �������е����еĵ�λ�뾶����ѡ��һ�������s������һ�����ߴ����е����������s������Ϊ��p+N�� ����������ǽ����䷽�����һ������ķ�����Ϊ������ķ��� 12345678910111213141516171819202122232425262728vec3 random_in_unit_sphere()&#123; vec3 p; do &#123; float random0 = rand() % (100) / (float)(100); float random1 = rand() % (100) / (float)(100); float random2 = rand() % (100) / (float)(100); p = 2.0*vec3(random0, random1, random2) - vec3(1, 1, 1); &#125; while (p.squared_length() &gt;= 1.0); return p;&#125;vec3 color(const ray&amp; r, hitable *world)&#123; hit_record rec; if (world-&gt;hit(r, 0.001, (numeric_limits&lt;float&gt;::max)(), rec)) &#123; vec3 target = rec.p + rec.normal + random_in_unit_sphere(); return 0.5*color(ray(rec.p,target - rec.p), world); &#125; else &#123; vec3 unit_direction = unit_vector(r.direction()); float t = 0.5*(unit_direction.y() + 1.0); return (1.0 - t)*vec3(1.0, 1.0, 1.0) + t * vec3(0.5, 0.7, 1.0); &#125;&#125; Chapter8��Metal�ڰ��¼����˼򵥵Ĳ��ʡ� ���Ƕ�����һ���򵥵��ʲ������������������һ���ʣ�����ġ����֡����������������ԡ����۹۲��ߵ��ӽ���Σ��ʲ�����Թ۲��ߵı������ȶ�����ͬ�ġ� 12345678910111213141516171819202122232425262728293031#ifndef LANBERTIANH#define LANBERTIANH#include "material.h"class lambertian :public material&#123;public: lambertian(const vec3&amp; a):albedo(a)&#123;&#125; virtual bool scatter(const ray&amp; r_in, const hit_record&amp; rec, vec3&amp; attenuation, ray&amp; scattered)const; vec3 albedo;&#125;;vec3 random_in_unit_sphere() &#123; vec3 p; do &#123; float random0 = rand() % (100) / (float)(100); float random1 = rand() % (100) / (float)(100); float random2 = rand() % (100) / (float)(100); p = 2.0*vec3(random0, random1, random2) - vec3(1, 1, 1); &#125; while (p.squared_length() &gt;= 1.0); return p;&#125;bool lambertian::scatter(const ray&amp; r_in, const hit_record&amp; rec, vec3&amp; attenuation, ray&amp; scattered) const &#123; vec3 target = rec.p + rec.normal + random_in_unit_sphere(); scattered = ray(rec.p, target - rec.p); attenuation = albedo; return true;&#125;#endif // !LANBERTIANH ע��ԭ��������������û���ҵ���Ӧ�����ã���������ݴ�������rand()���档 ����ԭ�黹������һ�����淴���࣬�����ķ��亯���ο����������� 1234vec3 reflect(const vec3&amp; v, const vec3&amp; n)&#123; return v - 2 * dot(v, n)*n;&#125; �ڱ��µ��������������һ��ģ���Ĳ��������ģ���Ĳ���ʹ�÷�����ߵķ�������һ������ƫ�ơ� Chapter9��Dielectrics��һ�µı���Ϊ����ʣ�ʵ������˵�������ݰ���������ˮ����͸���Ŀ���������ߵĲ��ʣ� 123456789101112bool refract(const vec3&amp; v, const vec3&amp; n, float ni_over_nt, vec3&amp; refracted)&#123; vec3 uv = unit_vector(v); float dt = dot(uv, n); float discriminant = 1.0 - ni_over_nt * ni_over_nt*(1 - dt * dt); if (discriminant &gt; 0) &#123; refracted = ni_over_nt * (uv - n * dt) - n * sqrt(discriminant); return true; &#125; else return false;&#125; ע�⣬���������жϰ���һ��ȫ���������� ��������Ĺ�ʽ��ο���˹��������) Chapter10��Positionable camera�ڵ�ʮ�£����Ƕ�����һ������͸�ӹ��ܵ�������ڹ۲쳡���� ��������λ�ã��۲췽��fov�ȡ� Chapter11��Defocus Blur��Ŀ�ķ���Ϊɢ��ģ�����������ͷ�ļ��м�����һ�����Ȧ�뽹�ർ�³���ģ���Ĺ��ܡ� Chapter12����ʮ��������һ���ܽ��������������˽�����Ҫ������һЩϸ�ڣ� You now have a cool ray tracer! What next? Lights. You can do this explicitly, by sending shadow rays to lights. Or it can be done implicitly by making some objects emit light, biasing scattered rays toward them, and then downweighting those rays to cancel out the bias. Both work. I am in the minority in favoring the latter approach. Triangles. Most cool models are in triangle form. The model I/O is the worst and almost everybody tries to get somebody else��s code to do this. Surface textures. This lets you paste images on like wall paper. Pretty easy and a good thing to do. Solid textures. Ken Perlin has his code online. Andrew Kensler has some very cool info at his blog. Volumes and media. Cool stuff and will challenge your software architecture. I favor making volumes have the hitable interface and probabilistically have intersections based on density. Your rendering code doesn��t even have to know it has volumes with that method. Parallelism. Run N copies of your code on N cores with different random seeds. Average the N runs. This averaging can also be done hierarchically where N/2 pairs can be averaged to get N/4 images, and pairs of those can be averaged. That method of parallelism should extend well into the thousands of cores with very little coding. Have fun, and please send me your cool images! ��������һ���ܿ��Ray Tracer�ˣ���ô�������أ� �ƣ�������ͨ����ƹⷢ����Ӱ��������ȷ��ִ�д˲���������������ͨ��ʹһЩ���巢������ʽ����ɡ� ��ɢ�����ƫ�����ǣ�Ȼ�������Щ�����Ե���ƫ����߶���Ч������Ϊ�������ϲ����һ���������ˡ� �����Σ�����ģ���������εġ�ģ��I/O�������ģ�����ÿ���˶���ͼ���Ʊ��˵Ĵ�����������һ�㣨I/O���� �����������������Խ�������ǽֽһ�����������ϡ��ǳ��򵥣�Ҳ��һ��ֵ��ȥ���ĺ��¡� ��̵������� Ken Perlin�����ṩ���Ĵ��롣 Andrew Kensler�����Ĳ�������һЩ�ǳ������Ϣ�� ����ý�塣�ܿ�Ķ���������ս���������ܹ������޳�ʹ�����пɵ����Ľ��棬���Ҹ����Ͼ��л����ܶȵĽ���㡣���ĳ��ִ�����������֪�������и÷����ľ����������Ҳ��Ǿ��������ɡ��� ���С�ʹ�ò�ͬ�����������N������������N�����븱����ƽ��N�����С�����ƽ��Ҳ���Էֲ�ε���ɣ�����N / 2�Կ��Ա�ƽ���Ի��N / 4��ͼ�񣬲��ҿ��Զ���Щͼ��ĶԽ���ƽ�������ֲ��з���Ӧ�ÿ��Ժܺõ���չ����ǧ���ں��С� ���������Ȥ���뽫��ܿ��ͼ���͸��Ұɡ�]]></content>
      <categories>
        <category>�����ͼ��ѧ</category>
      </categories>
      <tags>
        <tag>�����ͼ��ѧ</tag>
        <tag>����׷��</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua迭代器和范型for]]></title>
    <url>%2F2019%2F07%2F05%2FLua%2FLua%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E8%8C%83%E5%9E%8Bfor%2F</url>
    <content type="text"><![CDATA[关于Lua中的迭代器：ipairs与pairs。 迭代器和泛型for：迭代器和闭包：所有的迭代器都需要在连续的调用之间保存一些状态，这样才能知道当前迭代所处的位置及如何从当前位置步进到下一位置。对于我们自己的迭代器而言，闭包为保存状态提供了一种良好的机制。一个闭包就是一个可以访问其自身的环境中一个或多个局部变量的函数。这些变量将连续调用过程中的值并将其保存在闭包中，从而使得闭包能够记住迭代所处的位置。当然，要创建一个新的闭包，我们还需要创建非局部变量。因此，一个闭包结构通常涉及两个函数：闭包本身和一个用于创建该闭包及其封装变量的工厂。 泛型for：泛型for在循环过程中在其内部保存了迭代函数，泛型for保存了三个值：一个迭代函数、一个不可变状态和一个控制变量。 语法如下： 123for var-list in exp-list do bodyend 其中，var-list是由一个或多个变量名组成的列表，以逗号分隔；exp-list是一个或多个表达式组成的列表，同样以逗号分隔。通常，表达式列表只有一个元素，即一句对迭代器工厂的调用。 1for k,v in pairs(t) do print(k,v) end 我们把变量列表的第一个变量称为控制变量，其值在循环过程中永远不会为nil，因为当其值为nil时循环就结束了。 for做的第一件事情是对in后面的表达式求值。这些表达式应该返回三个值供for保存：迭代函数、不可变状态和控制变量的初始值。类似于多重赋值，只有最后一个白哦大事能够产生不止一个值；表达式列表的结果只会保留三个，多余的值会被丢弃，不足三个则以nil补齐。 在上述的初始化步骤完成后，for使用不可变状态和控制变量为参数来调用迭代函数，从for代码结构的立足点来看，不可变状态根本没有意义，for只是把从初始化步骤得到的状态值传递给所有迭代函数，然后，for将迭代函数的返回值赋给变量列表中声明的变量。如果第一个返回值为nil，那么循环终止；否则，for执行它的循环体并再次调用迭代函数，再不断的重复这个过程。 两种语法等价： 1for var_1,...,var_n in explist do block end 等价于： 123456789do local _f,_s,_var = explist while true do local var_1,...,var_n = _f(_s,_var) _var = var_1 if _var == nil then break end block endend 假设迭代函数是f，不可变状态为s，控制变量的初始值为a0，那么在循环中控制变量的值依次为a1=f(s,a0),a2=f(s,a1)，直到ai为nil。如果for还有其他变量，那么这些变量只是简单的在每次调用f后得到额外的返回值。 无状态迭代器：无状态迭代器就是一种自身不保存任何状态的迭代器，因此，可以在多个循环中使用同一个无状态迭代器，从而避免创建新闭包的开销。 for循环会以不可变状态和控制变量为参数调用迭代函数，一个无状态迭代器之需要这两个值来为迭代生成下一个元素： 1234a = &#123;"One","Two","Three"&#125;for i,v in ipairs(a) do print(i,v)end ipairs和迭代器都非常简单： 1234567891011local function iter(t,i) i = i + 1 local v = t[i] if v then return i,v endendfunction ipairs(t) return iter,t,0end 当调用for循环中的ipairs(t)时，ipairs(t)会返回三个值，即迭代函数iter，不可变状态表t和控制变量的初始值0。 然后Lua语言调用iter(t,0)，得到1，t[1]（除非t[1]已经变成了nil）。在第二次迭代中，Lua语言调用iter(t,1)，得到2，t[2]，依次类推，直至得到第一个为nil的元素。 函数pairs和函数ipairs类似，也用于遍历一个表中的所有元素，不同的是，函数pairs的迭代函数是Lua语言中的一个基本函数next： 123function pairs(t) return next,t,nilend 在调用next(t,k)时，k是表t的一个键，该函数会以随机次序返回表中的下一个键以及k对应的值，调用next(t,nil)时，返回表中的第一个键值对。当所有的元素遍历完时，函数next返回nil。 区别： pairs：用于迭代table，可以遍历表中所有的key，可以返回nil ipairs: 迭代数组，不能返回 nil,如果遇到 nil 则退出]]></content>
      <categories>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua模块与包]]></title>
    <url>%2F2019%2F07%2F04%2FLua%2FLua%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85%2F</url>
    <content type="text"><![CDATA[Lua中的模块和包。 一个模块就是一些代码，这些代码可以通过函数require加载，然后创建和返回一个表。这个表就像是某种命名空间，其中定义的内容是模块中导出的东西，比如函数和常量。 函数require：函数require尝试对模块的定义做最小的假设。对于该函数来说，一个模块可以是定义了一些变量的（比如函数或者包含函数的表）的代码。 require的加载机制首先，函数require在表package.loaded中检查模块是否已被加载，如果模块已经被加载，函数require就返回相应的值，因此，一旦一个模块被加载过，后续的对于同一模块的所有require调用都将返回同一个值，而不会再运行任何代码。 如果模块尚未加载，那么函数require则搜索具有指定模块名的Lua文件（搜索路径由变量package.path指定）。如果函数require找到了相应的文件，那么就用函数loadfile将其进行加载，结果是一个我们称之为加载器的函数。 如果函数require找不到指定模块名的Lua文件，那么它就搜索相应名称的C标准库。如果找到了一个C标准库，则使用底层函数package.loadlib进行加载，这个底层函数会查找名为luaopen_modname的函数。在这种情况下，加载函数就是loadlib的执行结果，也就是一个被表示为Lua函数的C语言函数。 为了最终加载模块，函数require带着两个参数调用加载函数：模块名和加载函数所在的文件的名称。如果加载函数有返回值，那么函数require会返回这个值，然后将其保存在表package.loaded中，以便于将来在加载统一模块时返回相同的值。如果加载函数没有返回值且表中的package.loaded[@rep{modname}]为空，函数require就假设模块的返回值为true。如果没有这种补偿，那么后续调用函数require时将会重复加载模块。 编写模块的基本方法在Lua语言中创建一个表，并将所有需要导出的函数放入其中，最后返回这个表。 另一种编写模块的方法是把所有的函数定义为局部变量，然后在最后构造返回的表。 字模块和包Lua支持具有层次结构的模块名，通过点来分隔名称中的层次，例如一个名为mod.sub的模块是模块mod的一个子模块。一个包（package）是一棵由模块组成的完整的树，它是Lua语言用于发行程序的单位。]]></content>
      <categories>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Unity] 不同设备屏幕适配问题]]></title>
    <url>%2F2019%2F04%2F24%2FUnity%E7%AC%94%E8%AE%B0%2FUnity-%E4%B8%8D%E5%90%8C%E8%AE%BE%E5%A4%87%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[面试问到了，不同设备屏幕适配问题。]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Unity] 在Unity中纹理图该是什么格式？]]></title>
    <url>%2F2019%2F04%2F17%2FUnity%E7%AC%94%E8%AE%B0%2FUnity-%E5%9C%A8Unity%E4%B8%AD%E7%BA%B9%E7%90%86%E5%9B%BE%E8%AF%A5%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%BC%E5%BC%8F%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[一个在Windows下的png格式图，在Unity中存储为什么格式？ Unity下的资源导入问题：Unity会把我们放进去的外部资源转换成一种Unity内部格式的资源，这个过程就是资源导入。 比如说在Windows下显示为png格式的图片，在Unity内部会根据平台的不同而设置成不同的压缩格式。 可以使用AssetPostProcessor来对导入的资源进行规定化。 AssetPostProcessor是一个编辑器类，用来管理资源导入，当资源导入之前和之后都会发送通知，可以根据不同的资源类型，在导入之前和之后做不同的处理，来修改Unity内部资源格式。 由于这是一个编辑器类，在UnityEditor命名空间下，所以在使用C#脚本时，需要在脚本前加上using UnityEditor引用，且放在工程目录下的Asset/Editor文件夹下。一般我们通过修改这个类中OnPreprocessxxx和OnPostprocessxxx函数来修改资源数据和设置。这两者的区别可以简单理解为：前者用来Inspector视图可见的选项，后者为不可见的。 下面的脚本可以自动设置不同文件夹下贴图的压缩格式以及大小： 1234567891011121314151617181920212223242526272829303132using UnityEditor;using UnityEngine;public class Script_12_02 : AssetPostprocessor&#123; void OnPreprocessTexture() &#123; TextureImporter textureImporter = (TextureImporter)assetImporter; if(textureImporter.assetPath.Contains("UI")) &#123; textureImporter.textureType = TextureImporterType.Sprite; textureImporter.mipmapEnabled = false; // 设置UI贴图在三个平台下的压缩格式以及大小 textureImporter.SetPlatformTextureSettings("Standalone",2048,TextureImporterFormat.RGBA32); textureImporter.SetPlatformTextureSettings("iPhone",2048,TextureImporterFormat.RGBA32,100,true); textureImporter.SetPlatformTextureSettings("Android",2048,TextureImporterFormat.RGBA32,true); &#125; else if(textureImporter.assetPath.Contains("Texture")) &#123; textureImporter.textureType = TextureImporterType.Default; textureImporter.mipmapEnabled = true; // 设置模型贴图在三个平台下的压缩格式以及大小 textureImporter.SetPlatformTextureSettings("Standalone",2048,TextureImporterFormat.DXT5); textureImporter.SetPlatformTextureSettings("iPhone",2048,TextureImporterFormat.ASTC_RGBA_4x4,100,true); textureImporter.SetPlatformTextureSettings("Android",2048,TextureImporterFormat.ETC_RGB4,true); &#125; &#125;&#125; 拓展阅读：为什么要进行纹理压缩：http://www.newhappy.com.cn/?p=907 那么纹理有哪些压缩格式呢？桌面平台： RGB Compressed DXT1 压缩的RGB纹理。这是最常见的漫反射纹理格式。4位/像素（32 KB 256x256） RGBA Compressed DXT5 压缩的RGBA纹理。这是漫反射和高光控制纹理的主要格式。1 字节/像素（64 KB 256x256） RGB 16 bit 65万颜色不带alpha。压缩的DXT格式使用较少的内存，通常会更好看。（128 KB 256x256） RGB 24 bit 真彩色不带alpha。（192 KB 256x256） Alpha 8 bit 高质量alpha通道，不带颜色。（64 KB 256x256） RGBA 16 bit 低质量真彩色。有16级红，绿，蓝和alpha。压缩的DXT5格式使用较少的内存，通常会更好看。（128 KB 256x256） RGBA 32 bit 高质量真彩色带alpha（256 KB 256x256），这个文件很大。大多数情况下 DXT5提供足够的质量，文件大小要小得多。这个主要用于法线贴图，DXT压缩往往带有一个可见的质量损失。 Android： RGB Compressed DXT1 压缩的RGB纹理。支持Nvidia Tegra。4位/像素（32 KB 256x256） RGBA Compressed DXT5 压缩的RGBA纹理。支持Nvidia Tegra。6位/像素（64 KB 256x256） RGB Compressed ETC 4 bits 压缩的RGB纹理。这是Android工程默认的纹理格式。 ETC1是OpenGL ES 2.0标准的一部分，并且支持所有的OpenGL ES 2.0 GPU，但它不支持Alpha。4位/像素（32 KB 256x256） RGB Compressed PVRTC 2 bits 压缩的RGB纹理。 支持Imagination PowerVR GPU。2位/像素（16 KB 256x256） RGBA Compressed PVRTC 2 bits 压缩的RGBA纹理。支持Imagination PowerVR GPU。2位/像素（16 KB 256x256） RGB Compressed PVRTC 4 bits 压缩的RGB纹理。 支持Imagination PowerVR GPU。4位/像素（32 KB 256x256） RGBA Compressed PVRTC 4 bits 压缩的RGBA纹理。 支持Imagination PowerVR GPU。4位/像素（32 KB 256x256） RGB Compressed ATC 4 bits 压缩的RGB纹理。 支持Qualcomm Snapdragon。4位/像素（32 KB 256x256） RGBA Compressed ATC 8 bits 压缩的RGB纹理。 支持Qualcomm Snapdragon。6位/像素（64 KB 256x256） RGB 16 bit 65万颜色不带alpha。比压缩的格式使用更多的内存，但更适用于UI或不带渐变的明快的纹理。128 KB 256x256 RGB 24 bit 真彩色不带alpha。（192 KB 256x256） Alpha 8 bit 高质量alpha通道，不带颜色。（64 KB 256x256） RGBA 16 bit 低质量真彩色。默认压缩的纹理带有alpha通道（128 KB 256x256） RGBA 32 bit 真彩色带alpha - 这是高质量压缩的纹理带有alpha通道。（256 KB 256x256） IOS： RGB Compressed PVRTC 4 bits PVRTC 4位，压缩的RGB纹理。这是最常见的漫反射纹理格式。4位/像素（32 KB 256x256） RGBA Compressed PVRTC 4 bits 压缩的RGBA纹理。这是漫反射和高光控制纹理的主要格式。4 位/像素（32 KB 256x256） RGB Compressed PVRTC 2 bits压缩的RGB纹理。 低质量格式，适用于漫反射纹理。2 位/像素（16 KB 256x256） RGBA Compressed PVRTC 2 bits 压缩的RGBA纹理。 低质量格式，适用于漫反射纹理和高光控制纹理。2 位/像素（16 KB 256x256） RGB Compressed DXT1 压缩的RGB纹理。 在iOS不支持此格式，但为桌面项目保持向后兼容性。 RGBA Compressed DXT5 压缩的RGBA纹理。在iOS不支持此格式，但为桌面项目保持向后兼容性。 RGB 16 bit 65万颜色不带alpha。比PVRTC格式使用更多的内存，但更适用于UI或不带渐变的明快的纹理。128 KB 256x256 RGB 24 bit 真彩色不带alpha。（192 KB 256x256） Alpha 8 bit 高质量alpha通道，不带颜色。（64 KB 256x256） RGBA 16 bit 低质量真彩色。具有16级的红、绿、蓝和alpha。比PVRTC格式使用更多的内存，但如果需要精确的alpha通道，会更方便。（128 KB 256x256） RGBA 32 bit 真彩色带alpha - 这是最高质量。256KB 256x256，这个是很消耗性能的。大多数情况下，PVRTC格式提供足够的质量，但有更小的文件大小。 (图片来自：喵小逗@UWA问答社区) 几种主要的压缩格式介绍：高清晰无压缩 - RGBA32RGBA32等同于原图了，优点是清晰、与原图一致，缺点是内存占用十分大；对于一些美术要求最好清晰度的图片，是首选。 要注意一些png图片，在硬盘中占用几KB，怎么在Unity中显示却变大？因为Unity显示的是Texture大小，是实际运行时占用内存的大小，而png却是一种压缩显示格式；可以这样理解，png类似于zip格式，是一个压缩文件，只不过在运行时会自动解压解析罢了。 中清晰中压缩 - RGBA16 + DitheringUnity RGBA16，不抖动处理的渐变图片惨不忍睹 既然叫RGBA16，自然就是RGBA32的阉割版。对于一些采用渐变的图片，从RGBA32转换成RGBA16，能明显的看出颜色的层叠变化。 采用Floyd Steinberg抖动处理后，除非放大，否则肉眼基本看不出区别 RGBA16的优点，内存占用是RGBA32的1/2；搭配上Dithering抖动，在原尺寸下看清晰度一模一样； 缺点，Unity原生不支持Dithering抖动，需要自己做工具对图片做处理；对于需要放大、拉伸的图片，Dithering抖动的支持不好，会有非常明显的颗粒感。 RGB16而RGB16，是主要针对一些，不带透明通道，同时长宽又不是2的次方的图片；对于这些图片，使用RGB16可以降低一半的内存，但是效果会略逊于RGB32。 当然了，RGB16其实也是可以搭配抖动，也能提升显示效果；但同样的Dithering抖动对拉伸放大是不友好的。 低清晰高压缩 - ETC1+Alpha/PVRTC4很多初学者都会疑惑，为什么游戏开发中经常看到一些图片，需要设置成2的次方？因为像ETC1、PVRTC4等这类在内存中无需解压、直接被GPU支持的格式，占用内存极低，而且性能效率也是最好的。 但是，相对RGBA32，还是能肉眼看出质量有所下降的。 ETC1 ETC1+Alpha一般应用在Android版的UI图集中，ETC1不带透明通道，所以需要外挂一张同样是ETC1格式的Alpha通道图。方法是，在原RGBA32的原图中，提取RGB生成第一张ETC1，再提取A通道，填充另一张ETC1的R通道；游戏运行时，Shader将两张ETC1图片进行混合。 PVRTC4 PVRTC4在Unity中是直接支持的，不过要注意的细节是，它必须是二次方正方形；也就是说，长宽在二次方的同时，还必须要相等。 在项目中，尽可能是使用ETC1和PVRTV4等GPU直接支持的图片格式，不仅内存占用低、性能也更好；当出现质量不及格时，再逐步的提升压缩格式，来满足需要。 参考： Unity运用导入器规范资源格式和设置 Unity3D 图片纹理格式(作者：JumboWu) 干货：Unity游戏开发图片纹理压缩方案]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Unity] 生命周期相关]]></title>
    <url>%2F2019%2F04%2F17%2FUnity%E7%AC%94%E8%AE%B0%2FUnity-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[生命周期相关。 脚本的生命周期：Unity脚本有一套完整的生命周期，脚本需要挂在任意游戏对象上，并且同一个游戏对象可以挂不同的脚本，各脚本执行自己的生命周期，它们可以互相组合并且互不干预。生命周期中的所有方法都是Unity系统自己回调的，不需要手动调用，主要有编辑脚本、初始化、物理碰撞事件、更新回调、渲染和销毁等。学习脚本的生命周期之前，我们不得不引用文档中非常经典的一张图，它完整的描述了脚本的生命周期： 第一个场景加载：这些函数将在场景开始加载时调用。(场景中的每个物体仅调用一次) Awake：这个方法总是在在任何开始方法之前调用(可以理解成最先调用吧？)，并且在一个prefab刚被实例化后就调用。(如果一个游戏物体在开始时是不活跃的(inactive)则将不会调用awake函数，直到其变为活跃。) OnEnable：(仅在物体为活跃(active)状态调用)：这个函数仅在一个物体变为有效(enabled)后调用。这通常发生在一个MonoBehavior实例创建时，例如在一个场景加载时或者一个持有脚本组件的游戏物体被实例化时。 OnLevelWasLoaded：这个函数用来通知游戏逻辑一个新的场景已经被加载完。 注意：对于加到场景中的物体来说，Awake和OnEnable方法将在所有脚本的任何类似于Start、Update等方法被调用之前调用。自然的，这些方法也不能在游戏进行中强制调用。 编辑器： Reset：Reset被调用于第一次将脚本绑定到物体上时初始化脚本属性，或者在Reset指令被触发时调用。 在帧之间： OnApplicationPause:：这个方法在检测到暂停的帧的末尾调用，在正常帧更新间有效？之后将会发出一个额外的帧。调用OnApplicationPause以允许游戏显示指示暂停状态的图形。 更新顺序：当你追踪游戏逻辑和交互、动画、相机位置等，你可以使用几个不同的事件。常见的模式是在Update函数中执行大多数任务，但也可以使用其他功能。 FixedUpdate：FixedUpdate函数通常要比Update函数调用的更为频繁，会按照设置的时间固定频率来循环更新。如果帧速率低，则可以每帧调用多次，如果帧速率高，则可以不在帧之间调用。所有物理计算和更新在FixedUpdate之后立即发生。在FixedUpdate中应用移动计算时，不需要乘以Time.deltaTime。这是因为FixedUpdate在可靠的定时器上调用，与帧速率无关。 Update：Update每帧调用一次。它是帧更新的主要功能。 LateUpdate：LateUpdate每帧调用一次，但在Update执行结束之后。在LateUpdate开始时，在Update中执行的任何计算都应该已经完成。LateUpdate的一个常见用途是实现跟随的第三人称相机。如果你将角色移动放在Update中执行，那么你可以将所有的相机移动和旋转计算放在LateUpdate中执行。这将确保角色在摄像机跟踪其位置之前完全移动。 总体来说，Update()和LateUpdate()属于立即更新，更新之间的频率是不固定的，比如某一帧有一个耗时操作的时候，就会影响到下一帧更新的时间，所以对更新频率要求比较稳定的物理系统就不太适合在这里处理更新。 FixedUpdate()虽然是固定更新，但是其实也是相对固定的，比如某一帧耗了好几秒，它依然会卡住。不过正常的程序要优化耗时操作，小范围的帧率波动是正常的，可以让它更新的时间间隔稍微长一点，这样它的更新是比较平滑的。在实际的开发中，例如以秒为单位的倒计时，并不需要每一帧去判断时间，所以用FixedUpdate()就再合适不过了。 动画更新循环：这些方法和Profiler Markers在Unity评估(？)动画系统时会调用。 (暂略) 有用的profile markers：(暂略) 渲染： OnPreCull：在相机剔除场景之前调用。剔除确定相机可以看到哪些对象。在剔除之前调用OnPreCull。 OnBecameVisible/OnBecameInvisible：当对象变得对任何相机可见/不可见时调用。 OnWillRenderObject：如果对象可见，则为每个摄像机调用一次。 OnPreRender：在相机开始渲染场景之前调用一次。 OnRenderObject：在完成所有常规场景渲染后调用。您可以使用GL类或Graphics.DrawMeshNow来绘制自定义几何体。 OnPostRender：在相机完成渲染场景后调用。 OnRenderImage：在场景渲染完成后调用以允许对图像进行后处理，请参阅后处理效果。 OnGUI：响应GUI事件，每帧调用多次。首先处理Layout和Repaint事件，然后为每个输入事件处理Layout和keyboard / mouse事件。 OnDrawGizmos：用于在场景视图中绘制Gizmo以进行可视化。 协程：正常的协程在Update函数返回后更新。协程是一个可以暂停执行(yield)直到给定的YieldInstruction完成的函数。以下是协程的不同用处： yield：在下一帧调用所有Update函数后，协程将继续。 yield WaitForSeconds：在为帧调用了所有的Update函数后，协程在指定的延迟时间后继续。 yield WaitForFixedUpdate：在所有脚本中的的所有FixedUpdate执行后继续协程。 yield WWW：在一个WWW类的下载完成之后执行协程。 yield StartCoroutine：链接协程，并将等待MyFunc协程首先完成。 当物体被销毁时： OnDestroy：在对象存在的最后一帧的所有帧更新之后调用这个函数。(该对象可能在相应Object.Destory或者场景闭合时被销毁)。 当退出时：在场景中的所有活动对象上调用这些函数： OnApplicationQuit：在退出应用程序之前，将在所有游戏对象上调用此函数。在编辑器中，当用户停止播放模式时调用它。 OnDisable：当行为被禁用或处于非活动状态时，将调用此函数。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Unity] Unity中的内存泄漏]]></title>
    <url>%2F2019%2F04%2F11%2FUnity%E7%AC%94%E8%AE%B0%2FUnity-Unity%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%2F</url>
    <content type="text"><![CDATA[Unity中的内存泄漏。 参考： 内存是手游的硬伤——Unity游戏Mono内存管理及泄漏 深入浅出再谈Unity内存泄漏]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[游戏AI] 状态机]]></title>
    <url>%2F2019%2F04%2F01%2F%E6%B8%B8%E6%88%8FAI%2F%E6%B8%B8%E6%88%8FAI-%E7%8A%B6%E6%80%81%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[状态机的利与弊。 参考： 漫谈游戏中的人工智能 《游戏人工智能编程案例精粹》 状态机状态机是什么：为什么选择状态机：状态机的演进：最简单的状态机：首先很容易抽象出IUnit： 123456789101112public interface IUnit&#123; void ChangeState(UnitStateEnum state); void Patrol(); IUnit GetNearestTarget(); void LockTarget(IUnit unit); float GetFleeBloodRate(); bool CanMove(); bool HpRateLessThan(float rate); void Flee(); void Speak();&#125; 要注意的是，原作者的实现方式是定义一个单位接口，每个智能体要实现这个单位接口中定义的方法。(这样写会使每个单位类中有着一套自己所有行为的方法。我之前的实现方式是状态机来控制单位进行相应的行为，这样可以使每个状态仅有这个状态下自身的方法，但是耦合性较高。原作者这种接口是不是可以改写成虚方法的形式，在基类中实现基本行为，具体单位子类中再override出特定的行为？) 一个最简单的状态机定义： 12345678public interface IState&lt;TState,TUnit&gt; where TState : IConvertible&#123; TState Enum &#123;get;&#125; TUnit Self &#123;get;&#125; void OnEnter(); void Drive(); void OnExit();&#125; 这样写有着一个明显的性能问题：状态机本质是描述状态迁移的，并不需要保存实体的上下文，如果实体的上下文都保存在State中(上文中的TUnit类型的Self)，那么这个状态机的每个状态迁移逻辑需要每个状态都保存一个实体的实例，这样浪费内存，应该将决策逻辑与实体的上下文分离。 决策逻辑和上下文分离：剥离后： 1234567public interface IState&lt;TState,TUnit&gt; where TState : IConvertible&#123; TState Enum &#123;get;&#125; void OnEnter(TUnit self); void Drive(TUnit self); void OnExit(TUnit self);&#125; 可以使用单例模式保持静态的状态内容实例只有一个，此时状态之间的迁移逻辑变成了静态，动态的是状态迁移过程中的上下文。 分层有限状态机：如果想要让状态机框架描述层级结构的概念，需要对其进行拓展： 例如一个怪物需要在巡逻一段时间后进行休息，在休息一段时间后再次进行巡逻，而巡逻与休息状态均保持着对于战斗的检查。这时如果按照之前的框架(我之前就是最初级的那种)，就需要手动进行装配，在每个状态中都写入一个关于是否进入战斗状态的检查。可以看出战斗状态的优先级较高，并且相对来说算是一种”全局检查”，可以将其抽离出来作为上层状态。 父状态需要关注子状态的运行结果，所以状态的Drive接口需要一个运行结果的返回值。 子状态一定是由父状态驱动的。 考虑这样一个组合状态情景：巡逻时，需要依次得先走到一个点，然后怠工一会儿，再走到下一个点，然后再怠工一会儿，循环往复。这样就需要父状态（巡逻状态）注记当前激活的子状态，并且根据子状态执行结果的不同来修改激活的子状态集合。这样不仅是Unit自身有上下文，连组合状态也有了自己的上下文。 状态定义： 123456public interface IState&lt;TState, TCleverUnit, TResult&gt; where TState : IConvertible&#123; // ... TResult Drive(); // ...&#125; 组合状态的定义： 123456789101112131415161718192021222324public abstract class UnitCompositeStateBase : UnitStateBase&#123; protected readonly LinkedList&lt;UnitStateBase&gt; subStates = new LinkedList&lt;UnitStateBase&gt;(); // ... protected Result ProcessSubStates() &#123; if (subStates.Count == 0) &#123; return Result.Success; &#125; var front = subStates.First; var res = front.Value.Drive(); if (res != Result.Continue) &#123; subStates.RemoveFirst(); &#125; return Result.Continue; &#125; // ...&#125; 巡逻状态： 1234567891011121314151617181920212223242526272829303132333435363738394041public class PatrolState : UnitCompositeStateBase&#123; // ... public override void OnEnter() &#123; base.OnEnter(); AddSubState(new MoveToState(Self)); &#125; public override Result Drive() &#123; if (subStates.Count == 0) &#123; return Result.Success; &#125; var unit = Self.GetNearestTarget(); if (unit != null) &#123; Self.LockTarget(unit); return Result.Success; &#125; var front = subStates.First; var ret = front.Value.Drive(); if (ret != Result.Continue) &#123; if (front.Value.Enum == CleverUnitStateEnum.MoveTo) &#123; AddSubState(new IdleState(Self)); &#125; else &#123; AddSubState(new MoveToState(Self)); &#125; &#125; return Result.Continue; &#125;&#125; 分层有限状态机的上下文分离： 我们对之前重构出来的层次状态机框架再进行一次Context分离优化。 要优化的点有这样几个： 首先是继续之前的，unit不应该作为一个state自己的内部status。 组合状态的实例内部不应该包括自身执行的status。目前的组合状态，可以动态增删子状态，也就是根据status决定了结构的状态，理应分离静态与动态。巡逻状态组合了两个子状态——A和B，逻辑中是一个完成了就添加另一个，这样一想的话，其实巡逻状态应该重新描述——先进行A，再进行B，循环往复。 由于有了父状态的概念，其实状态接口的设计也可以再迭代，理论上只需要一个drive即可。因为状态内部的上下文要全部分离出来，所以也没必要对外提供OnEnter、OnExit，提供这两个接口的意义只是做一层内部信息的隐藏，但是现在内部的status没了，也就没必要隐藏了。 具体分析一下需要拆出的status： 一部分是entity本身的status，这里可以简单的认为是unit。 另一部分是state本身的status。 对于组合状态，这个status描述的是我当前执行到哪个substate。 对于原子状态，这个status描述的种类可能有所区别。 例如MoveTo/Flee，OnEnter的时候，修改了unit的status，然后Drive的时候去check。 例如Idle，OnEnter时改了自己的status，然后Drive的时候去check。 经过总结，我们可以发现，每个状态的status本质上都可以通过一个变量来描述。一个State作为一个最小粒度的单元，具有这样的Concept： 输入一个Context，输出一个Result。 Context暂时只需要包括这个Unit，和之前所说的status。同时，考虑这样一个问题： 父状态A，子状态B。 子状态B向上返回Continue的同时，status记录下来为b。 父状态ADrive子状态的结果为Continue，自身也需要向上抛出Continue，同时自己也有status为a。 这样，再还原现场时，就需要即给A一个a，还需要让A有能力从Context中拿到需要给B的b。因此上下文的结构理应是递归定义的，是一个层级结构。 Context如下定义： 123456789101112public class Continuation &#123; public Continuation SubContinuation &#123; get; set; &#125; public int NextStep &#123; get; set; &#125; public object Param &#123; get; set; &#125; &#125;public class Context&lt;T&gt;&#123; public Continuation Continuation &#123; get; set; &#125; public T Self &#123; get; set; &#125;&#125; 修改State的接口定义为： 1234public interface IState&lt;TCleverUnit, TResult&gt; &#123; TResult Drive(Context&lt;TCleverUnit&gt; ctx); &#125; 已经相当简洁了。 这样，我们对之前的巡逻状态也做下修改，达到一个ContextFree的效果。利用Context中的Continuation来确定当前结点应该从什么状态继续： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class PatrolState : IState&lt;ICleverUnit, Result&gt; &#123; private readonly List&lt;IState&lt;ICleverUnit, Result&gt;&gt; subStates; public PatrolState() &#123; subStates = new List&lt;IState&lt;ICleverUnit, Result&gt;&gt;() &#123; new MoveToState(), new IdleState(), &#125;; &#125; public Result Drive(Context&lt;ICleverUnit&gt; ctx) &#123; var unit = ctx.Self.GetNearestTarget(); if (unit != null) &#123; ctx.Self.LockTarget(unit); return Result.Success; &#125; var nextStep = 0; if (ctx.Continuation != null) &#123; // Continuation var thisContinuation = ctx.Continuation; ctx.Continuation = thisContinuation.SubContinuation; var ret = subStates[nextStep].Drive(ctx); if (ret == Result.Continue) &#123; thisContinuation.SubContinuation = ctx.Continuation; ctx.Continuation = thisContinuation; return Result.Continue; &#125; else if (ret == Result.Failure) &#123; ctx.Continuation = null; return Result.Failure; &#125; ctx.Continuation = null; nextStep = thisContinuation.NextStep + 1; &#125; for (; nextStep &lt; subStates.Count; nextStep++) &#123; var ret = subStates[nextStep].Drive(ctx); if (ret == Result.Continue) &#123; ctx.Continuation = new Continuation() &#123; SubContinuation = ctx.Continuation, NextStep = nextStep, &#125;; return Result.Continue; &#125; else if (ret == Result.Failure) &#123; ctx.Continuation = null; return Result.Failure; &#125; &#125; ctx.Continuation = null; return Result.Success; &#125; &#125; subStates是readonly的，在组合状态构造的一开始就确定了值。这样结构本身就是静态的，而上下文是动态的。不同的entity instance共用同一个树的instance。 ​ (最后这个理解起来比较吃力了)]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>游戏AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[游戏引擎架构] 第十章：渲染引擎]]></title>
    <url>%2F2019%2F03%2F26%2F%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%2F%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84-%E7%AC%AC%E5%8D%81%E7%AB%A0-%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[「占位」 渲染引擎采用深度缓冲的三角形光栅化基础三维场景渲染的本质涉及以下基本步骤： 描述一个虚拟场景。这些场景一般是以某数学形式表示的三维表面。 定位及定向一个虚拟摄像机，为场景取景。 设置光源。 描述场景中物体表面的视觉特性。 对于每个位于影像矩形内的像素，渲染引擎会找出经过该像素而聚焦于虚拟摄像机焦点的光线，并计算其颜色和强度。此过程为求解渲染方程，也叫做着色方程。 场景描述：高端渲染软件所用的表示法三角形网格游戏开发者会使用三角形网格来为表面建模。三角形是表面的分段线性逼近。 为什么选取三角形？ 三角形是最简单的多边形 三角形必然是平坦的 三角形经过多种转换之后仍然维持是三角形，对于仿射转换与透视转换也成立 几乎所有的商用图形加速软件都是为三角形光栅化而设计的。 镶嵌： 镶嵌是指把表面分割为一组离散多边形的过程。 构造三角形网格 缠绕顺序 三角形由三个顶点的位置矢量定义，此三个矢量设为p1，p2，p3。每条棱的相邻顶点的位置矢量相减，就能求得三条棱的矢量。 任何两棱的叉积，归一化后就能定义为三角形的单位面法线N，若要知道面法线的方向，需要定义哪一面才是三角形的正面，哪一面是背面，这个可以简单用缠绕顺序(winding order)定义，缠绕顺序用来定义表面方向有两种方式，分别是顺时针方向和逆时针方向。 模型空间世界空间及网格实例化描述表面的视觉性质光和颜色的概论顶点属性顶点格式属性插值纹理材质光照基础局部及全局光照模型Phong氏光照模型光源模型虚拟摄像机观察空间投影观察体积及平截头体投影及齐次裁剪空间屏幕空间及长宽比帧缓冲三角形光栅化及片段遮挡及深度缓冲渲染管道高级光照及全局光照视觉效果和覆盖层]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>游戏引擎</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Unity] 托管堆与垃圾回收]]></title>
    <url>%2F2019%2F03%2F25%2FUnity%E7%AC%94%E8%AE%B0%2FUnity-%E6%89%98%E7%AE%A1%E5%A0%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%2F</url>
    <content type="text"><![CDATA[有关Unity中的托管堆与垃圾回收。 托管堆与垃圾回收托管堆：“托管堆”是一段内存，由项目脚本运行时（Mono或IL2CPP）的内存管理器自动管理。托管代码中创建的所有对象必须在托管堆上分配（注意：严格地说，必须在托管堆上分配所有非空引用类型对象和所有盒装值类型对象）。 在上图中，白框表示分配给托管堆的内存量，其中的彩色框表示存储在托管堆内存空间中的数据值。当需要其他值时，将从托管堆中分配更多空间。 垃圾收集器定期运行（注意：确切的时间与平台有关）。这会扫描堆上的所有对象，标记删除任何不再引用的对象。然后删除未引用的对象，释放内存。 至关重要的是，Unity的垃圾收集 - 使用Boehm GC算法 - 是非代数和非压缩的。“非世代”意味着GC在执行收集传递时必须扫描整个堆，因此其性能因堆扩展而降低。“非压缩”意味着内存中的对象不会被重新定位以便关闭对象之间的间隙。 上图显示了内存碎片的示例。释放对象时，将释放其内存。但是，释放的空间也不会成为“空闲内存”一家独大池的一部分。释放对象两侧的对象可能仍在使用中。因此，释放的空间是存储器的其他部分之间的“间隙”（该间隙由图中的红色圆圈表示）。因此，新释放的空间仅可用于存储与释放的对象相同或更小的数据。 分配对象时，请记住该对象必须始终占用内存中的连续空间块。 这导致了内存碎片的核心问题：虽然堆中可用的总空间量可能很大，但是该空间中的一些或全部可能在分配的对象之间存在小的“间隙”。在这种情况下，即使可能有足够的总空间来容纳某个分配，托管堆也找不到足够大的连续内存块来适应分配。 但是，如果分配了大对象并且没有足够的连续可用空间来容纳对象，则如上所述，Unity内存管理器执行两个操作。 首先，如果还没有这样做，垃圾收集器就会运行。这会尝试释放足够的空间来完成分配请求。 如果在GC运行后，仍然没有足够的连续空间来满足请求的内存量，则堆必须扩展。堆扩展的具体数量取决于平台; 但是，大多数Unity平台的大小都是托管堆的两倍。 堆的关键问题托管堆扩展的核心问题有两个： Unity在扩展时不会经常释放分配给托管堆的内存页; 它乐观地保留了扩展堆，即使它的大部分是空的。这是为了防止在进一步发生大量分配时需要重新扩展堆。 在大多数平台上，Unity最终将托管堆空部分使用的页面释放回操作系统。发生这种情况的间隔不能保证，不应该依赖。 托管堆使用的地址空间永远不会返回给操作系统。 对于32位程序，如果托管堆多次扩展和收缩，则可能导致地址空间耗尽。如果程序的可用内存地址空间已用尽，操作系统将终止该程序。 对于64位程序，地址空间足够大，对于运行时间不超过人类平均寿命的程序来说，这种情况极不可能发生。 了解自动内存管理：创建对象，字符串或数组时，存储它所需的内存是从称为堆的中央池分配的。当项目不再使用时，它曾经占用的内存可以被回收并用于其他内容。在过去，通常由程序员通过适当的函数调用显式地分配和释放这些堆内存块。如今，Unity的Mono引擎等运行时系统会自动为您管理内存。自动内存管理比显式分配/释放需要更少的编码工作，并且大大降低了内存泄漏的可能性（分配内存但从未随后释放的情况）。 分配和垃圾收集内存管理器跟踪它知道未使用的堆中的区域。当请求新的存储器块时（例如，当实例化对象时），管理器选择一个未使用的区域，从该区域分配块，然后从已知的未使用空间中移除分配的存储器。后续请求以相同的方式处理，直到没有足够大的空闲区域来分配所需的块大小。此时极不可能从堆中分配的所有内存仍在使用中。只有存在可以找到它的引用变量时，才能访问堆上的引用项。如果对内存块的所有引用都消失了（即，引用变量已被重新分配，或者它们是现在超出范围的局部变量），则可以安全地重新分配它占用的内存。 为了确定哪些堆块不再使用，内存管理器搜索所有当前活动的引用变量，并将它们称为“实时”的块标记。在搜索结束时，内存管理器认为实时块之间的任何空格都是空的，并且可以用于后续分配。由于显而易见的原因，定位和释放未使用的内存的过程称为垃圾收集（或简称GC）。 优化垃圾收集是自动的，对于程序员不可见，但在采集过程中实际需要的背后显著CPU时间的场景。如果使用正确，自动内存管理通常会等于或超过手动分配以获得整体性能。但是，程序员必须避免错误，这些错误会比必要时更频繁地触发收集器并在执行时引入暂停。 Unity中的垃圾回收：堆分配期间会发生什么？堆分配比堆栈分配复杂得多。这是因为堆可用于存储长期和短期数据，以及许多不同类型和大小的数据。分配和解除分配并不总是以可预测的顺序发生，并且可能需要非常不同大小的存储器块。 创建堆变量时，将执行以下步骤： 首先，Unity必须检查堆中是否有足够的可用内存。如果堆中有足够的可用内存，则分配变量的内存。 如果堆中没有足够的可用内存，Unity会尝试释放垃圾收集器，以释放未使用的堆内存。这可能是一个缓慢的操作。如果堆中现在有足够的可用内存，则会分配变量的内存。 如果垃圾回收后堆中没有足够的可用内存，Unity会增加堆中的内存量。这可能是一个缓慢的操作。然后分配变量的内存。 堆分配可能很慢，特别是如果垃圾收集器必须运行并且必须扩展堆。 垃圾收集期间会发生什么？当堆变量超出范围时，用于存储它的内存不会立即释放。只有在垃圾收集器运行时才会释放未使用的堆内存。 每次垃圾收集器运行时，都会发生以下步骤： 垃圾收集器检查堆上的每个对象。 垃圾收集器搜索所有当前对象引用以确定堆上的对象是否仍在范围内。 任何不再在范围内的对象都被标记为删除。 将删除标记的对象，并将分配给它们的内存返回到堆中。 垃圾收集可能是一项昂贵的操作。堆上的对象越多，它必须做的工作越多，代码中的对象引用越多，它必须做的工作就越多。 垃圾收集什么时候发生？有三件事可能导致垃圾收集器运行： 无论何时请求堆分配都无法使用堆中的可用内存来执行垃圾收集器。 垃圾收集器会不时自动运行（尽管频率因平台而异）。 垃圾收集器可以强制手动运行。 垃圾收集可能是一个频繁的操作。每当无法从可用堆内存中实现堆分配时，就会触发垃圾收集器，这意味着频繁的堆分配和解除分配会导致频繁的垃圾回收。 参考： Understanding the managed heap（理解托管堆） Understanding Automatic Memory Management(理解自动内存管理) Optimizing garbage collection in Unity games(在Unity游戏中优化垃圾回收) Boehm garbage collector]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Unity] 动画系统]]></title>
    <url>%2F2019%2F03%2F25%2FUnity%E7%AC%94%E8%AE%B0%2FUnity-%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[Unity中的动画控制系统。 动画系统Unity的动画系统支持引擎内编辑动画，也支持外部导入FBX动画。由于引擎内置的的动画编辑器没有骨骼动画的概念，所以只能编辑每一帧模型的Transform、整体的旋转、缩放和平移。 模型：Unity显示模型必须给游戏对象提供Mesh Filter和Mesh Renderer组件，前者表示模型需要用的Mesh文件，后者通过材质的贴图和Shader最终将这个模型渲染出来。 Mesh Filter：Mesh Render：Prefab：动画编辑器：动画编辑器的原理就是通过时间线来修改组件的信息，比如修改Transform位置信息，修改Renderer组件或者修改颜色信息，控制模型显示隐藏；此外，还可以在时间线上添加动画事件，编辑后的动画需要配合Animator组件使用。 导入类动画：人形重定向动画：人形重定向动画就是多个身形不同的人物模型也可以共用一份骨骼动画，此技术应用在游戏中会大量减少内存和包体大小。重定向动画的原理就是将不同身形的骨骼信息套入相同的动画中来运算。 通用动画：老版动画：导入类动画事件：动画控制器：动画控制器的原理就是状态机：]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity Shader中的测试]]></title>
    <url>%2F2019%2F03%2F18%2FUnity%E7%AC%94%E8%AE%B0%2FUnity-Shader%E4%B8%AD%E7%9A%84%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[Unity Shader中的测试：Alpha测试、模版测试、深度测试。 Alpha测试：Alpha Test和Alpha Blending是两种处理透明的方法。 Alpha Test：Alpha Test采用一种很霸道极端的机制，只要一个像素的alpha不满足条件，那么它就会被fragment shader舍弃。被舍弃的fragments不会对后面的各种Tests产生影响；否则，就会按正常方式写入到缓存中，并进行正常的深度检验等等，也就是说，Alpha Test是不需要关闭ZWrite的。Alpha Test产生的效果也很极端，要么完全透明，即看不到，要么完全不透明。 Alpha Blending：而Alpha Blending则是一种中庸的方式，它使用当前fragment的alpha作为混合因子，来混合之前写入到缓存中颜色值。但Alpha Blending麻烦的一点就是它需要关闭ZWrite，并且要十分小心物体的渲染顺序。如果不关闭ZWrite，那么在进行深度检测的时候，它背后的物体本来是可以透过它被我们看到的，但由于深度检测时大于它的深度就被剔除了，从而我们就看不到它后面的物体了。因此，我们需要保证物体的渲染顺序是从后往前，并且关闭该半透明对象的ZWrite。 注意：Alpha Blending只是关闭ZWrite，人家可没有关闭ZTest哦！这意味着，在输出一个Alpha Blending的fragment时，它还是会判断和当前Color Buffer中的fragment的深度关系，如果它比当前的fragment深度更远，那么它就不会再做后续的混合操作；否则，它就会和当前的fragment进行混合，但是不会把自己的深度信息写入Depth Buffer中。这是非常重要的，这一点决定了，即便一个不透明物体出现在一个透明物体的前面，不透明物体仍可以正常的遮挡住透明物体！也就是说，对于Alpha Blending来说，Depth Buffer是只读的。 尽可能使用Alpha Blending，而不要使用Alpha Test。 模板测试：模板测试stencil test是3d渲染管线中介于透明测试alpha test和深度测试depth test之间的测试，目的是根据条件来比较设置的参考值referenceValue和模板缓冲区stencil buff中对应的值stencilBuffValue的大小，如果条件满足就让片段fragment（候选的像素）进入下一测试，即深度测试，条件不满足就过滤掉片段，不把对应材质的片段输出到屏幕。 深度测试： 什么是深度？ 深度其实就是该像素点在3d世界中距离摄象机的距离，深度值Zbuffer（Z值）越大，则离摄像机越远。 什么是深度缓存？ 深度缓存中存储着每个像素点（绘制在屏幕上的）的深度值，如果启用了深度缓冲区，在绘制每个像素之前，OpenGL会把它的深度值和已经存储在这个像素的深度值进行比较。新像素深度值小于原先像素深度值，则新像素值会取代原先的；反之，新像素值被遮挡，其颜色值和深度将被丢弃，最终屏幕显示的就是深度缓存中深度对应的像素点的颜色！(深度主要起的是比较的作用) 什么是深度测试？ 在深度测试中，默认情况是将要绘制的新像素的z值与深度缓冲区中对应位置的z值进行比较，如果比深度缓存中的值小，那么用新像素的颜色值更新深度缓存中对应像素的颜色值。 为什么需要深度？ 在不使用深度测试的时候，如果我们先绘制一个距离较近的物体，再绘制距离较远的物体，则距离远的物体因为后绘制，会把距离近的物体覆盖掉，这样的效果并不是我们所希望的。而有了深度缓冲以后，绘制物体的顺序就不那么重要了，都能按照远近（Z值）正常显示，这很关键。(越后绘制的东西，距离相机就越近) ZWrite：ZWrite可以取的值为：On/Off，默认值为On，代表是否要将像素的深度写入深度缓存中。 ZTest：ZTest可以取的值为：Greater/GEqual/Less/LEqual/Equal/NotEqual/Always/Never/Off，默认值为LEqual，代表如何将像素的颜色写入深度缓存中，例如当取默认值的情况下，如果将要绘制的新像素的z值小于等于深度缓存中的值，则将用新像素的颜色值更新深度缓存中对应像素的颜色值。需要注意的是，当ZTest取值为Off时，表示的是关闭深度测试，等价于取值为Always，而不是Never！Always指的是直接将当前像素颜色(不是深度)写进颜色缓冲区中；而Never指的是不要将当前像素颜色写进颜色缓冲区中，相当于消失。 Early-Z技术：传统的渲染管线中，ZTest其实是在Blending阶段，这时候进行深度测试，所有对象的像素着色器都会计算一遍，没有什么性能提升，仅仅是为了得出正确的遮挡结果，会造成大量的无用计算，因为每个像素点上肯定重叠了很多计算。因此现代GPU中运用了Early-Z的技术，在Vertex阶段和Fragment阶段之间（光栅化之后，fragment之前）进行一次深度测试，如果深度测试失败，就不必进行fragment阶段的计算了，因此在性能上会有很大的提升。但是最终的ZTest仍然需要进行，以保证最终的遮挡关系结果正确。前面的一次主要是Z-Cull为了裁剪以达到优化的目的，后一次主要是Z-Check。 Early-Z的实现，主要是通过一个Z-pre-pass实现，简单来说，对于所有不透明的物体（透明的没有用，本身不会写深度），首先用一个超级简单的shader进行渲染，这个shader不写颜色缓冲区，只写深度缓冲区，第二个pass关闭深度写入，开启深度测试，用正常的shader进行渲染。其实这种技术，我们也可以借鉴，在渲染透明物体时，因为关闭了深度写入，有时候会有其他不透明的部分遮挡住透明的部分，而我们其实不希望他们被遮挡，仅仅希望被遮挡的物体半透，这时我们就可以用两个pass来渲染，第一个pass使用Color Mask屏蔽颜色写入，仅写入深度，第二个pass正常渲染半透，关闭深度写入。 Unity渲染顺序：如果我们先绘制后面的物体，再绘制前面的物体，就会造成over draw；而通过Early-Z技术，我们就可以先绘制较近的物体，再绘制较远的物体（仅限不透明物体），这样，通过先渲染前面的物体，让前面的物体先占坑，就可以让后面的物体深度测试失败，进而减少重复的fragment计算，达到优化的目的。Unity中默认应该就是按照最近距离的面进行绘制的。 参考： 【Unity Shaders】Alpha Test和Alpha Blending Unity Shader中的渲染队列、ZWrite和ZTest Unity Shader-渲染队列，ZTest，ZWrite，Early-Z]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity Shader 使用噪声]]></title>
    <url>%2F2019%2F03%2F10%2FUnity%E7%AC%94%E8%AE%B0%2FUnity-Shader-%E4%BD%BF%E7%94%A8%E5%99%AA%E5%A3%B0%2F</url>
    <content type="text"><![CDATA[消融效果、水波效果、全局雾效。 消融效果的实现：通过噪声纹理采样与设置好的消融属性相减，将算得结果小于0的像素剔除。对于剩下的像素进行正常的光照计算，然后在设定好的宽度范围内对两种溶解颜色进行插值，再将混合得到的颜色与环境光和漫反射光照混合输出。 后面还需要加一个用于处理阴影的Pass，否则已经消融的部分会投射影子。 定义属性： 定义消融需要的Pass：为了得到正确的光照，我们设置了Pass的LightMode和multi_compile_fwdbase的编译指令。 我们使用Cull off来关闭Shader的面片剔除，来使得其正面和背面都会被渲染。 定义顶点着色器： 通过片元着色器实现模拟消融效果： 首先对噪声纹理进行采样，并将结果和用于控制消融程度的属性相减，传递给clip函数，将结果小于0的像素剔除。 对于剩下的像素，进行正常的光照计算。我们根据漫反射纹理获得反射率albedo，并由此计算环境光照与漫反射光照。 计算烧焦颜色：在宽度为_LineWidth的范围内模拟一个烧焦的颜色变化，使用smoothstep来计算混合系数（当t为1时，表明该像素位于消融的边界处；当t为0时，表明该像素为正常的模型颜色），插值用来模拟一个烧焦效果：使用t来混合两种火焰颜色。同样使用step函数来保证剔除。 自定义投射阴影的Pass： 同样使用clip函数来剔除片元，然后使用内置宏SHADOW_CASTER_FRAGMENT()来完成阴影投射，将结果输出到深度图和阴影映射纹理中。 水波效果：全局雾效：生成噪声：噪声是怎么生成的：https://blog.csdn.net/candycat1992/article/details/50346469 基于晶格的方法（Lattice based） 基于点的方法（Point based） Perlin噪声： Perlin噪声还是比较简单的，Perlin噪声的实现需要三个步骤： 定义一个晶格结构，每个晶格的顶点有一个“伪随机”的梯度向量（其实就是个向量啦）。对于二维的Perlin噪声来说，晶格结构就是一个平面网格，三维的就是一个立方体网格。 输入一个点（二维的话就是二维坐标，三维就是三维坐标，n维的就是n个坐标），我们找到和它相邻的那些晶格顶点（二维下有4个，三维下有8个，n维下有2n2n个），计算该点到各个晶格顶点的距离向量，再分别与顶点上的梯度向量做点乘，得到2n2n个点乘结果。 使用缓和曲线（ease curves）来计算它们的权重和。在原始的Perlin噪声实现中，缓和曲线是s(t)=3t2−2t3s(t)=3t2−2t3。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity Shader 高级纹理]]></title>
    <url>%2F2019%2F03%2F06%2FUnity%E7%AC%94%E8%AE%B0%2FUnity-Shader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86%2F</url>
    <content type="text"><![CDATA[立方体纹理实现环境映射，渲染纹理以及程序纹理。 立方体纹理：定义：立方体纹理是环境映射的一种实现方式。环境映射可以模拟物体周围的环境，使用了环境映射的物体可以看起来像是镀了金属一样反射出周围的环境。 采样方式正方体纹理一共包含了6张图像，这些图像对应了一个立方体的6个面。立方体的每个面表示沿着世界空间下的轴向观察所得来的图像。对立方体纹理采样需要我们提供一个三维的纹理坐标，这个三维纹理坐标表示了我们在世界空间下的一个3D方向。这个方向矢量从立方体的中心出发，当它向外部延伸时就会和立方体的6个纹理之一发生相交，而采样得到的结果就是由该交点计算而来的。 优点与缺点： 优点：实现简单快速，得到的效果比较好。 缺点： 当场景中引入了新的物体、光源，或者物体发生移动时，我们就需要重新生成立方体纹理。 立方体纹理只能反射环境，不能反射使用了该立方体纹理的物体本身。它不能模拟多次反射的结果，故应尽量对凸面体而不是凹面体使用立方体纹理。 天空盒子（Skybox）：天空盒子是在所有不透明物体之后渲染的，而其背后使用的网格是一个立方体或一个细分后的球体。 创建用于环境映射的立方体纹理： 直接由一些特殊布局的纹理创建：需要一张具有特殊布局的纹理，然后将其Texture Type设置成Cubemap即可。 手动创建一个Cubemap资源：创建一个Cubemap，将六张纹理拖拽到它的面板中。 由脚本生成：使用Camera.RenderToCubemap函数实现——从任意位置观察到的场景图像存储到6张图像中，从而创建出该位置上对应的正方体纹理。 反射效果： 通过入射光线的方向和表面法线方向来计算反射方向，再利用反射方向对立方体纹理采样。 首先，声明需要用到的属性： 在顶点着色器中计算该顶点处的反射方向，根据CG的reflect函数来实现： 物体反射到摄像机中的光线方向，可以由光路可逆的原则来反向求得。可以计算视角方向关于顶点法线的反射方向来求得入射光线的方向。 (TRANSFER_SHADOW参见以前的博客：（此处应有链接）) 在片元着色器中，利用反射方向来对立方体纹理采样： 对立方体纹理的采样需要使用CG的texCUBE函数，用于采样的参数仅仅是作为方向变量传递给texCUBE函数的，没有必要进行归一化。 然后使用_ReflectAmount来混合漫反射颜色和反射颜色，并和环境光照相加后返回。 可以在片元着色器中计算反射方向，这样效果更好，但是差别不大；处于性能考虑，我们选择在顶点着色器中计算反射方向。 效果： 折射效果： 当光线从一种介质斜射入另一种介质时，传播方向一般会发生改变。当给定入射角时，可以使用斯涅尔定律来计算反射角。 ​ $n_1sinθ_1 = n_2sinθ_2$ 其中，n1和n2分别是两个介质的折射率。 一般对一个透明物体，准确的模拟需要计算两次折射——一次入射与一次出射。但是这样模拟很复杂，所以初学在此仅模拟一次折射。 声明属性： 使用CG的refract函数来计算折射方向。 第一个参数是入射光线的方向，必须是归一化后的矢量；第二个参数是表面法线，法线方向同样需要是归一化的；第三个参数是入射光线所在介质的折射率与折射光线所在介质的折射率之间的比值。返回计算而得的折射方向，它的模则等于入射光线的模。 在片元着色器中使用折射方向对立方体纹理进行采样： 最后使用_RefractAmount来混合漫反射和折射颜色，并和环境光照相加后返回。 效果： 菲涅尔反射： 当光线照射到物体表面上时，一部分发生反射，一部分进入物体内部，发生折射或散射。被反射的光和入射光之间存在一定的比率关系，这个比例关系可以通过菲涅尔等式进行计算。 菲涅尔等式： Schlick菲涅尔近似等式： ​ $F_{Schlick}(v,n) = F_0 + (1 - F_0)(1 - v·n)^5$ ​ $F_0$是反射系数，用于控制菲涅尔反射的强度，v是视角方向，n是表面法线。 Empricial菲涅尔近似等式： ​ $F_{Empricial}(v,n) = max(0, min(1,bias + scale * (1 - v·n)^{power})$ Bias、scale和power是控制项。 定义属性：_FresnelScale属性用于调整菲涅尔反射 在顶点着色器中计算世界空间下的法线方向、视角方向和反射方向： 在片元着色器中计算菲涅尔反射，并使用结果值混合漫反射光照和反射光照： 效果： 当_FresnelScale为1时： 为0.5时： 为0时： 渲染纹理：镜子效果的实现：玻璃效果的实现：我们可以使用GrabPass来完成获取屏幕图像的目的。在Shader中定义了一个GrabPass后，Unity会把当前屏幕的图像绘制在一张纹理中，以便在后续的Pass中访问。与简单的透明混合不同，使用GrabPass可以让我们对物体后面的图像进行更复杂的处理，例如使用法线来模拟折射效果，而不是简单的与原屏幕颜色进行混合。 使用GrabPass时，要小心物体的渲染队列设置，往往需要把物体的渲染队列设置成透明队列（“Queue ” = “Transparent”），来保证当渲染该物体的时候，所有的不透明物体已经被绘制在屏幕上，获得正确的屏幕图像。 整体思路： 首先使用一张法线纹理来修改模型的法线信息，然后使用反射方法，通过一个Cubemap来模拟玻璃的反射，而在模拟折射时，使用了GrabPass获取玻璃后面的屏幕图像，并使用切线空间下的法线对屏幕纹理坐标偏移后，再对屏幕图像进行采样来模拟近似的折射效果。 声明属性： 定义相应的渲染队列 定义变量： 定义顶点着色器阶段： 先进行必要的顶点坐标变换。 调用内置的ComputeGrabScreenPos函数来得到对应被抓取的屏幕图像的采样坐标。 计算_MainTex和_BumpMap的采样坐标，并存储在一个float4类型变量中。 接着计算顶点对应的从切线空间到世界空间的变换矩阵，并把该矩阵的每一行分别存储在三个TtoWx的xyz分量中。这样做是为了在片元着色器中把法线方向从切线空间转换到世界空间下，以便对CubeMap进行采样。 计算得到的分量被按列组成一个变换矩阵，w轴被用来存储世界空间下的顶点坐标。 定义片元着色器： 通过世界坐标得到该片元对应的视角方向。 对法线纹理进行采样，得到切线空间下的法线方向。 使用切线空间下的法线方向进行偏移（因为该空间下的法线可以反映顶点局部空间下的法线方向） 随后对scrPos透视除法得到真正的屏幕坐标，再使用该坐标对抓取的屏幕图像_RefractionTex进行采样，得到模拟的折射颜色。 下一步把法线方向从切线空间变换到了世界空间下，并据此得到视角方向相对于法线方向的反射方向。 使用反射方向对Cubemap进行采样，并把结果和主纹理颜色相乘后得到反射颜色。 最后使用_RefractAmount属性对反射和折射颜色进行混合，作为最终的输出颜色。 效果： 为什么要在Pass中使用一个字符串指明被抓取的屏幕图像存储名称？ 直接使用GrabPass{}性能消耗较大，因为这样对于每个使用它的物体，Unity会为它单独进行一次昂贵的屏幕抓取工作。不过这样可以使不同的物体得到不同的屏幕图像。 指明字符串后，可以在后续的Pass中通过名称来访问屏幕图像。这样效果更高效，但是所有物体都会使用同一张屏幕图像。 程序纹理：可以使用程序纹理来创建程序材质。 波点纹理实例：]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[翻译] StateMachine]]></title>
    <url>%2F2018%2F12%2F17%2F%E7%BF%BB%E8%AF%91%2F%E7%BF%BB%E8%AF%91-StateMachine%2F</url>
    <content type="text"><![CDATA[[TOC] 游戏中的状态机，分层状态机以及伪代码实现。 Chapter 5 Decision Making5.3 STATE MACHINES：状态机Often, characters in a game will act in one of a limited set of ways. They will carry on doing the same thing until some event or influence makes them change. A covenant warrior in Halo [Bungie Software, 2001], for example, will stand at its post until it notices the player, then it will switch into attack mode, taking cover and firing. 通常来说，游戏中的角色所进行的行为将会从有限的行为集合中选取。它们将会保持这个状态，直到一些事件或者影响使得它们改变。以 光环：战斗进化 为例，敌人将会一直驻守直到它们注意到玩家，此时将会转换到攻击状态，寻求掩体以及开火。 We can support this kind of behavior using decision trees, and we’ve gone some way to doing that using random decisions. In most cases, however, it is easier to use a technique designed for this purpose: state machines. 我们可以通过决策树来实现这种行为，并且我们已经采用某种方式使用随机决策来做到这一点。然而，在大多数情况下，对于这个目标，我们可以采用更为容易的技术设计：状态机。 State machines are the technique most often used for this kind of decision making and, along with scripting (see Section 5.9), make up the vast majority of decision making systems used in current games. 状态机是一种经常用于这类决策的技术，它与脚本一起使用（参见第5.9节），构成当前游戏中使用的绝大多数（vast majority）决策系统。 State machines take account of both the world around them (like decision trees) and their internal makeup (their state). 状态机既与它周围的世界相关（类似于决策树）又与其内部组成相关（它们自身的状态）。 A Basic State Machine ：一个基本状态机In a state machine each character occupies one state. Normally, actions or behaviors are associated with each state. So as long as the character remains in that state, it will continue carrying out the same action. 在状态机中，每个角色占据一个状态。通常，动作或行为与每个状态相关联。因此，只要角色保持在该状态，它将继续执行相同的动作。 States are connected together by transitions. Each transition leads from one state to another, the target state, and each has a set of associated conditions. If the game determines that the conditions of a transition are met, then the character changes state to the transition’s target state. When a transition’s conditions are met, it is said to trigger, and when the transition is followed to a new state, it has fired. 每个状态通过状态转换联系在一起。每个转换从一个状态引导到另一个状态，即目标状态，并且每个转换具有一组相关条件。如果游戏确定满足转换的条件，则角色将状态改变为要转换的目标状态。当满足转换条件时，它会被触发，当转换到新状态时，它就会被触发。 Figure 5.13 shows a simple state machine with three states: On Guard, Fight, and Run Away. Notice that each state has its own set of transitions. 图5.13显示了一个具有三种状态的简单状态机：On Guard，Fight和Run Away。请注意，每个状态都有自己的一组转换。 The state machine diagrams in this chapter are based on the UML state chart di- agram format, a standard notation used throughout software engineering. States are shown as curved corner boxes. Transitions are arrowed lines, labelled by the condition that triggers them. Conditions are contained in square brackets. 本章中的状态机图表基于UML状态图表格式，这是整个软件工程中使用的标准符号。状态显示为弯角框。过渡是箭头线，由触发它们的条件标记。条件包含在方括号中。 The solid circle in Figure 5.13 has only one transition without a trigger condition. The transition points to the initial state that will be entered when the state machine is first run. 图5.13中的实心圆只有一个没有触发条件的转换。转换指向首次运行状态机时将进入的初始状态。 You won’t need an in-depth understanding of UML to understand this chapter. If you want to find out more about UML, I’d recommend Pilone [2005]. 您不需要深入了解UML来理解本章。如果你想了解更多关于UML的信息，我推荐Pilone [2005]。 In a decision tree the same set of decisions is always used, and any action can be reached through the tree. In a state machine only transitions from the current state are considered, so not every action can be reached. 在决策树中，始终使用相同的决策集，并且可以通过树到达任何操作。在状态机中，仅考虑从当前状态的转换，因此不是每个动作都可以到达。 Finite State Machines ：有限状态机In game AI any state machine with this kind of structure is usually called a finite state machine (FSM). This and the following sections will cover a range of increasingly powerful state machine implementations, all of which are often referred to as FSMs. 在游戏AI中，具有这种结构的任何状态机通常称为有限状态机（FSM）。本节和以下部分将介绍一系列日益强大的状态机实现，所有这些实现通常都称为FSM。 This causes confusion with non-games programmers, for whom the term FSM is more commonly used for a particular type of simple state machine. An FSM in computer science normally refers to an algorithm used for parsing text. Compilers use an FSM to tokenize the input code into symbols that can be interpreted by the compiler. 这导致与非游戏程序员的混淆，对于他们来说，术语FSM更常用于特定类型的简单状态机。计算机科学中的FSM通常是指用于解析文本的算法。编译器使用FSM将输入代码标记为可由编译器解释的符号。 The Game FSM ：游戏中的有限状态机The basic state machine structure is very general and admits any number of imple- mentations. I have seen tens of different ways to implement a game FSM, and it is rare to find any two developers using exactly the same technique. That makes it difficult to put forward a single algorithm as being the “state machine” algorithm. 基本状态机结构非常通用，允许任意数量的实现。我已经看到了几种不同的方法来实现游戏FSM，并且很少发现任何两个开发人员使用完全相同的技术。这使得将单个算法提出为“状态机”算法变得困难。 Later in this section, I’ll look at a range of different implementation styles for the FSM, but the main algorithm I work through is just one. I chose it for its flexibility and the cleanness of its implementation. 在本节的后面部分，我将介绍FSM的一系列不同的实现样式，但我使用的主要算法只有一个。我之所以选择它是因为它的灵活性和实现的优雅性。 5.3.1 THE PROBLEM ：问题We would like a general system that supports arbitrary state machines with any kind of transition condition. The state machine will conform to the structure given above and will occupy only one state at a time. 我们想要一个支持具有任何转换条件的任意状态机的通用系统。这个状态机将符合上面给出的结构，并且一次只占用一个状态。 5.3.2 THE ALGORITHM ：算法We will use a generic state interface which can be implemented to include any spe- cific code. The state machine keeps track of the set of possible states and records the current state it is in. Alongside each state, a series of transitions are maintained. Each transition is again a generic interface that can be implemented with the appropriate conditions. It simply reports to the state machine whether it is triggered or not. 我们将使用通用状态接口，可以实现包含任何特定代码。 状态机跟踪可能状态的集合并记录它所处的当前状态。在每个状态下，保持一系列转换。 每次转换都是一个通用接口，可以使用适当的条件实现。 它只是向状态机报告它是否被触发。 At each iteration (normally each frame), the state machine’s update function is called. This checks to see if any transition from the current state is triggered. The first transition that is triggered is scheduled to fire. The method then compiles a list of actions to perform from the currently active state. If a transition has been triggered, then the transition is fired. 在每次迭代（通常是每个帧），调用状态机的更新函数。 这将检查是否触发了当前状态的任何转换。 触发的第一个转换将会被执行。 然后，该方法维护一个要从当前活动状态执行的动作列表(actions)。 如果已触发某个转换，则会执行这个转换。 This separation of the triggering and firing of transitions allows the transitions to also have their own actions. Often, transitioning from one state to another also involves carrying out some action. In this case a fired transition can add the action it needs to those returned by the state. 这种转换的触发和触发的分离允许转换也具有它们自己的动作。 通常，从一个状态转换到另一个状态也涉及执行某些行动。 //在这种情况下，触发转换可以将所需的操作添加到状态返回的操作。 5.3.3 PSEUDO-CODE ：伪代码实现The state machine holds a list of states, with an indication of which one is the current state. It has an update function for triggering and firing transitions and a function that returns a set of actions to carry out. 状态机保存状态列表，指示哪一个是当前状态。 //它具有用于执行和触发转换的更新功能以及返回要执行的一组操作的功能。 12345678910111213141516171819202122232425262728293031323334353637383940414243class machine&#123; // 维护一个状态机的状态列表 list&lt;State&gt; states; // 初始状态 State initialState； // 当前状态 currentState = initialState; // 检查并执行转换，同时返回一个动作列表 Update() &#123; // 假定没有转换被触发 triggeredTransition = None; // 遍历所有状态并保存第一个被触发的状态 for transition in currentState.getTransitions() &#123; if transition.isTriggered(): triggeredTransition = transition; break; &#125; // 检查是否有状态被触发？ if triggeredTransition &#123; targetState = triggeredTransition.getTargetState(); // 在行为列表之中增加旧状态的退出操作、状态转移的操作以及新状态的入口操作 actions = currentState.getExitAction() actions += triggeredTransition.getAction() actions += targetState.getEntryAction() // 完成状态转移并返回行为列表 currentState = targetState return actions &#125; // 否则直接返回当前状态的行为列表 else return currentState.getAction() &#125;&#125; 5.3.4 DATA STRUCTURES AND INTERFACES ：数据结构与接口The state machine relies on having states and transitions with a particular interface.The state interface has the following form: 状态机依赖于具有特定接口的状态和转换。状态接口具有以下形式： 12345678class State&#123; def getAction(); def getEntryAction(); def getExitAction(); def getTransitions();&#125; Each of the getAction methods should return a list of actions to carry out. As we will see below, the getEntryAction is only called when the state is entered from a transition, and the getExitAction is only called when the state is exited. The rest of the time that the state is active, getAction is called. The getTransitions method should return a list of transitions that are outgoing from this state. The transition interface has the following form: 每个getAction方法都应返回要执行的操作列表。 正如我们将在下面看到的，只有在从转换进入状态时才调用getEntryAction，并且仅在退出状态时调用getExitAction。 其余时间状态为活动状态，调用getAction。 getTransitions方法应返回从此状态传出的转换列表。 转换接口具有以下形式： 123456class Transition&#123; def isTriggered(); def getTargetState(); def getAction();&#125; The isTriggered method returns true if the transition can fire; the getTarget-State method reports which state to transition to; and the getAction method returns a list of actions to carry out when the transition fires. 如果转换可以触发，则isTriggered方法返回true; getTarget-State方法报告要转换到的状态; 并且getAction方法返回转换触发时要执行的操作列表。 Transition Implementation ：实现转换Only one implementation of the state class should be required: it can simply hold the three lists of actions and the list of transitions as data members, returning them in the corresponding get methods. 只需要一个状态类的实现：它可以简单地将三个动作列表和转换列表保存为数据成员，并在相应的get方法中返回它们。 In the same way, we can store the target state and a list of actions in the transition class and have its methods return the stored values. The isTriggered method is more difficult to generalize. Each transition will have its own set of conditions, and much of the power in this method is allowing the transition to implement any kind of tests it likes. 以同样的方式，我们可以在转换类中存储目标状态和操作列表，并使其方法返回存储的值。 isTriggered方法更难以概括。 每个转换都有自己的一组条件，这种方法的大部分功能是允许转换实现它喜欢的任何类型的条件测试。 Because state machines are often defined in a data file and read into the game at run time, it is a common requirement to have a set of generic transitions. The state machine can then be set up from the data file by using the appropriate transitions for each state. 由于状态机通常在数据文件中定义并在运行时读入游戏，因此通常需要具有一组通用转换。 然后，可以通过使用每个状态的适当转换从数据文件中设置状态机。 In the previous section on decision trees, we saw generic testing decisions that operated on basic data types. The same principle can be used with state machine transitions: we have generic transitions that trigger when data they are looking at is in a given range. 在上一节关于决策树的部分中，我们看到了对基本数据类型进行操作的通用测试决策。 相同的原理可以与状态机转换一起使用：我们具有通用转换，当它们正在查看的数据处于给定范围内时触发。 Unlike decision trees, state machines don’t provide a simple way of combining these tests together to make more complex queries. If we need to transition based on the condition that the enemy is far away AND health is low, then we need some way of combining triggers together. 与决策树不同，状态机不提供将这些测试组合在一起以进行更复杂查询的简单方法。// 如果我们需要根据敌人在远处且健康状况低的条件进行过渡，那么我们需要一些将触发器组合在一起的方法。 In keeping with our polymorphic design for the state machine, we can accom- plish this with the addition of another interface: the condition interface. We can use a general transition class of the following form: 为了与状态机的多态设计保持一致，我们可以通过添加另一个接口来实现这一点：条件接口。 我们可以使用以下形式的一般转换类： 1234567891011class Transition&#123;// 条件接口类 actions def getAction(): return actions targetState def getTargetState(): return targetState condition def isTriggered(): return condition.test()&#125; The isTriggered function now delegates the testing to its condition member.Conditions have the following simple format: isTriggered函数现在将测试委托给其条件成员。条件具有以下简单格式： 1234class Condition&#123; def test();&#125; We can then make a set of sub-classes of condition for particular tests, just like we did for decision trees: 然后，我们可以为特定测试创建一组条件子类，就像我们为决策树所做的那样： 12345678910class FloatCondition (Condition)&#123;// 数值条件 minValue; maxValue; testValue; // 我们想关注的游戏数据 def test() &#123; return minValue &lt;= testValue &lt;= maxValue &#125;&#125; We can combine conditions together using Boolean sub-classes, such as AND, NOT, and OR: 我们可以使用布尔子类将条件组合在一起，例如AND，NOT和OR： 1234567891011121314151617181920212223242526272829class AndCondition (Condition)&#123;// 布尔条件 conditionA conditionB def test() &#123; return conditionA.test() and conditionB.test(); &#125;&#125;class NotCondition (Condition)&#123; condition def test() &#123; return not condition.test(); &#125; &#125;class OrCondition (Condition)&#123; conditionA conditionB def test() &#123; return conditionA.test() or conditionB.test() &#125;&#125; and so on, for any level of sophistication we need. 等等……，支持我们需要的任何复杂程度。 Weaknesses ：缺点This approach to transitions gives a lot of flexibility, but at the price of lots of method calls. In C++ these method calls have to be polymorphic, which can slow down the call and confuse the processor. All this adds time, which may make it unsuitable for use in every frame on lots of characters. 这种转换方法提供了很大的灵活性，但代价是大量的方法调用。 在C ++中，这些方法调用必须是多态的，这会降低调用速度并使处理器混淆。 所有这些都增加了时间，这可能使其不适合在许多角色的每个帧中使用。 Several developers I have come across use a homegrown scripting language to ex- press conditions for transitions. This still allows designers to create the state machine rules, but can be slightly more efficient. In practice, however, the speed up over this approach is quite small, unless the scripting language includes some kind of compila- tion into machine code (i.e., Just In Time Compiling). For all but the simplest code, interpreting a script is at least as time-consuming as calling polymorphic functions. 我遇到的几个开发人员使用自己开发的脚本语言来表达转换条件。 这仍然允许设计人员创建状态机规则，但可以稍微提高效率。 然而，在实践中，除非脚本语言包括对机器代码的某种编译（即，及时编译），否则这种方法的速度非常快。 对于除最简单代码之外的所有代码，解释脚本至少与调用多态函数一样耗时。 5.3.6 PERFORMANCE ：开销The state machine algorithm only requires memory to hold a triggered transition and the current state. It is O(1) in memory, and O(m) in time, where m is the number of transitions per state. 状态机算法仅需要存储器来保持触发转换和当前状态。 它在存储器中是O（1），在时间上是O（m），其中m是每个状态的转换数。 The algorithm calls other functions in both the state and the transition classes, and in most cases the execution time of these functions accounts for most of the time spent in the algorithm. 该算法调用状态和转换类中的其他函数，并且在大多数情况下，这些函数的执行时间占算法中花费的大部分时间。 5.3.7 IMPLEMENTATION NOTES ：实现的一些说明As I mentioned earlier, there are any number of ways to implement a state machine. The state machine described in this section is as flexible as possible. I’ve tried to aim for an implementation that allows you to experiment with any kind of state machine and add interesting features. In many cases it may be too flexible. If you’re only planning to use a small subset of its flexibility, then it is very likely to be unnecessarily inefficient. 正如我之前提到的，有许多方法可以实现状态机。 本节中描述的状态机尽可能灵活。 我试图实现一个允许您尝试任何类型的状态机并添加有趣功能的实现。 在许多情况下，它可能过于灵活。 如果您只计划使用其灵活性的一小部分，则很可能会产生不必要的低效率。 5.3.8 HARD-CODED FSM ：FSM的硬编码问题A few years back, almost all state machines were hard-coded. The rules for transitions and the execution of actions were part of the game code. It has become less common as level designers get more control over building the state machine logic, but it is still an important approach. 几年前，几乎所有的状态机都是硬编码的。 转换规则和动作的执行是游戏代码的一部分。 随着关卡设计师对构建状态机逻辑的更多控制，它变得不那么常见，但它仍然是一种重要的方法。 Pseudo-Code ：伪代码In a hard-coded FSM, the state machine consists of an enumerated value, indicating which state is currently occupied, and a function that checks if a transition should be followed. Here I’ve combined the two into a class definition (although I personally tend to associate hard-coded FSMs with developers still working in C). 在硬编码的FSM中，状态机由枚举值组成，指示当前占用的状态，以及检查是否应遵循转换的函数。 在这里，我将两者合并为一个类定义（尽管我个人倾向于将硬编码的FSM与仍在C中工作的开发人员联系起来）。 1234567891011121314151617181920212223242526272829303132333435363738class MyFSM&#123; // 声明所有状态名 enum State &#123; PATROL, DEFEND, SLEEP &#125;; // 当前状态 myState； def update() &#123; // 寻找当前状态 if myState == PATROL &#123; if canSeePlayer() myState = DEFEND if tired() myState = SLEEP &#125; else if myState == DEFEND &#123; if not canSeePlayer() myState = PATROL &#125; else if myState == SLEEP &#123; if not tired() myState = PATROL &#125; def notifyNoiseHeard(volume) &#123; if myState == SLEEP and volume &gt; 10: myState = DEFEND &#125; &#125;&#125; Notice that this is pseudo-code for a particular state machine rather than a type of state machine. In the update function there is a block of code for each state. In that block of code the conditions for each transition are checked in turn, and the state is updated if required. The transitions in this example all call functions (tired and canSeePlayer), which I am assuming have access to the current game state. 请注意，这是特定状态机的伪代码，而不是一种状态机。 在更新功能中，每个状态都有一个代码块。 在该代码块中，依次检查每个转换的条件，并在需要时更新状态。 这个例子中的转换都是调用函数（tired()和canSeePlayer()），我假设它们可以访问当前的游戏状态。 In addition, I’ve added a state transition in a separate function, notifyNoiseHeard. I am assuming that the game code will call this function whenever the character hears a loud noise. This illustrates the difference between a polling (asking for informa- tion explicitly) and an event-based (waiting to be told information) approach to state transitions. Chapter 10 on world interfacing contains more details on this distinction. 另外，我在一个单独的函数notifyNoiseHeard中添加了一个状态转换。 我假设只要角色听到很大的噪音，游戏代码就会调用此函数。 这说明了轮询（明确要求信息）和基于事件（等待被告知信息）的状态转换方法之间的区别。 关于世界接口的第10章包含有关这种区别的更多细节。 The update function is called in each frame, as before, and the current state is used to generate an output action. To do this, the FSM might have a method containing conditional blocks of the following form: 更新函数像以前一样在每个帧中调用，当前状态用于生成输出动作。 为此，FSM可能有一个包含以下形式的条件块的方法： 123456def getAction()&#123; if myState == PATROL: return PatrolAction elif myState == DEFEND: return DefendAction elif myState == SLEEP: return SleepAction&#125; Often, the state machine simply carries out the actions directly, rather than returning details of the action for another piece of code to execute. 通常，状态机只是直接执行操作，而不是返回要执行的另一段代码的操作细节。 Performance ：开销This approach requires no memory and is O(n + m), where n is the number of states, and m is the number of transitions per state. 这种方法不需要存储器，并且是O（n + m），其中n是状态数，m是每个状态的转换数。 Although this appears to perform worse than the flexible implementation, it is usually faster in practice for all but huge state machines (i.e., thousands of states). 虽然这似乎比灵活的实现更糟糕，但实际上除了巨大的状态机（即数千个状态）之外通常更快。 Weaknesses ：缺点Although hard-coded state machines are easy to write, they are notoriously difficult to maintain. State machines in games can often get fairly large, and this can appear as ugly and unclear code. 虽然硬编码的状态机很容易编写，但它们很难维护。 游戏中的状态机通常会变得相当大，这可能看起来像丑陋和不清楚的代码。 Most developers, however, find that the main drawback is the need for program- mers to write the AI behaviors for each character. This implies a need to recompile the game each time the behavior changes. While it may not be a problem for a hobby game writer, it can become critical in a large game project that takes many minutes or hours to rebuild. 然而，大多数开发人员发现主要缺点是程序员需要为每个角色编写AI行为。 这意味着每次行为改变时都需要重新编译游戏。 虽然它可能不是一个业余爱好游戏开发者的问题，但它可能在一个大型游戏项目中变得至关重要，需要花费很多分钟或几小时来重建。 More complex structures, such as hierarchical state machines (see below), are also difficult to coordinate using hard-coded FSMs. With a more flexible implementation, debugging output can easily be added to all state machines, making it easier to track down problems in the AI. 更复杂的结构，例如分层状态机（见下文），也很难使用硬编码的FSM进行协调。 通过更灵活的实现，可以轻松地将调试输出添加到所有状态机，从而更容易跟踪AI中的问题。 5.3.9 HIERARCHICAL STATE MACHINES：分层状态机On its own, one state machine is a powerful tool, but it can be difficult to express some behaviors. One common source of difficulty is “alarm behaviors.” 就其本身而言，一台状态机是一种强大的工具，但表达某些行为可能很困难。一个常见的例子是“警报行为”。 Imagine a service robot that moves around a facility cleaning the floors. It has a state machine allowing it to do this. It might search around for objects that have been dropped, pick one up when it finds it, and carry it off to the trash compactor. This can be simply implemented using a normal state machine (see Figure 5.14). 想象一下一个机器人在清洁地板的设施周围移动。 它有一个状态机允许它这样做。 它可能会搜索掉落的物体，找到它时拾取一个物体，然后将它带到垃圾压缩机。 这可以使用普通状态机简单地实现（参见图5.14）。 Unfortunately, the robot can run low on power, whereupon it has to scurry off to the nearest electrical point and get recharged. Regardless of what it is doing at the time, it needs to stop, and when it is fully charged again, it needs to pick up where it left off. The recharging periods could allow the player to sneak by unnoticed, for example, or allow the player to disable all electricity to the area and thereby disable the robot. 不幸的是，机器人的能源不是无限的，因此它必须赶到最近的电气点并进行充电。 不管它当时在做什么，它需要停止。当它再次充满电时，它需要从它停止的地方开始。 例如，充电时段可允许玩家不加注意地潜行，或允许玩家禁用该区域的所有电力，从而禁用机器人。（注：游戏场景模拟） This is an alarm mechanism: something that interrupts normal behavior to respond to something important. Representing this in a state machine leads to a dou- bling in the number of states. 这是一种警报机制：可以中断正常行为以回应重要事件。 在状态机中表示这一点会导致状态数量的增加。 With one level of alarm this isn’t a problem, but what would happen if we wanted the robot to hide when fighting breaks out in the corridor. If its hiding instinct is more important than its refuelling instinct, then it will have to interrupt refuelling to go hide. After the battle it will need to pick up refuelling where it left off, after which it will pick up whatever it was doing before that. For just 2 levels of alarm, we would have 16 states. 通过一层警报，这不是问题，但如果我们希望机器人在走廊中发生战斗时隐藏会发生什么。 如果它的隐藏决策比加油决策优先级更高，那么就不得不中断加油才能隐藏起来。 在战斗结束后，它需要在停止的地方接受加油，之后它将重拾它之前做的事情。 对于仅2层警报，我们将有16个状态。（？） Rather than combining all the logic into a single state machine, we can separate it into several. Each alarm mechanism has its own state machine, along with the original behavior. They are arranged in a hierarchy, so the next state machine down is only considered when the higher level state machine is not responding to its alarm. 我们可以将它分成几个，而不是将所有逻辑组合到一个状态机中。 每个报警机制都有自己的状态机以及原始行为。 它们按层次结构排列，因此仅当较高级别的状态机未响应其警报时才考虑下一个状态机。 Figure 5.15 shows one alarm mechanism and corresponds exactly to the diagram above. 图5.15显示了一种报警机制，与上图完全一致。 We will nest one state machine inside another to indicate a hierarchical state ma- chine (Figure 5.16). The solid circle again represents the start state of the machine. When a composite state is first entered, the circle with H* inside it indicates which sub-state should be entered. 我们将一个状态机嵌套在另一个状态机中以指示分层状态机（图5.16）。 实心圆圈再次表示机器的启动状态。 首次输入复合状态时，其中带有H *的圆圈表示应输入哪个子状态。 If the composite state has already been entered, then the previous sub-state is returned to. The H* node is called the “history state” for this reason. 如果已经输入复合状态，则返回先前的子状态。 由于这个原因，H *节点被称为“历史状态”。 The details of why there’s an asterisk after the H, and some of the other vagaries of the UML state chart diagram, are beyond the scope of this chapter. Refer back to Pilone [2005] for more details. H之后有一个星号的原因以及UML状态图表中的一些其他变幻莫测的细节超出了本章的范围。 有关更多详细信息，请参阅Pilone [2005]。 Rather than having separate states to keep track of the non-alarm state, we intro- duce nested states. We still keep track of the state of the cleaning state machine, even if we are in the process of refuelling. When the refuelling is over, the cleaning state machine will pick up where it left off. 我们引入嵌套状态，而不是使用单独的状态来跟踪非警报状态。 即使我们正在加油，我们仍然会跟踪清洁状态机的状态。 当加油结束时，清洁状态机将从停止的地方开始。 In effect, we are in more than one state at once: we might be in the “Refuel” state in the alarm mechanism, while at the same time be in the “Pick Up Object” state in the cleaning machine. Because there is a strict hierarchy, there is never any confusion about which state wins out: the highest state in the hierarchy is always in control. 实际上，我们同时处于多个状态：我们可能处于报警机制中的“加油”状态，同时处于清洗机制中的“拾取对象”状态。 因为存在严格的层次结构，所以对于执行哪个状态并不存在任何混淆：层次结构中的最高状态始终处于控制之中。 To implement this, we could simply arrange the state machines in our program so that one state machine calls another if it needs to. So if the refuelling state ma- chine is in its “Clean Up” state, it calls the cleaning state machine and asks it for the action to take. When it is in the “Refuel” state, it returns the refuelling action directly. 为了实现这一点，我们可以简单地在我们的程序中安排状态机，以便一个状态机在需要时调用另一个状态机。 因此，如果加油状态机处于“清理”状态，它会调用清洁状态机并要求其采取措施。 当它处于“加油”状态时，它直接返回加油动作。 While this would lead to slightly ugly code, it would implement our scenario. Most hierarchical state machines, however, support transitions between levels of the hierarchy, and for that we’ll need more complex algorithms. 虽然这会导致稍微丑陋的代码，但它会实现我们的场景。 但是，大多数分层状态机支持层次结构级别之间的转换，为此我们需要更复杂的算法。 For example, let’s expand our robot so that it can do something useful if there are no objects to collect. It makes sense that it will use the opportunity to go and recharge, rather than standing around waiting for its battery to go flat. The new state machine is shown in Figure 5.17. 例如，让我们扩展我们的机器人，以便在没有要收集的对象时它可以做一些有用的事情。 这是有意义的，它会利用这个机会去充电，而不是站在那里等待电池电量消失。 新的状态机如图5.17所示。 Notice that we’ve added one more transition: from the “Search” state right out into the “Refuel” state. This transition is triggered when there are no objects to collect. Because we transitioned directly out of this state, the inner state machine no longer has any state. When the robot has refuelled and the alarm system transitions back to cleaning, the robot will not have a record of where to pick up from, so it must start the state machine again from its initial node (“Search”). 请注意，我们又添加了一个转换：从“搜索”状态直接进入“加油”状态。 没有要收集的对象时会触发此转换。 因为我们直接从这个状态转换，内部状态机不再具有任何状态。 当机器人加满了油并且报警系统转换回清洁时，机器人将无法记录从哪里取货，因此它必须从其初始节点（“搜索”）再次启动状态机。 The Problem ：问题We’d like an implementation of a state machine system that supports hierarchical state machines. We’d also like transitions that pass between different layers of the machine. 我们想要一个支持分层状态机的状态机系统的实现。 我们也喜欢在机器的不同层之间传递的过渡。 The Algorithm ：算法In a hierarchical state machine each state can be a complete state machine in its own right. We therefore rely on recursive algorithms to process the whole hierarchy. As with most recursive algorithms, this can be pretty tricky to follow. The simplest im- plementation covered here is doubly tricky because it recurses up and down the hier- archy at different points. I’d encourage you to use the informal discussion and exam- ples in this section alongside the pseudo-code in the next section and play with the Hierarchical State Machine program on the CD to get a feel for how it is all working. 在分层状态机中，每个状态本身可以是完整的状态机。 因此，我们依靠递归算法来处理整个层次结构。 与大多数递归算法一样，这可能非常棘手。 这里涉及的最简单的实现是双重棘手的，因为它在不同的点上上下起伏。 我鼓励您使用本节中的非正式讨论和示例以及下一节中的伪代码，并使用CD上的Hierarchical State Machine程序来了解它是如何工作的。 The first part of the system returns the current state. The result is a list of states, from highest to lowest in the hierarchy. The state machine asks its current state to return its hierarchy. If the state is a terminal state, it returns itself; otherwise, it returns itself and adds to it the hierarchy of state from its own current state. 系统的第一部分返回当前状态。 结果是状态列表，从层次结构的最高到最低。 状态机要求其当前状态返回其层次结构。 如果状态是终端状态，则返回自身; 否则，它返回自身并从其当前状态向其添加状态层次结构。 In Figure 5.18 the current state is [State L, State A]. 在图5.18中，当前状态是[状态L，状态A]。 The second part of the hierarchical state machine is its update. In the original state machine we assumed that each state machine started off in its initial state. Because the state machine always transitioned from one state to another, there was never any need to check if there was no state. State machines in a hierarchy can be in no state; they may have a cross hierarchy transition. The first stage of the update, then, is to check if the state machine has a state. If not, it should enter its initial state. 分层状态机的第二部分是它的更新。 在原始状态机中，我们假设每个状态机在其初始状态下启动。 因为状态机总是从一个状态转换到另一个状态，所以从来没有必要检查是否没有状态。 层次结构中的状态机可以处于无状态; 他们可能有一个跨层次的过渡。 然后，更新的第一阶段是检查状态机是否具有状态。 如果没有，它应该进入其初始状态。 Next, we check if the current state has a transition it wants to execute. Transitions at higher levels in the hierarchy always take priority, and the transitions of sub-states will not be considered if the super-state has one that triggers. 接下来，我们检查当前状态是否有要执行的转换。 层次结构中较高级别的转换始终具有优先级，如果父状态已经被触发，则不会考虑子状态的转换。 A triggered transition may be one of three types: it might be a transition to an- other state at the current level of the hierarchy; it might be a transition to a state higher up in the hierarchy; or it might be a transition to a state lower in the hierarchy. Clearly, the transition needs to provide more data than just a target state. We allow it to return a relative level: how many steps up or down the hierarchy the target state is. 触发转换可以是以下三种类型之一：它可能是在层次结构的当前级别转换到另一种状态; 它可能是向层次结构中更高级别的状态过渡; 或者它可能是转换到层次结构中较低的状态。 显然，转换需要提供的数据多于目标状态。 我们允许它返回一个相对级别：目标状态在层次结构中向上或向下的步数。 We could simply search the hierarchy for the target state and not require an ex- plicit level. While this would be more flexible (we wouldn’t have to worry about the level values being wrong), it would be considerably more time-consuming. A hybrid, but fully automatic, extension could search the hierarchy once offline and store all appropriate level values. 我们可以简单地在层次结构中搜索目标状态，而不需要一个明确的级别。 虽然这会更灵活（我们不必担心水平值是错误的），但它会更加耗时。 混合但全自动的扩展可以在离线时搜索层次结构并存储所有适当的级别值。 So the triggered transition has a level of zero (state is at the same level), a level greater than zero (state is higher in the hierarchy), or a level less than zero (state is lower in the hierarchy). It acts differently depending on which category the level falls into. 因此，触发转换拥有三种情况：级别为零（状态处于同一级别），级别大于零（层次结构中的状态较高），或小于零的级别（状态在层次结构中较低）。 它的行为取决于级别所属的类别。 If the level is zero, then the transition is a normal state machine transition and can be performed at the current level, using the same algorithm used in the finite state machine. 如果级别为零，则转换是正常状态机转换，并且可以使用在有限状态机中使用的相同算法在当前级别执行。 If the level is greater than zero, then the current state needs to be exited and noth- ing else needs to be done at this level. The exit action is returned, along with an indication to whoever called the update function that the transition hasn’t been com- pleted. We will return the exit action, the transition outstanding, and the number of levels higher to pass the transition. This level value is decreased by one as it is returned. As we will see, the update function will be returning to the next highest state machine in the hierarchy. 如果级别大于零，则需要退出当前状态，而不需要在此级别完成其他操作。 返回退出操作，同时向任何调用Update()的位置指示转换尚未完成。 我们将返回退出时执行的行为、未完成的转换以及更高级别的数量以通过转换。 该级别值在返回时减少一。 正如我们将看到的，更新功能将返回到层次结构中的下一个最高状态机。 If the level is less than zero, then the current state needs to transition to the ancestor of the target state on the current level in the hierarchy. In addition, each of the children of that state also needs to do the same, down to the level of the final desti- nation state. To achieve this we use a separate function, updateDown, that recursively performs this transition from the level of the target state back up to the current level and returns any exit and entry actions along the way. The transition is then complete and doesn’t need to be passed on up. All the accumulated actions can be returned. // 如果级别小于零，则当前状态需要转换到层次结构中当前级别上的目标状态的父状态。 此外，该状态的每个孩子也需要做同样的事情，直到最终目标状态的水平。 为了实现这一点，我们使用一个单独的函数updateDown，它递归地执行从目标状态级别到当前级别的转换，并返回任何退出和进入操作。 然后转换完成，不需要向上传递。 可以返回所有累积的动作。 So we’ve covered all possibilities if the current state has a transition that triggers. If it does not have a transition that triggers, then its action depends on whether the current state is a state machine itself. If not, and if the current state is a plain state, then we can return the actions associated with being in that state, just as before. 因此，如果当前状态具有触发的转换，我们已经涵盖了所有可能性。 如果它没有触发的转换，那么它的动作取决于当前状态是否是状态机本身。 如果不是，并且如果当前状态是普通状态，那么我们可以像以前一样返回与处于该状态相关联的动作。 If the current state is a state machine, then we need to give it the opportunity to trigger any transitions. We can do this by calling its update function. The update func- tion will handle any triggers and transitions automatically. As we saw above, a lower level transition that fires may have its target state at a higher level. The update func- tion will return a list of actions, but it may also return a transition that it is passing up the hierarchy and that hasn’t yet been fired. 如果当前状态是状态机，那么我们需要给它机会来触发任何转换。 我们可以通过调用它的更新函数来实现。 更新功能将自动处理任何触发和转换。 如上所述，触发的较低级别转换可能使其目标状态处于较高级别。 更新功能将返回一个操作列表，但它也可能返回一个它正在向层次结构传递但尚未触发的转换。 If such a transition is received, its level is checked. If the level is zero, then the transition should be acted on at this level. The transition is honored, just as if it were a regular transition for the current state. If the level is still greater than zero (it should never be less than zero, because we are passing up the hierarchy at this point), then the state machine should keep passing it up. It does this, as before, by exiting the current state and returning the following pieces of information: the exit action; any actions provided by the current state’s update function; the transition that is still pending; and the transition’s level, less one. 如果收到这样的转换，则检查其级别。 如果级别为零，则应在此级别上执行转换。转换已经执行，就像它是当前状态的常规过渡一样。 如果级别仍然大于零（它应该永远不会小于零，因为我们此时正在调整层次结构），那么状态机应该继续传递它。 它像以前一样通过退出当前状态并返回以下信息来执行此操作：退出操作; 当前状态更新功能提供的任何行动; 仍未决的状态转换; 和转换的层级//，少一个。 If no transition is returned from the current state’s update function, then we can simply return its list of actions. If we are at the top level of the hierarchy, the list alone is fine. If we are lower down, then we are also within a state, so we need to add the action for the state we’re in to the list we return. 如果没有从当前状态的更新函数返回转换，那么我们可以简单地返回其动作列表。 如果我们处于层次结构的顶层，那么单独列表就可以了。 如果我们处于较低的层级，那么我们也处于一个状态，所以我们需要为我们返回的列表中的状态添加动作。 Fortunately, this algorithm is at least as difficult to explain as it is to implement. To see how and why it works, let’s work through an example. 幸运的是，这种算法至少与实现一样难以解释。 为了了解它的工作原理和原因，让我们来看一个例子。 Examples ：例子Figure 5.19 shows a hierarchical state machine that we will use as an example. 图5.19显示了我们将用作示例的分层状态机。 To clarify the actions returned for each example, we will say S-entry is the set of entry actions for state S, similarly S-active and S-exit for active and exit actions. In transitions we use the same format 1-actions for the actions associated with transi- tion 1. 为了阐明每个示例返回的操作，我们将说S-entry是状态S的入口操作集，类似于活动和退出操作的S-active和S-exit。 在转换中，我们对与转换1相关的操作使用相同的格式1动作。 These examples can appear confusing if you skim them through. If you’re having trouble with the algorithm, I urge you to follow through step by step with both the diagram above and the pseudo-code from the next section. 如果您浏览它们，这些示例可能会让您感到困惑。 如果您在使用算法时遇到问题，我建议您按照上图和下一部分的伪代码一步一步地进行操作。 Suppose we start just in State L, and no transition triggers. We will transition into State [L, A], because L’s initial state is A. The update function will return: L-active and A-entry, because we are staying in L and just entering A. 假设我们只是在状态L开始，没有转换触发器。 我们将转换到状态[L，A]，因为L’的初始状态是A.更新函数将返回：L-active和A-entry，因为我们留在L并且只是进入A. Now suppose transition 1 is the only one that triggers. The top-level state ma- chine will detect no valid transitions, so will call state machine L to see if it has any. L finds that its current state (A) has a triggered transition. Transition 1 is a transition at the current level, so it is handled within L and not passed anywhere. A transitions to A, and L’s update function returns: A-exit, 1-actions, B-entry. The top-level state machine accepts these actions and adds its own active action. Because we have stayed in State L throughout, the final set of actions is A-exit, 1-actions, B-entry, L-active. The current state is [L, B]. 现在假设转换1是唯一触发的转换。 顶层状态机将检测到无有效转换，因此将调用状态机L以查看它是否有任何转换。 L发现其当前状态（A）具有触发转换。 转换1是当前级别的转换，因此它在L内处理，不会在任何地方传递。 转换到A，并且L的更新函数返回：A-exit，1—actions，B-entry。 顶层状态机接受这些操作并添加其自己的活动操作。 因为我们始终处于状态L，所以最后一组动作是A-exit，1-actions，B-entry，L-active。 当前状态是[L，B]。 From this state, transition 4 triggers. The top-level state machine sees that transi- tion 4 triggers, and because it is a top-level transition, it can be honored immediately. The transition leads to State M, and the corresponding actions are L-exit, 4-actions, M-entry. The current state is [M]. Note that L is still keeping a record of being in State B, but because the top-level state machine is in State M, this record isn’t used at the moment. 从这个状态，转换4触发。 顶级状态机看到转换4触发，并且因为它是顶级转换，所以它可以立即兑现。 转换导致状态M，并且相应的动作是L-exit，4-actions，M-entry。 当前状态是[M]。 请注意，L仍然保留在状态B中的记录，但由于顶级状态机处于状态M，因此此记录不会被使用。 We’ll go from State M to State N in the normal way through transition 5. The pro- cedure is exactly the same as for the previous example and the non-hierarchical state machine. Now transition 6 triggers. Because it is a level zero transition, the top-level state machine can honor it immediately. It transitions into State L and returns the ac- tions N-exit, 6-actions, L-entry. But now, L’s record of being in State B is important: we end up in State [L, B] again. In our implementation we don’t return the B-entry action, because we didn’t return the B-exit action when we left State L previously. This is a personal preference on my part and isn’t fixed in stone. If you want to exit and re-enter State B, then you can modify your algorithm to return these extra actions at the appropriate time. 我们将通过转换5以正常方式从状态M转到状态N.该过程与前一个示例和非分层状态机完全相同。 现在转换6个触发器。 因为它是一个零级转换，所以顶级状态机可以立即兑现它。 它转换到状态L并返回N-exit，6-actions，L-entry的动作。 但是现在，L在状态B的记录很重要：我们再次进入状态[L，B]。 在我们的实现中，我们不返回B-entry动作，因为我们之前离开状态L时没有返回B-exit动作。 这是我个人的偏好，并不是固定的。 如果要退出并重新输入状态B，则可以修改算法以在适当的时间返回这些额外的操作。 Now suppose from State [L, B] transition 3 triggers. The top-level state machine finds no triggers, so it will call state machine L to see if it has any. L finds that State B has a triggered transition. This transition has a level of one: its target is one level higher in the hierarchy. This means that State B is being exited, and it means that we can’t honor the transition at this level. We return B-exit, along with the uncompleted transition, and the level minus one (i.e., zero, indicating that the next level up needs to handle the transition). So control returns to the top-level update function. It sees that L returned an outstanding transition, with zero level, so it honors it, transitioning in the normal way to State N. It combines the actions that L returned (namely,B-exit) with the normal transition actions to give a final set of actions: B-exit, L-exit,3-actions, N-entry. Note that, unlike in our third example, L is no longer keeping track of the fact that it is in State B, because we transitioned out of that state. If we fire transition 6 to return to State L, then State L’s initial state, A, would be entered, just like in the first example. 现在假设从状态[L，B]过渡3触发。顶级状态机找不到触发器，因此它将调用状态机L以查看它是否有任何触发器。 L发现状态B已经触发转换。此转换的级别为1：其目标在层次结构中高一级。这意味着状态B正在退出，并且我们无法履行这一级别的过渡。我们返回B-exit，以及未完成的转换，以及级别减1（即，零，表示下一级需要处理转换）。因此控制移交回上层的Update函数。Update函数得到了一个未完成的状态转换，零级别，所以Update函数将执行这个转换：以正常方式转换到状态N。它将L返回的动作（即B-exit）与正常的过渡动作结合起来给出一组最终动作集：B-exit，L-exit，3-actions，N-entry。请注意，与我们的第三个示例不同，L不再跟踪它在状态B中执行的事，因为我们已经转换出该状态。如果我们触发转换6返回到状态L，则将输入State L’的初始状态A，就像在第一个示例中一样。 Our final example covers transitions with level less than zero. Suppose we moved from State N to State M via transition 7. Now we make transition 2 trigger. The top- level state machine looks at its current state (M) and finds transition 2 triggered. It has a level of minus one, because it is descending one level in the hierarchy. Because it has a level of minus one, the state machine calls the updateDown function to perform the recursive transition. The updateDown function starts at the state machine (L) that contains the final target state (C), asking it to perform the transition at its level. State machine L, in turn, asks the top-level state machine to perform the transition at its level. The top-level state machine changes from State M to State L, returning M-exit, L-entry as the appropriate actions. Control returns to state machine L’s updateDown function. State machine L checks if it is currently in any state (it isn’t, since we left State B in the last example). It adds its action, C-entry, to those returned by the top- level machine. Control then returns to the top-level state machine’s update function: the descending transition has been honored, it adds the transition’s actions to the result, and returns M-exit, C-entry, L-entry, 2-actions. 我们的最后一个示例涵盖了级别小于零的转换。假设我们通过转换7从状态N移动到状态M，现在我们通过触发器2执行转换。顶级状态机查看其当前状态（M）并找到触发的转换2。它的级别为-1，因为它在层次结构中下降一级。因为它的级别为-1，所以状态机调用updateDown函数来执行递归转换。 updateDown函数从包含最终目标状态（C）的状态机（L）开始，要求它在其级别执行转换。状态机L反过来要求顶级状态机在其级别执行转换。顶级状态机从状态M变为状态L，返回M-exit，L-entry作为适当的动作。控制返回状态机L的updateDown函数。状态机L检查它当前是否处于任何状态（它不是，因为我们在最后一个例子中离开了状态B）。它将其操作C-entry添加到顶级计算机返回的操作中。然后，Control返回到顶级状态机的Update函数：已经执行过降序转换，它将转换的动作添加到结果中，并返回M-exit，C-entry，L-entry，2-actions。 If state machine L had still been in State B, then when L’s updateDown function was called, it would transition out of B and into C. It would add B-exit and C-entry to the actions that it received from the top-level state machine. 如果状态机L仍处于状态B，那么当调用L的 updateDown函数时，它将从B转换为C。它会将B-exit和C-entry添加到它从顶层状态机接收的操作集中。 Pseudo-Code ：伪代码The hierarchical state machine implementation is made up of five classes and forms one of the longest algorithms in this book. The State and Transition classes are similar to those in the regular finite state machine. The HierarchicalStateMachine class runs state transitions, and SubMachineState combines the functionality of the state machine and a state. It is used for state machines that aren’t at the top level of the hierarchy. All classes but the Transition inherit from a HSMBase class, which simpli- fies the algorithm by allowing functions to treat anything in the hierarchy in the same way. 分层状态机实现由五个类组成，并形成本书中最长的算法之一。 State和Transition类与常规有限状态机中的类相似。 HierarchicalStateMachine类运行状态转换，SubMachineState结合状态机和状态的功能。 它用于不在层次结构顶层的状态机。 除了Transition之外的所有类都继承自HSMBase类，它通过允许函数以相同的方式处理层次结构中的任何内容来简化算法。 The HSMBase has the following form: HSMBase类如下所示： 12345678910111213141516171819class HSMBase # The structure returned by update // Update函数返回结果的结构体 struct UpdateResult actions // 行为 transition// 转换路径 level // 层级 def getAction(): return [] def update() &#123; UpdateResult result result.actions = getAction() result.transition = None result.level = 0 return result &#125; // 未实现的功能？ def getStates() # unimplemented function The HierarchicalStateMachine class has the following implementation: HierarchicalStateMachine类有着如下实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132class HierarchicalStateMachine (HSMBase) # List of states at this level of the hierarchy // 本层次的状态列表 states # The initial state for when the machine has to # current state. // 机器必须处于当前状态的初始状态 initialState # The current state of the machine. // 状态机的当前状态 currentState = initialState # Gets the current state stack // 获得当前状态栈 def getStates(): if currentState: return currentState.getStates() else: return [] # Recursively updates the machine. // 递归更新状态机 def update(): # If we’re in no state, use the initial state // 如果没有处于任何状态，使用初始状态 if not currentState: currentState = initialState return currentState.getEntryAction() # Try to find a transition in the current state // 从当前状态尝试找到一个转换 triggeredTransition = None for transition in currentState.getTransitions(): if transition.isTriggered(): triggeredTransition = transition break # If we’ve found one, make a result structure for it // 如果我们找到了一个转换，为其生成一个结果结构体 if triggeredTransition: result = UpdateResult() result.actions = [] result.transition = triggeredTransition result.level = triggeredTransition.getLevel() # Otherwise recurse down for a result // 否则递归获得结果 else: result = currentState.update() # Check if the result contains a transition // 检查结果中是否包含转换 if result.transition: # Act based on its level // 基于本层执行 if result.level == 0: # Its on our level: honor it // 结果行为在本层：执行 targetState = result.transition.getTargetState() result.actions += currentState.getExitAction() result.actions += result.transition.getAction() result.actions += targetState.getEntryAction() # Set our current state // 设置当前状态 currentState = targetState # Add our normal action (we may be a state) // 添加基本操作 result.actions += getAction() # Clear the transition, so nobody else does it // 清除转换，因此没有其他(?)执行它 result.transition = None else if result.level &gt; 0: # Its destined for a higher level // 这表示一个更高的层级 # Exit our current state // 退出当前状态 result.actions += currentState.getExitAction() currentState = None # Decrease the number of levels to go // 当相对于目标层级为降低时 result.level -= 1 else: # It needs to be passed down // 它需要向下迁移 targetState = result.transition.getTargetState() targetMachine = targetState.parent result.actions += result.transition.getAction() result.actions += targetMachine.updateDown(targetState, -result.level) # Clear the transition, so nobody else does it // 清除转换，因此没有其他(?)执行它 result.transition = None # If we didn’t get a transition // 如果我们没有（从结果中）取得转换 else: # We can simply do our normal action // 我们可以简单的执行我们的基本行为 result.action += getAction() # Return the accumulated result // 返回积累的结果 return result# Recurses up the parent hierarchy, transitioning into# each state in turn for the given number of levels// 递归父层次结构，依次转换到指定层级号的每个状态def updateDown(state, level): # If we’re not at top level, continue recursing // 如果不在顶层，继续递归 if level &gt; 0: # Pass ourself as the transition state to our parent // 将自己作为转换状态传递给父状态 actions = parent.updateDown(this, level-1) # Otherwise we have no actions to add to // 否则我们将没有要添加的行为 else: actions = [] # If we have a current state, exit it // 如果当前状态存在，退出 if currentState: actions += currentState.getExitAction() # Move to the new state, and return all the actions // 转移到新的状态，并且返回所有行为 currentState = state actions += state.getEntryAction() return actions The state class is substantially the same as before, but adds an implementation for getStates: 状态类的实现与之前的实现大体相同，但是增加了一个有关getStates的实现： 12345678910class State (HSMBase): def getStates(): # If we’re just a state, then the stack is just us // 如果是一个状态，那么要返回的状态栈仅有这个状态自身 return [this] # As before... def getAction() def getEntryAction() def getExitAction() def getTransitions() Similarly, the Transition class is the same, but adds a method to retrieve the level of the transition. 无独有偶，Transition类的实现也一样，但是添加了一个方法来返回的转换所在的层级。 123456789class Transition: # Returns the different in levels of the hierarchy from # the source to the target of the transition. // 返回 def getLevel() # As before... def isTriggered() def getTargetState() def getAction() Finally, the SubMachineState class merges the functionality of a state and a state machine. 最后，SubMachineState类整合了一个状态的功能与一个状态机。 1234567891011121314class SubMachineState (State, HierarchicalStateMachine): # Route get action to the state // 转换 def getAction(): return State::getAction() # Route update to the state machine // 转换 def update(): return HierarchicalStateMachine::update() # We get states by adding ourself to our active children // 通过将自身加入活跃子节点集中获取当前状态 def getStates(): if currentState: return [this] + currentState.getStates() else: return [this] Implementation Notes：实现说明I’ve used multiple inheritance to implement SubMachineState. For languages (or programmers) that don’t support multiple inheritance, there are two options. The Sub- MachineState could encapsulate HierarchicalStateMachine, or the Hierarchical- StateMachine can be converted so that it is a sub-class of State. The downside with the latter approach is that the top-level state machine will always return its active action from the update function, and getStates will always have it as the head of the list. 我已经使用多重继承来实现SubMachineState类。对于不支持多重继承的语言（或程序员），有两种选择。 Sub-MachineState可以封装HierarchicalStateMachine，或者Hierarchical-StateMachine可以被转换，使其成为State的子类。后一种方法的缺点是顶级状态机将始终从更新函数返回其活动操作，并且getStates将始终将其作为列表的头部。 I’ve elected to use a polymorphic structure for the state machine again. It is possible to implement the same algorithm without any polymorphic method calls. Given that it is complex enough already, however, I’ll leave that as an exercise. My experience deploying a hierarchical state machine involved an implementation using poly- morphic method calls (provided on the CD). In-game profiling on both PC and PS2 showed that the method call overhead was not a bottleneck in the algorithm. In a system with hundreds or thousands of states, it may well be, as cache efficiency issues come into play.Some implementations of hierarchical state machines are significantly simpler than this by making it a requirement that transitions can only occur between states at the same level. With this requirement, all the recursion code can be eliminated. If you don’t need cross hierarchy transitions, then the simpler version will be easier to implement. It is unlikely to be any faster, however. Because the recursion isn’t used when the transition is at the same level, the code above will run about as fast if all the transitions have a zero level. 我已经选择再次使用状态机的多态结构。没有任何多态方法调用就可以实现相同的算法。鉴于它已经足够复杂了，我将把它留作练习。我部署分层状态机的经验涉及使用多态方法调用的实现（在CD上提供）。 PC和PS2上的游戏内分析表明，方法调用开销不是算法中的瓶颈。在具有数百或数千个状态的系统中，很可能会出现缓存效率问题。分层状态机的一些实现比这更简单，因为要求转换只能在同一级别的状态之间发生。根据此要求，可以消除所有递归代码。如果您不需要跨层次转换，则更简单的版本将更容易实现。然而，它不太可能更快。因为当转换处于相同级别时不使用递归，所以如果所有转换具有零级别，则上述代码将以相同的速度运行。 Performance ：开销The algorithm is O(n) in memory, where n is the number of layers in the hierarchy. It requires temporary storage for actions when it recurses down and up the hierarchy. 该算法在内存中是O（n），其中n是层次结构中的层数。它需要临时存储操作，以便在向下和向下递增层次结构时执行操作。 Similarly, it is O(nt) in time, where t is the number of transitions per state. To find the correct transition to fire, it potentially needs to search each transition at each level of the hierarchy and O(nt) process. The recursion, both for a transition level 0 is O(n), so it does not affect the O(nt) for the whole algorithm. 类似地，它是时间上的O（nt），其中t是每个状态的转换数。要找到正确的触发转换，可能需要在层次结构的每个级别和O（nt）进程中搜索每个转换。对于转换级别 0的递归都是O（n），因此它不会影响整个算法的O（nt）。 5.3.10 COMBINING DECISION TREES AND STATE MACHINES ：决策树与状态机的结合The implementation of transitions bears more than a passing resemblance to the implementation of decision trees. This is no coincidence, but we can take it even further. Decision trees are an efficient way of matching a series of conditions, and this has application in state machines for matching transitions. We can combine the two approaches by replacing transitions from a state with a decision tree. The leaves of the tree, rather than being actions as before, are transitions to new states. 转换的实现不仅仅与决策树的实现有相似之处。这不是巧合，但我们可以更进一步。决策树是匹配一系列条件的有效方式，而且具有这种行为在用于匹配转换的状态机中有效。 我们可以通过用状态替换状态转换的方式来组合这两种方法决策树。树的叶子，而不是像以前那样的动作，是向新状态的过渡。 A simple state machine might look like Figure 5.20. 一个简单的状态机可能如图5.20所示。 The diamond symbol is also part of the UML state chart diagram format, repre- senting a decision. In UML there is no differentiation between decisions and transi- tions, and the decisions themselves are usually not labelled. In this book I’ve labelled the decisions with the test that they perform, which is clearer for our needs. 菱形符号也是UML状态图表格式的一部分，代表了一个决定。在UML中，决策和转换之间没有区别，决策本身通常没有标记。 在本书中，我用他们执行的测试标记了决策，这更符合我们的需求。 When in the “Alert” state, a sentry has only one possible transition: via the de- cision tree. It quickly ascertains whether the sentry can see the player. If the sentry is not able to see the player, then the transition ends and no new state is reached. If the sentry is able to see the player, then the decision tree makes a choice based on the distance of the player. Depending on the result of this choice, two different states may be reached: “Raise Alarm” or “Defend.” The latter can only be reached if a further test (distance to the player) passes. 当处于“警报”状态时，哨兵只有一个可能的过渡：通过决策树。它可以快速确定哨兵是否可以看到玩家。如果哨兵无法看到该玩家，则转换结束并且不会达到新的状态。如果哨兵能够看到玩家，则决策树根据玩家的距离做出选择。根据此选择的结果，可能会达到两种不同的状态：“提升警报”或“防御”。只有在进一步测试（与玩家的距离）通过后才能达到后者。 To implement the same state machine without the decision nodes, the state ma- chine in Figure 5.21 would be required. Note that now we have two very complex con- ditions and both have to evaluate the same information (distance to the player and distance to the alarm point). If the condition involved a time-consuming algorithm (such as the line of sight test in our example), then the decision tree implementationwould be significantly faster. 要在没有决策节点的情况下实现相同的状态机，将需要图5.21中的状态机。请注意，现在我们有两个非常复杂的条件，两者都必须评估相同的信息（到播放器的距离和到报警点的距离）。如果条件涉及耗时的算法（例如我们示例中的视线测试），那么决策树实现将明显更快。 Pseudo-Code ：伪代码We can incorporate a decision tree into the state machine framework we’ve developed so far. 我们可以将决策树合并到我们迄今为止开发的状态机框架中。 The decision tree, as before, consists of DecisionTreeNodes. These may be decisions (using the same Decision class as before) or TargetStates (which replace the Action class in the basic decision tree). TargetStates hold the state to transition to and can contain actions. As before, if a branch of the decision tree should lead to no result, then we can have some null value at the leaf of the tree. 与以前一样，决策树由DecisionTreeNodes组成。这些可能是决策（使用与之前相同的Decision类）或TargetStates（它们替换基本决策树中的Action类）。 TargetStates保持状态转换并可以包含操作。和以前一样，如果决策树的一个分支应该导致没有结果，那么我们可以在树的叶子上有一些空值。 The decision making algorithm needs to change. Rather than testing for Actions to return, it now tests for TargetState instances: 决策算法需要改变。它不是测试要返回的Actions，而是测试TargetState实例： We can then build an implementation of the Transition interface which supports these decision trees. It has the following algorithm: 然后我们可以构建支持的Transition接口的实现这些决策树。它有以下算法： Implementation：实现As before, this implementation relies heavily on polymorphic methods in an object- oriented framework. The corresponding performance overhead may be unacceptable in some cases where lots of transitions or decisions are being considered.和以前一样，这种实现在很大程度上依赖于面向对象框架中的多态方法。在考虑大量转换或决策的某些情况下，相应的性能开销可能是不可接受的。]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>Artificial Intelligence for Games</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unity shader 渲染管线]]></title>
    <url>%2F2018%2F10%2F22%2FUnity%E7%AC%94%E8%AE%B0%2Funity-shader-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[GPU图形渲染管线流程流程概述应用程序阶段应用程序阶段，使用高级编程语言(C、C++、JAVA 等)进行开发，主要和CPU、内存打交道，诸如碰撞检测、场景图建立、空间八叉树更新、视锥裁剪等经典算法都在此阶段执行。在该阶段的末端，几何体数据(顶点坐标、法向量、纹理坐标、纹理等)通过数据总线传送到图形硬件。 工作： 准备场景数据：如摄像机的位置、视锥体、场景中包含的模型、光源等 粗粒度剔除：把不可见的物体剔除 设置好每个模型的渲染状态：包括材质、使用的纹理、使用的Shader等 输出： 渲染图元：渲染所需的几何信息 几何阶段几何阶段，主要负责顶点坐标变换、光照、裁剪、投影以及屏幕映射，该阶段基于GPU进行运算，在该阶段的末端得到了经过变换和投影之后的顶点坐标、颜色、以及纹理坐标。光照计算属于几何阶段，因为光照计算涉及视点、光源和物体的世界坐标，所以通常放在世界坐标系中进行计算。 工作： 决定需要绘制的图元是什么 怎样绘制 在哪里绘制 输出： 屏幕空间的二维顶点坐标 每个顶点的深度值、着色等相关信息 光栅阶段 光栅阶段，基于几何阶段的输出数据，为像素(Pixel)正确配色，以便绘制完整图像，该阶段进行的都是单个像素的操作，每个像素的信息存储在颜色缓冲器(color buffer 或者 frame buffer)中。 雾化以及涉及物体透明度的计算属于光栅化阶段，因为上述两种计算都需要深度值信息(Z 值)，而深度值是在几何阶段中计算，并传递到光栅阶段的。 工作：根据上个阶段传递的数据来产生屏幕上的像素，并渲染出最终的图像。 输出：逐像素处理过的渲染图元。 从几何阶段到光栅化阶段： 几何阶段：变换三维顶点坐标和光照计算 将模型空间坐标（object space coordinate）通过四阶矩阵变换矩阵（world matrix）转换为世界空间坐标（ world space coordinate ）。 进行光照计算。 将模型空间下的顶点法向量转换为世界空间下的，所用的转换矩阵为world matrix的转置矩阵的逆矩阵。 将物体顶点坐标从世界空间（world space）转换到观察空间下（eye space）。 将顶点坐标从观察空间下转换到裁剪空间下（project and clip space）。 投影：用透视变换矩阵把顶点从视锥体（viewing frustum）中变换到裁剪空间的规范立方体（CVV）中。 图元装配（Primitive Assembly）：将顶点根据原始的连接关系还原出网格结构。 裁剪：在CVV中将位于视体外的场景数据去除。 将得到的完全位于视体中的场景数据映射到屏幕坐标系上。 光栅化阶段：决定哪些像素被集合图元覆盖。光栅化是将几何数据经过一系列变换后最终转换为像素，从而呈现在显示设备上的过程，光栅化的本质是坐标变换，几何离散化。 三角形设置：计算光栅化一个三角网格所需的信息 三角形遍历：检查每个像素是否被一个三角网格所覆盖，被覆盖则生成一个片元（对顶点信息插值）。 读取模型的顶点，3个3个的读，因为要画三角形。 将3个顶点两两连成线，形成三角形。 计算屏幕像素点在三角形内还是三角形外。在三角形内部的，就上色（颜色是之前算出来的），在三角形外部的，就不上色。http://www.cnblogs.com/graphics/archive/2010/08/05/1793393.html（可以通过叉积来实现，连接PA，将PA和AB做叉积，再将CA和AB做叉积，如果两个叉积的结果方向一致，那么两个点在同一测。判断两个向量的是否同向可以用点积实现，如果点积大于0，则两向量夹角是锐角，否则是钝角。） Pixel Operation 纹理操作（Texture operation）：根据像素的纹理坐标，查询对应的纹理值。 消除遮挡面：深度测试，模版测试等。 混色（Blending）：根据目前已经画好的颜色，与正在计算的颜色的透明度(Alpha)，混合为两种颜色，作为新的颜色输出。 滤波（Filtering）：将正在算的颜色通过某种滤波后输出。 HLSL、GLSL与Cg：常见的着色语言： DirectX的HLSL：微软控制着色器编译，编译结果在不同硬件上相同，但平台有限。 OpenGL的GLSL：跨平台性良好，编译结果取决于硬件供应商。 NVIDIA的Cg：真正的跨平台。 DrawCall：CPU调用图像编程接口，命令GPU进行渲染的操作。 Shader： GPU流水线上一些可高度编程的阶段，由着色器编译出来的最终代码会在GPU上运行 有一些特定类型的着色器 依靠着色器来控制流水线中的渲染细节。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[六月七日随笔]]></title>
    <url>%2F2018%2F06%2F07%2F%E9%9A%8F%E7%AC%94%2F%E5%85%AD%E6%9C%88%E4%B8%83%E6%97%A5%E9%9A%8F%E7%AC%94%2F</url>
    <content type="text"><![CDATA[无聊夜晚的碎碎念罢了。 近来还好。 不知道是什么原因，现在拿起笔或者打开word，面对着一片空白，总不知道该敲下点什么。但是偏偏又觉得应该写点什么，作为一种记录被遗忘，在机缘巧合之下向某个尘封已久的服务器发出一个请求，再把这点文字翻出来，以一种陌生人的眼光重新审视当时的自己。 事实上，以上所描述的情况很可能不会发生，于我自己而言，以往写过的那些烂东西（包括这一篇），我只能让它静静地躺在我的日志列表里，并不指望以后翻出来再得到什么愉悦的享受。 之所以有记录的想法，与对他人的效仿不无关系。去年工程实训的时候偶然接触到学长的游戏——《没有人知道的大冒险》，后来在种子班宣讲的时候才得知，原来这款游戏是学长所做。我对这个游戏本身所表达的内容很有感触，便由此对学长其人也生出了些许好奇。互联网是有记忆的，我还是找到了学长的博客，虽然它已经好久没有更新，但是我还是从他当时的文字中依稀看到他当时的状态。我想，文字的魅力在于，它无法向你描述所有，但是你却可以从文字本身生发出基于你人生经验的幻想世界。它或许只是一个截面、一个场景、甚至是一种氛围，但是却可以给你无比真实的代入感。 但是记录仅仅是记录本身，它代表着我当下思想的一部分——用文字所能表述的那部分。 很久没有读过书，我是指文学类的书籍。笼统的把原因归结为每天太忙其实是不成立的，每天固然有很多事情要去做，但是闲下来的时间，还是投入到了无限的收割快速愉悦事业中去了。刷刷微博、看看视频、翻翻好友的动态（所幸目前还没有接触短视频），我的大脑就告诉我：“哦，我感受到多巴胺了！”。纵使我知道这世界也没那么需要我，也没有什么动态是非我知道不可的，我还是这样做了。低级并快乐。 伴随而来的就是，快乐的阈值提高了，而表达自己的水平降低了。可表达的事情越来越少，能感触到的事情也越来越少。我从心底里觉得这不是什么好事，当一部分情绪很久不再出现在你的备选项中，其实是一件非常无聊的事情。就如同炒菜少了那么几位调料，寡淡而无趣。 很清楚的意识到这一点的时候，大概是在成都站的gamejam结束，当主持人宣布第二组入围的时候，我以为我会很开心，但是并没有发生。对事物的好奇、对成就的满足和那种单纯的想要做某件事情的欲望——这些好像都在离我而去。 当然，这或许可以解释为所谓的“佛系”或者“人间不值得”或者随便一句什么用烂了的腔调，但是我想我不该是这样，我想象中的自己是一个有血有肉的、愚蠢的、有着清楚欲望的年轻人，而不是一个默认着某些事情发生、而盲从于某些“看起来好”的人。 我知道这团火终归会熄，但至少不应该是现在。 无知且狂妄总要好过纠结且麻木，起码前者看起来还活着。 先记到这。]]></content>
      <categories>
        <category>文字</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity Shader 基础]]></title>
    <url>%2F2018%2F05%2F11%2FUnity%E7%AC%94%E8%AE%B0%2FUnity-Shader-%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Unity Shader的一些基础知识 Chapter3 Unity Shader 基础概述在Unity需要材质（Material）与Unity Shader配合使用来达到满意的效果。 Unity Shader定义了渲染需要的各种代码（顶点着色器与片元着色器等），属性（使用哪些纹理）和指令（渲染和标签设置），我们通过材质调节这些属性，再赋给相应的模型。 材质：配合GameObject的Mesh或者Particle Systems组件来工作。 Unity Shader： Standard Surface Shader:使用了一个包含了标准光照模型的表面着色器模板 Unlit Shader: 一个不包含光照但是包含雾效的基本顶点/片元着色器 Image Effect Shader: 为实现屏幕后处理提供基本模板 Compute Shader: 借助GPU的并行性来进行一些与渲染流水线无关的计算 ShaderLab一款专门为Unity Shader服务的语言。 Properties 属性 语句格式：Name(&quot;display name&quot;,PropertyType)=DefaultValue 支持的属性类型： |属性类型|定义语法| |:————:|:————:| |Int|number| |Float|number| |Range(min,max)|number| |Color|(number,number,number,number)| |Vector|(number,number,number,number)| |2D|”defaulttexture”{}| |Cube|”defaulttexture”{}| |3D|”defaulttexture”{}| Unity允许重载默认的材质编辑面板以提供更多的自定义数据类型。 关键词“Custom Shader GUI”Properties语义块的作用仅仅是为了让这些属性可以出现在材质面板里。 SubShader:表面着色器 语句格式 123456789101112SubShader&#123; //可选的，标签 [Tags] //可选的，状态 [RenderSetup] //一次完整的渲染流程，如果pass的数目过多，会造成渲染性能的下降。 Pass&#123; &#125; ...&#125; RenderSetup 状态：关于渲染状态的设置指令| 状态名称 | 设置指令 |解释||:————:|:————:|:——:|| Cull |Cull Back/Front/Off| 剔除模式：剔除背面/正面/关闭剔除||ZTest|ZTest Less Greater/LEqual/GEqual/Equal/NotEqual/Always|设置深度剔除时使用的函数||ZWrite|ZWrite On/Off|关闭/开启深度写入||Blend|Blend SrcFactor DstFactor|开启并设置混合模式| Tags 标签：希望怎样以及何时渲染这个对象Tags{&quot;TagName1&quot;=&quot;Value1&quot; &quot;TagName2&quot;=&quot;Value2&quot;}| 标签类型 | 说明 ||————|————|| Queue | 控制渲染顺序，指定该物体属于哪一个渲染队列 ||RenderType|对着色器进行分类，可以用于着色器替换功能||DisableBatching|指明是否对该SubShader使用批处理||ForceNoShadowCasting|控制使用该SubShader的物体是否会投射阴影||IgnoreProjector|控制使用该SubShader的物体是否受projector（投影仪？）的影响||CanUseSpriteAtlas|当该SubShader是用于sprite时，将该标签设为“false”||PreviewType|指明材质面板将如何预览该材质。默认材质下，材质将显示为一个球形，我们可以通过将该标签的值设为“Plane”“SkyBox”来改变预览类型|上述标签可以在SubShader中声明，而不可以在Pass块中声明，Pass块有专属于自己的标签。 Pass语义块： 123456Pass&#123; [Name] [Tag] [RenderSetup] // Other code&#125; Name “MyPassName”：定义该Pass的名称，可以使用UsePass命令来直接使用其他unity shader中的Pass，例如：UsePass &quot;MyShader/MYPASSNAME&quot;，由于Unity 内部会将所有Pass 名称转换为大写字母的表示，所以在使用UsePass的时候必须使用大写形式的名字。 RenderSetup：我们可以对Pass设置渲染状态，除上述状态设置以外，我们还可以使用固定管线的着色器。 Tag：|标签类型|说明|例子||—-|——|—-||LightMode|定义该Pass在Unity渲染流水线中的角色|Tags{“LightMode”=”ForwardBase”}||RequireOptions|用于制定当满足某些条件的时候才渲染该Pass，它的值是一个由空格分割的字符串，目前支持的选项：SoftVegetation|Tags{“RequireOptions”=”SoftVegetation”}| 特殊的Pass： UsePass：使用该指令复用其他UnityShader中的Pass。 GrabPass：负责抓取屏幕并将结果存储在一张纹理之中，以用于后续的Pass 处理。 FallBack如果上面所有的SubShader在这块显卡上都不能运行，那么就用这个最低级的Shader。 123FallBack &quot;name&quot;// 或者FallBack Off 通过一个字符串通知引擎最低级的Shader是哪个，也可以关闭Fallback功能——如果上述的SubShader无法使用，那就不要管它了。 其他语义 拓展编辑界面：CustomEditor 对命令进行分组：CateGory UnityShader的形式ShaderLab语句块：1234567891011121314Shader &quot;Myshader&quot;&#123; Properties&#123; // 所需的各种属性 &#125; SubShader&#123; // 真正意义上的SubShdaer代码会出现在这里 // 表面着色器(Surface Shader) // 顶点/片元着色器(Vertex/Fragment Shader) // 固定函数着色器(Fixed Function Shader) &#125; SubShader&#123; // 与上一个Shader类似 &#125;&#125; 表面着色器当给Unity提供一个表面着色器的时候，它在背后依旧将其转换为对应的顶点/片元着色器。意义在于Unity为我们处理了很多光照细节，使得我们无需再操心这些事情。 12345678910111213141516Shader &quot;Custom/Simple Surface Shader&quot;&#123; SubShader&#123; Tags&#123; &quot;RenderType&quot; = &quot;Opaque&quot; &#125; CGPROGRAM #pragma surface surf Lambert struct Input &#123; float4 color:COLOR; &#125;; void surf (Input IN,inout SurfaceOutput o) &#123; o.Albedo = 1; &#125; ENDCG &#125; Fallback &quot;Diffuse&quot;&#125; 表面着色器被定义在SubShader语义块中的CGPROGRAM与ENDCG之间。之间的代码使用Cg/HLSL语言编写，它嵌套在ShaderLab语言中。 顶点/片元着色器顶点/片元着色器的代码需要定义在CGPROGRAM与ENDCG之间，而着色器是写在Pass语义块内，而非SubShader内，这样做来定义每个Pass需要的Shader代码，灵活性更高，同时控制渲染的实现细节。 1234567891011121314151617181920Shader &quot;Custom/Simple VertexFragment Shader&quot;&#123; SubShader&#123; Pass&#123; CGPROGRAM #pragma vertex vert #pragma fragment frag float4 vert(float4 v:POSITION):SV_POSITION&#123; return mul(UNITY_MATRIX_MVP,v); &#125; fixed4 frag():SV_Target&#123; return fixed4(1.0,0.0,0.0,1.0); &#125; ENDCG &#125; &#125;&#125; 固定函数着色器上面两种UnityShader形式都使用了可编程管线，而对于一些旧的设备不支持可编程管线着色器，此时需要使用固定函数着色器来完成渲染，这些着色器往往只可以完成一些非常简单的效果。 12345678910111213Shader &quot;Tutorial/Basic&quot;&#123; Properties&#123; _Color(&quot;Main Color&quot;,color)=(1.0,5.0,5.1) &#125; SubShader&#123; Pass&#123; Material&#123; Diffuse[_Color] &#125; Lighting On &#125; &#125;&#125; 乐乐女神的一些建议： 除非有明确的需求必须要使用固定函数着色器，否则请使用可编程管线的着色器。 如果想和各种光源打交道，你可能更喜欢表面着色器，但需要小心它在移动平台的性能表现。 如果需要使用的光照数目非常少，使用顶点/片元着色器是一个更好的选择。 如果有很多自定义的渲染效果，请选择顶点/片元着色器。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Unity】 Cursor学习]]></title>
    <url>%2F2018%2F04%2F11%2FUnity%E7%AC%94%E8%AE%B0%2FUnity-Cursor%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[关于CursorLockMode 光标锁定模式的一个随手记。 CursorLockMode.None 光标行为未修改，第一人称视角下鼠标可以突破窗口。 CursorLockMode.Locked 光标锁定到游戏窗口的中心，与全屏与否无关，同时隐藏光标（这一点在3D相机下成立，在2D相机下貌似不成立，还需要用visible来控制隐藏），无论如何移动光标光标都无法出现，按‘esc’切换到None模式。 CursorLockMode.Confined 光标限制在游戏窗口内，光标不会隐藏，在窗口模式下无法突破窗口，限制在窗口区域内。 Cursor.visible 光标可见性，和人感觉用来实现鼠标隐藏的效果并不好，或许和Confined联合可以有Locked的效果？那为什么不用Locked呢…… 示例代码：https://docs.unity3d.com/ScriptReference/Cursor-lockState.html资料来源：http://wiki.ceeger.com/script/unityengine/enumerations/cursorlockmode/cursorlockmode]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>unity学习</tag>
      </tags>
  </entry>
</search>
