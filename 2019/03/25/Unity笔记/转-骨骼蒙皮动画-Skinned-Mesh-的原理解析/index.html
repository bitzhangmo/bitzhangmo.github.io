<!DOCTYPE html>
<html>
<head>
    
<!-- Google Analytics -->
<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'true', 'auto');
ga('send', 'pageview');
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
<!-- End Google Analytics -->


    

    



    <meta charset="utf-8">
    
    <meta name="google-site-verification" content="true">
    
    
    
    
    <title>[转] 骨骼蒙皮动画(Skinned Mesh)的原理解析 | zhangMo Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#1eb4e9">
    
    
    <meta name="keywords" content="动画,骨骼动画">
    <meta name="description" content="骨骼蒙皮动画(Skinned Mesh)的原理解析。">
<meta name="keywords" content="动画,骨骼动画">
<meta property="og:type" content="article">
<meta property="og:title" content="[转] 骨骼蒙皮动画(Skinned Mesh)的原理解析">
<meta property="og:url" content="https:&#x2F;&#x2F;bitzhangmo.github.io&#x2F;2019&#x2F;03&#x2F;25&#x2F;Unity%E7%AC%94%E8%AE%B0&#x2F;%E8%BD%AC-%E9%AA%A8%E9%AA%BC%E8%92%99%E7%9A%AE%E5%8A%A8%E7%94%BB-Skinned-Mesh-%E7%9A%84%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90&#x2F;index.html">
<meta property="og:site_name" content="zhangMo Blog">
<meta property="og:description" content="骨骼蒙皮动画(Skinned Mesh)的原理解析。">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-03-25T03:27:21.780Z">
<meta name="twitter:card" content="summary">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" target="_blank" rel="noopener" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.png">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">zhangMo</h5>
          <a href="mailto:wangxc1998@qq.com" target="_blank" rel="noopener" title="wangxc1998@qq.com" class="mail">wangxc1998@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags/"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories/"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/about/"  >
                <i class="icon icon-lg icon-child"></i>
                About
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/bitzhangmo" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://weibo.com/u/7175236950" target="_blank" >
                <i class="icon icon-lg icon-weibo"></i>
                Weibo
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-steam"></i>
                Steam
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://skmtjun.github.io/" target="_blank" >
                <i class="icon icon-lg icon-dice"></i>
                螺涅神社
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://tenwoods.github.io/" target="_blank" >
                <i class="icon icon-lg icon-link"></i>
                十木杂物间
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" target="_blank" rel="noopener" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">[转] 骨骼蒙皮动画(Skinned Mesh)的原理解析</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" target="_blank" rel="noopener" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" target="_blank" rel="noopener" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" target="_blank" rel="noopener" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">[转] 骨骼蒙皮动画(Skinned Mesh)的原理解析</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-03-25T03:00:28.000Z" itemprop="datePublished" class="page-time">
  2019-03-25
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E8%BD%AC%E8%BD%BD/">转载</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#骨骼蒙皮动画-Skinned-Mesh-的原理解析（一）"><span class="post-toc-number">1.</span> <span class="post-toc-text">骨骼蒙皮动画(Skinned Mesh)的原理解析（一）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3D模型动画基本原理和分类"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">3D模型动画基本原理和分类</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Skinned-Mesh原理和结构分析"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">Skinned Mesh原理和结构分析</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#理解骨骼和骨骼层次结构（Bone-Hierarchy）"><span class="post-toc-number">1.2.1.</span> <span class="post-toc-text">理解骨骼和骨骼层次结构（Bone Hierarchy）</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#骨骼蒙皮动画-Skinned-Mesh-的原理解析（二）"><span class="post-toc-number">2.</span> <span class="post-toc-text">骨骼蒙皮动画(Skinned Mesh)的原理解析（二）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#蒙皮信息和蒙皮过程"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">蒙皮信息和蒙皮过程</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Skin-info的定义"><span class="post-toc-number">2.1.1.</span> <span class="post-toc-text">Skin info的定义</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Bone-Offset-Matrix的含义和计算方法"><span class="post-toc-number">2.1.2.</span> <span class="post-toc-text">Bone Offset Matrix的含义和计算方法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#最终-顶点混合（vertex-blending）"><span class="post-toc-number">2.1.3.</span> <span class="post-toc-text">最终:顶点混合（vertex blending）</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#动画数据和播放动画"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">动画数据和播放动画</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#总结"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">总结</span></a></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-Unity笔记/转-骨骼蒙皮动画-Skinned-Mesh-的原理解析"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">[转] 骨骼蒙皮动画(Skinned Mesh)的原理解析</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-03-25 11:00:28" datetime="2019-03-25T03:00:28.000Z"  itemprop="datePublished">2019-03-25</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E8%BD%AC%E8%BD%BD/">转载</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p>骨骼蒙皮动画(Skinned Mesh)的原理解析。</p>
<a id="more"></a>

<p>原文地址（已经404）：<a href="http://blog.csdn.net/ccx1234/article/details/6641944" target="_blank" rel="noopener">http://blog.csdn.net/ccx1234/article/details/6641944</a></p>
<h2 id="骨骼蒙皮动画-Skinned-Mesh-的原理解析（一）"><a href="#骨骼蒙皮动画-Skinned-Mesh-的原理解析（一）" class="headerlink" title="骨骼蒙皮动画(Skinned Mesh)的原理解析（一）"></a>骨骼蒙皮动画(Skinned Mesh)的原理解析（一）</h2><h3 id="3D模型动画基本原理和分类"><a href="#3D模型动画基本原理和分类" class="headerlink" title="3D模型动画基本原理和分类"></a>3D模型动画基本原理和分类</h3><p> 3D模型动画的基本原理是让模型中各顶点的位置随时间变化。主要种类有Morph动画，关节动画和骨骼蒙皮动画(Skinned Mesh)。从动画数据的角度来说，三者一般都采用关键帧技术，即只给出关键帧的数据，其他帧的数据使用插值得到。但由于这三种技术的不同，关键帧的数据 是不一样的。</p>
<p>Morph（渐变，变形）动画是直接指定动画每一帧的顶点位置，其动画关键中存储的是Mesh所有顶点在关键帧对应时刻的位置。</p>
<p>关节动画的模型不是一个整体的Mesh,而是分成很多部分(Mesh)，通过一个父子层次结构将这些分散的Mesh组织在一起，父Mesh带动其下子 Mesh的运动，各Mesh中的顶点坐标定义在自己的坐标系中，这样各个Mesh是作为一个整体参与运动的。动画帧中设置各子Mesh相对于其父Mesh 的变换（主要是旋转，当然也可包括移动和缩放），通过子到父，一级级的变换累加（当然从技术上，如果是矩阵操作是累乘）得到该Mesh在整个动画模型所在 的坐标空间中的变换（从本文的视角来说就是世界坐标系了，下同），从而确定每个Mesh在世界坐标系中的位置和方向，然后以Mesh为单位渲染即可。关节 动画的问题是，各部分Mesh中的顶点是固定在其Mesh坐标系中的，这样在两个Mesh结合处就可能产生裂缝。</p>
<p>第三类就是骨骼蒙皮动画即Skinned Mesh了，骨骼蒙皮动画的出现解决了关节动画的裂缝问题，而且效果非常酷，发明这个算法的人一定是个天才，因为Skinned Mesh的原理简单的难以置信，而效果却那么好。骨骼动画的基本原理可概括为：在骨骼控制下，通过顶点混合动态计算蒙皮网格的顶点，而骨骼的运动相对于其 父骨骼，并由动画关键帧数据驱动。一个骨骼动画通常包括骨骼层次结构数据，网格(Mesh)数据，网格蒙皮数据(skin info)和骨骼的动画(关键帧)数据。下面将具体分析。</p>
<h3 id="Skinned-Mesh原理和结构分析"><a href="#Skinned-Mesh原理和结构分析" class="headerlink" title="Skinned Mesh原理和结构分析"></a>Skinned Mesh原理和结构分析</h3><p>Skinned Mesh中文一般称作骨骼蒙皮动画，正如其名，这种动画中包含骨骼（Bone）和蒙皮(Skinned Mesh)两个部分，Bone的层次结构和关节动画类似，Mesh则和关节动画不同：关节动画中是使用多个分散的Mesh，而Skinned Mesh中Mesh是一个整体，也就是说只有一个Mesh,实际上如果没有骨骼让Mesh运动变形，Mesh就和静态模型一样了。Skinned Mesh技术的精华在于蒙皮，所谓的皮并不是模型的贴图（也许会有人这么想过吧），而是Mesh本身，<strong>蒙皮是指将Mesh中的顶点附着（绑定）在骨骼之上，而且每个顶点可以被多个骨骼所控制，这样在关节处的顶点由于同时受到父子骨骼的拉扯而改变位置就消除了裂缝。</strong>Skinned Mesh这个词从字面上理解似乎是有皮的模型，哦，如果贴图是皮，那么普通静态模型不也都有吗？所以我觉得应该理解为具有蒙皮信息的Mesh或可当做皮肤用的Mesh，这个皮肤就是Mesh。而为了有皮肤功能，Mesh还需要蒙皮信息，即Skin数据，没有Skin数据就是一个普通的静态Mesh了。</p>
<p>Skin数据决定顶点如何绑定到骨骼上。顶点的Skin数据包括顶点受哪些骨骼影响以及这些骨骼影响该顶点时的权重(weight)，另外对于每块骨骼还需要骨骼偏移矩阵(BoneOffsetMatrix)用来将顶点从Mesh空间变换到骨骼空间。在本文中，提到骨骼动画中的Mesh特指这个皮肤 Mesh，提到模型是指骨骼动画模型整体。骨骼控制蒙皮运动，而骨骼本身的运动呢？当然是动画数据了。每个关键帧中包含时间和骨骼运动信息，运动信息可以 用一个矩阵直接表示骨骼新的变换，也可用四元数表示骨骼的旋转，也可以随便自己定义什么只要能让骨骼动就行。除了使用编辑设定好的动画帧数据，也可以使用 物理计算对骨骼进行实时控制。</p>
<p>下面分别具体分析骨骼蒙皮动画中的结构部件。</p>
<h4 id="理解骨骼和骨骼层次结构（Bone-Hierarchy）"><a href="#理解骨骼和骨骼层次结构（Bone-Hierarchy）" class="headerlink" title="理解骨骼和骨骼层次结构（Bone Hierarchy）"></a>理解骨骼和骨骼层次结构（Bone Hierarchy）</h4><p>首先要明确一个观念：<strong>骨骼决定了模型整体在世界坐标系中的位置和朝向。</strong></p>
<p>先看看静态模型吧，静态模型没有骨骼，我们在世界坐标系中放置静态模型时，只要指定模型自身坐标系在世界坐标系中的位置和朝向。在骨骼动画中，不是把 Mesh直接放到世界坐标系中，Mesh只是作为Skin使用的，是依附于骨骼的，真正决定模型在世界坐标系中的位置和朝向的是骨骼。在渲染静态模型时， 由于模型的顶点都是定义在模型坐标系中的，所以各顶点只要经过模型坐标系到世界坐标系的变换后就可进行渲染。而对于骨骼动画，我们设置模型的位置和朝向， 实际是在设置根骨骼的位置和朝向，然后根据骨骼层次结构中父子骨骼之间的变换关系计算出各个骨骼的位置和朝向，然后根据骨骼对Mesh中顶点的绑定计算出 顶点在世界坐标系中的坐标，从而对顶点进行渲染。要记住，在骨骼动画中，骨骼才是模型主体，Mesh不过是一层皮，一件衣服。</p>
<p>如何理解骨骼？请看第二个观念：<strong>骨骼可理解为一个坐标空间。</strong></p>
<p>在一些文章中往往会提到关节和骨骼，那么关节是什么?骨骼又是什么？下图是一个手臂的骨骼层次的示例。</p>
<p>骨骼只是一个形象的说法，实际上骨骼可理解为一个坐标空间，关节可理解为骨骼坐标空间的原点。关节的位置由它在父骨骼坐标空间中的位置描述。上图中有三块 骨骼，分别是上臂，前臂和两个手指。Clavicle(锁骨)是一个关节，它是上臂的原点，同样肘关节(elbow joint)是前臂的原点，腕关节(wrist)是手指骨骼的原点。关节既决定了骨骼空间的位置，又是骨骼空间的旋转和缩放中心。为什么用一个4X4矩阵 就可以表达一个骨骼，因为4X4矩阵中含有的平移分量决定了关节的位置，旋转和缩放分量决定了骨骼空间的旋转和缩放。我们来看前臂这个骨骼，其原点位置是 位于上臂上某处的，对于上臂来说，它知道自己的坐标空间某处（即肘关节所在的位置）有一个子空间，那就是前臂，至于前臂里面是啥就不考虑了。当前臂绕肘关 节旋转时，实际是前臂坐标空间在旋转，从而其中包含的子空间也在绕肘关节旋转，在这个例子中是finger骨骼。和实际生物骨骼不同的是，我们这里的骨骼 并没有实质的骨头，所以前臂旋转时，他自己没啥可转的，改变的只是坐标空间的朝向。你可以说上图的蓝线在转，但实际蓝线并不存在，蓝线只是画上去表示骨骼 之间关系的，真正转的是骨骼空间，我们能看到在转的是wrist joint，也就是两个finger骨骼的坐标空间，因为他们是子空间，会跟随父空间运动，就好比人跟着地球转一样。</p>
<p>骨骼就是坐标空间，骨骼层次就是嵌套的坐标空间。关节只是描述骨骼的位置即骨骼自己的坐标空间原点在其父空间中的位置，绕关节旋转是指骨骼坐标空间（包括 所有子空间）自身的旋转，如此理解足矣。但还有两个可能的疑问，一是骨骼的长度问题，由于骨骼是坐标空间，没有所谓的长度和宽度的限制，我们看到的长度一 方面是蒙皮后的结果，另一方面子骨骼的原点（也就是关节）的位置往往决定了视觉上父骨骼的长度，比如这里upper arm线段的长度实际是由elbow joint的位置决定的。第二个问题，手指的那个端点是啥啊？实际上在我们的例子中手指没有子骨骼，所以那个端点并不存在：）那是为了方便演示画上去的。 实际问题中总有最下层的骨骼，他们不能决定其他骨骼了，他们的作用只剩下控制Mesh顶点。对了，那么手指的长度如何确定？我们看到的长度应该是由蒙皮决定的，也就是由Mesh中属于手指的那些点离腕关节的距离决定。</p>
<p>经过一段长篇大论，我们终于清楚骨骼和骨骼层次是啥了，但是为什么要将骨骼组织成层次结构呢？答案是为了做动画方便，设想如果只有一块骨骼，那么让他动起 来就太简单了，动画每一帧直接指定他的位置即可。如果是n块呢？通过组成一个层次结构，就可以通过父骨骼控制子骨骼的运动，牵一发而动全身，改变某骨骼时并不需要设置其下子骨骼的位置，子骨骼的位置会通过计算自动得到。上文已经说过，父子骨骼之间的关系可以理解为，子骨骼位于父骨骼的坐标系中。我们知道物 体在坐标系中可以做平移变换，以及自身的旋转和缩放变换。子骨骼在父骨骼的坐标系中也可以做这些变换来改变自己在其父骨骼坐标系中的位置和朝向等。那么如 何表示呢？由于4X4矩阵可以同时表示上述三种变换，所以一般描述骨骼在其父骨骼坐标系中的变换时使用一个矩阵，也就是DirectX SkinnedMesh中的FrameTransformMatrix。实际上这不是唯一的方法，但应该是公认的方法，因为矩阵不光可以同时表示多种变换 还可以方便的通过连乘进行变换的组合，这在层次结构中非常方便。在本文的例子-最简单的skinned mesh实例中，我只演示了平移变换，所以只用一个3d坐标就可以表示子骨骼在父骨骼中的位置。下面是Bone Class最初的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bone</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">float</span> m_x, m_y, m_z;<span class="comment">//这个坐标是定义在父骨骼坐标系中的</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>OK,除了使用矩阵，坐标或某东西描述子骨骼的位置，我们的Bone Class定义中还需要一些指针来建立层次结构，也就是说我们要能通过父骨骼找到子骨骼或反之。问题是我们需要什么指针呢？从父指向子还是反之？结论是看 你需要怎么用了。如果使用矩阵，需要将父子骨骼矩阵级联相乘，无论你的矩阵是左乘列向量还是右乘行向量，从哪边开始乘不重要，只要乘法中父子矩阵的左右位置正确，所以可以在骨骼中只存放指向父的指针，从子到父每次得到父矩阵循环相乘。也可以像DX中那样从根开始相乘并递归。在文本的DEMO中由于没用矩阵，直接使用坐标相加计算坐标，所以要指定父的位置，然后计算出子的位置，那么需要在Bone Class中加入子骨骼的指针，因为子骨骼有n个，所以需要n个指针吗？不一定，看看DirectX的做法，只需要两个就搞定了，指向第一子的和指向兄弟骨骼的。这样事先就不需要知道有多少子了。下面是修改后的Bone Class：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bone</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">		Bone* m_pSibling;</span><br><span class="line">		Bone* m_pFirstChild;</span><br><span class="line">		<span class="keyword">float</span> m_x, m_y, m_z;<span class="comment">//pos in its parent's space</span></span><br><span class="line">		<span class="keyword">float</span> m_wx, m_wy, m_wz; <span class="comment">//pos in world space</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>同时增加了一组坐标，存放计算好的世界坐标系坐标。</p>
<p>将各个骨骼相对于其父骨骼摆放好，就行成了一个骨骼层次结构的初始位置，所谓初始是指定义骨骼层次时，那后来呢？后来动画改变了骨骼的相对位置，准确的说 一般是改变了骨骼自身的旋转而位置保持不变（特殊情况总是存在，比如雷曼，可以把拳头扔出去的那个家伙），总之骨骼动了，位置变化了。初始位置很重要，因为通过初始位置骨骼层次间的变换，我们确定了骨骼之间的关系，然后在动画中你可以只用旋转。</p>
<p>假设我们通过某种方法建立了骨骼层次结构，那么每一块骨骼的位置都依赖于其父骨骼的位置，而根骨骼没有父，他的位置就是整个骨骼体系在世界坐标系中的位 置。可以认为root的父就是世界坐标系。但是初始位置时，根骨骼一般不是在世界原点的，比如使用3d max character studio创建的biped骨架时，一般两脚之间是世界原点，而根骨骼-骨盆位于原点上方（+z轴上）。这有什么关系呢？其实也没什么大不了的，只是我 们在指定骨骼动画模型整体坐标时，比如设定坐标为（0，0，0），则根骨骼-骨盆被置于世界原点，假如xy平面是地面，那么人下半个身子到地面下了。我们 想让两脚之间算作人的原点，这样设定（0，0，0）的坐标时人就站在地面上了，所以可以在两脚之间设定一个额外的根骨骼放在世界原点上，或者这个骨骼并不 需要真实存在，只是在你的骨骼模型结构中保存骨盆骨骼到世界原点的变换矩阵。在微软X文件中，一般有一个Scene_Root节点，这算一个额外的骨骼 吧，他的变换矩阵为单位阵，表示他初始位于世界原点，而真正骨骼的根Bip01，作为Scene_root的子骨骼，其变换矩阵表示相对于root的位 置。说这么多其实我只是想解释下，为什么要存在Scene_Root这种额外的骨骼，以及加深理解骨骼定位骨骼动画模型整体的世界坐标的作用。</p>
<p>有了骨骼类，现在让我们看一下建立骨骼层次的代码，在bone class中增加一个构造函数和两个成员函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bone</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		Bone(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z):m_pSibling(<span class="literal">NULL</span>),m_pFirstChild(<span class="literal">NULL</span>),m_pFather(<span class="literal">NULL</span>),m_x(x),m_y(y),m_z(z)&#123;&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">SetFirstChild</span><span class="params">(Bone* pChild)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			m_pFirstChild = pChild; m_pFirstChild-&gt;m_pFather = <span class="keyword">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">SetSibling</span><span class="params">(Bone* pSibling)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			m_pSibling = pSibling; m_pSibling-&gt;m_pFather = m_pFather;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意我增加了一个成员变量，Bone* m_pFather，这是指向父骨骼的指针，在这个例子中计算骨骼动画时本不需要这个指针，但我为了画一条从父骨骼关节到子骨骼关节的连线，增加了它，因 为每个骨骼只有第一子骨骼的指针，绘制父骨骼时从父到子画线就只能画一条，所以记录每个骨骼的父，在绘制子骨骼时画这根线。</p>
<p>有了这个函数，就可以创建骨骼层次了，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Bone* g_boneRoot;</span><br><span class="line">Bone* g_bone1, *g_bone21, *g_bone22;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildBones</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	g_boneRoot = <span class="keyword">new</span> Bone(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	g_bone1 = <span class="keyword">new</span> Bone(<span class="number">0.1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	g_bone21 = <span class="keyword">new</span> Bone(<span class="number">0.0</span>, <span class="number">0.1</span>, <span class="number">0</span>);</span><br><span class="line">	g_bone22 = <span class="keyword">new</span> Bone(<span class="number">0.1</span>, <span class="number">0.0</span>, <span class="number">0</span>);</span><br><span class="line">	g_boneRoot-&gt;SetFirstChild(g_bone1);</span><br><span class="line">	g_bone1-&gt;SetFirstChild(g_bone21);</span><br><span class="line">	g_bone21-&gt;SetSibling(g_bone22);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来是骨骼层次中最核心的部分，更新骨骼！由于动画的作用，某个骨骼的变换（TransformMatrix）变了，这时就要根据新的变换来计算，所以 这个过程一般称作UpdateBoneMatrix。因为骨骼的变换都是相对父的，要变换顶点必须使用世界变换矩阵，所以这个过程是根据更新了的某些骨骼 的骨骼变换矩阵（TransformMatrix）计算出所有骨骼的世界变换矩阵（也即CombinedMatrix）。在本文的例子中，骨骼只能平移， 甚至我们没有用矩阵，所以当有骨骼变动时要做的只是直接计算骨骼的世界坐标，因此函数命名为ComputeWorldPos，相当于 UpdateBoneMatrix后再用顶点乘以CombinedMatrix。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bone</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">//give father's world pos, compute the bone's world pos</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ComputeWorldPos</span><span class="params">(<span class="keyword">float</span> fatherWX, <span class="keyword">float</span> fatherWY, <span class="keyword">float</span> fatherWZ)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_wx = fatherWX+m_x;</span><br><span class="line">		m_wy = fatherWY+m_y;</span><br><span class="line">		m_wz = fatherWZ+m_z;</span><br><span class="line">		<span class="keyword">if</span>(m_pSibling!=<span class="literal">NULL</span>)</span><br><span class="line">			m_pSibling-&gt;ComputeWorldPos(fatherWX, fatherWY, fatherWZ);</span><br><span class="line">		<span class="keyword">if</span>(m_pFirstChild!=<span class="literal">NULL</span>)</span><br><span class="line">			m_pFirstChild-&gt;ComputeWorldPos(m_wx, m_wy, m_wz);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中的递归调用使用了微软例子的思想。 </p>
<p>有了上述函数，当某骨骼运动时就可以让其子骨骼跟随运动了，但是怎么让骨骼运动呢？这就是动画问题了。我不打算在这个简单的例子中使用关键帧动画，而只是 通过程序每帧改变某些骨骼的位置，DEMO中animateBones就是做这个的，你可以在里面改变不同的骨骼看看效果。在本文下面会对骨骼的关键帧动 画做简单的讨论。</p>
<p>至此，我们定义了骨骼类的结构，手工创建了骨骼层次（实际引擎应该从文件读入），并且可以根据新位置更新骨骼了（实际引擎应该从动画数据读入新的变换或使 用物理计算），这样假如我们用连线将骨骼画出来，并且让某个骨骼动起来，我们就会看见他下面的子骨骼跟着动了。当然只有骨骼是不够的，我们要让Mesh跟 随骨骼运动，下面就是蒙皮了。</p>
<h2 id="骨骼蒙皮动画-Skinned-Mesh-的原理解析（二）"><a href="#骨骼蒙皮动画-Skinned-Mesh-的原理解析（二）" class="headerlink" title="骨骼蒙皮动画(Skinned Mesh)的原理解析（二）"></a>骨骼蒙皮动画(Skinned Mesh)的原理解析（二）</h2><h3 id="蒙皮信息和蒙皮过程"><a href="#蒙皮信息和蒙皮过程" class="headerlink" title="蒙皮信息和蒙皮过程"></a>蒙皮信息和蒙皮过程</h3><h4 id="Skin-info的定义"><a href="#Skin-info的定义" class="headerlink" title="Skin info的定义"></a>Skin info的定义</h4><p>上文曾讨论过，Skinned Mesh中Mesh是作为皮肤使用，蒙在骨骼之上的。为了让普通的Mesh具有蒙皮的功能，必须添加蒙皮信息，即Skin info。我们知道Mesh是由顶点构成的，建模时顶点是定义在模型自身坐标系的，即相对于Mesh原点的，而骨骼动画中决定模型顶点最终世界坐标的是骨 骼，所以要让骨骼决定顶点的世界坐标，这就要将顶点和骨骼联系起来，Skin info正是起了这个作用。下面是DEMO中顶点类的定义的代码片段：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_BONE_PER_VERTEX 4</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">float</span> m_x, m_y, m_z; <span class="comment">//local pos in mesh space</span></span><br><span class="line">	<span class="keyword">float</span> m_wX, m_wY, m_wZ;<span class="comment">//blended vertex pos, in world space</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//skin info</span></span><br><span class="line">	<span class="keyword">int</span> m_boneNum;</span><br><span class="line">	Bone* m_bones[MAX_BONE_PER_VERTEX];</span><br><span class="line">	<span class="keyword">float</span> m_boneWeights[MAX_BONE_PER_VERTEX];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>顶点的Skin info包含影响该顶点的骨骼数目，指向这些骨骼的指针，这些骨骼作用于该顶点的权重(Skin weight)。由于只是一个简单的例子，这儿没有考虑优化，所以用静态数组存放骨骼指针和权重，且实际引擎中Skin info的定义方式不一定是这样的，但基本原理一致。</p>
<p>MAX_BONE_PER_VERTEX在这儿用来设置可同时影响顶点的最大骨骼数，实际上由于这个DEMO是手工进行Vertex Blending并且也没用硬件加速，可影响顶点的骨骼数量并没有限制，只是恰好需要一个常量来定义数组，所以定义了一下。在实际引擎中由于要使用硬件加 速，以及为了确保速度，一般会定义最大骨骼数。另外在本DEMO中，Skin info是手工设定的，而在实际项目中，一般是在建模软件中生成这些信息并导出。</p>
<p>Skin info的作用是使用各个骨骼的变换矩阵对顶点进行变换并乘以权重，这样某块骨骼只能对该顶点产生部分影响。各骨骼权重之和应该为1。</p>
<p>Skin info是针对顶点的，然而在使用Skin info前我们必须要使用Bone Offset Matrix对顶点进行变换，下面具体讨论Bone offset Matrix。（写下这句话的时候我感觉有些不妥，因为实际是先将所有的矩阵相乘最后再作用于顶点，这儿是按照理论上的顺序进行讲述吧，请不要与实际情况 混淆，其实他们也并不矛盾。而且在我们的DEMO中由于没有使用矩阵，所以变换的顺序和理论顺序是一致的）</p>
<h4 id="Bone-Offset-Matrix的含义和计算方法"><a href="#Bone-Offset-Matrix的含义和计算方法" class="headerlink" title="Bone Offset Matrix的含义和计算方法"></a>Bone Offset Matrix的含义和计算方法</h4><p>上文已经说过：“骨骼动画中决定模型顶点最终世界坐标的是骨骼，所以要让骨骼决定顶点的世界坐标”，现在让我们看下顶点受一块骨骼的作用时的坐标变换过程：</p>
<p><strong>mesh vertex (defined in mesh space)</strong>—BoneOffsetMatrix—&gt;<strong>Bone space</strong>—BoneCombinedTransformMatrix—&gt;<strong>World</strong></p>
<p>从这个过程中可看出，需要首先将模型顶点从模型空间变换到某块骨骼自身的骨骼空间，然后才能利用骨骼的世界变换计算顶点的世界坐标。Bone Offset Matrix的作用正是将模型从顶点空间变换到骨骼空间。那么Bone Offset Matrix如何得到呢？下面具体分析：</p>
<p>Mesh space是建模时使用的空间，mesh中顶点的位置相对于这个空间的原点定义。比如在3d max中建模时（视xy平面为地面，+z朝上），可将模型两脚之间的中点作为Mesh空间的原点，并将其放置在世界原点，这样左脚上某一顶点坐标是 （10，10，2），右脚上对称的一点坐标是（-10，10，2），头顶上某一顶点的坐标是（0，0，170）。由于此时Mesh空间和世界空间重合，上 述坐标既在Mesh空间也在世界空间，换句话说，此时实际是以世界空间作为Mesh空间了。在骨骼动画中，在世界中放置的是骨骼而不是Mesh，所以这个 区别并不重要。在3d max中添加骨骼的时候，也是将骨骼放入世界空间中，并调整骨骼的相对位置使得和mesh相吻合（即设置骨骼的TransformMatrix），得到骨 架的初始姿势以及相应的Transform Matrix(按惯例模型做成两臂侧平举直立，骨骼也要适合这个姿态)。由于骨骼的Transform Matrix（作用是将顶点从骨骼空间变换到上层空间）是基于其父骨骼空间的，只有根骨骼的Transform是基于世界空间的，所以要通过自下而上一层 层Transform变换（如果使用行向量右乘矩阵，这个Transform的累积过程就是 C=Mbone*Mfather*Mgrandpar*…*Mroot）,得到该骨骼在世界空间上的变换矩阵 - Combined Transform Matrix，即通过这个矩阵可将顶点从骨骼空间变换到世界空间。那么这个矩阵的逆矩阵就可以将世界空间中的顶点变换到某块骨骼的骨骼空间。由于Mesh 实际上就是定义在世界空间了，所以这个逆矩阵就是Offset Matrix。即OffsetMatrix就是骨骼在初始位置（没有经过任何动画改变）时将bone变换到世界空间的矩阵 （CombinedTransformMatrix）的逆矩阵，有一些资料称之为InverseMatrix。在几何流水线中，是通过变换矩阵将顶点变换 到上层空间，最终得到世界坐标，逆矩阵则做相反的事，所以Inverse这种提法也符合惯例。那么Offset这种提法从字面上怎么理解呢？Offset 即骨骼相对于世界原点的偏移，世界原点加上这个偏移就变成骨骼空间的原点，同样定义在世界空间中的点经过这个偏移矩阵的作用也被变换到骨骼空间了。从另一 角度理解，在动画中模型中顶点的位置是根据骨骼位置动态计算的，也就是说顶点跟着骨骼动，但首先必须确定顶点和骨骼之间的相对位置（即顶点在该骨骼坐标系 中的位置），一个骨骼可能对应很多顶点，如果要保存这个相对位置每个顶点对于每块受控制的骨骼都要保存，这样就要保存太多的矩阵了。。。所以只保存 mesh空间到骨骼空间的变换（即OffsetMatrix），然后通过这个变换计算每个顶点在该骨骼空间中的坐标，所以OffsetMatrix也反应 了mesh和每块骨骼的相对位置，只是这个位置是间接的通过和世界坐标空间的关系表达的，在初始位置将骨骼按照模型的形状摆好是关键之处。</p>
<p>以上的分析是通过将mesh space和world space重合得到Offset Matrix的计算方法。那么如果他们不重合呢？那就要先计算顶点从mesh space变换到world space的变换矩阵，并乘上（还是右乘为例）Combined Matrix的Inverse Matrix从而得到Offset Matrix。但是这不是找麻烦吗？因为Mesh的原点在哪儿并不重要，为啥不让他们重合呢？</p>
<p>还有一个问题是，既然Offset Matrix可以计算出来，为啥还要在骨骼动画文件中同时提供TransformMatrix和OffsetMatrix呢？实际上文件中确实可以不提供 OffsetMatrix，而只在载入时计算。但TransformMatrix不可缺少，动画关键帧数据一般只存储骨骼的旋转和根骨骼的位置，骨骼间的 相对位置还是要靠TransformMatrix提供。在微软的X文件结构中提供了OffsetMatrix，原因是什么呢？我不知道。我猜想一个可能的 原因是为了兼容性和灵活性，比如mesh并没有定义在世界坐标系，而是作为一个object放置在3d max中，在导出骨骼动画时不能简单的认为mesh的顶点坐标是相对于世界原点的，还要把这个object的位置考虑进去，于是导出插件要计算出 OffsetMatrix并保存在x文件中以避免兼容性问题。</p>
<p>关于OffsetMatrix和TransformMatrix含有平移，旋转和缩放的讨论：</p>
<p>首先，OffsetMatrix取决于骨骼的初始位置(即TransformMatrix)，由于骨骼动画中我们使用的是动画中的位置，初始位置是什么样 并不重要，所以可以在初始位置中只包含平移，而旋转和缩放在动画中设置（一般也仅仅使用旋转，这也是为啥动画通常中可以用一个四元数表示骨骼的关键帧）。 在这种情况下，OffsetMatrix只包含平移即可。因此一些引擎的Bone中不存放Transform矩阵，而只存放骨骼在父骨骼空间中的坐标，然 后旋转只在动画帧中设置，最基本的骨骼动画即可实现。但也可在Transform和Offset Matrix中包括旋转和缩放，这样可以提高创建动画时的容错性。</p>
<p>在本文DEMO中，我们也没有使用矩阵保存Bone Offset，而只用了一个坐标保存偏移位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoneOffset</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">float</span> m_offx, m_offy, m_offz;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在Bone class中，有一个方法用来计算Bone Offset</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bone</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	BoneOffset m_boneOffset;</span><br><span class="line">	<span class="comment">//called after ComputeWorldPos() when bone loaded but not animated</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ComputeBoneOffset</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_boneOffset.m_offx = -m_wx;</span><br><span class="line">		m_boneOffset.m_offy = -m_wy;</span><br><span class="line">		m_boneOffset.m_offz = -m_wz;</span><br><span class="line">		<span class="keyword">if</span>(m_pSibling!=<span class="literal">NULL</span>)</span><br><span class="line">			m_pSibling-&gt;ComputeBoneOffset();</span><br><span class="line">		<span class="keyword">if</span>(m_pFirstChild!=<span class="literal">NULL</span>)</span><br><span class="line">			m_pFirstChild-&gt;ComputeBoneOffset();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在ComputeBoneOffset()中，使用计算好的骨骼的世界坐标来计算bone offset,这儿的计算只是取一个负数，在实际引擎中，如果bone offset是一个矩阵，这儿就应该是求逆矩阵，本文不做讨论了。注意由于我们计算Bone offset时是使用计算好的世界坐标，所以在这之前必须在初始位置时对根骨骼调用ComputeWorldPos()以计算出各个骨骼在初始位置时的世界坐标。</p>
<h4 id="最终-顶点混合（vertex-blending）"><a href="#最终-顶点混合（vertex-blending）" class="headerlink" title="最终:顶点混合（vertex blending）"></a>最终:顶点混合（vertex blending）</h4><p>现在我们有了Skin info,有了Bone offset，可谓万事具备，只欠东风了。现在就可以做顶点混合了，这是骨骼动画的精髓所在，正是这个技术消除了关节处的裂缝。顶点混合后得到了顶点新的 世界坐标，对所有的顶点执行vertex blending后，从Mesh的角度看，Mesh deform(变形)了，变成动画需要的形状了。 </p>
<p>首先，让我们看看使用单块骨骼对顶点进行作用的过程，以下是DEMO中的相关代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">ComputeWorldPosByBone</span><span class="params">(Bone* pBone, <span class="keyword">float</span>&amp; outX, <span class="keyword">float</span>&amp; outY, <span class="keyword">float</span>&amp; outZ)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="comment">//step1: transform vertex from mesh space to bone space</span></span><br><span class="line">			outX = m_x+pBone-&gt;m_boneOffset.m_offx;</span><br><span class="line">			outY = m_y+pBone-&gt;m_boneOffset.m_offy;</span><br><span class="line">			outZ = m_z+pBone-&gt;m_boneOffset.m_offz;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//step2: transform vertex from bone space to world sapce</span></span><br><span class="line">			outX += pBone-&gt;m_wx;</span><br><span class="line">			outY += pBone-&gt;m_wy;</span><br><span class="line">			outZ += pBone-&gt;m_wz;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个函数使用一块骨骼对顶点进行变换，将顶点从Mesh坐标系变换到世界坐标系，这儿使用了骨骼的Bone Offset Matrix和 Combined Transform Matrix (嗯，我知道这儿没用矩阵，但意思是一样的对吗) </p>
<p>对于多块骨骼，对每块骨骼执行这个过程并将结果根据权重混合(即vertex blending)就得到顶点最终的世界坐标。进行vertex blending的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">BlendVertex</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//do the vertex blending,get the vertex's pos in world space</span></span><br><span class="line">		m_wX = <span class="number">0</span>;</span><br><span class="line">		m_wY = <span class="number">0</span>;</span><br><span class="line">		m_wZ = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m_boneNum; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">float</span> tx, ty, tz;</span><br><span class="line">			ComputeWorldPosByBone(m_bones[i], tx, ty, tz);</span><br><span class="line">			tx*= m_boneWeights[i];</span><br><span class="line">			ty*= m_boneWeights[i];</span><br><span class="line">			tz*= m_boneWeights[i];</span><br><span class="line"></span><br><span class="line">			m_wX += tx;</span><br><span class="line">			m_wY += ty;</span><br><span class="line">			m_wZ += tz;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这些函数我都放在Vertex类中了，因为只是一个简单DEMO所以没有特别考虑引擎结构问题，在BlendVertex()中，遍历影响该顶点的所有骨 骼，用每块骨骼计算出顶点的世界坐标，然后使用Skin Weight对这些坐标进行加权平均。tx,ty,tz是某块骨骼作用后顶点的世界坐标乘以权重后的值，这些值相加后就是最终的世界坐标了。</p>
<p>现在让我们用一个公式回顾一下Vertex blending的整个过程(使用矩阵变换)</p>
<p>Vworld = Vmesh * BoneOffsetMatrix1 * CombindMatrix1 * Weight1</p>
<p>+ Vmesh* BoneOffsetMatrix2 * CombinedMatrix2 * Weight2</p>
<p>+ …</p>
<p>+ Vmesh * BoneOffsetMatrixN * CombindMatrixN * WeightN</p>
<p>（这个公式使用的是行向量左乘矩阵）</p>
<p>由于BoneOffsetMatrix和Combined Matrix都是矩阵，可以先相乘这样就减少很多计算了，在实际PC游戏中可以使用VS进行硬件加速计算。</p>
<h3 id="动画数据和播放动画"><a href="#动画数据和播放动画" class="headerlink" title="动画数据和播放动画"></a>动画数据和播放动画</h3><p>正如前面所说，本例子中并没有使用动画数据，但动画数据在骨骼动画中确实最重要的，因为我们的最终目的就是播放动画。所以作为DEMO的补充，这儿简要讨论一下动画数据相关问题。其实我觉得动画的处理在骨骼动画中是很灵活的，需要专门的一篇文章讨论。</p>
<p>本文的最开始说，3D模型动画的基本原理是让模型中各顶点的位置随时间变化。骨骼动画的情况是，骨骼的位置随时间变化，顶点位置随骨骼变化。所以动画数据 中必然包含的是骨骼的运动信息。可以在动画帧中包含某时刻骨骼的Transform Matrix，但骨骼一般只是做旋转，所以也可以用一个四元数表示。但有时候骨骼层次整体会在动画中进行平移，所以可能需要在动画帧中包含根骨骼的位置信 息。播放动画时，给出当前播放的时间值，对于每块需要动画的骨骼，根据这个值找出该骨骼前后两个关键帧，根据时间差进行插值，对于四元数要使用四元数球面 插值。然后将插值得到的四元数转换成Transform Matrix,再调用UpdateBoneMatrix（其含义上文已介绍）更新计算整个骨骼层次的CombinedMatrix。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>从结构上看，SkinnedMesh包括：动画数据，骨骼数据，包含Skin info的Mesh数据，以及Bone Offset Matrix。</p>
<p>从过程上看，载入阶段：载入并建立骨骼层次结构，计算或载入Bone Offset Matrix，载入Mesh数据和Skin info（如果是DX的Skinned Mesh这个过程更复杂，因为还涉及到Matrix Palette等）。运行阶段：根据时间从动画数据中获取骨骼当前时刻的Transform Matrix，调用UpdateBoneMatrix计算出各骨骼的CombinedMatrix，对于每个顶点根据Skin info进行Vertex Blending计算出顶点的世界坐标，最终进行模型的渲染。</p>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2019-03-25T03:27:21.780Z" itemprop="dateUpdated">2019-03-25 11:27:21</time>
</span><br>


        
        欢迎指正～
        
    </div>
    
    <footer>
        <a href="https://bitzhangmo.github.io">
            <img src="/img/avatar.png" alt="zhangMo">
            zhangMo
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8A%A8%E7%94%BB/" rel="tag">动画</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%AA%A8%E9%AA%BC%E5%8A%A8%E7%94%BB/" rel="tag">骨骼动画</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://bitzhangmo.github.io/2019/03/25/Unity%E7%AC%94%E8%AE%B0/%E8%BD%AC-%E9%AA%A8%E9%AA%BC%E8%92%99%E7%9A%AE%E5%8A%A8%E7%94%BB-Skinned-Mesh-%E7%9A%84%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/&title=《[转] 骨骼蒙皮动画(Skinned Mesh)的原理解析》 — zhangMo Blog&pic=https://bitzhangmo.github.io/img/avatar.png" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" target="_blank" rel="noopener" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://bitzhangmo.github.io/2019/03/25/Unity%E7%AC%94%E8%AE%B0/%E8%BD%AC-%E9%AA%A8%E9%AA%BC%E8%92%99%E7%9A%AE%E5%8A%A8%E7%94%BB-Skinned-Mesh-%E7%9A%84%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/&title=《[转] 骨骼蒙皮动画(Skinned Mesh)的原理解析》 — zhangMo Blog&source=骨骼蒙皮动画(Skinned Mesh)的原理解析。" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://bitzhangmo.github.io/2019/03/25/Unity%E7%AC%94%E8%AE%B0/%E8%BD%AC-%E9%AA%A8%E9%AA%BC%E8%92%99%E7%9A%AE%E5%8A%A8%E7%94%BB-Skinned-Mesh-%E7%9A%84%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《[转] 骨骼蒙皮动画(Skinned Mesh)的原理解析》 — zhangMo Blog&url=https://bitzhangmo.github.io/2019/03/25/Unity%E7%AC%94%E8%AE%B0/%E8%BD%AC-%E9%AA%A8%E9%AA%BC%E8%92%99%E7%9A%AE%E5%8A%A8%E7%94%BB-Skinned-Mesh-%E7%9A%84%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/&via=https://bitzhangmo.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://bitzhangmo.github.io/2019/03/25/Unity%E7%AC%94%E8%AE%B0/%E8%BD%AC-%E9%AA%A8%E9%AA%BC%E8%92%99%E7%9A%AE%E5%8A%A8%E7%94%BB-Skinned-Mesh-%E7%9A%84%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" target="_blank" rel="noopener" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2019/03/25/Unity%E7%AC%94%E8%AE%B0/Unity-%E6%89%98%E7%AE%A1%E5%A0%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">[Unity] 托管堆与垃圾回收</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2019/03/25/Unity%E7%AC%94%E8%AE%B0/%E8%BD%AC-%E6%B5%85%E8%B0%88Unity3D%E9%AA%A8%E9%AA%BC%E5%8A%A8%E7%94%BB/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">[转] 浅谈Unity3D骨骼动画</h4>
      </a>
    </div>
  
</nav>



    




















</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
            <span>博客内容遵循 <a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>zhangMo &copy; 2018 - 2019</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" target="_blank" rel="noopener" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://bitzhangmo.github.io/2019/03/25/Unity%E7%AC%94%E8%AE%B0/%E8%BD%AC-%E9%AA%A8%E9%AA%BC%E8%92%99%E7%9A%AE%E5%8A%A8%E7%94%BB-Skinned-Mesh-%E7%9A%84%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/&title=《[转] 骨骼蒙皮动画(Skinned Mesh)的原理解析》 — zhangMo Blog&pic=https://bitzhangmo.github.io/img/avatar.png" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" target="_blank" rel="noopener" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://bitzhangmo.github.io/2019/03/25/Unity%E7%AC%94%E8%AE%B0/%E8%BD%AC-%E9%AA%A8%E9%AA%BC%E8%92%99%E7%9A%AE%E5%8A%A8%E7%94%BB-Skinned-Mesh-%E7%9A%84%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/&title=《[转] 骨骼蒙皮动画(Skinned Mesh)的原理解析》 — zhangMo Blog&source=骨骼蒙皮动画(Skinned Mesh)的原理解析。" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://bitzhangmo.github.io/2019/03/25/Unity%E7%AC%94%E8%AE%B0/%E8%BD%AC-%E9%AA%A8%E9%AA%BC%E8%92%99%E7%9A%AE%E5%8A%A8%E7%94%BB-Skinned-Mesh-%E7%9A%84%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《[转] 骨骼蒙皮动画(Skinned Mesh)的原理解析》 — zhangMo Blog&url=https://bitzhangmo.github.io/2019/03/25/Unity%E7%AC%94%E8%AE%B0/%E8%BD%AC-%E9%AA%A8%E9%AA%BC%E8%92%99%E7%9A%AE%E5%8A%A8%E7%94%BB-Skinned-Mesh-%E7%9A%84%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/&via=https://bitzhangmo.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://bitzhangmo.github.io/2019/03/25/Unity%E7%AC%94%E8%AE%B0/%E8%BD%AC-%E9%AA%A8%E9%AA%BC%E8%92%99%E7%9A%AE%E5%8A%A8%E7%94%BB-Skinned-Mesh-%E7%9A%84%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;" target="_blank" rel="noopener"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=https://bitzhangmo.github.io/2019/03/25/Unity%E7%AC%94%E8%AE%B0/%E8%BD%AC-%E9%AA%A8%E9%AA%BC%E8%92%99%E7%9A%AE%E5%8A%A8%E7%94%BB-Skinned-Mesh-%E7%9A%84%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags=""}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" async></script>




<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = 'MossWang';
            clearTimeout(titleTime);
        } else {
            document.title = 'zhangMo';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
