<!DOCTYPE html>
<html lang=zh>
<head><meta name="generator" content="Hexo 3.9.0">
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="Lua 虚拟机的执行过程。">
<meta name="keywords" content="Lua">
<meta property="og:type" content="article">
<meta property="og:title" content="Lua源码阅读：虚拟机概述">
<meta property="og:url" content="https://bitzhangmo.github.io/2019/08/21/Lua/Lua源码阅读：虚拟机概述/index.html">
<meta property="og:site_name" content="zhangMo Blog">
<meta property="og:description" content="Lua 虚拟机的执行过程。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://i.loli.net/2019/08/22/sUtLPaW61eX8jx7.png">
<meta property="og:updated_time" content="2019-08-27T06:29:30.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Lua源码阅读：虚拟机概述">
<meta name="twitter:description" content="Lua 虚拟机的执行过程。">
<meta name="twitter:image" content="https://i.loli.net/2019/08/22/sUtLPaW61eX8jx7.png">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>Lua源码阅读：虚拟机概述</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- persian styles -->
    
      <link rel="stylesheet" href="/css/rtl.css">
    
    <!-- rss -->
    
    
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/tags/">tags</a></li>
         
          <li><a href="/categories/">categories</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="/categories/reports/">reports</a></li>
         
          <li><a href="/search/">搜索</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2019/09/11/OpenGL笔记/Mac下配置OpenGL环境/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2019/08/16/Lua/Lua与C交互相关/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://bitzhangmo.github.io/2019/08/21/Lua/Lua源码阅读：虚拟机概述/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://bitzhangmo.github.io/2019/08/21/Lua/Lua源码阅读：虚拟机概述/&text=Lua源码阅读：虚拟机概述"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://bitzhangmo.github.io/2019/08/21/Lua/Lua源码阅读：虚拟机概述/&title=Lua源码阅读：虚拟机概述"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://bitzhangmo.github.io/2019/08/21/Lua/Lua源码阅读：虚拟机概述/&is_video=false&description=Lua源码阅读：虚拟机概述"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Lua源码阅读：虚拟机概述&body=Check out this article: https://bitzhangmo.github.io/2019/08/21/Lua/Lua源码阅读：虚拟机概述/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://bitzhangmo.github.io/2019/08/21/Lua/Lua源码阅读：虚拟机概述/&title=Lua源码阅读：虚拟机概述"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://bitzhangmo.github.io/2019/08/21/Lua/Lua源码阅读：虚拟机概述/&title=Lua源码阅读：虚拟机概述"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://bitzhangmo.github.io/2019/08/21/Lua/Lua源码阅读：虚拟机概述/&title=Lua源码阅读：虚拟机概述"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://bitzhangmo.github.io/2019/08/21/Lua/Lua源码阅读：虚拟机概述/&title=Lua源码阅读：虚拟机概述"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://bitzhangmo.github.io/2019/08/21/Lua/Lua源码阅读：虚拟机概述/&name=Lua源码阅读：虚拟机概述&description=&lt;p&gt;Lua 虚拟机的执行过程。&lt;/p&gt;"><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://news.ycombinator.com/submitlink?u=https://bitzhangmo.github.io/2019/08/21/Lua/Lua源码阅读：虚拟机概述/&t=Lua源码阅读：虚拟机概述"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Lua-执行过程概述："><span class="toc-number">1.</span> <span class="toc-text">Lua 执行过程概述：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#虚拟机的实现方式："><span class="toc-number">1.1.</span> <span class="toc-text">虚拟机的实现方式：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#虚拟机执行流程："><span class="toc-number">1.2.</span> <span class="toc-text">虚拟机执行流程：</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Lua源码阅读：虚拟机概述
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">zhangMo Blog</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2019-08-21T08:38:37.000Z" itemprop="datePublished">2019-08-21</time>
        
        (Updated: <time datetime="2019-08-27T06:29:30.000Z" itemprop="dateModified">2019-08-27</time>)
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/源码阅读/">源码阅读</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/Lua/">Lua</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>Lua 虚拟机的执行过程。</p>
<a id="more"></a>
<h3 id="Lua-执行过程概述："><a href="#Lua-执行过程概述：" class="headerlink" title="Lua 执行过程概述："></a>Lua 执行过程概述：</h3><p>解释型脚本语言与编译型语言的区别如下：</p>
<ul>
<li>由于每个脚本语言都有自己的一套字节码，与具体的硬件平台无关，所以不用修改脚本代码，就能运行在各个平台上。硬件、软件平台的差异都由语言自身的虚拟机解决。</li>
<li>由于脚本语言的字节码需要虚拟机执行，而不像机器代码能够直接执行，所以运行速度比编译型语言差不少。</li>
</ul>
<p>虚拟机需要完成以下工作：</p>
<ul>
<li>将源代码编译成虚拟机可以识别执行的字节码。</li>
<li>为函数调用准备调用栈。</li>
<li>内部维持一个 IP（Instruction Pointer，指令指针）来保存下一个将执行的指令地址。在 Lua 代码中，IP 对应的是 PC 指针。</li>
<li>模拟一个 CPU 的运行：循环拿出由 IP 指向的字节码，根据字节码格式进行解码，然后执行字节码。</li>
</ul>
<h4 id="虚拟机的实现方式："><a href="#虚拟机的实现方式：" class="headerlink" title="虚拟机的实现方式："></a>虚拟机的实现方式：</h4><p>虚拟机有两种不同的实现方式：基于栈的虚拟机和基于寄存器的虚拟机。Lua 是基于寄存器虚拟机的语言。</p>
<p>区别：</p>
<ul>
<li>在基于栈的虚拟机中，字节码的操作数是从栈顶上弹出（pop），在执行完操作后再压入栈顶的，这样的缺点是会多出几条指令来准备数据，优点是指令中不需要关心操作数的地址，在执行操作之前就已经将操作数准备在栈顶上了。</li>
<li>在基于寄存器的指令中，操作数是放在“CPU 的寄存器”中，因此，同样的操作不再需要 PUSH、POP 指令，取而代之的是在字节码中带上具体操作数所在的寄存器地址。对比需要栈的寄存器，这里的指令数会减少，但缺点是此时程序需要关注操作数所在的位置。</li>
</ul>
<p>实现一个脚本语言的解释器：</p>
<ul>
<li>设计一套字节码，分析源代码文件生成字节码。</li>
<li>在虚拟机中执行字节码。</li>
<li>如何在整个执行过程中保存整个执行环境。</li>
</ul>
<p>执行Lua文件调用的是luaL_dofile 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> luaL_dofile(L, fn) \<br>true(luaL_loadfile(L, fn) || lua_pcall(L, 0, LUA_MULTRET, 0))</span><br></code></pre></td></tr></table></figure>
<p>其中 luaL_loadfile 函数用于进行词法和语法分析，lua_pcall 用于将第一步中分析的结果（字节码）放在虚拟机中执行。</p>
<p>luaL_loadfile 函数，通过lua_load，luaD_protectedparser，最终调用 f_parser 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// ldo.c</span><br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f_parser</span> <span class="hljs-params">(lua_State *L, <span class="hljs-keyword">void</span> *ud)</span> </span>&#123;<br>  LClosure *cl;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SParser</span> *<span class="hljs-title">p</span> = <span class="hljs-title">cast</span>(<span class="hljs-title">struct</span> <span class="hljs-title">SParser</span> *, <span class="hljs-title">ud</span>);</span><br>  <span class="hljs-keyword">int</span> c = zgetc(p-&gt;z);  <span class="hljs-comment">/* read first character */</span><br>  <span class="hljs-keyword">if</span> (c == LUA_SIGNATURE[<span class="hljs-number">0</span>]) &#123;<br>    checkmode(L, p-&gt;mode, <span class="hljs-string">"binary"</span>);<br>    cl = luaU_undump(L, p-&gt;z, &amp;p-&gt;buff, p-&gt;name);<br>  &#125;<br>  <span class="hljs-keyword">else</span> &#123;<br>    checkmode(L, p-&gt;mode, <span class="hljs-string">"text"</span>);<br>    cl = luaY_parser(L, p-&gt;z, &amp;p-&gt;buff, &amp;p-&gt;dyd, p-&gt;name, c);<br>  &#125;<br>  lua_assert(cl-&gt;nupvalues == cl-&gt;p-&gt;sizeupvalues);<br>  luaF_initupvals(L, cl);<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>完成词法分析之后，返回了 Proto 类型的指针tf，然后将其绑定在新创建的 Closure 指针上，初始化 Upvalue，最后压入栈中。</p>
<p>词法分析之后产生的字节码等相关数据都在这个 Proto 类型的结构体中，而这个数据又作为 Closure 保存了下来。</p>
</blockquote>
<p>lua_pcall 内部调用了lua_pcallk函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// lapi.c</span><br><br><span class="hljs-function">LUA_API <span class="hljs-keyword">int</span> <span class="hljs-title">lua_pcallk</span> <span class="hljs-params">(lua_State *L, <span class="hljs-keyword">int</span> nargs, <span class="hljs-keyword">int</span> nresults, <span class="hljs-keyword">int</span> errfunc,<br>                        lua_KContext ctx, lua_KFunction k)</span> </span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CallS</span> <span class="hljs-title">c</span>;</span><br>  <span class="hljs-keyword">int</span> status;<br>  <span class="hljs-keyword">ptrdiff_t</span> func;<br>  lua_lock(L);<br>  api_check(k == <span class="hljs-literal">NULL</span> || !isLua(L-&gt;ci),<br>    <span class="hljs-string">"cannot use continuations inside hooks"</span>);<br>  api_checknelems(L, nargs+<span class="hljs-number">1</span>);<br>  api_check(L-&gt;status == LUA_OK, <span class="hljs-string">"cannot do calls on non-normal thread"</span>);<br>  checkresults(L, nargs, nresults);<br>  <span class="hljs-keyword">if</span> (errfunc == <span class="hljs-number">0</span>)<br>    func = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">else</span> &#123;<br>    StkId o = index2addr(L, errfunc);<br>    api_checkstackindex(errfunc, o);<br>    func = savestack(L, o);<br>  &#125;<br>  c.func = L-&gt;top - (nargs+<span class="hljs-number">1</span>);  <span class="hljs-comment">/* function to be called */</span><br>  <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">NULL</span> || L-&gt;nny &gt; <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">/* no continuation or no yieldable? */</span><br>    c.nresults = nresults;  <span class="hljs-comment">/* do a 'conventional' protected call */</span><br>    status = luaD_pcall(L, f_call, &amp;c, savestack(L, c.func), func);<br>  &#125;<br>  <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">/* prepare continuation (call is already protected by 'resume') */</span><br>    CallInfo *ci = L-&gt;ci;<br>    ci-&gt;u.c.k = k;  <span class="hljs-comment">/* save continuation */</span><br>    ci-&gt;u.c.ctx = ctx;  <span class="hljs-comment">/* save context */</span><br>    <span class="hljs-comment">/* save information for error recovery */</span><br>    ci-&gt;extra = savestack(L, c.func);<br>    ci-&gt;u.c.old_errfunc = L-&gt;errfunc;<br>    L-&gt;errfunc = func;<br>    setoah(ci-&gt;callstatus, L-&gt;allowhook);  <span class="hljs-comment">/* save value of 'allowhook' */</span><br>    ci-&gt;callstatus |= CIST_YPCALL;  <span class="hljs-comment">/* function can do error recovery */</span><br>    luaD_call(L, c.func, nresults, <span class="hljs-number">1</span>);  <span class="hljs-comment">/* do the call */</span><br>    ci-&gt;callstatus &amp;= ~CIST_YPCALL;<br>    L-&gt;errfunc = ci-&gt;u.c.old_errfunc;<br>    status = LUA_OK;  <span class="hljs-comment">/* if it is here, there were no errors */</span><br>  &#125;<br>  adjustresults(L, nresults);<br>  lua_unlock(L);<br>  <span class="hljs-keyword">return</span> status;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以看到，首先获取需要调用的函数指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">c.func = L-&gt;top - (nargs+<span class="hljs-number">1</span>);  <span class="hljs-comment">/* function to be called */</span><br></code></pre></td></tr></table></figure>
<p>这里的 nargs 是由函数参数传入的，在 lual_dofile 中调用 lua_pcall 时，这里传入的参数是 0。换句话说，这里得到的函数对象指针就是前面 f_parser 函数中最后两句代码放入 Lua 栈的 Closure 指针。</p>
<p>继续向下执行，在调用函数 luaD_pcall 时，最终会执行到 luaD_call 函数，其中有：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (!luaD_precall(L, func, nResults))  <span class="hljs-comment">/* is a Lua function? */</span><br>  luaV_execute(L);  <span class="hljs-comment">/* call it */</span><br></code></pre></td></tr></table></figure>
<p>首先调用 luaD_precall 函数进行执行前的准备工作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*<br>** returns true if function has been executed (C function)<br>true...部分有省略<br>*/</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">luaD_precall</span> <span class="hljs-params">(lua_State *L, StkId func, <span class="hljs-keyword">int</span> nresults)</span> </span>&#123;<br>  lua_CFunction f;<br>  CallInfo *ci;<br>  <span class="hljs-keyword">int</span> n;  <span class="hljs-comment">/* number of arguments (Lua) or returns (C) */</span><br>  <span class="hljs-keyword">ptrdiff_t</span> funcr = savestack(L, func);<br>  <span class="hljs-keyword">switch</span> (ttype(func)) &#123;<br>truetrue...<br>    <span class="hljs-keyword">case</span> LUA_TLCL: &#123;  <span class="hljs-comment">/* Lua function: prepare its call */</span><br>      StkId base;<br>      Proto *p = clLvalue(func)-&gt;p;<br>      ...<br>      ci = next_ci(L);  <span class="hljs-comment">/* now 'enter' new function */</span><br>      ci-&gt;nresults = nresults;<br>      ci-&gt;func = func;<br>      ci-&gt;u.l.base = base;<br>      ci-&gt;top = base + p-&gt;maxstacksize;<br>      <br>      lua_assert(ci-&gt;top &lt;= L-&gt;stack_last);<br>      <br>      ci-&gt;u.l.savedpc = p-&gt;code;  <span class="hljs-comment">/* starting point */</span><br>      ci-&gt;callstatus = CIST_LUA;<br>      <br>      L-&gt;top = ci-&gt;top;<br>      luaC_checkGC(L);  <span class="hljs-comment">/* stack grow uses memory */</span><br>      <span class="hljs-keyword">if</span> (L-&gt;hookmask &amp; LUA_MASKCALL)<br>        callhook(L, ci);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>truetrue...<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>从 lua_State 的 CallInfo 数组中得到一个新的 CallInfo 结构体，设置它的func、base、top 指针</li>
<li>从前面分析阶段生成的 Closure 指针中，取出保存下来的 Proto 结构体。这个结构体中保存的是分析过程完结之后生成的字节码等信息。</li>
<li>将这里创建的 CallInfo 指针的 top、base 指针赋给 lua_State 结构体的 top、base 指针。将 Proto 结构体的 code 成员赋值给 lua_State 指针的 savedpc 字段，code 成员保留的就是字节码。</li>
<li>将多余的函数参数赋值为 nil，比如一个函数定义中需要的是两个参数，实际传入的只有一个，那么多出来的那个参数会被赋值为 nil。</li>
</ul>
<p>执行完 luaD_precall 函数之后，接着会进入 luaV_execute 函数，<strong>这里是虚拟机执行代码的主函数</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// lvm.c</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">luaV_execute</span> <span class="hljs-params">(lua_State *L)</span> </span>&#123;<br>  CallInfo *ci = L-&gt;ci;<br>  LClosure *cl;<br>  TValue *k;<br>  StkId base;<br> newframe:  <span class="hljs-comment">/* reentry point when frame changes (call/return) */</span><br>  lua_assert(ci == L-&gt;ci);<br>  cl = clLvalue(ci-&gt;func);<br>  k = cl-&gt;p-&gt;k;<br>  base = ci-&gt;u.l.base;<br>  <span class="hljs-comment">/* main loop of interpreter */</span><br>  <span class="hljs-keyword">for</span> (;;) &#123;<br>    Instruction i = *(ci-&gt;u.l.savedpc++);<br>    StkId ra;<br>    <span class="hljs-keyword">if</span> ((L-&gt;hookmask &amp; (LUA_MASKLINE | LUA_MASKCOUNT)) &amp;&amp;<br>        (--L-&gt;hookcount == <span class="hljs-number">0</span> || L-&gt;hookmask &amp; LUA_MASKLINE)) &#123;<br>      Protect(luaG_traceexec(L));<br>    &#125;<br>    <span class="hljs-comment">/* WARNING: several calls may realloc the stack and invalidate 'ra' */</span><br>    ra = RA(i);<br>    <span class="hljs-comment">/* 后面是各种字节码的处理流程 */</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里的 ci-&gt;u.l.savedpc存放的是虚拟机 OpCode 代码，这部分从 L-&gt;savepc 初始化而来，而 L-&gt;savepc 在 luaD_precall 中赋值。可以看到，luaV_execute 函数最主要的作用就是一个大循环，将当前传入的指令依次执行。</p>
<p>执行完毕后，会调用 luaD_poscall 函数恢复到上一次函数调用的环境。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">luaD_poscall</span> <span class="hljs-params">(lua_State *L, StkId firstResult)</span> </span>&#123;<br>  StkId res;<br>  <span class="hljs-keyword">int</span> wanted, i;<br>  CallInfo *ci = L-&gt;ci;<br>  <span class="hljs-keyword">if</span> (L-&gt;hookmask &amp; (LUA_MASKRET | LUA_MASKLINE)) &#123;<br>    <span class="hljs-keyword">if</span> (L-&gt;hookmask &amp; LUA_MASKRET) &#123;<br>      <span class="hljs-keyword">ptrdiff_t</span> fr = savestack(L, firstResult);  <span class="hljs-comment">/* hook may change stack */</span><br>      luaD_hook(L, LUA_HOOKRET, <span class="hljs-number">-1</span>);<br>      firstResult = restorestack(L, fr);<br>    &#125;<br>    L-&gt;oldpc = ci-&gt;previous-&gt;u.l.savedpc;  <span class="hljs-comment">/* 'oldpc' for caller function */</span><br>  &#125;<br>  res = ci-&gt;func;  <span class="hljs-comment">/* res == final position of 1st result */</span><br>  wanted = ci-&gt;nresults;<br>  L-&gt;ci = ci = ci-&gt;previous;  <span class="hljs-comment">/* back to caller */</span><br>  <span class="hljs-comment">/* move results to correct place */</span><br>  <span class="hljs-keyword">for</span> (i = wanted; i != <span class="hljs-number">0</span> &amp;&amp; firstResult &lt; L-&gt;top; i--)<br>    setobjs2s(L, res++, firstResult++);<br>  <span class="hljs-keyword">while</span> (i-- &gt; <span class="hljs-number">0</span>)<br>    setnilvalue(res++);<br>  L-&gt;top = res;<br>  <span class="hljs-keyword">return</span> (wanted - LUA_MULTRET);  <span class="hljs-comment">/* 0 iff wanted == LUA_MULTRET */</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="虚拟机执行流程："><a href="#虚拟机执行流程：" class="headerlink" title="虚拟机执行流程："></a>虚拟机执行流程：</h4><ol>
<li>在f_parser函数中，对代码文件的分析返回了Proto指针。这个指针会保存在Closure指针中，留待后续继续使用。</li>
<li>在luaD_precall函数中，将lua_state的savedpc指针指向第一步中Proto结构体的code指针，同时准备好函数调用时的栈信息。</li>
<li>在luaV_execute函数中，pc指针指向第二步的savedpc指针（Lua5.3中似乎直接使用的savedpc指针），紧跟着就是一个大的循环体，依次取出其中的OpCode执行。</li>
<li>执行完毕后，调用luaD_poscall函数恢复到上一个函数的环境。</li>
</ol>
<p><img src="https://i.loli.net/2019/08/22/sUtLPaW61eX8jx7.png" alt="FlowchartDiagram2.png"></p>
<p>虚拟机指令执行的两大入口如下：</p>
<ul>
<li>词法、语法分析阶段的luaY_parser，Lua一次遍历脚本文件完成了词法分析和语法分析，生成的OpCode存放在Proto结构体的code数组中。</li>
<li>luaV_execute：虚拟机执行指令阶段的入口函数，取出第一步生成的Proto结构体中的指令执行。</li>
</ul>
<p>Proto结构体中的数据：</p>
<ul>
<li>函数的常量数组</li>
<li>编译生成的字节码信息</li>
<li>函数的局部变量信息</li>
<li>保存upvalue名字的数组</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*<br>** Function Prototypes<br>*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Proto</span> &#123;</span><br>  CommonHeader;<br>  lu_byte numparams;  <span class="hljs-comment">/* number of fixed parameters */</span><br>  lu_byte is_vararg;<br>  lu_byte maxstacksize;  <span class="hljs-comment">/* maximum stack used by this function */</span><br>  <span class="hljs-keyword">int</span> sizeupvalues;  <span class="hljs-comment">/* size of 'upvalues' */</span><br>  <span class="hljs-keyword">int</span> sizek;  <span class="hljs-comment">/* size of 'k' */</span><br>  <span class="hljs-keyword">int</span> sizecode;<br>  <span class="hljs-keyword">int</span> sizelineinfo;<br>  <span class="hljs-keyword">int</span> sizep;  <span class="hljs-comment">/* size of 'p' */</span><br>  <span class="hljs-keyword">int</span> sizelocvars;<br>  <span class="hljs-keyword">int</span> linedefined;<br>  <span class="hljs-keyword">int</span> lastlinedefined;<br>  TValue *k;  <span class="hljs-comment">/* constants used by the function */</span><br>  Instruction *code;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Proto</span> **<span class="hljs-title">p</span>;</span>  <span class="hljs-comment">/* functions defined inside the function */</span><br>  <span class="hljs-keyword">int</span> *lineinfo;  <span class="hljs-comment">/* map from opcodes to source lines (debug information) */</span><br>  LocVar *locvars;  <span class="hljs-comment">/* information about local variables (debug information) */</span><br>  Upvaldesc *upvalues;  <span class="hljs-comment">/* upvalue information */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LClosure</span> *<span class="hljs-title">cache</span>;</span>  <span class="hljs-comment">/* last created closure with this prototype */</span><br>  TString  *source;  <span class="hljs-comment">/* used for debug information */</span><br>  GCObject *gclist;<br>&#125; Proto;<br></code></pre></td></tr></table></figure>
<hr>
<p>该程序最终会调用 luaV_execute() 函数执行，开始会初始化 global_State、lua_State 两个结构体，用来保存上下文的相关信息。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs lua">main()<br> |-luaL_newstate()                  # 创建global_State+lua_State，并初始化<br> |-lua_pcall()                      # 实际会调用pmain()函数<br>   |                                # 根据不同的参数调用不同的函数<br>   |-runargs()                      # 执行命令行通过-e指定的命令<br>   |-doREPL()                       # 执行交互模式，也即<span class="hljs-built_in">read</span>-eval-<span class="hljs-built_in">print</span> loop<br>   |-handle_script()                # 执行lua脚本<br>     |-luaL_loadfile()              # 加载lua文件，后面详细介绍<br>     | |-lua_load()<br>     |<br>     |-docall()                     # 调用执行<br>       |-lua_pcall()<br>         |-luaD_pcall()             # 实际会调用f_call()函数<br></code></pre></td></tr></table></figure>
<p>在调用函数执行过程中，最终会调用 luaV_execute() 函数。<br>其中，主要处理字节码的是 for(;;){} 循环，也即进入到解释器的主循环，处理很简单，取得当前指令，pc 递增，初始化 ra，然后根据指令的操作码进行选择；然后接下来是一大串的 switch … case … 处理。</p>
<p>接下来对其中有主要的几类指令进行说明。</p>
<hr>
<p>关于define部分符号用法详见：<a href="https://www.jianshu.com/p/e9f00097904a，先转一个，有时间了再写。" target="_blank" rel="noopener">https://www.jianshu.com/p/e9f00097904a，先转一个，有时间了再写。</a></p>
<p>另一个参考：<a href="https://gcc.gnu.org/onlinedocs/cpp/Macros.html#Macros" target="_blank" rel="noopener">https://gcc.gnu.org/onlinedocs/cpp/Macros.html#Macros</a></p>

  </div>
</article>



    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
    <script src="https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.min.js"></script>
    <div id="gitalk-container"></div>
    <script type="text/javascript">
        var gitalk = new Gitalk({
            clientID: '643bb65e08572c0f02f9',
            clientSecret: '267594ee5074e2f5b6392c6deba31c86b4b98abe',
            id: md5(window.location.pathname),
            repo: 'bitzhangmo.github.io',
            owner: 'bitzhangmo',
            admin: 'bitzhangmo',
            distractionFreeMode: ''
        })
        gitalk.render('gitalk-container')
    </script>


        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/tags/">tags</a></li>
         
          <li><a href="/categories/">categories</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="/categories/reports/">reports</a></li>
         
          <li><a href="/search/">搜索</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Lua-执行过程概述："><span class="toc-number">1.</span> <span class="toc-text">Lua 执行过程概述：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#虚拟机的实现方式："><span class="toc-number">1.1.</span> <span class="toc-text">虚拟机的实现方式：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#虚拟机执行流程："><span class="toc-number">1.2.</span> <span class="toc-text">虚拟机执行流程：</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://bitzhangmo.github.io/2019/08/21/Lua/Lua源码阅读：虚拟机概述/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://bitzhangmo.github.io/2019/08/21/Lua/Lua源码阅读：虚拟机概述/&text=Lua源码阅读：虚拟机概述"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://bitzhangmo.github.io/2019/08/21/Lua/Lua源码阅读：虚拟机概述/&title=Lua源码阅读：虚拟机概述"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://bitzhangmo.github.io/2019/08/21/Lua/Lua源码阅读：虚拟机概述/&is_video=false&description=Lua源码阅读：虚拟机概述"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Lua源码阅读：虚拟机概述&body=Check out this article: https://bitzhangmo.github.io/2019/08/21/Lua/Lua源码阅读：虚拟机概述/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://bitzhangmo.github.io/2019/08/21/Lua/Lua源码阅读：虚拟机概述/&title=Lua源码阅读：虚拟机概述"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://bitzhangmo.github.io/2019/08/21/Lua/Lua源码阅读：虚拟机概述/&title=Lua源码阅读：虚拟机概述"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://bitzhangmo.github.io/2019/08/21/Lua/Lua源码阅读：虚拟机概述/&title=Lua源码阅读：虚拟机概述"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://bitzhangmo.github.io/2019/08/21/Lua/Lua源码阅读：虚拟机概述/&title=Lua源码阅读：虚拟机概述"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://bitzhangmo.github.io/2019/08/21/Lua/Lua源码阅读：虚拟机概述/&name=Lua源码阅读：虚拟机概述&description=&lt;p&gt;Lua 虚拟机的执行过程。&lt;/p&gt;"><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://news.ycombinator.com/submitlink?u=https://bitzhangmo.github.io/2019/08/21/Lua/Lua源码阅读：虚拟机概述/&t=Lua源码阅读：虚拟机概述"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2021 zhangMo
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/tags/">tags</a></li>
         
          <li><a href="/categories/">categories</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="/categories/reports/">reports</a></li>
         
          <li><a href="/search/">搜索</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

        
    </div>
    <!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">

    <!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>
<!-- clipboard -->

  <script src="/lib/clipboard/clipboard.min.js"></script>
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功!");
      e.clearSelection();
    })
  })
  </script>

<script src="/js/main.js"></script>
<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Disqus Comments -->


<script src="/live2dw/lib/L2Dwidget.min.js?bd2294fafea3389ee458f1d9be5a2157"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"left","width":100,"height":200},"mobile":{"show":false},"log":false});</script></body>
</html>
